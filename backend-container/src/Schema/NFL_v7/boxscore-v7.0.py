#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Sat Dec 16 08:18:26 2023 by generateDS.py version 2.43.3.
# Python 3.10.12 (main, Nov 20 2023, 15:14:05) [GCC 11.4.0]
#
# Command line options:
#   ('-o', 'boxscore.py')
#
# Command line arguments:
#   boxscore-v7.0.xsd
#
# Command line:
#   /home/zepor/.local/bin/generateDS -o "boxscore.py" boxscore-v7.0.xsd
#
# Current working directory (os.getcwd()):
#   NFL_v7
#

import sys
try:
    ModulenotfoundExp_ = ModuleNotFoundError
except NameError:
    ModulenotfoundExp_ = ImportError
from six.moves import zip_longest
import os
import re as re_
import base64
import datetime as datetime_
import decimal as decimal_
from lxml import etree as etree_


Validate_simpletypes_ = True
SaveElementTreeNode = True
TagNamePrefix = ""
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    try:
        if isinstance(infile, os.PathLike):
            infile = os.path.join(infile)
    except AttributeError:
        pass
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for an example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#
# Additionally, the generatedsnamespaces module can contain a python
# dictionary named GenerateDSNamespaceTypePrefixes that associates element
# types with the namespace prefixes that are to be added to the
# "xsi:type" attribute value.  See the _exportAttributes method of
# any generated element type and the generation of "xsi:type" for an
# example of the use of this table.
# An example table:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceTypePrefixes = {
#         "ElementtypeC": "aaa:",
#         "ElementtypeD": "bbb:",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ModulenotfoundExp_ :
    GenerateDSNamespaceDefs_ = {}
try:
    from generatedsnamespaces import GenerateDSNamespaceTypePrefixes as GenerateDSNamespaceTypePrefixes_
except ModulenotfoundExp_ :
    GenerateDSNamespaceTypePrefixes_ = {}

#
# You can replace the following class definition by defining an
# importable module named "generatedscollector" containing a class
# named "GdsCollector".  See the default class definition below for
# clues about the possible content of that class.
#
try:
    from generatedscollector import GdsCollector as GdsCollector_
except ModulenotfoundExp_ :

    class GdsCollector_(object):

        def __init__(self, messages=None):
            if messages is None:
                self.messages = []
            else:
                self.messages = messages

        def add_message(self, msg):
            self.messages.append(msg)

        def get_messages(self):
            return self.messages

        def clear_messages(self):
            self.messages = []

        def print_messages(self):
            for msg in self.messages:
                print("Warning: {}".format(msg))

        def write_messages(self, outstream):
            for msg in self.messages:
                outstream.write("Warning: {}\n".format(msg))


#
# The super-class for enum types
#

try:
    from enum import Enum
except ModulenotfoundExp_ :
    Enum = object

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ModulenotfoundExp_ as exp:
    try:
        from generatedssupersuper import GeneratedsSuperSuper
    except ModulenotfoundExp_ as exp:
        class GeneratedsSuperSuper(object):
            pass
    
    class GeneratedsSuper(GeneratedsSuperSuper):
        __hash__ = object.__hash__
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def __str__(self):
            settings = {
                'str_pretty_print': True,
                'str_indent_level': 0,
                'str_namespaceprefix': '',
                'str_name': self.__class__.__name__,
                'str_namespacedefs': '',
            }
            for n in settings:
                if hasattr(self, n):
                    settings[n] = getattr(self, n)
            if sys.version_info.major == 2:
                from StringIO import StringIO
            else:
                from io import StringIO
            output = StringIO()
            self.export(
                output,
                settings['str_indent_level'],
                pretty_print=settings['str_pretty_print'],
                namespaceprefix_=settings['str_namespaceprefix'],
                name_=settings['str_name'],
                namespacedef_=settings['str_namespacedefs']
            )
            strval = output.getvalue()
            output.close()
            return strval
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_parse_string(self, input_data, node=None, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data).decode('ascii')
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % int(input_data)
        def gds_parse_integer(self, input_data, node=None, input_name=''):
            try:
                ival = int(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires integer value: %s' % exp)
            return ival
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            try:
                value = int(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires integer value')
            return value
        def gds_format_integer_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integer values')
            return values
        def gds_format_float(self, input_data, input_name=''):
            value = ('%.15f' % float(input_data)).rstrip('0')
            if value.endswith('.'):
                value += '0'
            return value
    
        def gds_parse_float(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires float or double value: %s' % exp)
            return fval_
        def gds_validate_float(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires float value')
            return value
        def gds_format_float_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of float values')
            return values
        def gds_format_decimal(self, input_data, input_name=''):
            return_value = '%s' % input_data
            if '.' in return_value:
                return_value = return_value.rstrip('0')
                if return_value.endswith('.'):
                    return_value = return_value.rstrip('.')
            return return_value
        def gds_parse_decimal(self, input_data, node=None, input_name=''):
            try:
                decimal_value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return decimal_value
        def gds_validate_decimal(self, input_data, node=None, input_name=''):
            try:
                value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return value
        def gds_format_decimal_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return ' '.join([self.gds_format_decimal(item) for item in input_data])
        def gds_validate_decimal_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    decimal_.Decimal(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of decimal values')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_parse_double(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires double or float value: %s' % exp)
            return fval_
        def gds_validate_double(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires double or float value')
            return value
        def gds_format_double_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(
                        node, 'Requires sequence of double or float values')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_parse_boolean(self, input_data, node=None, input_name=''):
            input_data = input_data.strip()
            if input_data in ('true', '1'):
                bval = True
            elif input_data in ('false', '0'):
                bval = False
            else:
                raise_parse_error(node, 'Requires boolean value')
            return bval
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            if input_data not in (True, 1, False, 0, ):
                raise_parse_error(
                    node,
                    'Requires boolean value '
                    '(one of True, 1, False, 0)')
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                value = self.gds_parse_boolean(value, node, input_name)
                if value not in (True, 1, False, 0, ):
                    raise_parse_error(
                        node,
                        'Requires sequence of boolean values '
                        '(one of True, 1, False, 0)')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            target = str(target)
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_check_cardinality_(
                self, value, input_name,
                min_occurs=0, max_occurs=1, required=None):
            if value is None:
                length = 0
            elif isinstance(value, list):
                length = len(value)
            else:
                length = 1
            if required is not None :
                if required and length < 1:
                    self.gds_collector_.add_message(
                        "Required value {}{} is missing".format(
                            input_name, self.gds_get_node_lineno_()))
            if length < min_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is below "
                    "the minimum allowed, "
                    "expected at least {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        min_occurs, length))
            elif length > max_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is above "
                    "the maximum allowed, "
                    "expected at most {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        max_occurs, length))
        def gds_validate_builtin_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value, input_name=input_name)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_validate_defined_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            # provide default value in case option --disable-xml is used.
            content = ""
            content = etree_.tostring(node, encoding="unicode")
            return content
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            def excl_select_objs_(obj):
                return (obj[0] != 'parent_object_' and
                        obj[0] != 'gds_collector_')
            if type(self) != type(other):
                return False
            return all(x == y for x, y in zip_longest(
                filter(excl_select_objs_, self.__dict__.items()),
                filter(excl_select_objs_, other.__dict__.items())))
        def __ne__(self, other):
            return not self.__eq__(other)
        # Django ETL transform hooks.
        def gds_djo_etl_transform(self):
            pass
        def gds_djo_etl_transform_db_obj(self, dbobj):
            pass
        # SQLAlchemy ETL transform hooks.
        def gds_sqa_etl_transform(self):
            return 0, None
        def gds_sqa_etl_transform_db_obj(self, dbobj):
            pass
        def gds_get_node_lineno_(self):
            if (hasattr(self, "gds_elementtree_node_") and
                    self.gds_elementtree_node_ is not None):
                return ' near line {}'.format(
                    self.gds_elementtree_node_.sourceline)
            else:
                return ""
    
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
# Set this to false in order to deactivate during export, the use of
# name space prefixes captured from the input document.
UseCapturedNS_ = True
CapturedNsmap_ = {}
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    s1 = s1.replace('\n', '&#10;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        if prefix == 'xml':
            namespace = 'http://www.w3.org/XML/1998/namespace'
        else:
            namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


def encode_str_2_3(instr):
    return instr


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if node is not None:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name_=name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element, mapping_=None, reverse_mapping_=None, nsmap_=None):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self, mapping_=None, reverse_mapping_=None, nsmap_=None):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)


#
# Start enum classes
#
class categoryType(str, Enum):
    PUNT_RETURN='punt_return'
    KICK_RETURN='kick_return'


class categoryType22(str, Enum):
    PUNT_RETURN='punt_return'
    KICK_RETURN='kick_return'


class categoryType24(str, Enum):
    FIELD_GOAL='field_goal'
    EXTRA_POINT='extra_point'
    PUNT='punt'


class categoryType27(str, Enum):
    PASS='pass'
    RECEIVE='receive'
    RUSH='rush'
    TURNOVER='turnover'


class categoryType29(str, Enum):
    CONVERSION='conversion'
    EXTRA_POINT='extra_point'


class categoryType32(str, Enum):
    PASS='pass'
    RUSH='rush'
    PENALTY='penalty'


class categoryType6(str, Enum):
    FIELD_GOAL='field_goal'
    EXTRA_POINT='extra_point'
    PUNT='punt'


class categoryType7(str, Enum):
    PASS='pass'
    RECEIVE='receive'
    RUSH='rush'
    TURNOVER='turnover'


class categoryType8(str, Enum):
    CONVERSION='conversion'
    EXTRA_POINT='extra_point'


class categoryType9(str, Enum):
    PASS='pass'
    RUSH='rush'
    PENALTY='penalty'


class coverageType(str, Enum):
    FULL='full'
    EXTENDED_BOXSCORE='extended_boxscore'
    BOXSCORE='boxscore'


class driveReason(str, Enum):
    UNKNOWN='UNKNOWN'
    TOUCHDOWN='Touchdown'
    SAFETY='Safety'
    FIELD_GOAL='Field Goal'
    MISSEDFG='Missed FG'
    BLOCKEDFG='Blocked FG'
    BLOCKEDFG_DOWNS='Blocked FG, Downs'
    BLOCKEDFG_SAFETY='Blocked FG, Safety'
    PUNT='Punt'
    BLOCKED_PUNT='Blocked Punt'
    BLOCKED_PUNT_DOWNS='Blocked Punt, Downs'
    BLOCKED_PUNT_SAFETY='Blocked Punt, Safety'
    DOWNS='Downs'
    INTERCEPTION='Interception'
    FUMBLE='Fumble'
    FUMBLE_SAFETY='Fumble, Safety'
    MUFFEDFG='Muffed FG'
    MUFFED_PUNT='Muffed Punt'
    MUFFED_KICKOFF='Muffed Kickoff'
    KICKOFF='Kickoff'
    OWN_KICKOFF='Own Kickoff'
    ONSIDE_KICK='Onside Kick'
    KICKOFF_NO_PLAY='Kickoff, No Play'
    ENDOF_HALF='End of Half'
    ENDOF_GAME='End of Game'


class eligibilityType(str, Enum):
    FR='FR'
    SO='SO'
    JR='JR'
    SR='SR'
    GR='GR'


class entry_modeType(str, Enum):
    INGEST='INGEST'
    LDE='LDE'


class game_typeType(str, Enum):
    REGULAR='regular'
    CONFERENCE_CHAMPIONSHIP='conference_championship'
    BOWL='bowl'
    PLAYOFF='playoff'


class hash_markType(str, Enum):
    LEFT_HASH='Left Hash'
    RIGHT_HASH='Right Hash'
    MIDDLE='Middle'


class incompletion_typeType(str, Enum):
    THROWN_AWAY='Thrown Away'
    PASS_DEFENDED='Pass Defended'
    DROPPED_PASS='Dropped Pass'
    SPIKE='Spike'
    POORLY_THROWN='Poorly Thrown'


class play_directionType(str, Enum):
    LEFT_SIDELINE='Left Sideline'
    LEFT='Left'
    MIDDLE='Middle'
    RIGHT='Right'
    RIGHT_SIDELINE='Right Sideline'


class playoff_game_typeType(str, Enum):
    CFP_SEMIFINAL='CFP Semifinal'
    CFP_NATIONAL_CHAMPIONSHIP='CFP National Championship'
    FCS_FIRST_ROUND='FCS First Round'
    FCS_SECOND_ROUND='FCS Second Round'
    FCS_QUARTERFINAL='FCS Quarterfinal'
    FCS_SEMIFINAL='FCS Semifinal'
    FCS_CHAMPIONSHIP='FCS Championship'


class pocket_locationType(str, Enum):
    SCRAMBLE_LEFT='Scramble Left'
    SCRAMBLE_RIGHT='Scramble Right'
    BOOT_LEFT='Boot Left'
    BOOT_RIGHT='Boot Right'
    ROLLOUT_LEFT='Rollout Left'
    ROLLOUT_RIGHT='Rollout Right'
    MIDDLE='Middle'


class positionType(str, Enum):
    ATH='ATH'
    C='C'
    CG='C/G'
    CB='CB'
    CBRS='CB/RS'
    CBS='CB/S'
    DB='DB'
    DE='DE'
    DELB='DE/LB'
    DL='DL'
    DT='DT'
    FB='FB'
    FBRB='FB/RB'
    FS='FS'
    G='G'
    GC='G/C'
    GT='G/T'
    HB='H/B'
    HBT='H/B/T'
    HB_1='HB'
    ILB='ILB'
    K='K'
    KP='K/P'
    KR='KR'
    L='L'
    LB='LB'
    LBDE='LB/DE'
    LS='LS'
    MLB='MLB'
    NT='NT'
    OG='OG'
    OL='OL'
    OLB='OLB'
    OT='OT'
    P='P'
    QB='QB'
    QBWR='QB/WR'
    RB='RB'
    RBST='RB/ST'
    RBWR='RB/WR'
    RS='RS'
    S='S'
    SS='SS'
    SAF='SAF'
    T='T'
    TG='T/G'
    TE='TE'
    TEDT='TE/DT'
    TEFB='TE/FB'
    TELS='TE/LS'
    TEW='TEW'
    WR='WR'
    WRCB='WR/CB'
    WRKR='WR/KR'
    WRPR='WR/PR'
    WRRB='WR/RB'
    WRRS='WR/RS'
    QBWR_1='QB/WR'
    DBLB='DB/LB'
    FBDL='FB/DL'
    DEDT='DE/DT'


class qb_at_snapType(str, Enum):
    SHOTGUN='Shotgun'
    UNDER_CENTER='Under Center'
    PISTOL='Pistol'


class roof_typeType(str, Enum):
    OUTDOOR='outdoor'
    DOME='dome'
    RETRACTABLE_DOME='retractable_dome'


class statusType(str, Enum):
    SCHEDULED='scheduled'
    CREATED='created'
    INPROGRESS='inprogress'
    HALFTIME='halftime'
    COMPLETE='complete'
    CLOSED='closed'
    CANCELLED='cancelled'
    POSTPONED='postponed'
    DELAYED='delayed'
    TIMETBD='time-tbd'
    FLEXSCHEDULE='flex-schedule'


class surfaceType(str, Enum):
    TURF='turf'
    ARTIFICIAL='artificial'


class typeType(str, Enum):
    SETUP='setup'
    TIMEOUT='timeout'
    COMMENT='comment'
    PERIOD_END='period_end'
    GAME_OVER='game_over'


class typeType4(str, Enum):
    PASS='pass'
    RUSH='rush'
    FAIRCATCH_KICK='faircatch_kick'
    EXTRA_POINT='extra_point'
    CONVERSION='conversion'
    FREE_KICK='free_kick'
    KICKOFF='kickoff'
    PUNT='punt'
    FIELD_GOAL='field_goal'
    PENALTY='penalty'


class typeType40(str, Enum):
    PRE='PRE'
    REG='REG'
    PST='PST'


class typeType5(str, Enum):
    EXTRA_POINT='extra_point'
    CONVERSION='conversion'
    PENALTY='penalty'


#
# Start data representation classes
#
class gameType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, sr_id=None, number=None, utc_offset=None, reference=None, scheduled=None, title=None, neutral_site=None, status=None, game_type=None, playoff_game_type=None, attendance=None, duration=None, coverage=None, clock=None, quarter=None, entry_mode=None, weather=None, coin_toss=None, summary=None, situation=None, last_event=None, scoring=None, scoring_drives=None, scoring_plays=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "b"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.sr_id = _cast(None, sr_id)
        self.sr_id_nsprefix_ = None
        self.number = _cast(int, number)
        self.number_nsprefix_ = None
        self.utc_offset = _cast(int, utc_offset)
        self.utc_offset_nsprefix_ = None
        self.reference = _cast(int, reference)
        self.reference_nsprefix_ = None
        if isinstance(scheduled, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(scheduled, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = scheduled
        self.scheduled = initvalue_
        self.title = _cast(None, title)
        self.title_nsprefix_ = None
        self.neutral_site = _cast(bool, neutral_site)
        self.neutral_site_nsprefix_ = None
        self.status = _cast(None, status)
        self.status_nsprefix_ = None
        self.game_type = _cast(None, game_type)
        self.game_type_nsprefix_ = None
        self.playoff_game_type = _cast(None, playoff_game_type)
        self.playoff_game_type_nsprefix_ = None
        self.attendance = _cast(int, attendance)
        self.attendance_nsprefix_ = None
        self.duration = _cast(None, duration)
        self.duration_nsprefix_ = None
        self.coverage = _cast(None, coverage)
        self.coverage_nsprefix_ = None
        self.clock = _cast(None, clock)
        self.clock_nsprefix_ = None
        self.quarter = _cast(int, quarter)
        self.quarter_nsprefix_ = None
        self.entry_mode = _cast(None, entry_mode)
        self.entry_mode_nsprefix_ = None
        self.weather = weather
        self.weather_nsprefix_ = "b"
        if coin_toss is None:
            self.coin_toss = []
        else:
            self.coin_toss = coin_toss
        self.coin_toss_nsprefix_ = "b"
        self.summary = summary
        self.summary_nsprefix_ = "b"
        self.situation = situation
        self.situation_nsprefix_ = "b"
        self.last_event = last_event
        self.last_event_nsprefix_ = "b"
        self.scoring = scoring
        self.scoring_nsprefix_ = "b"
        self.scoring_drives = scoring_drives
        self.scoring_drives_nsprefix_ = "b"
        self.scoring_plays = scoring_plays
        self.scoring_plays_nsprefix_ = "b"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, gameType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if gameType.subclass:
            return gameType.subclass(*args_, **kwargs_)
        else:
            return gameType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_weather(self):
        return self.weather
    def set_weather(self, weather):
        self.weather = weather
    def get_coin_toss(self):
        return self.coin_toss
    def set_coin_toss(self, coin_toss):
        self.coin_toss = coin_toss
    def add_coin_toss(self, value):
        self.coin_toss.append(value)
    def insert_coin_toss_at(self, index, value):
        self.coin_toss.insert(index, value)
    def replace_coin_toss_at(self, index, value):
        self.coin_toss[index] = value
    def get_summary(self):
        return self.summary
    def set_summary(self, summary):
        self.summary = summary
    def get_situation(self):
        return self.situation
    def set_situation(self, situation):
        self.situation = situation
    def get_last_event(self):
        return self.last_event
    def set_last_event(self, last_event):
        self.last_event = last_event
    def get_scoring(self):
        return self.scoring
    def set_scoring(self, scoring):
        self.scoring = scoring
    def get_scoring_drives(self):
        return self.scoring_drives
    def set_scoring_drives(self, scoring_drives):
        self.scoring_drives = scoring_drives
    def get_scoring_plays(self):
        return self.scoring_plays
    def set_scoring_plays(self, scoring_plays):
        self.scoring_plays = scoring_plays
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_sr_id(self):
        return self.sr_id
    def set_sr_id(self, sr_id):
        self.sr_id = sr_id
    def get_number(self):
        return self.number
    def set_number(self, number):
        self.number = number
    def get_utc_offset(self):
        return self.utc_offset
    def set_utc_offset(self, utc_offset):
        self.utc_offset = utc_offset
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def get_scheduled(self):
        return self.scheduled
    def set_scheduled(self, scheduled):
        self.scheduled = scheduled
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_neutral_site(self):
        return self.neutral_site
    def set_neutral_site(self, neutral_site):
        self.neutral_site = neutral_site
    def get_status(self):
        return self.status
    def set_status(self, status):
        self.status = status
    def get_game_type(self):
        return self.game_type
    def set_game_type(self, game_type):
        self.game_type = game_type
    def get_playoff_game_type(self):
        return self.playoff_game_type
    def set_playoff_game_type(self, playoff_game_type):
        self.playoff_game_type = playoff_game_type
    def get_attendance(self):
        return self.attendance
    def set_attendance(self, attendance):
        self.attendance = attendance
    def get_duration(self):
        return self.duration
    def set_duration(self, duration):
        self.duration = duration
    def get_coverage(self):
        return self.coverage
    def set_coverage(self, coverage):
        self.coverage = coverage
    def get_clock(self):
        return self.clock
    def set_clock(self, clock):
        self.clock = clock
    def get_quarter(self):
        return self.quarter
    def set_quarter(self, quarter):
        self.quarter = quarter
    def get_entry_mode(self):
        return self.entry_mode
    def set_entry_mode(self, entry_mode):
        self.entry_mode = entry_mode
    def validate_statusType(self, value):
        # Validate type statusType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['scheduled', 'created', 'inprogress', 'halftime', 'complete', 'closed', 'cancelled', 'postponed', 'delayed', 'time-tbd', 'flex-schedule']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on statusType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_game_typeType(self, value):
        # Validate type game_typeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['regular', 'conference_championship', 'bowl', 'playoff']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on game_typeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_playoff_game_typeType(self, value):
        # Validate type playoff_game_typeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['CFP Semifinal', 'CFP National Championship', 'FCS First Round', 'FCS Second Round', 'FCS Quarterfinal', 'FCS Semifinal', 'FCS Championship']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on playoff_game_typeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_coverageType(self, value):
        # Validate type coverageType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['full', 'extended_boxscore', 'boxscore']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on coverageType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_entry_modeType(self, value):
        # Validate type entry_modeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['INGEST', 'LDE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on entry_modeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.weather is not None or
            self.coin_toss or
            self.summary is not None or
            self.situation is not None or
            self.last_event is not None or
            self.scoring is not None or
            self.scoring_drives is not None or
            self.scoring_plays is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='gameType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('gameType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'gameType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='gameType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='gameType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='gameType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.sr_id is not None and 'sr_id' not in already_processed:
            already_processed.add('sr_id')
            outfile.write(' sr_id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.sr_id), input_name='sr_id')), ))
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number="%s"' % self.gds_format_integer(self.number, input_name='number'))
        if self.utc_offset is not None and 'utc_offset' not in already_processed:
            already_processed.add('utc_offset')
            outfile.write(' utc_offset="%s"' % self.gds_format_integer(self.utc_offset, input_name='utc_offset'))
        if self.reference is not None and 'reference' not in already_processed:
            already_processed.add('reference')
            outfile.write(' reference="%s"' % self.gds_format_integer(self.reference, input_name='reference'))
        if self.scheduled is not None and 'scheduled' not in already_processed:
            already_processed.add('scheduled')
            outfile.write(' scheduled="%s"' % self.gds_format_datetime(self.scheduled, input_name='scheduled'))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.title), input_name='title')), ))
        if self.neutral_site is not None and 'neutral_site' not in already_processed:
            already_processed.add('neutral_site')
            outfile.write(' neutral_site="%s"' % self.gds_format_boolean(self.neutral_site, input_name='neutral_site'))
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            outfile.write(' status=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.status), input_name='status')), ))
        if self.game_type is not None and 'game_type' not in already_processed:
            already_processed.add('game_type')
            outfile.write(' game_type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.game_type), input_name='game_type')), ))
        if self.playoff_game_type is not None and 'playoff_game_type' not in already_processed:
            already_processed.add('playoff_game_type')
            outfile.write(' playoff_game_type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.playoff_game_type), input_name='playoff_game_type')), ))
        if self.attendance is not None and 'attendance' not in already_processed:
            already_processed.add('attendance')
            outfile.write(' attendance="%s"' % self.gds_format_integer(self.attendance, input_name='attendance'))
        if self.duration is not None and 'duration' not in already_processed:
            already_processed.add('duration')
            outfile.write(' duration=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.duration), input_name='duration')), ))
        if self.coverage is not None and 'coverage' not in already_processed:
            already_processed.add('coverage')
            outfile.write(' coverage=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.coverage), input_name='coverage')), ))
        if self.clock is not None and 'clock' not in already_processed:
            already_processed.add('clock')
            outfile.write(' clock=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.clock), input_name='clock')), ))
        if self.quarter is not None and 'quarter' not in already_processed:
            already_processed.add('quarter')
            outfile.write(' quarter="%s"' % self.gds_format_integer(self.quarter, input_name='quarter'))
        if self.entry_mode is not None and 'entry_mode' not in already_processed:
            already_processed.add('entry_mode')
            outfile.write(' entry_mode=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.entry_mode), input_name='entry_mode')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='gameType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.weather is not None:
            namespaceprefix_ = self.weather_nsprefix_ + ':' if (UseCapturedNS_ and self.weather_nsprefix_) else ''
            self.weather.export(outfile, level, namespaceprefix_, namespacedef_='', name_='weather', pretty_print=pretty_print)
        for coin_toss_ in self.coin_toss:
            namespaceprefix_ = self.coin_toss_nsprefix_ + ':' if (UseCapturedNS_ and self.coin_toss_nsprefix_) else ''
            coin_toss_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='coin_toss', pretty_print=pretty_print)
        if self.summary is not None:
            namespaceprefix_ = self.summary_nsprefix_ + ':' if (UseCapturedNS_ and self.summary_nsprefix_) else ''
            self.summary.export(outfile, level, namespaceprefix_, namespacedef_='', name_='summary', pretty_print=pretty_print)
        if self.situation is not None:
            namespaceprefix_ = self.situation_nsprefix_ + ':' if (UseCapturedNS_ and self.situation_nsprefix_) else ''
            self.situation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='situation', pretty_print=pretty_print)
        if self.last_event is not None:
            namespaceprefix_ = self.last_event_nsprefix_ + ':' if (UseCapturedNS_ and self.last_event_nsprefix_) else ''
            self.last_event.export(outfile, level, namespaceprefix_, namespacedef_='', name_='last_event', pretty_print=pretty_print)
        if self.scoring is not None:
            namespaceprefix_ = self.scoring_nsprefix_ + ':' if (UseCapturedNS_ and self.scoring_nsprefix_) else ''
            self.scoring.export(outfile, level, namespaceprefix_, namespacedef_='', name_='scoring', pretty_print=pretty_print)
        if self.scoring_drives is not None:
            namespaceprefix_ = self.scoring_drives_nsprefix_ + ':' if (UseCapturedNS_ and self.scoring_drives_nsprefix_) else ''
            self.scoring_drives.export(outfile, level, namespaceprefix_, namespacedef_='', name_='scoring_drives', pretty_print=pretty_print)
        if self.scoring_plays is not None:
            namespaceprefix_ = self.scoring_plays_nsprefix_ + ':' if (UseCapturedNS_ and self.scoring_plays_nsprefix_) else ''
            self.scoring_plays.export(outfile, level, namespaceprefix_, namespacedef_='', name_='scoring_plays', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('sr_id', node)
        if value is not None and 'sr_id' not in already_processed:
            already_processed.add('sr_id')
            self.sr_id = value
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            self.number = self.gds_parse_integer(value, node, 'number')
        value = find_attr_value_('utc_offset', node)
        if value is not None and 'utc_offset' not in already_processed:
            already_processed.add('utc_offset')
            self.utc_offset = self.gds_parse_integer(value, node, 'utc_offset')
        value = find_attr_value_('reference', node)
        if value is not None and 'reference' not in already_processed:
            already_processed.add('reference')
            self.reference = self.gds_parse_integer(value, node, 'reference')
        value = find_attr_value_('scheduled', node)
        if value is not None and 'scheduled' not in already_processed:
            already_processed.add('scheduled')
            try:
                self.scheduled = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (scheduled): %s' % exp)
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('neutral_site', node)
        if value is not None and 'neutral_site' not in already_processed:
            already_processed.add('neutral_site')
            if value in ('true', '1'):
                self.neutral_site = True
            elif value in ('false', '0'):
                self.neutral_site = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.add('status')
            self.status = value
            self.validate_statusType(self.status)    # validate type statusType
        value = find_attr_value_('game_type', node)
        if value is not None and 'game_type' not in already_processed:
            already_processed.add('game_type')
            self.game_type = value
            self.validate_game_typeType(self.game_type)    # validate type game_typeType
        value = find_attr_value_('playoff_game_type', node)
        if value is not None and 'playoff_game_type' not in already_processed:
            already_processed.add('playoff_game_type')
            self.playoff_game_type = value
            self.validate_playoff_game_typeType(self.playoff_game_type)    # validate type playoff_game_typeType
        value = find_attr_value_('attendance', node)
        if value is not None and 'attendance' not in already_processed:
            already_processed.add('attendance')
            self.attendance = self.gds_parse_integer(value, node, 'attendance')
        value = find_attr_value_('duration', node)
        if value is not None and 'duration' not in already_processed:
            already_processed.add('duration')
            self.duration = value
        value = find_attr_value_('coverage', node)
        if value is not None and 'coverage' not in already_processed:
            already_processed.add('coverage')
            self.coverage = value
            self.validate_coverageType(self.coverage)    # validate type coverageType
        value = find_attr_value_('clock', node)
        if value is not None and 'clock' not in already_processed:
            already_processed.add('clock')
            self.clock = value
        value = find_attr_value_('quarter', node)
        if value is not None and 'quarter' not in already_processed:
            already_processed.add('quarter')
            self.quarter = self.gds_parse_integer(value, node, 'quarter')
        value = find_attr_value_('entry_mode', node)
        if value is not None and 'entry_mode' not in already_processed:
            already_processed.add('entry_mode')
            self.entry_mode = value
            self.validate_entry_modeType(self.entry_mode)    # validate type entry_modeType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'weather':
            obj_ = weatherType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.weather = obj_
            obj_.original_tagname_ = 'weather'
        elif nodeName_ == 'coin_toss':
            obj_ = coinTossType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.coin_toss.append(obj_)
            obj_.original_tagname_ = 'coin_toss'
        elif nodeName_ == 'summary':
            obj_ = summaryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.summary = obj_
            obj_.original_tagname_ = 'summary'
        elif nodeName_ == 'situation':
            obj_ = fieldSituationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.situation = obj_
            obj_.original_tagname_ = 'situation'
        elif nodeName_ == 'last_event':
            obj_ = last_eventType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.last_event = obj_
            obj_.original_tagname_ = 'last_event'
        elif nodeName_ == 'scoring':
            obj_ = scoringType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.scoring = obj_
            obj_.original_tagname_ = 'scoring'
        elif nodeName_ == 'scoring_drives':
            obj_ = scoring_drivesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.scoring_drives = obj_
            obj_.original_tagname_ = 'scoring_drives'
        elif nodeName_ == 'scoring_plays':
            obj_ = scoring_playsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.scoring_plays = obj_
            obj_.original_tagname_ = 'scoring_plays'
# end class gameType


class periodType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, away_points=None, home_points=None, id=None, number=None, sequence=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "b"
        self.away_points = _cast(int, away_points)
        self.away_points_nsprefix_ = None
        self.home_points = _cast(int, home_points)
        self.home_points_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.number = _cast(int, number)
        self.number_nsprefix_ = None
        self.sequence = _cast(int, sequence)
        self.sequence_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, periodType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if periodType.subclass:
            return periodType.subclass(*args_, **kwargs_)
        else:
            return periodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_away_points(self):
        return self.away_points
    def set_away_points(self, away_points):
        self.away_points = away_points
    def get_home_points(self):
        return self.home_points
    def set_home_points(self, home_points):
        self.home_points = home_points
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_number(self):
        return self.number
    def set_number(self, number):
        self.number = number
    def get_sequence(self):
        return self.sequence
    def set_sequence(self, sequence):
        self.sequence = sequence
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='periodType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('periodType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'periodType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='periodType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='periodType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='periodType'):
        if self.away_points is not None and 'away_points' not in already_processed:
            already_processed.add('away_points')
            outfile.write(' away_points="%s"' % self.gds_format_integer(self.away_points, input_name='away_points'))
        if self.home_points is not None and 'home_points' not in already_processed:
            already_processed.add('home_points')
            outfile.write(' home_points="%s"' % self.gds_format_integer(self.home_points, input_name='home_points'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number="%s"' % self.gds_format_integer(self.number, input_name='number'))
        if self.sequence is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            outfile.write(' sequence="%s"' % self.gds_format_integer(self.sequence, input_name='sequence'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='periodType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('away_points', node)
        if value is not None and 'away_points' not in already_processed:
            already_processed.add('away_points')
            self.away_points = self.gds_parse_integer(value, node, 'away_points')
        value = find_attr_value_('home_points', node)
        if value is not None and 'home_points' not in already_processed:
            already_processed.add('home_points')
            self.home_points = self.gds_parse_integer(value, node, 'home_points')
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            self.number = self.gds_parse_integer(value, node, 'number')
        value = find_attr_value_('sequence', node)
        if value is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            self.sequence = self.gds_parse_integer(value, node, 'sequence')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class periodType


class scoringDriveType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, sequence=None, start_reason=None, end_reason=None, duration=None, first_downs=None, gain=None, inside_20=None, penalty_yards=None, play_count=None, scoring_drive=None, created_at=None, updated_at=None, quarter=None, overtime=None, team=None, plays=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "b"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.sequence = _cast(int, sequence)
        self.sequence_nsprefix_ = None
        self.start_reason = _cast(None, start_reason)
        self.start_reason_nsprefix_ = None
        self.end_reason = _cast(None, end_reason)
        self.end_reason_nsprefix_ = None
        self.duration = _cast(None, duration)
        self.duration_nsprefix_ = None
        self.first_downs = _cast(int, first_downs)
        self.first_downs_nsprefix_ = None
        self.gain = _cast(int, gain)
        self.gain_nsprefix_ = None
        self.inside_20 = _cast(bool, inside_20)
        self.inside_20_nsprefix_ = None
        self.penalty_yards = _cast(int, penalty_yards)
        self.penalty_yards_nsprefix_ = None
        self.play_count = _cast(int, play_count)
        self.play_count_nsprefix_ = None
        self.scoring_drive = _cast(bool, scoring_drive)
        self.scoring_drive_nsprefix_ = None
        self.created_at = _cast(None, created_at)
        self.created_at_nsprefix_ = None
        self.updated_at = _cast(None, updated_at)
        self.updated_at_nsprefix_ = None
        self.quarter = quarter
        self.quarter_nsprefix_ = "b"
        self.overtime = overtime
        self.overtime_nsprefix_ = "b"
        self.team = team
        self.team_nsprefix_ = "b"
        self.plays = plays
        self.plays_nsprefix_ = "b"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, scoringDriveType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if scoringDriveType.subclass:
            return scoringDriveType.subclass(*args_, **kwargs_)
        else:
            return scoringDriveType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_quarter(self):
        return self.quarter
    def set_quarter(self, quarter):
        self.quarter = quarter
    def get_overtime(self):
        return self.overtime
    def set_overtime(self, overtime):
        self.overtime = overtime
    def get_team(self):
        return self.team
    def set_team(self, team):
        self.team = team
    def get_plays(self):
        return self.plays
    def set_plays(self, plays):
        self.plays = plays
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_sequence(self):
        return self.sequence
    def set_sequence(self, sequence):
        self.sequence = sequence
    def get_start_reason(self):
        return self.start_reason
    def set_start_reason(self, start_reason):
        self.start_reason = start_reason
    def get_end_reason(self):
        return self.end_reason
    def set_end_reason(self, end_reason):
        self.end_reason = end_reason
    def get_duration(self):
        return self.duration
    def set_duration(self, duration):
        self.duration = duration
    def get_first_downs(self):
        return self.first_downs
    def set_first_downs(self, first_downs):
        self.first_downs = first_downs
    def get_gain(self):
        return self.gain
    def set_gain(self, gain):
        self.gain = gain
    def get_inside_20(self):
        return self.inside_20
    def set_inside_20(self, inside_20):
        self.inside_20 = inside_20
    def get_penalty_yards(self):
        return self.penalty_yards
    def set_penalty_yards(self, penalty_yards):
        self.penalty_yards = penalty_yards
    def get_play_count(self):
        return self.play_count
    def set_play_count(self, play_count):
        self.play_count = play_count
    def get_scoring_drive(self):
        return self.scoring_drive
    def set_scoring_drive(self, scoring_drive):
        self.scoring_drive = scoring_drive
    def get_created_at(self):
        return self.created_at
    def set_created_at(self, created_at):
        self.created_at = created_at
    def get_updated_at(self):
        return self.updated_at
    def set_updated_at(self, updated_at):
        self.updated_at = updated_at
    def validate_driveReason(self, value):
        # Validate type driveReason, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['UNKNOWN', 'Touchdown', 'Safety', 'Field Goal', 'Missed FG', 'Blocked FG', 'Blocked FG, Downs', 'Blocked FG, Safety', 'Punt', 'Blocked Punt', 'Blocked Punt, Downs', 'Blocked Punt, Safety', 'Downs', 'Interception', 'Fumble', 'Fumble, Safety', 'Muffed FG', 'Muffed Punt', 'Muffed Kickoff', 'Kickoff', 'Own Kickoff', 'Onside Kick', 'Kickoff, No Play', 'End of Half', 'End of Game']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on driveReason' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.quarter is not None or
            self.overtime is not None or
            self.team is not None or
            self.plays is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='scoringDriveType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('scoringDriveType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'scoringDriveType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='scoringDriveType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='scoringDriveType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='scoringDriveType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.sequence is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            outfile.write(' sequence="%s"' % self.gds_format_integer(self.sequence, input_name='sequence'))
        if self.start_reason is not None and 'start_reason' not in already_processed:
            already_processed.add('start_reason')
            outfile.write(' start_reason=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.start_reason), input_name='start_reason')), ))
        if self.end_reason is not None and 'end_reason' not in already_processed:
            already_processed.add('end_reason')
            outfile.write(' end_reason=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.end_reason), input_name='end_reason')), ))
        if self.duration is not None and 'duration' not in already_processed:
            already_processed.add('duration')
            outfile.write(' duration=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.duration), input_name='duration')), ))
        if self.first_downs is not None and 'first_downs' not in already_processed:
            already_processed.add('first_downs')
            outfile.write(' first_downs="%s"' % self.gds_format_integer(self.first_downs, input_name='first_downs'))
        if self.gain is not None and 'gain' not in already_processed:
            already_processed.add('gain')
            outfile.write(' gain="%s"' % self.gds_format_integer(self.gain, input_name='gain'))
        if self.inside_20 is not None and 'inside_20' not in already_processed:
            already_processed.add('inside_20')
            outfile.write(' inside_20="%s"' % self.gds_format_boolean(self.inside_20, input_name='inside_20'))
        if self.penalty_yards is not None and 'penalty_yards' not in already_processed:
            already_processed.add('penalty_yards')
            outfile.write(' penalty_yards="%s"' % self.gds_format_integer(self.penalty_yards, input_name='penalty_yards'))
        if self.play_count is not None and 'play_count' not in already_processed:
            already_processed.add('play_count')
            outfile.write(' play_count="%s"' % self.gds_format_integer(self.play_count, input_name='play_count'))
        if self.scoring_drive is not None and 'scoring_drive' not in already_processed:
            already_processed.add('scoring_drive')
            outfile.write(' scoring_drive="%s"' % self.gds_format_boolean(self.scoring_drive, input_name='scoring_drive'))
        if self.created_at is not None and 'created_at' not in already_processed:
            already_processed.add('created_at')
            outfile.write(' created_at=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.created_at), input_name='created_at')), ))
        if self.updated_at is not None and 'updated_at' not in already_processed:
            already_processed.add('updated_at')
            outfile.write(' updated_at=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.updated_at), input_name='updated_at')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='scoringDriveType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.quarter is not None:
            namespaceprefix_ = self.quarter_nsprefix_ + ':' if (UseCapturedNS_ and self.quarter_nsprefix_) else ''
            self.quarter.export(outfile, level, namespaceprefix_, namespacedef_='', name_='quarter', pretty_print=pretty_print)
        if self.overtime is not None:
            namespaceprefix_ = self.overtime_nsprefix_ + ':' if (UseCapturedNS_ and self.overtime_nsprefix_) else ''
            self.overtime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='overtime', pretty_print=pretty_print)
        if self.team is not None:
            namespaceprefix_ = self.team_nsprefix_ + ':' if (UseCapturedNS_ and self.team_nsprefix_) else ''
            self.team.export(outfile, level, namespaceprefix_, namespacedef_='', name_='team', pretty_print=pretty_print)
        if self.plays is not None:
            namespaceprefix_ = self.plays_nsprefix_ + ':' if (UseCapturedNS_ and self.plays_nsprefix_) else ''
            self.plays.export(outfile, level, namespaceprefix_, namespacedef_='', name_='plays', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('sequence', node)
        if value is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            self.sequence = self.gds_parse_integer(value, node, 'sequence')
        value = find_attr_value_('start_reason', node)
        if value is not None and 'start_reason' not in already_processed:
            already_processed.add('start_reason')
            self.start_reason = value
            self.validate_driveReason(self.start_reason)    # validate type driveReason
        value = find_attr_value_('end_reason', node)
        if value is not None and 'end_reason' not in already_processed:
            already_processed.add('end_reason')
            self.end_reason = value
            self.validate_driveReason(self.end_reason)    # validate type driveReason
        value = find_attr_value_('duration', node)
        if value is not None and 'duration' not in already_processed:
            already_processed.add('duration')
            self.duration = value
        value = find_attr_value_('first_downs', node)
        if value is not None and 'first_downs' not in already_processed:
            already_processed.add('first_downs')
            self.first_downs = self.gds_parse_integer(value, node, 'first_downs')
        value = find_attr_value_('gain', node)
        if value is not None and 'gain' not in already_processed:
            already_processed.add('gain')
            self.gain = self.gds_parse_integer(value, node, 'gain')
        value = find_attr_value_('inside_20', node)
        if value is not None and 'inside_20' not in already_processed:
            already_processed.add('inside_20')
            if value in ('true', '1'):
                self.inside_20 = True
            elif value in ('false', '0'):
                self.inside_20 = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('penalty_yards', node)
        if value is not None and 'penalty_yards' not in already_processed:
            already_processed.add('penalty_yards')
            self.penalty_yards = self.gds_parse_integer(value, node, 'penalty_yards')
        value = find_attr_value_('play_count', node)
        if value is not None and 'play_count' not in already_processed:
            already_processed.add('play_count')
            self.play_count = self.gds_parse_integer(value, node, 'play_count')
        value = find_attr_value_('scoring_drive', node)
        if value is not None and 'scoring_drive' not in already_processed:
            already_processed.add('scoring_drive')
            if value in ('true', '1'):
                self.scoring_drive = True
            elif value in ('false', '0'):
                self.scoring_drive = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('created_at', node)
        if value is not None and 'created_at' not in already_processed:
            already_processed.add('created_at')
            self.created_at = value
        value = find_attr_value_('updated_at', node)
        if value is not None and 'updated_at' not in already_processed:
            already_processed.add('updated_at')
            self.updated_at = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'quarter':
            obj_ = quarterType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.quarter = obj_
            obj_.original_tagname_ = 'quarter'
        elif nodeName_ == 'overtime':
            obj_ = overtimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.overtime = obj_
            obj_.original_tagname_ = 'overtime'
        elif nodeName_ == 'team':
            obj_ = teamType1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.team = obj_
            obj_.original_tagname_ = 'team'
        elif nodeName_ == 'plays':
            obj_ = playsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.plays = obj_
            obj_.original_tagname_ = 'plays'
# end class scoringDriveType


class summaryType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, season=None, week=None, venue=None, home=None, away=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "b"
        self.season = season
        self.season_nsprefix_ = "b"
        self.week = week
        self.week_nsprefix_ = "b"
        self.venue = venue
        self.venue_nsprefix_ = "b"
        self.home = home
        self.home_nsprefix_ = "b"
        self.away = away
        self.away_nsprefix_ = "b"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, summaryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if summaryType.subclass:
            return summaryType.subclass(*args_, **kwargs_)
        else:
            return summaryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_season(self):
        return self.season
    def set_season(self, season):
        self.season = season
    def get_week(self):
        return self.week
    def set_week(self, week):
        self.week = week
    def get_venue(self):
        return self.venue
    def set_venue(self, venue):
        self.venue = venue
    def get_home(self):
        return self.home
    def set_home(self, home):
        self.home = home
    def get_away(self):
        return self.away
    def set_away(self, away):
        self.away = away
    def has__content(self):
        if (
            self.season is not None or
            self.week is not None or
            self.venue is not None or
            self.home is not None or
            self.away is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='summaryType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('summaryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'summaryType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='summaryType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='summaryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='summaryType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='summaryType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.season is not None:
            namespaceprefix_ = self.season_nsprefix_ + ':' if (UseCapturedNS_ and self.season_nsprefix_) else ''
            self.season.export(outfile, level, namespaceprefix_, namespacedef_='', name_='season', pretty_print=pretty_print)
        if self.week is not None:
            namespaceprefix_ = self.week_nsprefix_ + ':' if (UseCapturedNS_ and self.week_nsprefix_) else ''
            self.week.export(outfile, level, namespaceprefix_, namespacedef_='', name_='week', pretty_print=pretty_print)
        if self.venue is not None:
            namespaceprefix_ = self.venue_nsprefix_ + ':' if (UseCapturedNS_ and self.venue_nsprefix_) else ''
            self.venue.export(outfile, level, namespaceprefix_, namespacedef_='', name_='venue', pretty_print=pretty_print)
        if self.home is not None:
            namespaceprefix_ = self.home_nsprefix_ + ':' if (UseCapturedNS_ and self.home_nsprefix_) else ''
            self.home.export(outfile, level, namespaceprefix_, namespacedef_='', name_='home', pretty_print=pretty_print)
        if self.away is not None:
            namespaceprefix_ = self.away_nsprefix_ + ':' if (UseCapturedNS_ and self.away_nsprefix_) else ''
            self.away.export(outfile, level, namespaceprefix_, namespacedef_='', name_='away', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'season':
            obj_ = seasonType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.season = obj_
            obj_.original_tagname_ = 'season'
        elif nodeName_ == 'week':
            obj_ = weekType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.week = obj_
            obj_.original_tagname_ = 'week'
        elif nodeName_ == 'venue':
            obj_ = venueType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.venue = obj_
            obj_.original_tagname_ = 'venue'
        elif nodeName_ == 'home':
            obj_ = gameTeamType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.home = obj_
            obj_.original_tagname_ = 'home'
        elif nodeName_ == 'away':
            obj_ = gameTeamType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.away = obj_
            obj_.original_tagname_ = 'away'
# end class summaryType


class fieldSituationType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, clock=None, down=None, yfd=None, possession=None, location=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "b"
        self.clock = _cast(None, clock)
        self.clock_nsprefix_ = None
        self.down = _cast(int, down)
        self.down_nsprefix_ = None
        self.yfd = _cast(int, yfd)
        self.yfd_nsprefix_ = None
        self.possession = possession
        self.possession_nsprefix_ = "b"
        self.location = location
        self.location_nsprefix_ = "b"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fieldSituationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fieldSituationType.subclass:
            return fieldSituationType.subclass(*args_, **kwargs_)
        else:
            return fieldSituationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_possession(self):
        return self.possession
    def set_possession(self, possession):
        self.possession = possession
    def get_location(self):
        return self.location
    def set_location(self, location):
        self.location = location
    def get_clock(self):
        return self.clock
    def set_clock(self, clock):
        self.clock = clock
    def get_down(self):
        return self.down
    def set_down(self, down):
        self.down = down
    def get_yfd(self):
        return self.yfd
    def set_yfd(self, yfd):
        self.yfd = yfd
    def has__content(self):
        if (
            self.possession is not None or
            self.location is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='fieldSituationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fieldSituationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'fieldSituationType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='fieldSituationType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='fieldSituationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='fieldSituationType'):
        if self.clock is not None and 'clock' not in already_processed:
            already_processed.add('clock')
            outfile.write(' clock=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.clock), input_name='clock')), ))
        if self.down is not None and 'down' not in already_processed:
            already_processed.add('down')
            outfile.write(' down="%s"' % self.gds_format_integer(self.down, input_name='down'))
        if self.yfd is not None and 'yfd' not in already_processed:
            already_processed.add('yfd')
            outfile.write(' yfd="%s"' % self.gds_format_integer(self.yfd, input_name='yfd'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='fieldSituationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.possession is not None:
            namespaceprefix_ = self.possession_nsprefix_ + ':' if (UseCapturedNS_ and self.possession_nsprefix_) else ''
            self.possession.export(outfile, level, namespaceprefix_, namespacedef_='', name_='possession', pretty_print=pretty_print)
        if self.location is not None:
            namespaceprefix_ = self.location_nsprefix_ + ':' if (UseCapturedNS_ and self.location_nsprefix_) else ''
            self.location.export(outfile, level, namespaceprefix_, namespacedef_='', name_='location', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('clock', node)
        if value is not None and 'clock' not in already_processed:
            already_processed.add('clock')
            self.clock = value
        value = find_attr_value_('down', node)
        if value is not None and 'down' not in already_processed:
            already_processed.add('down')
            self.down = self.gds_parse_integer(value, node, 'down')
        value = find_attr_value_('yfd', node)
        if value is not None and 'yfd' not in already_processed:
            already_processed.add('yfd')
            self.yfd = self.gds_parse_integer(value, node, 'yfd')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'possession':
            class_obj_ = self.get_class_obj_(child_, teamType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.possession = obj_
            obj_.original_tagname_ = 'possession'
        elif nodeName_ == 'location':
            obj_ = fieldLocationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.location = obj_
            obj_.original_tagname_ = 'location'
# end class fieldSituationType


class fieldLocationType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, yardline=None, id=None, sr_id=None, alias=None, name=None, market=None, founded=None, reference=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "b"
        self.yardline = _cast(int, yardline)
        self.yardline_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.sr_id = _cast(None, sr_id)
        self.sr_id_nsprefix_ = None
        self.alias = _cast(None, alias)
        self.alias_nsprefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.market = _cast(None, market)
        self.market_nsprefix_ = None
        self.founded = _cast(int, founded)
        self.founded_nsprefix_ = None
        self.reference = _cast(None, reference)
        self.reference_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fieldLocationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fieldLocationType.subclass:
            return fieldLocationType.subclass(*args_, **kwargs_)
        else:
            return fieldLocationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_yardline(self):
        return self.yardline
    def set_yardline(self, yardline):
        self.yardline = yardline
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_sr_id(self):
        return self.sr_id
    def set_sr_id(self, sr_id):
        self.sr_id = sr_id
    def get_alias(self):
        return self.alias
    def set_alias(self, alias):
        self.alias = alias
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_market(self):
        return self.market
    def set_market(self, market):
        self.market = market
    def get_founded(self):
        return self.founded
    def set_founded(self, founded):
        self.founded = founded
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='fieldLocationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fieldLocationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'fieldLocationType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='fieldLocationType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='fieldLocationType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='fieldLocationType'):
        if self.yardline is not None and 'yardline' not in already_processed:
            already_processed.add('yardline')
            outfile.write(' yardline="%s"' % self.gds_format_integer(self.yardline, input_name='yardline'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.sr_id is not None and 'sr_id' not in already_processed:
            already_processed.add('sr_id')
            outfile.write(' sr_id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.sr_id), input_name='sr_id')), ))
        if self.alias is not None and 'alias' not in already_processed:
            already_processed.add('alias')
            outfile.write(' alias=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.alias), input_name='alias')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.market is not None and 'market' not in already_processed:
            already_processed.add('market')
            outfile.write(' market=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.market), input_name='market')), ))
        if self.founded is not None and 'founded' not in already_processed:
            already_processed.add('founded')
            outfile.write(' founded="%s"' % self.gds_format_integer(self.founded, input_name='founded'))
        if self.reference is not None and 'reference' not in already_processed:
            already_processed.add('reference')
            outfile.write(' reference=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.reference), input_name='reference')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='fieldLocationType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('yardline', node)
        if value is not None and 'yardline' not in already_processed:
            already_processed.add('yardline')
            self.yardline = self.gds_parse_integer(value, node, 'yardline')
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('sr_id', node)
        if value is not None and 'sr_id' not in already_processed:
            already_processed.add('sr_id')
            self.sr_id = value
        value = find_attr_value_('alias', node)
        if value is not None and 'alias' not in already_processed:
            already_processed.add('alias')
            self.alias = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('market', node)
        if value is not None and 'market' not in already_processed:
            already_processed.add('market')
            self.market = value
        value = find_attr_value_('founded', node)
        if value is not None and 'founded' not in already_processed:
            already_processed.add('founded')
            self.founded = self.gds_parse_integer(value, node, 'founded')
        value = find_attr_value_('reference', node)
        if value is not None and 'reference' not in already_processed:
            already_processed.add('reference')
            self.reference = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class fieldLocationType


class gameEventType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, created_at=None, updated_at=None, id=None, sequence=None, reference=None, clock=None, wall_clock=None, deleted=None, source=None, description=None, alt_description=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "b"
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.created_at = _cast(None, created_at)
        self.created_at_nsprefix_ = None
        self.updated_at = _cast(None, updated_at)
        self.updated_at_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.sequence = _cast(float, sequence)
        self.sequence_nsprefix_ = None
        self.reference = _cast(int, reference)
        self.reference_nsprefix_ = None
        self.clock = _cast(None, clock)
        self.clock_nsprefix_ = None
        if isinstance(wall_clock, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(wall_clock, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = wall_clock
        self.wall_clock = initvalue_
        self.deleted = _cast(bool, deleted)
        self.deleted_nsprefix_ = None
        self.source = _cast(None, source)
        self.source_nsprefix_ = None
        self.description = description
        self.description_nsprefix_ = "b"
        self.alt_description = alt_description
        self.alt_description_nsprefix_ = "b"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, gameEventType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if gameEventType.subclass:
            return gameEventType.subclass(*args_, **kwargs_)
        else:
            return gameEventType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_alt_description(self):
        return self.alt_description
    def set_alt_description(self, alt_description):
        self.alt_description = alt_description
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_created_at(self):
        return self.created_at
    def set_created_at(self, created_at):
        self.created_at = created_at
    def get_updated_at(self):
        return self.updated_at
    def set_updated_at(self, updated_at):
        self.updated_at = updated_at
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_sequence(self):
        return self.sequence
    def set_sequence(self, sequence):
        self.sequence = sequence
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def get_clock(self):
        return self.clock
    def set_clock(self, clock):
        self.clock = clock
    def get_wall_clock(self):
        return self.wall_clock
    def set_wall_clock(self, wall_clock):
        self.wall_clock = wall_clock
    def get_deleted(self):
        return self.deleted
    def set_deleted(self, deleted):
        self.deleted = deleted
    def get_source(self):
        return self.source
    def set_source(self, source):
        self.source = source
    def validate_typeType(self, value):
        # Validate type typeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['setup', 'timeout', 'comment', 'period_end', 'game_over']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.description is not None or
            self.alt_description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='gameEventType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('gameEventType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'gameEventType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='gameEventType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='gameEventType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='gameEventType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.created_at is not None and 'created_at' not in already_processed:
            already_processed.add('created_at')
            outfile.write(' created_at=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.created_at), input_name='created_at')), ))
        if self.updated_at is not None and 'updated_at' not in already_processed:
            already_processed.add('updated_at')
            outfile.write(' updated_at=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.updated_at), input_name='updated_at')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.sequence is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            outfile.write(' sequence="%s"' % self.gds_format_decimal(self.sequence, input_name='sequence'))
        if self.reference is not None and 'reference' not in already_processed:
            already_processed.add('reference')
            outfile.write(' reference="%s"' % self.gds_format_integer(self.reference, input_name='reference'))
        if self.clock is not None and 'clock' not in already_processed:
            already_processed.add('clock')
            outfile.write(' clock=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.clock), input_name='clock')), ))
        if self.wall_clock is not None and 'wall_clock' not in already_processed:
            already_processed.add('wall_clock')
            outfile.write(' wall_clock="%s"' % self.gds_format_datetime(self.wall_clock, input_name='wall_clock'))
        if self.deleted is not None and 'deleted' not in already_processed:
            already_processed.add('deleted')
            outfile.write(' deleted="%s"' % self.gds_format_boolean(self.deleted, input_name='deleted'))
        if self.source is not None and 'source' not in already_processed:
            already_processed.add('source')
            outfile.write(' source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.source), input_name='source')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='gameEventType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.alt_description is not None:
            namespaceprefix_ = self.alt_description_nsprefix_ + ':' if (UseCapturedNS_ and self.alt_description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%salt-description>%s</%salt-description>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.alt_description), input_name='alt-description')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_typeType(self.type_)    # validate type typeType
        value = find_attr_value_('created_at', node)
        if value is not None and 'created_at' not in already_processed:
            already_processed.add('created_at')
            self.created_at = value
        value = find_attr_value_('updated_at', node)
        if value is not None and 'updated_at' not in already_processed:
            already_processed.add('updated_at')
            self.updated_at = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('sequence', node)
        if value is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            value = self.gds_parse_decimal(value, node, 'sequence')
            self.sequence = value
        value = find_attr_value_('reference', node)
        if value is not None and 'reference' not in already_processed:
            already_processed.add('reference')
            self.reference = self.gds_parse_integer(value, node, 'reference')
        value = find_attr_value_('clock', node)
        if value is not None and 'clock' not in already_processed:
            already_processed.add('clock')
            self.clock = value
        value = find_attr_value_('wall_clock', node)
        if value is not None and 'wall_clock' not in already_processed:
            already_processed.add('wall_clock')
            try:
                self.wall_clock = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (wall_clock): %s' % exp)
        value = find_attr_value_('deleted', node)
        if value is not None and 'deleted' not in already_processed:
            already_processed.add('deleted')
            if value in ('true', '1'):
                self.deleted = True
            elif value in ('false', '0'):
                self.deleted = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('source', node)
        if value is not None and 'source' not in already_processed:
            already_processed.add('source')
            self.source = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'alt-description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'alt_description')
            value_ = self.gds_validate_string(value_, node, 'alt_description')
            self.alt_description = value_
            self.alt_description_nsprefix_ = child_.prefix
# end class gameEventType


class basePlayType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, away_points=None, home_points=None, play_clock=None, scoring_play=None, goaltogo=None, created_at=None, updated_at=None, id=None, sequence=None, reference=None, clock=None, wall_clock=None, deleted=None, source=None, type_=None, start_situation=None, end_situation=None, description=None, alt_description=None, scoring_description=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "b"
        self.away_points = _cast(int, away_points)
        self.away_points_nsprefix_ = None
        self.home_points = _cast(int, home_points)
        self.home_points_nsprefix_ = None
        self.play_clock = _cast(int, play_clock)
        self.play_clock_nsprefix_ = None
        self.scoring_play = _cast(bool, scoring_play)
        self.scoring_play_nsprefix_ = None
        self.goaltogo = _cast(bool, goaltogo)
        self.goaltogo_nsprefix_ = None
        self.created_at = _cast(None, created_at)
        self.created_at_nsprefix_ = None
        self.updated_at = _cast(None, updated_at)
        self.updated_at_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.sequence = _cast(float, sequence)
        self.sequence_nsprefix_ = None
        self.reference = _cast(int, reference)
        self.reference_nsprefix_ = None
        self.clock = _cast(None, clock)
        self.clock_nsprefix_ = None
        if isinstance(wall_clock, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(wall_clock, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = wall_clock
        self.wall_clock = initvalue_
        self.deleted = _cast(bool, deleted)
        self.deleted_nsprefix_ = None
        self.source = _cast(None, source)
        self.source_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.start_situation = start_situation
        self.start_situation_nsprefix_ = "b"
        self.end_situation = end_situation
        self.end_situation_nsprefix_ = "b"
        self.description = description
        self.description_nsprefix_ = "b"
        self.alt_description = alt_description
        self.alt_description_nsprefix_ = "b"
        self.scoring_description = scoring_description
        self.scoring_description_nsprefix_ = "b"
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, basePlayType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if basePlayType.subclass:
            return basePlayType.subclass(*args_, **kwargs_)
        else:
            return basePlayType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_start_situation(self):
        return self.start_situation
    def set_start_situation(self, start_situation):
        self.start_situation = start_situation
    def get_end_situation(self):
        return self.end_situation
    def set_end_situation(self, end_situation):
        self.end_situation = end_situation
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_alt_description(self):
        return self.alt_description
    def set_alt_description(self, alt_description):
        self.alt_description = alt_description
    def get_scoring_description(self):
        return self.scoring_description
    def set_scoring_description(self, scoring_description):
        self.scoring_description = scoring_description
    def get_away_points(self):
        return self.away_points
    def set_away_points(self, away_points):
        self.away_points = away_points
    def get_home_points(self):
        return self.home_points
    def set_home_points(self, home_points):
        self.home_points = home_points
    def get_play_clock(self):
        return self.play_clock
    def set_play_clock(self, play_clock):
        self.play_clock = play_clock
    def get_scoring_play(self):
        return self.scoring_play
    def set_scoring_play(self, scoring_play):
        self.scoring_play = scoring_play
    def get_goaltogo(self):
        return self.goaltogo
    def set_goaltogo(self, goaltogo):
        self.goaltogo = goaltogo
    def get_created_at(self):
        return self.created_at
    def set_created_at(self, created_at):
        self.created_at = created_at
    def get_updated_at(self):
        return self.updated_at
    def set_updated_at(self, updated_at):
        self.updated_at = updated_at
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_sequence(self):
        return self.sequence
    def set_sequence(self, sequence):
        self.sequence = sequence
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def get_clock(self):
        return self.clock
    def set_clock(self, clock):
        self.clock = clock
    def get_wall_clock(self):
        return self.wall_clock
    def set_wall_clock(self, wall_clock):
        self.wall_clock = wall_clock
    def get_deleted(self):
        return self.deleted
    def set_deleted(self, deleted):
        self.deleted = deleted
    def get_source(self):
        return self.source
    def set_source(self, source):
        self.source = source
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_typeType4(self, value):
        # Validate type typeType4, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['pass', 'rush', 'faircatch_kick', 'extra_point', 'conversion', 'free_kick', 'kickoff', 'punt', 'field_goal', 'penalty']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeType4' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.start_situation is not None or
            self.end_situation is not None or
            self.description is not None or
            self.alt_description is not None or
            self.scoring_description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='basePlayType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('basePlayType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'basePlayType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='basePlayType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='basePlayType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='basePlayType'):
        if self.away_points is not None and 'away_points' not in already_processed:
            already_processed.add('away_points')
            outfile.write(' away_points="%s"' % self.gds_format_integer(self.away_points, input_name='away_points'))
        if self.home_points is not None and 'home_points' not in already_processed:
            already_processed.add('home_points')
            outfile.write(' home_points="%s"' % self.gds_format_integer(self.home_points, input_name='home_points'))
        if self.play_clock is not None and 'play_clock' not in already_processed:
            already_processed.add('play_clock')
            outfile.write(' play_clock="%s"' % self.gds_format_integer(self.play_clock, input_name='play_clock'))
        if self.scoring_play is not None and 'scoring_play' not in already_processed:
            already_processed.add('scoring_play')
            outfile.write(' scoring_play="%s"' % self.gds_format_boolean(self.scoring_play, input_name='scoring_play'))
        if self.goaltogo is not None and 'goaltogo' not in already_processed:
            already_processed.add('goaltogo')
            outfile.write(' goaltogo="%s"' % self.gds_format_boolean(self.goaltogo, input_name='goaltogo'))
        if self.created_at is not None and 'created_at' not in already_processed:
            already_processed.add('created_at')
            outfile.write(' created_at=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.created_at), input_name='created_at')), ))
        if self.updated_at is not None and 'updated_at' not in already_processed:
            already_processed.add('updated_at')
            outfile.write(' updated_at=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.updated_at), input_name='updated_at')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.sequence is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            outfile.write(' sequence="%s"' % self.gds_format_decimal(self.sequence, input_name='sequence'))
        if self.reference is not None and 'reference' not in already_processed:
            already_processed.add('reference')
            outfile.write(' reference="%s"' % self.gds_format_integer(self.reference, input_name='reference'))
        if self.clock is not None and 'clock' not in already_processed:
            already_processed.add('clock')
            outfile.write(' clock=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.clock), input_name='clock')), ))
        if self.wall_clock is not None and 'wall_clock' not in already_processed:
            already_processed.add('wall_clock')
            outfile.write(' wall_clock="%s"' % self.gds_format_datetime(self.wall_clock, input_name='wall_clock'))
        if self.deleted is not None and 'deleted' not in already_processed:
            already_processed.add('deleted')
            outfile.write(' deleted="%s"' % self.gds_format_boolean(self.deleted, input_name='deleted'))
        if self.source is not None and 'source' not in already_processed:
            already_processed.add('source')
            outfile.write(' source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.source), input_name='source')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='basePlayType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.start_situation is not None:
            namespaceprefix_ = self.start_situation_nsprefix_ + ':' if (UseCapturedNS_ and self.start_situation_nsprefix_) else ''
            self.start_situation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='start_situation', pretty_print=pretty_print)
        if self.end_situation is not None:
            namespaceprefix_ = self.end_situation_nsprefix_ + ':' if (UseCapturedNS_ and self.end_situation_nsprefix_) else ''
            self.end_situation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='end_situation', pretty_print=pretty_print)
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.alt_description is not None:
            namespaceprefix_ = self.alt_description_nsprefix_ + ':' if (UseCapturedNS_ and self.alt_description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%salt-description>%s</%salt-description>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.alt_description), input_name='alt-description')), namespaceprefix_ , eol_))
        if self.scoring_description is not None:
            namespaceprefix_ = self.scoring_description_nsprefix_ + ':' if (UseCapturedNS_ and self.scoring_description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sscoring-description>%s</%sscoring-description>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.scoring_description), input_name='scoring-description')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('away_points', node)
        if value is not None and 'away_points' not in already_processed:
            already_processed.add('away_points')
            self.away_points = self.gds_parse_integer(value, node, 'away_points')
        value = find_attr_value_('home_points', node)
        if value is not None and 'home_points' not in already_processed:
            already_processed.add('home_points')
            self.home_points = self.gds_parse_integer(value, node, 'home_points')
        value = find_attr_value_('play_clock', node)
        if value is not None and 'play_clock' not in already_processed:
            already_processed.add('play_clock')
            self.play_clock = self.gds_parse_integer(value, node, 'play_clock')
        value = find_attr_value_('scoring_play', node)
        if value is not None and 'scoring_play' not in already_processed:
            already_processed.add('scoring_play')
            if value in ('true', '1'):
                self.scoring_play = True
            elif value in ('false', '0'):
                self.scoring_play = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('goaltogo', node)
        if value is not None and 'goaltogo' not in already_processed:
            already_processed.add('goaltogo')
            if value in ('true', '1'):
                self.goaltogo = True
            elif value in ('false', '0'):
                self.goaltogo = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('created_at', node)
        if value is not None and 'created_at' not in already_processed:
            already_processed.add('created_at')
            self.created_at = value
        value = find_attr_value_('updated_at', node)
        if value is not None and 'updated_at' not in already_processed:
            already_processed.add('updated_at')
            self.updated_at = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('sequence', node)
        if value is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            value = self.gds_parse_decimal(value, node, 'sequence')
            self.sequence = value
        value = find_attr_value_('reference', node)
        if value is not None and 'reference' not in already_processed:
            already_processed.add('reference')
            self.reference = self.gds_parse_integer(value, node, 'reference')
        value = find_attr_value_('clock', node)
        if value is not None and 'clock' not in already_processed:
            already_processed.add('clock')
            self.clock = value
        value = find_attr_value_('wall_clock', node)
        if value is not None and 'wall_clock' not in already_processed:
            already_processed.add('wall_clock')
            try:
                self.wall_clock = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (wall_clock): %s' % exp)
        value = find_attr_value_('deleted', node)
        if value is not None and 'deleted' not in already_processed:
            already_processed.add('deleted')
            if value in ('true', '1'):
                self.deleted = True
            elif value in ('false', '0'):
                self.deleted = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('source', node)
        if value is not None and 'source' not in already_processed:
            already_processed.add('source')
            self.source = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_typeType4(self.type_)    # validate type typeType4
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'start_situation':
            obj_ = fieldSituationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.start_situation = obj_
            obj_.original_tagname_ = 'start_situation'
        elif nodeName_ == 'end_situation':
            obj_ = fieldSituationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.end_situation = obj_
            obj_.original_tagname_ = 'end_situation'
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'alt-description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'alt_description')
            value_ = self.gds_validate_string(value_, node, 'alt_description')
            self.alt_description = value_
            self.alt_description_nsprefix_ = child_.prefix
        elif nodeName_ == 'scoring-description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'scoring_description')
            value_ = self.gds_validate_string(value_, node, 'scoring_description')
            self.scoring_description = value_
            self.scoring_description_nsprefix_ = child_.prefix
# end class basePlayType


class gamePlayType(basePlayType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = basePlayType
    def __init__(self, away_points=None, home_points=None, play_clock=None, scoring_play=None, goaltogo=None, created_at=None, updated_at=None, id=None, sequence=None, reference=None, clock=None, wall_clock=None, deleted=None, source=None, type_=None, start_situation=None, end_situation=None, description=None, alt_description=None, scoring_description=None, drive_info=None, score=None, statistics=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "b"
        super(globals().get("gamePlayType"), self).__init__(away_points, home_points, play_clock, scoring_play, goaltogo, created_at, updated_at, id, sequence, reference, clock, wall_clock, deleted, source, type_, start_situation, end_situation, description, alt_description, scoring_description,  **kwargs_)
        self.drive_info = drive_info
        self.drive_info_nsprefix_ = "b"
        self.score = score
        self.score_nsprefix_ = "b"
        self.statistics = statistics
        self.statistics_nsprefix_ = "b"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, gamePlayType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if gamePlayType.subclass:
            return gamePlayType.subclass(*args_, **kwargs_)
        else:
            return gamePlayType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_drive_info(self):
        return self.drive_info
    def set_drive_info(self, drive_info):
        self.drive_info = drive_info
    def get_score(self):
        return self.score
    def set_score(self, score):
        self.score = score
    def get_statistics(self):
        return self.statistics
    def set_statistics(self, statistics):
        self.statistics = statistics
    def has__content(self):
        if (
            self.drive_info is not None or
            self.score is not None or
            self.statistics is not None or
            super(gamePlayType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='gamePlayType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('gamePlayType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'gamePlayType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='gamePlayType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='gamePlayType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='gamePlayType'):
        super(gamePlayType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='gamePlayType')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='gamePlayType', fromsubclass_=False, pretty_print=True):
        super(gamePlayType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.drive_info is not None:
            namespaceprefix_ = self.drive_info_nsprefix_ + ':' if (UseCapturedNS_ and self.drive_info_nsprefix_) else ''
            self.drive_info.export(outfile, level, namespaceprefix_, namespacedef_='', name_='drive-info', pretty_print=pretty_print)
        if self.score is not None:
            namespaceprefix_ = self.score_nsprefix_ + ':' if (UseCapturedNS_ and self.score_nsprefix_) else ''
            self.score.export(outfile, level, namespaceprefix_, namespacedef_='', name_='score', pretty_print=pretty_print)
        if self.statistics is not None:
            namespaceprefix_ = self.statistics_nsprefix_ + ':' if (UseCapturedNS_ and self.statistics_nsprefix_) else ''
            self.statistics.export(outfile, level, namespaceprefix_, namespacedef_='', name_='statistics', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(gamePlayType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'drive-info':
            obj_ = drive_infoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.drive_info = obj_
            obj_.original_tagname_ = 'drive-info'
        elif nodeName_ == 'score':
            obj_ = playScoreType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.score = obj_
            obj_.original_tagname_ = 'score'
        elif nodeName_ == 'statistics':
            obj_ = playStatisticsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.statistics = obj_
            obj_.original_tagname_ = 'statistics'
        super(gamePlayType, self)._buildChildren(child_, node, nodeName_, True)
# end class gamePlayType


class gameDriveType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, sequence=None, start_reason=None, end_reason=None, duration=None, first_downs=None, gain=None, inside_20=None, penalty_yards=None, play_count=None, scoring_drive=None, created_at=None, updated_at=None, event=None, play=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "b"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.sequence = _cast(int, sequence)
        self.sequence_nsprefix_ = None
        self.start_reason = _cast(None, start_reason)
        self.start_reason_nsprefix_ = None
        self.end_reason = _cast(None, end_reason)
        self.end_reason_nsprefix_ = None
        self.duration = _cast(None, duration)
        self.duration_nsprefix_ = None
        self.first_downs = _cast(int, first_downs)
        self.first_downs_nsprefix_ = None
        self.gain = _cast(int, gain)
        self.gain_nsprefix_ = None
        self.inside_20 = _cast(bool, inside_20)
        self.inside_20_nsprefix_ = None
        self.penalty_yards = _cast(int, penalty_yards)
        self.penalty_yards_nsprefix_ = None
        self.play_count = _cast(int, play_count)
        self.play_count_nsprefix_ = None
        self.scoring_drive = _cast(bool, scoring_drive)
        self.scoring_drive_nsprefix_ = None
        self.created_at = _cast(None, created_at)
        self.created_at_nsprefix_ = None
        self.updated_at = _cast(None, updated_at)
        self.updated_at_nsprefix_ = None
        if event is None:
            self.event = []
        else:
            self.event = event
        self.event_nsprefix_ = "b"
        if play is None:
            self.play = []
        else:
            self.play = play
        self.play_nsprefix_ = "b"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, gameDriveType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if gameDriveType.subclass:
            return gameDriveType.subclass(*args_, **kwargs_)
        else:
            return gameDriveType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_event(self):
        return self.event
    def set_event(self, event):
        self.event = event
    def add_event(self, value):
        self.event.append(value)
    def insert_event_at(self, index, value):
        self.event.insert(index, value)
    def replace_event_at(self, index, value):
        self.event[index] = value
    def get_play(self):
        return self.play
    def set_play(self, play):
        self.play = play
    def add_play(self, value):
        self.play.append(value)
    def insert_play_at(self, index, value):
        self.play.insert(index, value)
    def replace_play_at(self, index, value):
        self.play[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_sequence(self):
        return self.sequence
    def set_sequence(self, sequence):
        self.sequence = sequence
    def get_start_reason(self):
        return self.start_reason
    def set_start_reason(self, start_reason):
        self.start_reason = start_reason
    def get_end_reason(self):
        return self.end_reason
    def set_end_reason(self, end_reason):
        self.end_reason = end_reason
    def get_duration(self):
        return self.duration
    def set_duration(self, duration):
        self.duration = duration
    def get_first_downs(self):
        return self.first_downs
    def set_first_downs(self, first_downs):
        self.first_downs = first_downs
    def get_gain(self):
        return self.gain
    def set_gain(self, gain):
        self.gain = gain
    def get_inside_20(self):
        return self.inside_20
    def set_inside_20(self, inside_20):
        self.inside_20 = inside_20
    def get_penalty_yards(self):
        return self.penalty_yards
    def set_penalty_yards(self, penalty_yards):
        self.penalty_yards = penalty_yards
    def get_play_count(self):
        return self.play_count
    def set_play_count(self, play_count):
        self.play_count = play_count
    def get_scoring_drive(self):
        return self.scoring_drive
    def set_scoring_drive(self, scoring_drive):
        self.scoring_drive = scoring_drive
    def get_created_at(self):
        return self.created_at
    def set_created_at(self, created_at):
        self.created_at = created_at
    def get_updated_at(self):
        return self.updated_at
    def set_updated_at(self, updated_at):
        self.updated_at = updated_at
    def validate_driveReason(self, value):
        # Validate type driveReason, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['UNKNOWN', 'Touchdown', 'Safety', 'Field Goal', 'Missed FG', 'Blocked FG', 'Blocked FG, Downs', 'Blocked FG, Safety', 'Punt', 'Blocked Punt', 'Blocked Punt, Downs', 'Blocked Punt, Safety', 'Downs', 'Interception', 'Fumble', 'Fumble, Safety', 'Muffed FG', 'Muffed Punt', 'Muffed Kickoff', 'Kickoff', 'Own Kickoff', 'Onside Kick', 'Kickoff, No Play', 'End of Half', 'End of Game']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on driveReason' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.event or
            self.play
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='gameDriveType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('gameDriveType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'gameDriveType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='gameDriveType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='gameDriveType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='gameDriveType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.sequence is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            outfile.write(' sequence="%s"' % self.gds_format_integer(self.sequence, input_name='sequence'))
        if self.start_reason is not None and 'start_reason' not in already_processed:
            already_processed.add('start_reason')
            outfile.write(' start_reason=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.start_reason), input_name='start_reason')), ))
        if self.end_reason is not None and 'end_reason' not in already_processed:
            already_processed.add('end_reason')
            outfile.write(' end_reason=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.end_reason), input_name='end_reason')), ))
        if self.duration is not None and 'duration' not in already_processed:
            already_processed.add('duration')
            outfile.write(' duration=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.duration), input_name='duration')), ))
        if self.first_downs is not None and 'first_downs' not in already_processed:
            already_processed.add('first_downs')
            outfile.write(' first_downs="%s"' % self.gds_format_integer(self.first_downs, input_name='first_downs'))
        if self.gain is not None and 'gain' not in already_processed:
            already_processed.add('gain')
            outfile.write(' gain="%s"' % self.gds_format_integer(self.gain, input_name='gain'))
        if self.inside_20 is not None and 'inside_20' not in already_processed:
            already_processed.add('inside_20')
            outfile.write(' inside_20="%s"' % self.gds_format_boolean(self.inside_20, input_name='inside_20'))
        if self.penalty_yards is not None and 'penalty_yards' not in already_processed:
            already_processed.add('penalty_yards')
            outfile.write(' penalty_yards="%s"' % self.gds_format_integer(self.penalty_yards, input_name='penalty_yards'))
        if self.play_count is not None and 'play_count' not in already_processed:
            already_processed.add('play_count')
            outfile.write(' play_count="%s"' % self.gds_format_integer(self.play_count, input_name='play_count'))
        if self.scoring_drive is not None and 'scoring_drive' not in already_processed:
            already_processed.add('scoring_drive')
            outfile.write(' scoring_drive="%s"' % self.gds_format_boolean(self.scoring_drive, input_name='scoring_drive'))
        if self.created_at is not None and 'created_at' not in already_processed:
            already_processed.add('created_at')
            outfile.write(' created_at=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.created_at), input_name='created_at')), ))
        if self.updated_at is not None and 'updated_at' not in already_processed:
            already_processed.add('updated_at')
            outfile.write(' updated_at=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.updated_at), input_name='updated_at')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='gameDriveType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for event_ in self.event:
            namespaceprefix_ = self.event_nsprefix_ + ':' if (UseCapturedNS_ and self.event_nsprefix_) else ''
            event_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='event', pretty_print=pretty_print)
        for play_ in self.play:
            namespaceprefix_ = self.play_nsprefix_ + ':' if (UseCapturedNS_ and self.play_nsprefix_) else ''
            play_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='play', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('sequence', node)
        if value is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            self.sequence = self.gds_parse_integer(value, node, 'sequence')
        value = find_attr_value_('start_reason', node)
        if value is not None and 'start_reason' not in already_processed:
            already_processed.add('start_reason')
            self.start_reason = value
            self.validate_driveReason(self.start_reason)    # validate type driveReason
        value = find_attr_value_('end_reason', node)
        if value is not None and 'end_reason' not in already_processed:
            already_processed.add('end_reason')
            self.end_reason = value
            self.validate_driveReason(self.end_reason)    # validate type driveReason
        value = find_attr_value_('duration', node)
        if value is not None and 'duration' not in already_processed:
            already_processed.add('duration')
            self.duration = value
        value = find_attr_value_('first_downs', node)
        if value is not None and 'first_downs' not in already_processed:
            already_processed.add('first_downs')
            self.first_downs = self.gds_parse_integer(value, node, 'first_downs')
        value = find_attr_value_('gain', node)
        if value is not None and 'gain' not in already_processed:
            already_processed.add('gain')
            self.gain = self.gds_parse_integer(value, node, 'gain')
        value = find_attr_value_('inside_20', node)
        if value is not None and 'inside_20' not in already_processed:
            already_processed.add('inside_20')
            if value in ('true', '1'):
                self.inside_20 = True
            elif value in ('false', '0'):
                self.inside_20 = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('penalty_yards', node)
        if value is not None and 'penalty_yards' not in already_processed:
            already_processed.add('penalty_yards')
            self.penalty_yards = self.gds_parse_integer(value, node, 'penalty_yards')
        value = find_attr_value_('play_count', node)
        if value is not None and 'play_count' not in already_processed:
            already_processed.add('play_count')
            self.play_count = self.gds_parse_integer(value, node, 'play_count')
        value = find_attr_value_('scoring_drive', node)
        if value is not None and 'scoring_drive' not in already_processed:
            already_processed.add('scoring_drive')
            if value in ('true', '1'):
                self.scoring_drive = True
            elif value in ('false', '0'):
                self.scoring_drive = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('created_at', node)
        if value is not None and 'created_at' not in already_processed:
            already_processed.add('created_at')
            self.created_at = value
        value = find_attr_value_('updated_at', node)
        if value is not None and 'updated_at' not in already_processed:
            already_processed.add('updated_at')
            self.updated_at = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'event':
            obj_ = gameEventType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.event.append(obj_)
            obj_.original_tagname_ = 'event'
        elif nodeName_ == 'play':
            obj_ = gamePlayType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.play.append(obj_)
            obj_.original_tagname_ = 'play'
# end class gameDriveType


class playScoreType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, clock=None, sequence=None, away_points=None, home_points=None, points=None, points_after_play=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "b"
        self.clock = _cast(None, clock)
        self.clock_nsprefix_ = None
        self.sequence = _cast(int, sequence)
        self.sequence_nsprefix_ = None
        self.away_points = _cast(int, away_points)
        self.away_points_nsprefix_ = None
        self.home_points = _cast(int, home_points)
        self.home_points_nsprefix_ = None
        self.points = _cast(int, points)
        self.points_nsprefix_ = None
        self.points_after_play = points_after_play
        self.points_after_play_nsprefix_ = "b"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, playScoreType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if playScoreType.subclass:
            return playScoreType.subclass(*args_, **kwargs_)
        else:
            return playScoreType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_points_after_play(self):
        return self.points_after_play
    def set_points_after_play(self, points_after_play):
        self.points_after_play = points_after_play
    def get_clock(self):
        return self.clock
    def set_clock(self, clock):
        self.clock = clock
    def get_sequence(self):
        return self.sequence
    def set_sequence(self, sequence):
        self.sequence = sequence
    def get_away_points(self):
        return self.away_points
    def set_away_points(self, away_points):
        self.away_points = away_points
    def get_home_points(self):
        return self.home_points
    def set_home_points(self, home_points):
        self.home_points = home_points
    def get_points(self):
        return self.points
    def set_points(self, points):
        self.points = points
    def has__content(self):
        if (
            self.points_after_play is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='playScoreType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('playScoreType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'playScoreType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='playScoreType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='playScoreType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='playScoreType'):
        if self.clock is not None and 'clock' not in already_processed:
            already_processed.add('clock')
            outfile.write(' clock=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.clock), input_name='clock')), ))
        if self.sequence is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            outfile.write(' sequence="%s"' % self.gds_format_integer(self.sequence, input_name='sequence'))
        if self.away_points is not None and 'away_points' not in already_processed:
            already_processed.add('away_points')
            outfile.write(' away_points="%s"' % self.gds_format_integer(self.away_points, input_name='away_points'))
        if self.home_points is not None and 'home_points' not in already_processed:
            already_processed.add('home_points')
            outfile.write(' home_points="%s"' % self.gds_format_integer(self.home_points, input_name='home_points'))
        if self.points is not None and 'points' not in already_processed:
            already_processed.add('points')
            outfile.write(' points="%s"' % self.gds_format_integer(self.points, input_name='points'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='playScoreType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.points_after_play is not None:
            namespaceprefix_ = self.points_after_play_nsprefix_ + ':' if (UseCapturedNS_ and self.points_after_play_nsprefix_) else ''
            self.points_after_play.export(outfile, level, namespaceprefix_, namespacedef_='', name_='points-after-play', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('clock', node)
        if value is not None and 'clock' not in already_processed:
            already_processed.add('clock')
            self.clock = value
        value = find_attr_value_('sequence', node)
        if value is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            self.sequence = self.gds_parse_integer(value, node, 'sequence')
        value = find_attr_value_('away_points', node)
        if value is not None and 'away_points' not in already_processed:
            already_processed.add('away_points')
            self.away_points = self.gds_parse_integer(value, node, 'away_points')
        value = find_attr_value_('home_points', node)
        if value is not None and 'home_points' not in already_processed:
            already_processed.add('home_points')
            self.home_points = self.gds_parse_integer(value, node, 'home_points')
        value = find_attr_value_('points', node)
        if value is not None and 'points' not in already_processed:
            already_processed.add('points')
            self.points = self.gds_parse_integer(value, node, 'points')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'points-after-play':
            obj_ = points_after_playType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.points_after_play = obj_
            obj_.original_tagname_ = 'points-after-play'
# end class playScoreType


class playStatisticsType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, timeout=None, misc=None, pass_=None, receive=None, rush=None, kick=None, punt=None, field_goal=None, extra_point=None, penalty=None, fumble=None, return_=None, block=None, defense=None, conversion=None, defense_conversion=None, down_conversion=None, first_down=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "b"
        if timeout is None:
            self.timeout = []
        else:
            self.timeout = timeout
        self.timeout_nsprefix_ = "b"
        if misc is None:
            self.misc = []
        else:
            self.misc = misc
        self.misc_nsprefix_ = "b"
        if pass_ is None:
            self.pass_ = []
        else:
            self.pass_ = pass_
        self.pass__nsprefix_ = "b"
        if receive is None:
            self.receive = []
        else:
            self.receive = receive
        self.receive_nsprefix_ = "b"
        if rush is None:
            self.rush = []
        else:
            self.rush = rush
        self.rush_nsprefix_ = "b"
        if kick is None:
            self.kick = []
        else:
            self.kick = kick
        self.kick_nsprefix_ = "b"
        if punt is None:
            self.punt = []
        else:
            self.punt = punt
        self.punt_nsprefix_ = "b"
        if field_goal is None:
            self.field_goal = []
        else:
            self.field_goal = field_goal
        self.field_goal_nsprefix_ = "b"
        if extra_point is None:
            self.extra_point = []
        else:
            self.extra_point = extra_point
        self.extra_point_nsprefix_ = "b"
        if penalty is None:
            self.penalty = []
        else:
            self.penalty = penalty
        self.penalty_nsprefix_ = "b"
        if fumble is None:
            self.fumble = []
        else:
            self.fumble = fumble
        self.fumble_nsprefix_ = "b"
        if return_ is None:
            self.return_ = []
        else:
            self.return_ = return_
        self.return__nsprefix_ = "b"
        if block is None:
            self.block = []
        else:
            self.block = block
        self.block_nsprefix_ = "b"
        if defense is None:
            self.defense = []
        else:
            self.defense = defense
        self.defense_nsprefix_ = "b"
        if conversion is None:
            self.conversion = []
        else:
            self.conversion = conversion
        self.conversion_nsprefix_ = "b"
        if defense_conversion is None:
            self.defense_conversion = []
        else:
            self.defense_conversion = defense_conversion
        self.defense_conversion_nsprefix_ = "b"
        if down_conversion is None:
            self.down_conversion = []
        else:
            self.down_conversion = down_conversion
        self.down_conversion_nsprefix_ = "b"
        if first_down is None:
            self.first_down = []
        else:
            self.first_down = first_down
        self.first_down_nsprefix_ = "b"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, playStatisticsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if playStatisticsType.subclass:
            return playStatisticsType.subclass(*args_, **kwargs_)
        else:
            return playStatisticsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_timeout(self):
        return self.timeout
    def set_timeout(self, timeout):
        self.timeout = timeout
    def add_timeout(self, value):
        self.timeout.append(value)
    def insert_timeout_at(self, index, value):
        self.timeout.insert(index, value)
    def replace_timeout_at(self, index, value):
        self.timeout[index] = value
    def get_misc(self):
        return self.misc
    def set_misc(self, misc):
        self.misc = misc
    def add_misc(self, value):
        self.misc.append(value)
    def insert_misc_at(self, index, value):
        self.misc.insert(index, value)
    def replace_misc_at(self, index, value):
        self.misc[index] = value
    def get_pass(self):
        return self.pass_
    def set_pass(self, pass_):
        self.pass_ = pass_
    def add_pass(self, value):
        self.pass_.append(value)
    def insert_pass_at(self, index, value):
        self.pass_.insert(index, value)
    def replace_pass_at(self, index, value):
        self.pass_[index] = value
    def get_receive(self):
        return self.receive
    def set_receive(self, receive):
        self.receive = receive
    def add_receive(self, value):
        self.receive.append(value)
    def insert_receive_at(self, index, value):
        self.receive.insert(index, value)
    def replace_receive_at(self, index, value):
        self.receive[index] = value
    def get_rush(self):
        return self.rush
    def set_rush(self, rush):
        self.rush = rush
    def add_rush(self, value):
        self.rush.append(value)
    def insert_rush_at(self, index, value):
        self.rush.insert(index, value)
    def replace_rush_at(self, index, value):
        self.rush[index] = value
    def get_kick(self):
        return self.kick
    def set_kick(self, kick):
        self.kick = kick
    def add_kick(self, value):
        self.kick.append(value)
    def insert_kick_at(self, index, value):
        self.kick.insert(index, value)
    def replace_kick_at(self, index, value):
        self.kick[index] = value
    def get_punt(self):
        return self.punt
    def set_punt(self, punt):
        self.punt = punt
    def add_punt(self, value):
        self.punt.append(value)
    def insert_punt_at(self, index, value):
        self.punt.insert(index, value)
    def replace_punt_at(self, index, value):
        self.punt[index] = value
    def get_field_goal(self):
        return self.field_goal
    def set_field_goal(self, field_goal):
        self.field_goal = field_goal
    def add_field_goal(self, value):
        self.field_goal.append(value)
    def insert_field_goal_at(self, index, value):
        self.field_goal.insert(index, value)
    def replace_field_goal_at(self, index, value):
        self.field_goal[index] = value
    def get_extra_point(self):
        return self.extra_point
    def set_extra_point(self, extra_point):
        self.extra_point = extra_point
    def add_extra_point(self, value):
        self.extra_point.append(value)
    def insert_extra_point_at(self, index, value):
        self.extra_point.insert(index, value)
    def replace_extra_point_at(self, index, value):
        self.extra_point[index] = value
    def get_penalty(self):
        return self.penalty
    def set_penalty(self, penalty):
        self.penalty = penalty
    def add_penalty(self, value):
        self.penalty.append(value)
    def insert_penalty_at(self, index, value):
        self.penalty.insert(index, value)
    def replace_penalty_at(self, index, value):
        self.penalty[index] = value
    def get_fumble(self):
        return self.fumble
    def set_fumble(self, fumble):
        self.fumble = fumble
    def add_fumble(self, value):
        self.fumble.append(value)
    def insert_fumble_at(self, index, value):
        self.fumble.insert(index, value)
    def replace_fumble_at(self, index, value):
        self.fumble[index] = value
    def get_return(self):
        return self.return_
    def set_return(self, return_):
        self.return_ = return_
    def add_return(self, value):
        self.return_.append(value)
    def insert_return_at(self, index, value):
        self.return_.insert(index, value)
    def replace_return_at(self, index, value):
        self.return_[index] = value
    def get_block(self):
        return self.block
    def set_block(self, block):
        self.block = block
    def add_block(self, value):
        self.block.append(value)
    def insert_block_at(self, index, value):
        self.block.insert(index, value)
    def replace_block_at(self, index, value):
        self.block[index] = value
    def get_defense(self):
        return self.defense
    def set_defense(self, defense):
        self.defense = defense
    def add_defense(self, value):
        self.defense.append(value)
    def insert_defense_at(self, index, value):
        self.defense.insert(index, value)
    def replace_defense_at(self, index, value):
        self.defense[index] = value
    def get_conversion(self):
        return self.conversion
    def set_conversion(self, conversion):
        self.conversion = conversion
    def add_conversion(self, value):
        self.conversion.append(value)
    def insert_conversion_at(self, index, value):
        self.conversion.insert(index, value)
    def replace_conversion_at(self, index, value):
        self.conversion[index] = value
    def get_defense_conversion(self):
        return self.defense_conversion
    def set_defense_conversion(self, defense_conversion):
        self.defense_conversion = defense_conversion
    def add_defense_conversion(self, value):
        self.defense_conversion.append(value)
    def insert_defense_conversion_at(self, index, value):
        self.defense_conversion.insert(index, value)
    def replace_defense_conversion_at(self, index, value):
        self.defense_conversion[index] = value
    def get_down_conversion(self):
        return self.down_conversion
    def set_down_conversion(self, down_conversion):
        self.down_conversion = down_conversion
    def add_down_conversion(self, value):
        self.down_conversion.append(value)
    def insert_down_conversion_at(self, index, value):
        self.down_conversion.insert(index, value)
    def replace_down_conversion_at(self, index, value):
        self.down_conversion[index] = value
    def get_first_down(self):
        return self.first_down
    def set_first_down(self, first_down):
        self.first_down = first_down
    def add_first_down(self, value):
        self.first_down.append(value)
    def insert_first_down_at(self, index, value):
        self.first_down.insert(index, value)
    def replace_first_down_at(self, index, value):
        self.first_down[index] = value
    def has__content(self):
        if (
            self.timeout or
            self.misc or
            self.pass_ or
            self.receive or
            self.rush or
            self.kick or
            self.punt or
            self.field_goal or
            self.extra_point or
            self.penalty or
            self.fumble or
            self.return_ or
            self.block or
            self.defense or
            self.conversion or
            self.defense_conversion or
            self.down_conversion or
            self.first_down
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='playStatisticsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('playStatisticsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'playStatisticsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='playStatisticsType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='playStatisticsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='playStatisticsType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='playStatisticsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for timeout_ in self.timeout:
            namespaceprefix_ = self.timeout_nsprefix_ + ':' if (UseCapturedNS_ and self.timeout_nsprefix_) else ''
            timeout_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='timeout', pretty_print=pretty_print)
        for misc_ in self.misc:
            namespaceprefix_ = self.misc_nsprefix_ + ':' if (UseCapturedNS_ and self.misc_nsprefix_) else ''
            misc_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='misc', pretty_print=pretty_print)
        for pass_ in self.pass_:
            namespaceprefix_ = self.pass__nsprefix_ + ':' if (UseCapturedNS_ and self.pass__nsprefix_) else ''
            pass_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='pass', pretty_print=pretty_print)
        for receive_ in self.receive:
            namespaceprefix_ = self.receive_nsprefix_ + ':' if (UseCapturedNS_ and self.receive_nsprefix_) else ''
            receive_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='receive', pretty_print=pretty_print)
        for rush_ in self.rush:
            namespaceprefix_ = self.rush_nsprefix_ + ':' if (UseCapturedNS_ and self.rush_nsprefix_) else ''
            rush_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rush', pretty_print=pretty_print)
        for kick_ in self.kick:
            namespaceprefix_ = self.kick_nsprefix_ + ':' if (UseCapturedNS_ and self.kick_nsprefix_) else ''
            kick_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='kick', pretty_print=pretty_print)
        for punt_ in self.punt:
            namespaceprefix_ = self.punt_nsprefix_ + ':' if (UseCapturedNS_ and self.punt_nsprefix_) else ''
            punt_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='punt', pretty_print=pretty_print)
        for field_goal_ in self.field_goal:
            namespaceprefix_ = self.field_goal_nsprefix_ + ':' if (UseCapturedNS_ and self.field_goal_nsprefix_) else ''
            field_goal_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='field_goal', pretty_print=pretty_print)
        for extra_point_ in self.extra_point:
            namespaceprefix_ = self.extra_point_nsprefix_ + ':' if (UseCapturedNS_ and self.extra_point_nsprefix_) else ''
            extra_point_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='extra_point', pretty_print=pretty_print)
        for penalty_ in self.penalty:
            namespaceprefix_ = self.penalty_nsprefix_ + ':' if (UseCapturedNS_ and self.penalty_nsprefix_) else ''
            penalty_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='penalty', pretty_print=pretty_print)
        for fumble_ in self.fumble:
            namespaceprefix_ = self.fumble_nsprefix_ + ':' if (UseCapturedNS_ and self.fumble_nsprefix_) else ''
            fumble_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='fumble', pretty_print=pretty_print)
        for return_ in self.return_:
            namespaceprefix_ = self.return__nsprefix_ + ':' if (UseCapturedNS_ and self.return__nsprefix_) else ''
            return_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='return', pretty_print=pretty_print)
        for block_ in self.block:
            namespaceprefix_ = self.block_nsprefix_ + ':' if (UseCapturedNS_ and self.block_nsprefix_) else ''
            block_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='block', pretty_print=pretty_print)
        for defense_ in self.defense:
            namespaceprefix_ = self.defense_nsprefix_ + ':' if (UseCapturedNS_ and self.defense_nsprefix_) else ''
            defense_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='defense', pretty_print=pretty_print)
        for conversion_ in self.conversion:
            namespaceprefix_ = self.conversion_nsprefix_ + ':' if (UseCapturedNS_ and self.conversion_nsprefix_) else ''
            conversion_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='conversion', pretty_print=pretty_print)
        for defense_conversion_ in self.defense_conversion:
            namespaceprefix_ = self.defense_conversion_nsprefix_ + ':' if (UseCapturedNS_ and self.defense_conversion_nsprefix_) else ''
            defense_conversion_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='defense_conversion', pretty_print=pretty_print)
        for down_conversion_ in self.down_conversion:
            namespaceprefix_ = self.down_conversion_nsprefix_ + ':' if (UseCapturedNS_ and self.down_conversion_nsprefix_) else ''
            down_conversion_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='down_conversion', pretty_print=pretty_print)
        for first_down_ in self.first_down:
            namespaceprefix_ = self.first_down_nsprefix_ + ':' if (UseCapturedNS_ and self.first_down_nsprefix_) else ''
            first_down_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='first_down', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'timeout':
            obj_ = timeoutType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.timeout.append(obj_)
            obj_.original_tagname_ = 'timeout'
        elif nodeName_ == 'misc':
            obj_ = miscType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.misc.append(obj_)
            obj_.original_tagname_ = 'misc'
        elif nodeName_ == 'pass':
            obj_ = passType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.pass_.append(obj_)
            obj_.original_tagname_ = 'pass'
        elif nodeName_ == 'receive':
            obj_ = receiveType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.receive.append(obj_)
            obj_.original_tagname_ = 'receive'
        elif nodeName_ == 'rush':
            obj_ = rushType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rush.append(obj_)
            obj_.original_tagname_ = 'rush'
        elif nodeName_ == 'kick':
            obj_ = kickType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.kick.append(obj_)
            obj_.original_tagname_ = 'kick'
        elif nodeName_ == 'punt':
            obj_ = puntType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.punt.append(obj_)
            obj_.original_tagname_ = 'punt'
        elif nodeName_ == 'field_goal':
            obj_ = field_goalType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.field_goal.append(obj_)
            obj_.original_tagname_ = 'field_goal'
        elif nodeName_ == 'extra_point':
            obj_ = extra_pointType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.extra_point.append(obj_)
            obj_.original_tagname_ = 'extra_point'
        elif nodeName_ == 'penalty':
            obj_ = penaltyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.penalty.append(obj_)
            obj_.original_tagname_ = 'penalty'
        elif nodeName_ == 'fumble':
            obj_ = fumbleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fumble.append(obj_)
            obj_.original_tagname_ = 'fumble'
        elif nodeName_ == 'return':
            obj_ = returnType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.return_.append(obj_)
            obj_.original_tagname_ = 'return'
        elif nodeName_ == 'block':
            obj_ = blockType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.block.append(obj_)
            obj_.original_tagname_ = 'block'
        elif nodeName_ == 'defense':
            obj_ = defenseType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.defense.append(obj_)
            obj_.original_tagname_ = 'defense'
        elif nodeName_ == 'conversion':
            obj_ = conversionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.conversion.append(obj_)
            obj_.original_tagname_ = 'conversion'
        elif nodeName_ == 'defense_conversion':
            obj_ = defense_conversionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.defense_conversion.append(obj_)
            obj_.original_tagname_ = 'defense_conversion'
        elif nodeName_ == 'down_conversion':
            obj_ = down_conversionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.down_conversion.append(obj_)
            obj_.original_tagname_ = 'down_conversion'
        elif nodeName_ == 'first_down':
            obj_ = first_downType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.first_down.append(obj_)
            obj_.original_tagname_ = 'first_down'
# end class playStatisticsType


class basePlayStatisticType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nullified=None, team=None, player=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "b"
        self.nullified = _cast(bool, nullified)
        self.nullified_nsprefix_ = None
        self.team = team
        self.team_nsprefix_ = "b"
        self.player = player
        self.player_nsprefix_ = "b"
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, basePlayStatisticType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if basePlayStatisticType.subclass:
            return basePlayStatisticType.subclass(*args_, **kwargs_)
        else:
            return basePlayStatisticType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_team(self):
        return self.team
    def set_team(self, team):
        self.team = team
    def get_player(self):
        return self.player
    def set_player(self, player):
        self.player = player
    def get_nullified(self):
        return self.nullified
    def set_nullified(self, nullified):
        self.nullified = nullified
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def has__content(self):
        if (
            self.team is not None or
            self.player is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='basePlayStatisticType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('basePlayStatisticType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'basePlayStatisticType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='basePlayStatisticType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='basePlayStatisticType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='basePlayStatisticType'):
        if self.nullified is not None and 'nullified' not in already_processed:
            already_processed.add('nullified')
            outfile.write(' nullified="%s"' % self.gds_format_boolean(self.nullified, input_name='nullified'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='basePlayStatisticType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.team is not None:
            namespaceprefix_ = self.team_nsprefix_ + ':' if (UseCapturedNS_ and self.team_nsprefix_) else ''
            self.team.export(outfile, level, namespaceprefix_, namespacedef_='', name_='team', pretty_print=pretty_print)
        if self.player is not None:
            namespaceprefix_ = self.player_nsprefix_ + ':' if (UseCapturedNS_ and self.player_nsprefix_) else ''
            self.player.export(outfile, level, namespaceprefix_, namespacedef_='', name_='player', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nullified', node)
        if value is not None and 'nullified' not in already_processed:
            already_processed.add('nullified')
            if value in ('true', '1'):
                self.nullified = True
            elif value in ('false', '0'):
                self.nullified = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'team':
            class_obj_ = self.get_class_obj_(child_, teamType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.team = obj_
            obj_.original_tagname_ = 'team'
        elif nodeName_ == 'player':
            obj_ = playerType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.player = obj_
            obj_.original_tagname_ = 'player'
# end class basePlayStatisticType


class extPlayStatisticsType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, timeout=None, misc=None, pass_=None, receive=None, rush=None, kick=None, punt=None, field_goal=None, extra_point=None, penalty=None, fumble=None, return_=None, block=None, defense=None, conversion=None, defense_conversion=None, down_conversion=None, first_down=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "b"
        if timeout is None:
            self.timeout = []
        else:
            self.timeout = timeout
        self.timeout_nsprefix_ = "b"
        if misc is None:
            self.misc = []
        else:
            self.misc = misc
        self.misc_nsprefix_ = "b"
        if pass_ is None:
            self.pass_ = []
        else:
            self.pass_ = pass_
        self.pass__nsprefix_ = "b"
        if receive is None:
            self.receive = []
        else:
            self.receive = receive
        self.receive_nsprefix_ = "b"
        if rush is None:
            self.rush = []
        else:
            self.rush = rush
        self.rush_nsprefix_ = "b"
        if kick is None:
            self.kick = []
        else:
            self.kick = kick
        self.kick_nsprefix_ = "b"
        if punt is None:
            self.punt = []
        else:
            self.punt = punt
        self.punt_nsprefix_ = "b"
        if field_goal is None:
            self.field_goal = []
        else:
            self.field_goal = field_goal
        self.field_goal_nsprefix_ = "b"
        if extra_point is None:
            self.extra_point = []
        else:
            self.extra_point = extra_point
        self.extra_point_nsprefix_ = "b"
        if penalty is None:
            self.penalty = []
        else:
            self.penalty = penalty
        self.penalty_nsprefix_ = "b"
        if fumble is None:
            self.fumble = []
        else:
            self.fumble = fumble
        self.fumble_nsprefix_ = "b"
        if return_ is None:
            self.return_ = []
        else:
            self.return_ = return_
        self.return__nsprefix_ = "b"
        if block is None:
            self.block = []
        else:
            self.block = block
        self.block_nsprefix_ = "b"
        if defense is None:
            self.defense = []
        else:
            self.defense = defense
        self.defense_nsprefix_ = "b"
        if conversion is None:
            self.conversion = []
        else:
            self.conversion = conversion
        self.conversion_nsprefix_ = "b"
        if defense_conversion is None:
            self.defense_conversion = []
        else:
            self.defense_conversion = defense_conversion
        self.defense_conversion_nsprefix_ = "b"
        if down_conversion is None:
            self.down_conversion = []
        else:
            self.down_conversion = down_conversion
        self.down_conversion_nsprefix_ = "b"
        if first_down is None:
            self.first_down = []
        else:
            self.first_down = first_down
        self.first_down_nsprefix_ = "b"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, extPlayStatisticsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if extPlayStatisticsType.subclass:
            return extPlayStatisticsType.subclass(*args_, **kwargs_)
        else:
            return extPlayStatisticsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_timeout(self):
        return self.timeout
    def set_timeout(self, timeout):
        self.timeout = timeout
    def add_timeout(self, value):
        self.timeout.append(value)
    def insert_timeout_at(self, index, value):
        self.timeout.insert(index, value)
    def replace_timeout_at(self, index, value):
        self.timeout[index] = value
    def get_misc(self):
        return self.misc
    def set_misc(self, misc):
        self.misc = misc
    def add_misc(self, value):
        self.misc.append(value)
    def insert_misc_at(self, index, value):
        self.misc.insert(index, value)
    def replace_misc_at(self, index, value):
        self.misc[index] = value
    def get_pass(self):
        return self.pass_
    def set_pass(self, pass_):
        self.pass_ = pass_
    def add_pass(self, value):
        self.pass_.append(value)
    def insert_pass_at(self, index, value):
        self.pass_.insert(index, value)
    def replace_pass_at(self, index, value):
        self.pass_[index] = value
    def get_receive(self):
        return self.receive
    def set_receive(self, receive):
        self.receive = receive
    def add_receive(self, value):
        self.receive.append(value)
    def insert_receive_at(self, index, value):
        self.receive.insert(index, value)
    def replace_receive_at(self, index, value):
        self.receive[index] = value
    def get_rush(self):
        return self.rush
    def set_rush(self, rush):
        self.rush = rush
    def add_rush(self, value):
        self.rush.append(value)
    def insert_rush_at(self, index, value):
        self.rush.insert(index, value)
    def replace_rush_at(self, index, value):
        self.rush[index] = value
    def get_kick(self):
        return self.kick
    def set_kick(self, kick):
        self.kick = kick
    def add_kick(self, value):
        self.kick.append(value)
    def insert_kick_at(self, index, value):
        self.kick.insert(index, value)
    def replace_kick_at(self, index, value):
        self.kick[index] = value
    def get_punt(self):
        return self.punt
    def set_punt(self, punt):
        self.punt = punt
    def add_punt(self, value):
        self.punt.append(value)
    def insert_punt_at(self, index, value):
        self.punt.insert(index, value)
    def replace_punt_at(self, index, value):
        self.punt[index] = value
    def get_field_goal(self):
        return self.field_goal
    def set_field_goal(self, field_goal):
        self.field_goal = field_goal
    def add_field_goal(self, value):
        self.field_goal.append(value)
    def insert_field_goal_at(self, index, value):
        self.field_goal.insert(index, value)
    def replace_field_goal_at(self, index, value):
        self.field_goal[index] = value
    def get_extra_point(self):
        return self.extra_point
    def set_extra_point(self, extra_point):
        self.extra_point = extra_point
    def add_extra_point(self, value):
        self.extra_point.append(value)
    def insert_extra_point_at(self, index, value):
        self.extra_point.insert(index, value)
    def replace_extra_point_at(self, index, value):
        self.extra_point[index] = value
    def get_penalty(self):
        return self.penalty
    def set_penalty(self, penalty):
        self.penalty = penalty
    def add_penalty(self, value):
        self.penalty.append(value)
    def insert_penalty_at(self, index, value):
        self.penalty.insert(index, value)
    def replace_penalty_at(self, index, value):
        self.penalty[index] = value
    def get_fumble(self):
        return self.fumble
    def set_fumble(self, fumble):
        self.fumble = fumble
    def add_fumble(self, value):
        self.fumble.append(value)
    def insert_fumble_at(self, index, value):
        self.fumble.insert(index, value)
    def replace_fumble_at(self, index, value):
        self.fumble[index] = value
    def get_return(self):
        return self.return_
    def set_return(self, return_):
        self.return_ = return_
    def add_return(self, value):
        self.return_.append(value)
    def insert_return_at(self, index, value):
        self.return_.insert(index, value)
    def replace_return_at(self, index, value):
        self.return_[index] = value
    def get_block(self):
        return self.block
    def set_block(self, block):
        self.block = block
    def add_block(self, value):
        self.block.append(value)
    def insert_block_at(self, index, value):
        self.block.insert(index, value)
    def replace_block_at(self, index, value):
        self.block[index] = value
    def get_defense(self):
        return self.defense
    def set_defense(self, defense):
        self.defense = defense
    def add_defense(self, value):
        self.defense.append(value)
    def insert_defense_at(self, index, value):
        self.defense.insert(index, value)
    def replace_defense_at(self, index, value):
        self.defense[index] = value
    def get_conversion(self):
        return self.conversion
    def set_conversion(self, conversion):
        self.conversion = conversion
    def add_conversion(self, value):
        self.conversion.append(value)
    def insert_conversion_at(self, index, value):
        self.conversion.insert(index, value)
    def replace_conversion_at(self, index, value):
        self.conversion[index] = value
    def get_defense_conversion(self):
        return self.defense_conversion
    def set_defense_conversion(self, defense_conversion):
        self.defense_conversion = defense_conversion
    def add_defense_conversion(self, value):
        self.defense_conversion.append(value)
    def insert_defense_conversion_at(self, index, value):
        self.defense_conversion.insert(index, value)
    def replace_defense_conversion_at(self, index, value):
        self.defense_conversion[index] = value
    def get_down_conversion(self):
        return self.down_conversion
    def set_down_conversion(self, down_conversion):
        self.down_conversion = down_conversion
    def add_down_conversion(self, value):
        self.down_conversion.append(value)
    def insert_down_conversion_at(self, index, value):
        self.down_conversion.insert(index, value)
    def replace_down_conversion_at(self, index, value):
        self.down_conversion[index] = value
    def get_first_down(self):
        return self.first_down
    def set_first_down(self, first_down):
        self.first_down = first_down
    def add_first_down(self, value):
        self.first_down.append(value)
    def insert_first_down_at(self, index, value):
        self.first_down.insert(index, value)
    def replace_first_down_at(self, index, value):
        self.first_down[index] = value
    def has__content(self):
        if (
            self.timeout or
            self.misc or
            self.pass_ or
            self.receive or
            self.rush or
            self.kick or
            self.punt or
            self.field_goal or
            self.extra_point or
            self.penalty or
            self.fumble or
            self.return_ or
            self.block or
            self.defense or
            self.conversion or
            self.defense_conversion or
            self.down_conversion or
            self.first_down
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='extPlayStatisticsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('extPlayStatisticsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'extPlayStatisticsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='extPlayStatisticsType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='extPlayStatisticsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='extPlayStatisticsType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='extPlayStatisticsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for timeout_ in self.timeout:
            namespaceprefix_ = self.timeout_nsprefix_ + ':' if (UseCapturedNS_ and self.timeout_nsprefix_) else ''
            timeout_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='timeout', pretty_print=pretty_print)
        for misc_ in self.misc:
            namespaceprefix_ = self.misc_nsprefix_ + ':' if (UseCapturedNS_ and self.misc_nsprefix_) else ''
            misc_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='misc', pretty_print=pretty_print)
        for pass_ in self.pass_:
            namespaceprefix_ = self.pass__nsprefix_ + ':' if (UseCapturedNS_ and self.pass__nsprefix_) else ''
            pass_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='pass', pretty_print=pretty_print)
        for receive_ in self.receive:
            namespaceprefix_ = self.receive_nsprefix_ + ':' if (UseCapturedNS_ and self.receive_nsprefix_) else ''
            receive_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='receive', pretty_print=pretty_print)
        for rush_ in self.rush:
            namespaceprefix_ = self.rush_nsprefix_ + ':' if (UseCapturedNS_ and self.rush_nsprefix_) else ''
            rush_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rush', pretty_print=pretty_print)
        for kick_ in self.kick:
            namespaceprefix_ = self.kick_nsprefix_ + ':' if (UseCapturedNS_ and self.kick_nsprefix_) else ''
            kick_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='kick', pretty_print=pretty_print)
        for punt_ in self.punt:
            namespaceprefix_ = self.punt_nsprefix_ + ':' if (UseCapturedNS_ and self.punt_nsprefix_) else ''
            punt_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='punt', pretty_print=pretty_print)
        for field_goal_ in self.field_goal:
            namespaceprefix_ = self.field_goal_nsprefix_ + ':' if (UseCapturedNS_ and self.field_goal_nsprefix_) else ''
            field_goal_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='field_goal', pretty_print=pretty_print)
        for extra_point_ in self.extra_point:
            namespaceprefix_ = self.extra_point_nsprefix_ + ':' if (UseCapturedNS_ and self.extra_point_nsprefix_) else ''
            extra_point_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='extra_point', pretty_print=pretty_print)
        for penalty_ in self.penalty:
            namespaceprefix_ = self.penalty_nsprefix_ + ':' if (UseCapturedNS_ and self.penalty_nsprefix_) else ''
            penalty_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='penalty', pretty_print=pretty_print)
        for fumble_ in self.fumble:
            namespaceprefix_ = self.fumble_nsprefix_ + ':' if (UseCapturedNS_ and self.fumble_nsprefix_) else ''
            fumble_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='fumble', pretty_print=pretty_print)
        for return_ in self.return_:
            namespaceprefix_ = self.return__nsprefix_ + ':' if (UseCapturedNS_ and self.return__nsprefix_) else ''
            return_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='return', pretty_print=pretty_print)
        for block_ in self.block:
            namespaceprefix_ = self.block_nsprefix_ + ':' if (UseCapturedNS_ and self.block_nsprefix_) else ''
            block_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='block', pretty_print=pretty_print)
        for defense_ in self.defense:
            namespaceprefix_ = self.defense_nsprefix_ + ':' if (UseCapturedNS_ and self.defense_nsprefix_) else ''
            defense_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='defense', pretty_print=pretty_print)
        for conversion_ in self.conversion:
            namespaceprefix_ = self.conversion_nsprefix_ + ':' if (UseCapturedNS_ and self.conversion_nsprefix_) else ''
            conversion_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='conversion', pretty_print=pretty_print)
        for defense_conversion_ in self.defense_conversion:
            namespaceprefix_ = self.defense_conversion_nsprefix_ + ':' if (UseCapturedNS_ and self.defense_conversion_nsprefix_) else ''
            defense_conversion_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='defense_conversion', pretty_print=pretty_print)
        for down_conversion_ in self.down_conversion:
            namespaceprefix_ = self.down_conversion_nsprefix_ + ':' if (UseCapturedNS_ and self.down_conversion_nsprefix_) else ''
            down_conversion_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='down_conversion', pretty_print=pretty_print)
        for first_down_ in self.first_down:
            namespaceprefix_ = self.first_down_nsprefix_ + ':' if (UseCapturedNS_ and self.first_down_nsprefix_) else ''
            first_down_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='first_down', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'timeout':
            obj_ = timeoutType10.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.timeout.append(obj_)
            obj_.original_tagname_ = 'timeout'
        elif nodeName_ == 'misc':
            obj_ = miscType11.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.misc.append(obj_)
            obj_.original_tagname_ = 'misc'
        elif nodeName_ == 'pass':
            obj_ = passType12.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.pass_.append(obj_)
            obj_.original_tagname_ = 'pass'
        elif nodeName_ == 'receive':
            obj_ = receiveType13.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.receive.append(obj_)
            obj_.original_tagname_ = 'receive'
        elif nodeName_ == 'rush':
            obj_ = rushType14.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rush.append(obj_)
            obj_.original_tagname_ = 'rush'
        elif nodeName_ == 'kick':
            obj_ = kickType15.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.kick.append(obj_)
            obj_.original_tagname_ = 'kick'
        elif nodeName_ == 'punt':
            obj_ = puntType16.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.punt.append(obj_)
            obj_.original_tagname_ = 'punt'
        elif nodeName_ == 'field_goal':
            obj_ = field_goalType17.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.field_goal.append(obj_)
            obj_.original_tagname_ = 'field_goal'
        elif nodeName_ == 'extra_point':
            obj_ = extra_pointType18.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.extra_point.append(obj_)
            obj_.original_tagname_ = 'extra_point'
        elif nodeName_ == 'penalty':
            obj_ = penaltyType19.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.penalty.append(obj_)
            obj_.original_tagname_ = 'penalty'
        elif nodeName_ == 'fumble':
            obj_ = fumbleType20.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fumble.append(obj_)
            obj_.original_tagname_ = 'fumble'
        elif nodeName_ == 'return':
            obj_ = returnType21.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.return_.append(obj_)
            obj_.original_tagname_ = 'return'
        elif nodeName_ == 'block':
            obj_ = blockType23.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.block.append(obj_)
            obj_.original_tagname_ = 'block'
        elif nodeName_ == 'defense':
            obj_ = defenseType25.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.defense.append(obj_)
            obj_.original_tagname_ = 'defense'
        elif nodeName_ == 'conversion':
            obj_ = conversionType26.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.conversion.append(obj_)
            obj_.original_tagname_ = 'conversion'
        elif nodeName_ == 'defense_conversion':
            obj_ = defense_conversionType28.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.defense_conversion.append(obj_)
            obj_.original_tagname_ = 'defense_conversion'
        elif nodeName_ == 'down_conversion':
            obj_ = down_conversionType30.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.down_conversion.append(obj_)
            obj_.original_tagname_ = 'down_conversion'
        elif nodeName_ == 'first_down':
            obj_ = first_downType31.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.first_down.append(obj_)
            obj_.original_tagname_ = 'first_down'
# end class extPlayStatisticsType


class extGamePlayType(basePlayType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = basePlayType
    def __init__(self, away_points=None, home_points=None, play_clock=None, scoring_play=None, goaltogo=None, created_at=None, updated_at=None, id=None, sequence=None, reference=None, clock=None, wall_clock=None, deleted=None, source=None, type_=None, start_situation=None, end_situation=None, description=None, alt_description=None, scoring_description=None, qb_at_snap=None, fake_punt=None, fake_field_goal=None, players_rushed=None, men_in_box=None, play_direction=None, left_tightends=None, right_tightends=None, hash_mark=None, screen_pass=None, pocket_location=None, blitz=None, huddle=None, pass_route=None, running_lane=None, drive_info=None, score=None, statistics=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "b"
        super(globals().get("extGamePlayType"), self).__init__(away_points, home_points, play_clock, scoring_play, goaltogo, created_at, updated_at, id, sequence, reference, clock, wall_clock, deleted, source, type_, start_situation, end_situation, description, alt_description, scoring_description,  **kwargs_)
        self.qb_at_snap = _cast(None, qb_at_snap)
        self.qb_at_snap_nsprefix_ = None
        self.fake_punt = _cast(bool, fake_punt)
        self.fake_punt_nsprefix_ = None
        self.fake_field_goal = _cast(bool, fake_field_goal)
        self.fake_field_goal_nsprefix_ = None
        self.players_rushed = _cast(int, players_rushed)
        self.players_rushed_nsprefix_ = None
        self.men_in_box = _cast(int, men_in_box)
        self.men_in_box_nsprefix_ = None
        self.play_direction = _cast(None, play_direction)
        self.play_direction_nsprefix_ = None
        self.left_tightends = _cast(int, left_tightends)
        self.left_tightends_nsprefix_ = None
        self.right_tightends = _cast(int, right_tightends)
        self.right_tightends_nsprefix_ = None
        self.hash_mark = _cast(None, hash_mark)
        self.hash_mark_nsprefix_ = None
        self.screen_pass = _cast(bool, screen_pass)
        self.screen_pass_nsprefix_ = None
        self.pocket_location = _cast(None, pocket_location)
        self.pocket_location_nsprefix_ = None
        self.blitz = _cast(bool, blitz)
        self.blitz_nsprefix_ = None
        self.huddle = _cast(None, huddle)
        self.huddle_nsprefix_ = None
        self.pass_route = _cast(None, pass_route)
        self.pass_route_nsprefix_ = None
        self.running_lane = _cast(int, running_lane)
        self.running_lane_nsprefix_ = None
        self.drive_info = drive_info
        self.drive_info_nsprefix_ = "b"
        self.score = score
        self.score_nsprefix_ = "b"
        self.statistics = statistics
        self.statistics_nsprefix_ = "b"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, extGamePlayType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if extGamePlayType.subclass:
            return extGamePlayType.subclass(*args_, **kwargs_)
        else:
            return extGamePlayType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_drive_info(self):
        return self.drive_info
    def set_drive_info(self, drive_info):
        self.drive_info = drive_info
    def get_score(self):
        return self.score
    def set_score(self, score):
        self.score = score
    def get_statistics(self):
        return self.statistics
    def set_statistics(self, statistics):
        self.statistics = statistics
    def get_qb_at_snap(self):
        return self.qb_at_snap
    def set_qb_at_snap(self, qb_at_snap):
        self.qb_at_snap = qb_at_snap
    def get_fake_punt(self):
        return self.fake_punt
    def set_fake_punt(self, fake_punt):
        self.fake_punt = fake_punt
    def get_fake_field_goal(self):
        return self.fake_field_goal
    def set_fake_field_goal(self, fake_field_goal):
        self.fake_field_goal = fake_field_goal
    def get_players_rushed(self):
        return self.players_rushed
    def set_players_rushed(self, players_rushed):
        self.players_rushed = players_rushed
    def get_men_in_box(self):
        return self.men_in_box
    def set_men_in_box(self, men_in_box):
        self.men_in_box = men_in_box
    def get_play_direction(self):
        return self.play_direction
    def set_play_direction(self, play_direction):
        self.play_direction = play_direction
    def get_left_tightends(self):
        return self.left_tightends
    def set_left_tightends(self, left_tightends):
        self.left_tightends = left_tightends
    def get_right_tightends(self):
        return self.right_tightends
    def set_right_tightends(self, right_tightends):
        self.right_tightends = right_tightends
    def get_hash_mark(self):
        return self.hash_mark
    def set_hash_mark(self, hash_mark):
        self.hash_mark = hash_mark
    def get_screen_pass(self):
        return self.screen_pass
    def set_screen_pass(self, screen_pass):
        self.screen_pass = screen_pass
    def get_pocket_location(self):
        return self.pocket_location
    def set_pocket_location(self, pocket_location):
        self.pocket_location = pocket_location
    def get_blitz(self):
        return self.blitz
    def set_blitz(self, blitz):
        self.blitz = blitz
    def get_huddle(self):
        return self.huddle
    def set_huddle(self, huddle):
        self.huddle = huddle
    def get_pass_route(self):
        return self.pass_route
    def set_pass_route(self, pass_route):
        self.pass_route = pass_route
    def get_running_lane(self):
        return self.running_lane
    def set_running_lane(self, running_lane):
        self.running_lane = running_lane
    def validate_qb_at_snapType(self, value):
        # Validate type qb_at_snapType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Shotgun', 'Under Center', 'Pistol']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on qb_at_snapType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_play_directionType(self, value):
        # Validate type play_directionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Left Sideline', 'Left', 'Middle', 'Right', 'Right Sideline']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on play_directionType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_hash_markType(self, value):
        # Validate type hash_markType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Left Hash', 'Right Hash', 'Middle']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on hash_markType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_pocket_locationType(self, value):
        # Validate type pocket_locationType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Scramble Left', 'Scramble Right', 'Boot Left', 'Boot Right', 'Rollout Left', 'Rollout Right', 'Middle']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on pocket_locationType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.drive_info is not None or
            self.score is not None or
            self.statistics is not None or
            super(extGamePlayType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='extGamePlayType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('extGamePlayType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'extGamePlayType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='extGamePlayType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='extGamePlayType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='extGamePlayType'):
        super(extGamePlayType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='extGamePlayType')
        if self.qb_at_snap is not None and 'qb_at_snap' not in already_processed:
            already_processed.add('qb_at_snap')
            outfile.write(' qb_at_snap=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.qb_at_snap), input_name='qb_at_snap')), ))
        if self.fake_punt is not None and 'fake_punt' not in already_processed:
            already_processed.add('fake_punt')
            outfile.write(' fake_punt="%s"' % self.gds_format_boolean(self.fake_punt, input_name='fake_punt'))
        if self.fake_field_goal is not None and 'fake_field_goal' not in already_processed:
            already_processed.add('fake_field_goal')
            outfile.write(' fake_field_goal="%s"' % self.gds_format_boolean(self.fake_field_goal, input_name='fake_field_goal'))
        if self.players_rushed is not None and 'players_rushed' not in already_processed:
            already_processed.add('players_rushed')
            outfile.write(' players_rushed="%s"' % self.gds_format_integer(self.players_rushed, input_name='players_rushed'))
        if self.men_in_box is not None and 'men_in_box' not in already_processed:
            already_processed.add('men_in_box')
            outfile.write(' men_in_box="%s"' % self.gds_format_integer(self.men_in_box, input_name='men_in_box'))
        if self.play_direction is not None and 'play_direction' not in already_processed:
            already_processed.add('play_direction')
            outfile.write(' play_direction=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.play_direction), input_name='play_direction')), ))
        if self.left_tightends is not None and 'left_tightends' not in already_processed:
            already_processed.add('left_tightends')
            outfile.write(' left_tightends="%s"' % self.gds_format_integer(self.left_tightends, input_name='left_tightends'))
        if self.right_tightends is not None and 'right_tightends' not in already_processed:
            already_processed.add('right_tightends')
            outfile.write(' right_tightends="%s"' % self.gds_format_integer(self.right_tightends, input_name='right_tightends'))
        if self.hash_mark is not None and 'hash_mark' not in already_processed:
            already_processed.add('hash_mark')
            outfile.write(' hash_mark=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.hash_mark), input_name='hash_mark')), ))
        if self.screen_pass is not None and 'screen_pass' not in already_processed:
            already_processed.add('screen_pass')
            outfile.write(' screen_pass="%s"' % self.gds_format_boolean(self.screen_pass, input_name='screen_pass'))
        if self.pocket_location is not None and 'pocket_location' not in already_processed:
            already_processed.add('pocket_location')
            outfile.write(' pocket_location=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.pocket_location), input_name='pocket_location')), ))
        if self.blitz is not None and 'blitz' not in already_processed:
            already_processed.add('blitz')
            outfile.write(' blitz="%s"' % self.gds_format_boolean(self.blitz, input_name='blitz'))
        if self.huddle is not None and 'huddle' not in already_processed:
            already_processed.add('huddle')
            outfile.write(' huddle=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.huddle), input_name='huddle')), ))
        if self.pass_route is not None and 'pass_route' not in already_processed:
            already_processed.add('pass_route')
            outfile.write(' pass_route=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.pass_route), input_name='pass_route')), ))
        if self.running_lane is not None and 'running_lane' not in already_processed:
            already_processed.add('running_lane')
            outfile.write(' running_lane="%s"' % self.gds_format_integer(self.running_lane, input_name='running_lane'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='extGamePlayType', fromsubclass_=False, pretty_print=True):
        super(extGamePlayType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.drive_info is not None:
            namespaceprefix_ = self.drive_info_nsprefix_ + ':' if (UseCapturedNS_ and self.drive_info_nsprefix_) else ''
            self.drive_info.export(outfile, level, namespaceprefix_, namespacedef_='', name_='drive-info', pretty_print=pretty_print)
        if self.score is not None:
            namespaceprefix_ = self.score_nsprefix_ + ':' if (UseCapturedNS_ and self.score_nsprefix_) else ''
            self.score.export(outfile, level, namespaceprefix_, namespacedef_='', name_='score', pretty_print=pretty_print)
        if self.statistics is not None:
            namespaceprefix_ = self.statistics_nsprefix_ + ':' if (UseCapturedNS_ and self.statistics_nsprefix_) else ''
            self.statistics.export(outfile, level, namespaceprefix_, namespacedef_='', name_='statistics', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('qb_at_snap', node)
        if value is not None and 'qb_at_snap' not in already_processed:
            already_processed.add('qb_at_snap')
            self.qb_at_snap = value
            self.validate_qb_at_snapType(self.qb_at_snap)    # validate type qb_at_snapType
        value = find_attr_value_('fake_punt', node)
        if value is not None and 'fake_punt' not in already_processed:
            already_processed.add('fake_punt')
            if value in ('true', '1'):
                self.fake_punt = True
            elif value in ('false', '0'):
                self.fake_punt = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('fake_field_goal', node)
        if value is not None and 'fake_field_goal' not in already_processed:
            already_processed.add('fake_field_goal')
            if value in ('true', '1'):
                self.fake_field_goal = True
            elif value in ('false', '0'):
                self.fake_field_goal = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('players_rushed', node)
        if value is not None and 'players_rushed' not in already_processed:
            already_processed.add('players_rushed')
            self.players_rushed = self.gds_parse_integer(value, node, 'players_rushed')
        value = find_attr_value_('men_in_box', node)
        if value is not None and 'men_in_box' not in already_processed:
            already_processed.add('men_in_box')
            self.men_in_box = self.gds_parse_integer(value, node, 'men_in_box')
        value = find_attr_value_('play_direction', node)
        if value is not None and 'play_direction' not in already_processed:
            already_processed.add('play_direction')
            self.play_direction = value
            self.validate_play_directionType(self.play_direction)    # validate type play_directionType
        value = find_attr_value_('left_tightends', node)
        if value is not None and 'left_tightends' not in already_processed:
            already_processed.add('left_tightends')
            self.left_tightends = self.gds_parse_integer(value, node, 'left_tightends')
        value = find_attr_value_('right_tightends', node)
        if value is not None and 'right_tightends' not in already_processed:
            already_processed.add('right_tightends')
            self.right_tightends = self.gds_parse_integer(value, node, 'right_tightends')
        value = find_attr_value_('hash_mark', node)
        if value is not None and 'hash_mark' not in already_processed:
            already_processed.add('hash_mark')
            self.hash_mark = value
            self.validate_hash_markType(self.hash_mark)    # validate type hash_markType
        value = find_attr_value_('screen_pass', node)
        if value is not None and 'screen_pass' not in already_processed:
            already_processed.add('screen_pass')
            if value in ('true', '1'):
                self.screen_pass = True
            elif value in ('false', '0'):
                self.screen_pass = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('pocket_location', node)
        if value is not None and 'pocket_location' not in already_processed:
            already_processed.add('pocket_location')
            self.pocket_location = value
            self.validate_pocket_locationType(self.pocket_location)    # validate type pocket_locationType
        value = find_attr_value_('blitz', node)
        if value is not None and 'blitz' not in already_processed:
            already_processed.add('blitz')
            if value in ('true', '1'):
                self.blitz = True
            elif value in ('false', '0'):
                self.blitz = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('huddle', node)
        if value is not None and 'huddle' not in already_processed:
            already_processed.add('huddle')
            self.huddle = value
        value = find_attr_value_('pass_route', node)
        if value is not None and 'pass_route' not in already_processed:
            already_processed.add('pass_route')
            self.pass_route = value
        value = find_attr_value_('running_lane', node)
        if value is not None and 'running_lane' not in already_processed:
            already_processed.add('running_lane')
            self.running_lane = self.gds_parse_integer(value, node, 'running_lane')
        super(extGamePlayType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'drive-info':
            obj_ = drive_infoType33.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.drive_info = obj_
            obj_.original_tagname_ = 'drive-info'
        elif nodeName_ == 'score':
            obj_ = playScoreType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.score = obj_
            obj_.original_tagname_ = 'score'
        elif nodeName_ == 'statistics':
            obj_ = extPlayStatisticsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.statistics = obj_
            obj_.original_tagname_ = 'statistics'
        super(extGamePlayType, self)._buildChildren(child_, node, nodeName_, True)
# end class extGamePlayType


class extGameDriveType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, sequence=None, start_reason=None, end_reason=None, duration=None, first_downs=None, gain=None, inside_20=None, penalty_yards=None, play_count=None, scoring_drive=None, created_at=None, updated_at=None, event=None, play=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "b"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.sequence = _cast(int, sequence)
        self.sequence_nsprefix_ = None
        self.start_reason = _cast(None, start_reason)
        self.start_reason_nsprefix_ = None
        self.end_reason = _cast(None, end_reason)
        self.end_reason_nsprefix_ = None
        self.duration = _cast(None, duration)
        self.duration_nsprefix_ = None
        self.first_downs = _cast(int, first_downs)
        self.first_downs_nsprefix_ = None
        self.gain = _cast(int, gain)
        self.gain_nsprefix_ = None
        self.inside_20 = _cast(bool, inside_20)
        self.inside_20_nsprefix_ = None
        self.penalty_yards = _cast(int, penalty_yards)
        self.penalty_yards_nsprefix_ = None
        self.play_count = _cast(int, play_count)
        self.play_count_nsprefix_ = None
        self.scoring_drive = _cast(bool, scoring_drive)
        self.scoring_drive_nsprefix_ = None
        self.created_at = _cast(None, created_at)
        self.created_at_nsprefix_ = None
        self.updated_at = _cast(None, updated_at)
        self.updated_at_nsprefix_ = None
        if event is None:
            self.event = []
        else:
            self.event = event
        self.event_nsprefix_ = "b"
        if play is None:
            self.play = []
        else:
            self.play = play
        self.play_nsprefix_ = "b"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, extGameDriveType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if extGameDriveType.subclass:
            return extGameDriveType.subclass(*args_, **kwargs_)
        else:
            return extGameDriveType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_event(self):
        return self.event
    def set_event(self, event):
        self.event = event
    def add_event(self, value):
        self.event.append(value)
    def insert_event_at(self, index, value):
        self.event.insert(index, value)
    def replace_event_at(self, index, value):
        self.event[index] = value
    def get_play(self):
        return self.play
    def set_play(self, play):
        self.play = play
    def add_play(self, value):
        self.play.append(value)
    def insert_play_at(self, index, value):
        self.play.insert(index, value)
    def replace_play_at(self, index, value):
        self.play[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_sequence(self):
        return self.sequence
    def set_sequence(self, sequence):
        self.sequence = sequence
    def get_start_reason(self):
        return self.start_reason
    def set_start_reason(self, start_reason):
        self.start_reason = start_reason
    def get_end_reason(self):
        return self.end_reason
    def set_end_reason(self, end_reason):
        self.end_reason = end_reason
    def get_duration(self):
        return self.duration
    def set_duration(self, duration):
        self.duration = duration
    def get_first_downs(self):
        return self.first_downs
    def set_first_downs(self, first_downs):
        self.first_downs = first_downs
    def get_gain(self):
        return self.gain
    def set_gain(self, gain):
        self.gain = gain
    def get_inside_20(self):
        return self.inside_20
    def set_inside_20(self, inside_20):
        self.inside_20 = inside_20
    def get_penalty_yards(self):
        return self.penalty_yards
    def set_penalty_yards(self, penalty_yards):
        self.penalty_yards = penalty_yards
    def get_play_count(self):
        return self.play_count
    def set_play_count(self, play_count):
        self.play_count = play_count
    def get_scoring_drive(self):
        return self.scoring_drive
    def set_scoring_drive(self, scoring_drive):
        self.scoring_drive = scoring_drive
    def get_created_at(self):
        return self.created_at
    def set_created_at(self, created_at):
        self.created_at = created_at
    def get_updated_at(self):
        return self.updated_at
    def set_updated_at(self, updated_at):
        self.updated_at = updated_at
    def validate_driveReason(self, value):
        # Validate type driveReason, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['UNKNOWN', 'Touchdown', 'Safety', 'Field Goal', 'Missed FG', 'Blocked FG', 'Blocked FG, Downs', 'Blocked FG, Safety', 'Punt', 'Blocked Punt', 'Blocked Punt, Downs', 'Blocked Punt, Safety', 'Downs', 'Interception', 'Fumble', 'Fumble, Safety', 'Muffed FG', 'Muffed Punt', 'Muffed Kickoff', 'Kickoff', 'Own Kickoff', 'Onside Kick', 'Kickoff, No Play', 'End of Half', 'End of Game']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on driveReason' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.event or
            self.play
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='extGameDriveType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('extGameDriveType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'extGameDriveType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='extGameDriveType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='extGameDriveType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='extGameDriveType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.sequence is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            outfile.write(' sequence="%s"' % self.gds_format_integer(self.sequence, input_name='sequence'))
        if self.start_reason is not None and 'start_reason' not in already_processed:
            already_processed.add('start_reason')
            outfile.write(' start_reason=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.start_reason), input_name='start_reason')), ))
        if self.end_reason is not None and 'end_reason' not in already_processed:
            already_processed.add('end_reason')
            outfile.write(' end_reason=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.end_reason), input_name='end_reason')), ))
        if self.duration is not None and 'duration' not in already_processed:
            already_processed.add('duration')
            outfile.write(' duration=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.duration), input_name='duration')), ))
        if self.first_downs is not None and 'first_downs' not in already_processed:
            already_processed.add('first_downs')
            outfile.write(' first_downs="%s"' % self.gds_format_integer(self.first_downs, input_name='first_downs'))
        if self.gain is not None and 'gain' not in already_processed:
            already_processed.add('gain')
            outfile.write(' gain="%s"' % self.gds_format_integer(self.gain, input_name='gain'))
        if self.inside_20 is not None and 'inside_20' not in already_processed:
            already_processed.add('inside_20')
            outfile.write(' inside_20="%s"' % self.gds_format_boolean(self.inside_20, input_name='inside_20'))
        if self.penalty_yards is not None and 'penalty_yards' not in already_processed:
            already_processed.add('penalty_yards')
            outfile.write(' penalty_yards="%s"' % self.gds_format_integer(self.penalty_yards, input_name='penalty_yards'))
        if self.play_count is not None and 'play_count' not in already_processed:
            already_processed.add('play_count')
            outfile.write(' play_count="%s"' % self.gds_format_integer(self.play_count, input_name='play_count'))
        if self.scoring_drive is not None and 'scoring_drive' not in already_processed:
            already_processed.add('scoring_drive')
            outfile.write(' scoring_drive="%s"' % self.gds_format_boolean(self.scoring_drive, input_name='scoring_drive'))
        if self.created_at is not None and 'created_at' not in already_processed:
            already_processed.add('created_at')
            outfile.write(' created_at=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.created_at), input_name='created_at')), ))
        if self.updated_at is not None and 'updated_at' not in already_processed:
            already_processed.add('updated_at')
            outfile.write(' updated_at=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.updated_at), input_name='updated_at')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='extGameDriveType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for event_ in self.event:
            namespaceprefix_ = self.event_nsprefix_ + ':' if (UseCapturedNS_ and self.event_nsprefix_) else ''
            event_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='event', pretty_print=pretty_print)
        for play_ in self.play:
            namespaceprefix_ = self.play_nsprefix_ + ':' if (UseCapturedNS_ and self.play_nsprefix_) else ''
            play_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='play', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('sequence', node)
        if value is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            self.sequence = self.gds_parse_integer(value, node, 'sequence')
        value = find_attr_value_('start_reason', node)
        if value is not None and 'start_reason' not in already_processed:
            already_processed.add('start_reason')
            self.start_reason = value
            self.validate_driveReason(self.start_reason)    # validate type driveReason
        value = find_attr_value_('end_reason', node)
        if value is not None and 'end_reason' not in already_processed:
            already_processed.add('end_reason')
            self.end_reason = value
            self.validate_driveReason(self.end_reason)    # validate type driveReason
        value = find_attr_value_('duration', node)
        if value is not None and 'duration' not in already_processed:
            already_processed.add('duration')
            self.duration = value
        value = find_attr_value_('first_downs', node)
        if value is not None and 'first_downs' not in already_processed:
            already_processed.add('first_downs')
            self.first_downs = self.gds_parse_integer(value, node, 'first_downs')
        value = find_attr_value_('gain', node)
        if value is not None and 'gain' not in already_processed:
            already_processed.add('gain')
            self.gain = self.gds_parse_integer(value, node, 'gain')
        value = find_attr_value_('inside_20', node)
        if value is not None and 'inside_20' not in already_processed:
            already_processed.add('inside_20')
            if value in ('true', '1'):
                self.inside_20 = True
            elif value in ('false', '0'):
                self.inside_20 = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('penalty_yards', node)
        if value is not None and 'penalty_yards' not in already_processed:
            already_processed.add('penalty_yards')
            self.penalty_yards = self.gds_parse_integer(value, node, 'penalty_yards')
        value = find_attr_value_('play_count', node)
        if value is not None and 'play_count' not in already_processed:
            already_processed.add('play_count')
            self.play_count = self.gds_parse_integer(value, node, 'play_count')
        value = find_attr_value_('scoring_drive', node)
        if value is not None and 'scoring_drive' not in already_processed:
            already_processed.add('scoring_drive')
            if value in ('true', '1'):
                self.scoring_drive = True
            elif value in ('false', '0'):
                self.scoring_drive = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('created_at', node)
        if value is not None and 'created_at' not in already_processed:
            already_processed.add('created_at')
            self.created_at = value
        value = find_attr_value_('updated_at', node)
        if value is not None and 'updated_at' not in already_processed:
            already_processed.add('updated_at')
            self.updated_at = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'event':
            obj_ = gameEventType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.event.append(obj_)
            obj_.original_tagname_ = 'event'
        elif nodeName_ == 'play':
            obj_ = extGamePlayType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.play.append(obj_)
            obj_.original_tagname_ = 'play'
# end class extGameDriveType


class playDetailsType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, safety=None, direction=None, category=None, description_attr=None, sequence=None, yards=None, result=None, onside=None, sack_split=None, reason_missed=None, first_touch=None, no_attempt=None, description=None, start_location=None, end_location=None, penalty=None, recovery=None, review=None, players=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "b"
        self.safety = _cast(bool, safety)
        self.safety_nsprefix_ = None
        self.direction = _cast(None, direction)
        self.direction_nsprefix_ = None
        self.category = _cast(None, category)
        self.category_nsprefix_ = None
        self.description_attr = _cast(None, description_attr)
        self.description_attr_nsprefix_ = None
        self.sequence = _cast(None, sequence)
        self.sequence_nsprefix_ = None
        self.yards = _cast(None, yards)
        self.yards_nsprefix_ = None
        self.result = _cast(None, result)
        self.result_nsprefix_ = None
        self.onside = _cast(None, onside)
        self.onside_nsprefix_ = None
        self.sack_split = _cast(None, sack_split)
        self.sack_split_nsprefix_ = None
        self.reason_missed = _cast(None, reason_missed)
        self.reason_missed_nsprefix_ = None
        self.first_touch = _cast(None, first_touch)
        self.first_touch_nsprefix_ = None
        self.no_attempt = _cast(None, no_attempt)
        self.no_attempt_nsprefix_ = None
        self.description = description
        self.description_nsprefix_ = "b"
        self.start_location = start_location
        self.start_location_nsprefix_ = "b"
        self.end_location = end_location
        self.end_location_nsprefix_ = "b"
        self.penalty = penalty
        self.penalty_nsprefix_ = "b"
        self.recovery = recovery
        self.recovery_nsprefix_ = "b"
        self.review = review
        self.review_nsprefix_ = "b"
        self.players = players
        self.players_nsprefix_ = "b"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, playDetailsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if playDetailsType.subclass:
            return playDetailsType.subclass(*args_, **kwargs_)
        else:
            return playDetailsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_start_location(self):
        return self.start_location
    def set_start_location(self, start_location):
        self.start_location = start_location
    def get_end_location(self):
        return self.end_location
    def set_end_location(self, end_location):
        self.end_location = end_location
    def get_penalty(self):
        return self.penalty
    def set_penalty(self, penalty):
        self.penalty = penalty
    def get_recovery(self):
        return self.recovery
    def set_recovery(self, recovery):
        self.recovery = recovery
    def get_review(self):
        return self.review
    def set_review(self, review):
        self.review = review
    def get_players(self):
        return self.players
    def set_players(self, players):
        self.players = players
    def get_safety(self):
        return self.safety
    def set_safety(self, safety):
        self.safety = safety
    def get_direction(self):
        return self.direction
    def set_direction(self, direction):
        self.direction = direction
    def get_category(self):
        return self.category
    def set_category(self, category):
        self.category = category
    def get_description_attr(self):
        return self.description_attr
    def set_description_attr(self, description_attr):
        self.description_attr = description_attr
    def get_sequence(self):
        return self.sequence
    def set_sequence(self, sequence):
        self.sequence = sequence
    def get_yards(self):
        return self.yards
    def set_yards(self, yards):
        self.yards = yards
    def get_result(self):
        return self.result
    def set_result(self, result):
        self.result = result
    def get_onside(self):
        return self.onside
    def set_onside(self, onside):
        self.onside = onside
    def get_sack_split(self):
        return self.sack_split
    def set_sack_split(self, sack_split):
        self.sack_split = sack_split
    def get_reason_missed(self):
        return self.reason_missed
    def set_reason_missed(self, reason_missed):
        self.reason_missed = reason_missed
    def get_first_touch(self):
        return self.first_touch
    def set_first_touch(self, first_touch):
        self.first_touch = first_touch
    def get_no_attempt(self):
        return self.no_attempt
    def set_no_attempt(self, no_attempt):
        self.no_attempt = no_attempt
    def has__content(self):
        if (
            self.description is not None or
            self.start_location is not None or
            self.end_location is not None or
            self.penalty is not None or
            self.recovery is not None or
            self.review is not None or
            self.players is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='playDetailsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('playDetailsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'playDetailsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='playDetailsType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='playDetailsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='playDetailsType'):
        if self.safety is not None and 'safety' not in already_processed:
            already_processed.add('safety')
            outfile.write(' safety="%s"' % self.gds_format_boolean(self.safety, input_name='safety'))
        if self.direction is not None and 'direction' not in already_processed:
            already_processed.add('direction')
            outfile.write(' direction=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.direction), input_name='direction')), ))
        if self.category is not None and 'category' not in already_processed:
            already_processed.add('category')
            outfile.write(' category=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.category), input_name='category')), ))
        if self.description_attr is not None and 'description_attr' not in already_processed:
            already_processed.add('description_attr')
            outfile.write(' description=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.description_attr), input_name='description_attr')), ))
        if self.sequence is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            outfile.write(' sequence=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.sequence), input_name='sequence')), ))
        if self.yards is not None and 'yards' not in already_processed:
            already_processed.add('yards')
            outfile.write(' yards=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.yards), input_name='yards')), ))
        if self.result is not None and 'result' not in already_processed:
            already_processed.add('result')
            outfile.write(' result=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.result), input_name='result')), ))
        if self.onside is not None and 'onside' not in already_processed:
            already_processed.add('onside')
            outfile.write(' onside=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.onside), input_name='onside')), ))
        if self.sack_split is not None and 'sack_split' not in already_processed:
            already_processed.add('sack_split')
            outfile.write(' sack_split=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.sack_split), input_name='sack_split')), ))
        if self.reason_missed is not None and 'reason_missed' not in already_processed:
            already_processed.add('reason_missed')
            outfile.write(' reason_missed=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.reason_missed), input_name='reason_missed')), ))
        if self.first_touch is not None and 'first_touch' not in already_processed:
            already_processed.add('first_touch')
            outfile.write(' first_touch=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.first_touch), input_name='first_touch')), ))
        if self.no_attempt is not None and 'no_attempt' not in already_processed:
            already_processed.add('no_attempt')
            outfile.write(' no_attempt=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.no_attempt), input_name='no_attempt')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='playDetailsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.start_location is not None:
            namespaceprefix_ = self.start_location_nsprefix_ + ':' if (UseCapturedNS_ and self.start_location_nsprefix_) else ''
            self.start_location.export(outfile, level, namespaceprefix_, namespacedef_='', name_='start_location', pretty_print=pretty_print)
        if self.end_location is not None:
            namespaceprefix_ = self.end_location_nsprefix_ + ':' if (UseCapturedNS_ and self.end_location_nsprefix_) else ''
            self.end_location.export(outfile, level, namespaceprefix_, namespacedef_='', name_='end_location', pretty_print=pretty_print)
        if self.penalty is not None:
            namespaceprefix_ = self.penalty_nsprefix_ + ':' if (UseCapturedNS_ and self.penalty_nsprefix_) else ''
            self.penalty.export(outfile, level, namespaceprefix_, namespacedef_='', name_='penalty', pretty_print=pretty_print)
        if self.recovery is not None:
            namespaceprefix_ = self.recovery_nsprefix_ + ':' if (UseCapturedNS_ and self.recovery_nsprefix_) else ''
            self.recovery.export(outfile, level, namespaceprefix_, namespacedef_='', name_='recovery', pretty_print=pretty_print)
        if self.review is not None:
            namespaceprefix_ = self.review_nsprefix_ + ':' if (UseCapturedNS_ and self.review_nsprefix_) else ''
            self.review.export(outfile, level, namespaceprefix_, namespacedef_='', name_='review', pretty_print=pretty_print)
        if self.players is not None:
            namespaceprefix_ = self.players_nsprefix_ + ':' if (UseCapturedNS_ and self.players_nsprefix_) else ''
            self.players.export(outfile, level, namespaceprefix_, namespacedef_='', name_='players', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('safety', node)
        if value is not None and 'safety' not in already_processed:
            already_processed.add('safety')
            if value in ('true', '1'):
                self.safety = True
            elif value in ('false', '0'):
                self.safety = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('direction', node)
        if value is not None and 'direction' not in already_processed:
            already_processed.add('direction')
            self.direction = value
        value = find_attr_value_('category', node)
        if value is not None and 'category' not in already_processed:
            already_processed.add('category')
            self.category = value
        value = find_attr_value_('description', node)
        if value is not None and 'description_attr' not in already_processed:
            already_processed.add('description_attr')
            self.description_attr = value
        value = find_attr_value_('sequence', node)
        if value is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            self.sequence = value
        value = find_attr_value_('yards', node)
        if value is not None and 'yards' not in already_processed:
            already_processed.add('yards')
            self.yards = value
        value = find_attr_value_('result', node)
        if value is not None and 'result' not in already_processed:
            already_processed.add('result')
            self.result = value
        value = find_attr_value_('onside', node)
        if value is not None and 'onside' not in already_processed:
            already_processed.add('onside')
            self.onside = value
        value = find_attr_value_('sack_split', node)
        if value is not None and 'sack_split' not in already_processed:
            already_processed.add('sack_split')
            self.sack_split = value
        value = find_attr_value_('reason_missed', node)
        if value is not None and 'reason_missed' not in already_processed:
            already_processed.add('reason_missed')
            self.reason_missed = value
        value = find_attr_value_('first_touch', node)
        if value is not None and 'first_touch' not in already_processed:
            already_processed.add('first_touch')
            self.first_touch = value
        value = find_attr_value_('no_attempt', node)
        if value is not None and 'no_attempt' not in already_processed:
            already_processed.add('no_attempt')
            self.no_attempt = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'start_location':
            obj_ = extFieldLocationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.start_location = obj_
            obj_.original_tagname_ = 'start_location'
        elif nodeName_ == 'end_location':
            obj_ = extFieldLocationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.end_location = obj_
            obj_.original_tagname_ = 'end_location'
        elif nodeName_ == 'penalty':
            obj_ = penaltyType34.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.penalty = obj_
            obj_.original_tagname_ = 'penalty'
        elif nodeName_ == 'recovery':
            obj_ = recoveryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.recovery = obj_
            obj_.original_tagname_ = 'recovery'
        elif nodeName_ == 'review':
            obj_ = reviewType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.review = obj_
            obj_.original_tagname_ = 'review'
        elif nodeName_ == 'players':
            obj_ = playersType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.players = obj_
            obj_.original_tagname_ = 'players'
# end class playDetailsType


class extFieldLocationType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, alias=None, yardline=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "b"
        self.alias = _cast(None, alias)
        self.alias_nsprefix_ = None
        self.yardline = _cast(int, yardline)
        self.yardline_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, extFieldLocationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if extFieldLocationType.subclass:
            return extFieldLocationType.subclass(*args_, **kwargs_)
        else:
            return extFieldLocationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_alias(self):
        return self.alias
    def set_alias(self, alias):
        self.alias = alias
    def get_yardline(self):
        return self.yardline
    def set_yardline(self, yardline):
        self.yardline = yardline
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='extFieldLocationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('extFieldLocationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'extFieldLocationType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='extFieldLocationType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='extFieldLocationType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='extFieldLocationType'):
        if self.alias is not None and 'alias' not in already_processed:
            already_processed.add('alias')
            outfile.write(' alias=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.alias), input_name='alias')), ))
        if self.yardline is not None and 'yardline' not in already_processed:
            already_processed.add('yardline')
            outfile.write(' yardline="%s"' % self.gds_format_integer(self.yardline, input_name='yardline'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='extFieldLocationType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('alias', node)
        if value is not None and 'alias' not in already_processed:
            already_processed.add('alias')
            self.alias = value
        value = find_attr_value_('yardline', node)
        if value is not None and 'yardline' not in already_processed:
            already_processed.add('yardline')
            self.yardline = self.gds_parse_integer(value, node, 'yardline')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class extFieldLocationType


class gamePlayDetailsType(basePlayType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = basePlayType
    def __init__(self, away_points=None, home_points=None, play_clock=None, scoring_play=None, goaltogo=None, created_at=None, updated_at=None, id=None, sequence=None, reference=None, clock=None, wall_clock=None, deleted=None, source=None, type_=None, start_situation=None, end_situation=None, description=None, alt_description=None, scoring_description=None, play_action=None, run_pass_option=None, qb_at_snap=None, fake_punt=None, fake_field_goal=None, players_rushed=None, men_in_box=None, play_direction=None, left_tightends=None, right_tightends=None, hash_mark=None, screen_pass=None, pocket_location=None, blitz=None, huddle=None, pass_route=None, running_lane=None, drive_info=None, score=None, quarter=None, overtime=None, statistics=None, details=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "b"
        super(globals().get("gamePlayDetailsType"), self).__init__(away_points, home_points, play_clock, scoring_play, goaltogo, created_at, updated_at, id, sequence, reference, clock, wall_clock, deleted, source, type_, start_situation, end_situation, description, alt_description, scoring_description,  **kwargs_)
        self.play_action = _cast(bool, play_action)
        self.play_action_nsprefix_ = None
        self.run_pass_option = _cast(bool, run_pass_option)
        self.run_pass_option_nsprefix_ = None
        self.qb_at_snap = _cast(None, qb_at_snap)
        self.qb_at_snap_nsprefix_ = None
        self.fake_punt = _cast(bool, fake_punt)
        self.fake_punt_nsprefix_ = None
        self.fake_field_goal = _cast(bool, fake_field_goal)
        self.fake_field_goal_nsprefix_ = None
        self.players_rushed = _cast(int, players_rushed)
        self.players_rushed_nsprefix_ = None
        self.men_in_box = _cast(int, men_in_box)
        self.men_in_box_nsprefix_ = None
        self.play_direction = _cast(None, play_direction)
        self.play_direction_nsprefix_ = None
        self.left_tightends = _cast(int, left_tightends)
        self.left_tightends_nsprefix_ = None
        self.right_tightends = _cast(int, right_tightends)
        self.right_tightends_nsprefix_ = None
        self.hash_mark = _cast(None, hash_mark)
        self.hash_mark_nsprefix_ = None
        self.screen_pass = _cast(bool, screen_pass)
        self.screen_pass_nsprefix_ = None
        self.pocket_location = _cast(None, pocket_location)
        self.pocket_location_nsprefix_ = None
        self.blitz = _cast(bool, blitz)
        self.blitz_nsprefix_ = None
        self.huddle = _cast(None, huddle)
        self.huddle_nsprefix_ = None
        self.pass_route = _cast(None, pass_route)
        self.pass_route_nsprefix_ = None
        self.running_lane = _cast(int, running_lane)
        self.running_lane_nsprefix_ = None
        self.drive_info = drive_info
        self.drive_info_nsprefix_ = "b"
        self.score = score
        self.score_nsprefix_ = "b"
        self.quarter = quarter
        self.quarter_nsprefix_ = "b"
        self.overtime = overtime
        self.overtime_nsprefix_ = "b"
        self.statistics = statistics
        self.statistics_nsprefix_ = "b"
        self.details = details
        self.details_nsprefix_ = "b"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, gamePlayDetailsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if gamePlayDetailsType.subclass:
            return gamePlayDetailsType.subclass(*args_, **kwargs_)
        else:
            return gamePlayDetailsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_drive_info(self):
        return self.drive_info
    def set_drive_info(self, drive_info):
        self.drive_info = drive_info
    def get_score(self):
        return self.score
    def set_score(self, score):
        self.score = score
    def get_quarter(self):
        return self.quarter
    def set_quarter(self, quarter):
        self.quarter = quarter
    def get_overtime(self):
        return self.overtime
    def set_overtime(self, overtime):
        self.overtime = overtime
    def get_statistics(self):
        return self.statistics
    def set_statistics(self, statistics):
        self.statistics = statistics
    def get_details(self):
        return self.details
    def set_details(self, details):
        self.details = details
    def get_play_action(self):
        return self.play_action
    def set_play_action(self, play_action):
        self.play_action = play_action
    def get_run_pass_option(self):
        return self.run_pass_option
    def set_run_pass_option(self, run_pass_option):
        self.run_pass_option = run_pass_option
    def get_qb_at_snap(self):
        return self.qb_at_snap
    def set_qb_at_snap(self, qb_at_snap):
        self.qb_at_snap = qb_at_snap
    def get_fake_punt(self):
        return self.fake_punt
    def set_fake_punt(self, fake_punt):
        self.fake_punt = fake_punt
    def get_fake_field_goal(self):
        return self.fake_field_goal
    def set_fake_field_goal(self, fake_field_goal):
        self.fake_field_goal = fake_field_goal
    def get_players_rushed(self):
        return self.players_rushed
    def set_players_rushed(self, players_rushed):
        self.players_rushed = players_rushed
    def get_men_in_box(self):
        return self.men_in_box
    def set_men_in_box(self, men_in_box):
        self.men_in_box = men_in_box
    def get_play_direction(self):
        return self.play_direction
    def set_play_direction(self, play_direction):
        self.play_direction = play_direction
    def get_left_tightends(self):
        return self.left_tightends
    def set_left_tightends(self, left_tightends):
        self.left_tightends = left_tightends
    def get_right_tightends(self):
        return self.right_tightends
    def set_right_tightends(self, right_tightends):
        self.right_tightends = right_tightends
    def get_hash_mark(self):
        return self.hash_mark
    def set_hash_mark(self, hash_mark):
        self.hash_mark = hash_mark
    def get_screen_pass(self):
        return self.screen_pass
    def set_screen_pass(self, screen_pass):
        self.screen_pass = screen_pass
    def get_pocket_location(self):
        return self.pocket_location
    def set_pocket_location(self, pocket_location):
        self.pocket_location = pocket_location
    def get_blitz(self):
        return self.blitz
    def set_blitz(self, blitz):
        self.blitz = blitz
    def get_huddle(self):
        return self.huddle
    def set_huddle(self, huddle):
        self.huddle = huddle
    def get_pass_route(self):
        return self.pass_route
    def set_pass_route(self, pass_route):
        self.pass_route = pass_route
    def get_running_lane(self):
        return self.running_lane
    def set_running_lane(self, running_lane):
        self.running_lane = running_lane
    def validate_qb_at_snapType(self, value):
        # Validate type qb_at_snapType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Shotgun', 'Under Center', 'Pistol']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on qb_at_snapType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_play_directionType(self, value):
        # Validate type play_directionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Left Sideline', 'Left', 'Middle', 'Right', 'Right Sideline']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on play_directionType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_hash_markType(self, value):
        # Validate type hash_markType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Left Hash', 'Right Hash', 'Middle']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on hash_markType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_pocket_locationType(self, value):
        # Validate type pocket_locationType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Scramble Left', 'Scramble Right', 'Boot Left', 'Boot Right', 'Rollout Left', 'Rollout Right', 'Middle']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on pocket_locationType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.drive_info is not None or
            self.score is not None or
            self.quarter is not None or
            self.overtime is not None or
            self.statistics is not None or
            self.details is not None or
            super(gamePlayDetailsType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='gamePlayDetailsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('gamePlayDetailsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'gamePlayDetailsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='gamePlayDetailsType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='gamePlayDetailsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='gamePlayDetailsType'):
        super(gamePlayDetailsType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='gamePlayDetailsType')
        if self.play_action is not None and 'play_action' not in already_processed:
            already_processed.add('play_action')
            outfile.write(' play_action="%s"' % self.gds_format_boolean(self.play_action, input_name='play_action'))
        if self.run_pass_option is not None and 'run_pass_option' not in already_processed:
            already_processed.add('run_pass_option')
            outfile.write(' run_pass_option="%s"' % self.gds_format_boolean(self.run_pass_option, input_name='run_pass_option'))
        if self.qb_at_snap is not None and 'qb_at_snap' not in already_processed:
            already_processed.add('qb_at_snap')
            outfile.write(' qb_at_snap=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.qb_at_snap), input_name='qb_at_snap')), ))
        if self.fake_punt is not None and 'fake_punt' not in already_processed:
            already_processed.add('fake_punt')
            outfile.write(' fake_punt="%s"' % self.gds_format_boolean(self.fake_punt, input_name='fake_punt'))
        if self.fake_field_goal is not None and 'fake_field_goal' not in already_processed:
            already_processed.add('fake_field_goal')
            outfile.write(' fake_field_goal="%s"' % self.gds_format_boolean(self.fake_field_goal, input_name='fake_field_goal'))
        if self.players_rushed is not None and 'players_rushed' not in already_processed:
            already_processed.add('players_rushed')
            outfile.write(' players_rushed="%s"' % self.gds_format_integer(self.players_rushed, input_name='players_rushed'))
        if self.men_in_box is not None and 'men_in_box' not in already_processed:
            already_processed.add('men_in_box')
            outfile.write(' men_in_box="%s"' % self.gds_format_integer(self.men_in_box, input_name='men_in_box'))
        if self.play_direction is not None and 'play_direction' not in already_processed:
            already_processed.add('play_direction')
            outfile.write(' play_direction=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.play_direction), input_name='play_direction')), ))
        if self.left_tightends is not None and 'left_tightends' not in already_processed:
            already_processed.add('left_tightends')
            outfile.write(' left_tightends="%s"' % self.gds_format_integer(self.left_tightends, input_name='left_tightends'))
        if self.right_tightends is not None and 'right_tightends' not in already_processed:
            already_processed.add('right_tightends')
            outfile.write(' right_tightends="%s"' % self.gds_format_integer(self.right_tightends, input_name='right_tightends'))
        if self.hash_mark is not None and 'hash_mark' not in already_processed:
            already_processed.add('hash_mark')
            outfile.write(' hash_mark=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.hash_mark), input_name='hash_mark')), ))
        if self.screen_pass is not None and 'screen_pass' not in already_processed:
            already_processed.add('screen_pass')
            outfile.write(' screen_pass="%s"' % self.gds_format_boolean(self.screen_pass, input_name='screen_pass'))
        if self.pocket_location is not None and 'pocket_location' not in already_processed:
            already_processed.add('pocket_location')
            outfile.write(' pocket_location=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.pocket_location), input_name='pocket_location')), ))
        if self.blitz is not None and 'blitz' not in already_processed:
            already_processed.add('blitz')
            outfile.write(' blitz="%s"' % self.gds_format_boolean(self.blitz, input_name='blitz'))
        if self.huddle is not None and 'huddle' not in already_processed:
            already_processed.add('huddle')
            outfile.write(' huddle=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.huddle), input_name='huddle')), ))
        if self.pass_route is not None and 'pass_route' not in already_processed:
            already_processed.add('pass_route')
            outfile.write(' pass_route=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.pass_route), input_name='pass_route')), ))
        if self.running_lane is not None and 'running_lane' not in already_processed:
            already_processed.add('running_lane')
            outfile.write(' running_lane="%s"' % self.gds_format_integer(self.running_lane, input_name='running_lane'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='gamePlayDetailsType', fromsubclass_=False, pretty_print=True):
        super(gamePlayDetailsType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.drive_info is not None:
            namespaceprefix_ = self.drive_info_nsprefix_ + ':' if (UseCapturedNS_ and self.drive_info_nsprefix_) else ''
            self.drive_info.export(outfile, level, namespaceprefix_, namespacedef_='', name_='drive-info', pretty_print=pretty_print)
        if self.score is not None:
            namespaceprefix_ = self.score_nsprefix_ + ':' if (UseCapturedNS_ and self.score_nsprefix_) else ''
            self.score.export(outfile, level, namespaceprefix_, namespacedef_='', name_='score', pretty_print=pretty_print)
        if self.quarter is not None:
            namespaceprefix_ = self.quarter_nsprefix_ + ':' if (UseCapturedNS_ and self.quarter_nsprefix_) else ''
            self.quarter.export(outfile, level, namespaceprefix_, namespacedef_='', name_='quarter', pretty_print=pretty_print)
        if self.overtime is not None:
            namespaceprefix_ = self.overtime_nsprefix_ + ':' if (UseCapturedNS_ and self.overtime_nsprefix_) else ''
            self.overtime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='overtime', pretty_print=pretty_print)
        if self.statistics is not None:
            namespaceprefix_ = self.statistics_nsprefix_ + ':' if (UseCapturedNS_ and self.statistics_nsprefix_) else ''
            self.statistics.export(outfile, level, namespaceprefix_, namespacedef_='', name_='statistics', pretty_print=pretty_print)
        if self.details is not None:
            namespaceprefix_ = self.details_nsprefix_ + ':' if (UseCapturedNS_ and self.details_nsprefix_) else ''
            self.details.export(outfile, level, namespaceprefix_, namespacedef_='', name_='details', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('play_action', node)
        if value is not None and 'play_action' not in already_processed:
            already_processed.add('play_action')
            if value in ('true', '1'):
                self.play_action = True
            elif value in ('false', '0'):
                self.play_action = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('run_pass_option', node)
        if value is not None and 'run_pass_option' not in already_processed:
            already_processed.add('run_pass_option')
            if value in ('true', '1'):
                self.run_pass_option = True
            elif value in ('false', '0'):
                self.run_pass_option = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('qb_at_snap', node)
        if value is not None and 'qb_at_snap' not in already_processed:
            already_processed.add('qb_at_snap')
            self.qb_at_snap = value
            self.validate_qb_at_snapType(self.qb_at_snap)    # validate type qb_at_snapType
        value = find_attr_value_('fake_punt', node)
        if value is not None and 'fake_punt' not in already_processed:
            already_processed.add('fake_punt')
            if value in ('true', '1'):
                self.fake_punt = True
            elif value in ('false', '0'):
                self.fake_punt = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('fake_field_goal', node)
        if value is not None and 'fake_field_goal' not in already_processed:
            already_processed.add('fake_field_goal')
            if value in ('true', '1'):
                self.fake_field_goal = True
            elif value in ('false', '0'):
                self.fake_field_goal = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('players_rushed', node)
        if value is not None and 'players_rushed' not in already_processed:
            already_processed.add('players_rushed')
            self.players_rushed = self.gds_parse_integer(value, node, 'players_rushed')
        value = find_attr_value_('men_in_box', node)
        if value is not None and 'men_in_box' not in already_processed:
            already_processed.add('men_in_box')
            self.men_in_box = self.gds_parse_integer(value, node, 'men_in_box')
        value = find_attr_value_('play_direction', node)
        if value is not None and 'play_direction' not in already_processed:
            already_processed.add('play_direction')
            self.play_direction = value
            self.validate_play_directionType(self.play_direction)    # validate type play_directionType
        value = find_attr_value_('left_tightends', node)
        if value is not None and 'left_tightends' not in already_processed:
            already_processed.add('left_tightends')
            self.left_tightends = self.gds_parse_integer(value, node, 'left_tightends')
        value = find_attr_value_('right_tightends', node)
        if value is not None and 'right_tightends' not in already_processed:
            already_processed.add('right_tightends')
            self.right_tightends = self.gds_parse_integer(value, node, 'right_tightends')
        value = find_attr_value_('hash_mark', node)
        if value is not None and 'hash_mark' not in already_processed:
            already_processed.add('hash_mark')
            self.hash_mark = value
            self.validate_hash_markType(self.hash_mark)    # validate type hash_markType
        value = find_attr_value_('screen_pass', node)
        if value is not None and 'screen_pass' not in already_processed:
            already_processed.add('screen_pass')
            if value in ('true', '1'):
                self.screen_pass = True
            elif value in ('false', '0'):
                self.screen_pass = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('pocket_location', node)
        if value is not None and 'pocket_location' not in already_processed:
            already_processed.add('pocket_location')
            self.pocket_location = value
            self.validate_pocket_locationType(self.pocket_location)    # validate type pocket_locationType
        value = find_attr_value_('blitz', node)
        if value is not None and 'blitz' not in already_processed:
            already_processed.add('blitz')
            if value in ('true', '1'):
                self.blitz = True
            elif value in ('false', '0'):
                self.blitz = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('huddle', node)
        if value is not None and 'huddle' not in already_processed:
            already_processed.add('huddle')
            self.huddle = value
        value = find_attr_value_('pass_route', node)
        if value is not None and 'pass_route' not in already_processed:
            already_processed.add('pass_route')
            self.pass_route = value
        value = find_attr_value_('running_lane', node)
        if value is not None and 'running_lane' not in already_processed:
            already_processed.add('running_lane')
            self.running_lane = self.gds_parse_integer(value, node, 'running_lane')
        super(gamePlayDetailsType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'drive-info':
            obj_ = drive_infoType36.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.drive_info = obj_
            obj_.original_tagname_ = 'drive-info'
        elif nodeName_ == 'score':
            obj_ = playScoreType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.score = obj_
            obj_.original_tagname_ = 'score'
        elif nodeName_ == 'quarter':
            obj_ = quarterType37.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.quarter = obj_
            obj_.original_tagname_ = 'quarter'
        elif nodeName_ == 'overtime':
            obj_ = overtimeType38.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.overtime = obj_
            obj_.original_tagname_ = 'overtime'
        elif nodeName_ == 'statistics':
            obj_ = extPlayStatisticsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.statistics = obj_
            obj_.original_tagname_ = 'statistics'
        elif nodeName_ == 'details':
            obj_ = detailsType39.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.details = obj_
            obj_.original_tagname_ = 'details'
        super(gamePlayDetailsType, self)._buildChildren(child_, node, nodeName_, True)
# end class gamePlayDetailsType


class gameDetailsDriveType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, sequence=None, start_reason=None, end_reason=None, duration=None, first_downs=None, gain=None, inside_20=None, penalty_yards=None, play_count=None, scoring_drive=None, created_at=None, updated_at=None, event=None, play=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "b"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.sequence = _cast(int, sequence)
        self.sequence_nsprefix_ = None
        self.start_reason = _cast(None, start_reason)
        self.start_reason_nsprefix_ = None
        self.end_reason = _cast(None, end_reason)
        self.end_reason_nsprefix_ = None
        self.duration = _cast(None, duration)
        self.duration_nsprefix_ = None
        self.first_downs = _cast(int, first_downs)
        self.first_downs_nsprefix_ = None
        self.gain = _cast(int, gain)
        self.gain_nsprefix_ = None
        self.inside_20 = _cast(bool, inside_20)
        self.inside_20_nsprefix_ = None
        self.penalty_yards = _cast(int, penalty_yards)
        self.penalty_yards_nsprefix_ = None
        self.play_count = _cast(int, play_count)
        self.play_count_nsprefix_ = None
        self.scoring_drive = _cast(bool, scoring_drive)
        self.scoring_drive_nsprefix_ = None
        self.created_at = _cast(None, created_at)
        self.created_at_nsprefix_ = None
        self.updated_at = _cast(None, updated_at)
        self.updated_at_nsprefix_ = None
        if event is None:
            self.event = []
        else:
            self.event = event
        self.event_nsprefix_ = "b"
        if play is None:
            self.play = []
        else:
            self.play = play
        self.play_nsprefix_ = "b"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, gameDetailsDriveType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if gameDetailsDriveType.subclass:
            return gameDetailsDriveType.subclass(*args_, **kwargs_)
        else:
            return gameDetailsDriveType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_event(self):
        return self.event
    def set_event(self, event):
        self.event = event
    def add_event(self, value):
        self.event.append(value)
    def insert_event_at(self, index, value):
        self.event.insert(index, value)
    def replace_event_at(self, index, value):
        self.event[index] = value
    def get_play(self):
        return self.play
    def set_play(self, play):
        self.play = play
    def add_play(self, value):
        self.play.append(value)
    def insert_play_at(self, index, value):
        self.play.insert(index, value)
    def replace_play_at(self, index, value):
        self.play[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_sequence(self):
        return self.sequence
    def set_sequence(self, sequence):
        self.sequence = sequence
    def get_start_reason(self):
        return self.start_reason
    def set_start_reason(self, start_reason):
        self.start_reason = start_reason
    def get_end_reason(self):
        return self.end_reason
    def set_end_reason(self, end_reason):
        self.end_reason = end_reason
    def get_duration(self):
        return self.duration
    def set_duration(self, duration):
        self.duration = duration
    def get_first_downs(self):
        return self.first_downs
    def set_first_downs(self, first_downs):
        self.first_downs = first_downs
    def get_gain(self):
        return self.gain
    def set_gain(self, gain):
        self.gain = gain
    def get_inside_20(self):
        return self.inside_20
    def set_inside_20(self, inside_20):
        self.inside_20 = inside_20
    def get_penalty_yards(self):
        return self.penalty_yards
    def set_penalty_yards(self, penalty_yards):
        self.penalty_yards = penalty_yards
    def get_play_count(self):
        return self.play_count
    def set_play_count(self, play_count):
        self.play_count = play_count
    def get_scoring_drive(self):
        return self.scoring_drive
    def set_scoring_drive(self, scoring_drive):
        self.scoring_drive = scoring_drive
    def get_created_at(self):
        return self.created_at
    def set_created_at(self, created_at):
        self.created_at = created_at
    def get_updated_at(self):
        return self.updated_at
    def set_updated_at(self, updated_at):
        self.updated_at = updated_at
    def validate_driveReason(self, value):
        # Validate type driveReason, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['UNKNOWN', 'Touchdown', 'Safety', 'Field Goal', 'Missed FG', 'Blocked FG', 'Blocked FG, Downs', 'Blocked FG, Safety', 'Punt', 'Blocked Punt', 'Blocked Punt, Downs', 'Blocked Punt, Safety', 'Downs', 'Interception', 'Fumble', 'Fumble, Safety', 'Muffed FG', 'Muffed Punt', 'Muffed Kickoff', 'Kickoff', 'Own Kickoff', 'Onside Kick', 'Kickoff, No Play', 'End of Half', 'End of Game']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on driveReason' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.event or
            self.play
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='gameDetailsDriveType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('gameDetailsDriveType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'gameDetailsDriveType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='gameDetailsDriveType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='gameDetailsDriveType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='gameDetailsDriveType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.sequence is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            outfile.write(' sequence="%s"' % self.gds_format_integer(self.sequence, input_name='sequence'))
        if self.start_reason is not None and 'start_reason' not in already_processed:
            already_processed.add('start_reason')
            outfile.write(' start_reason=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.start_reason), input_name='start_reason')), ))
        if self.end_reason is not None and 'end_reason' not in already_processed:
            already_processed.add('end_reason')
            outfile.write(' end_reason=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.end_reason), input_name='end_reason')), ))
        if self.duration is not None and 'duration' not in already_processed:
            already_processed.add('duration')
            outfile.write(' duration=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.duration), input_name='duration')), ))
        if self.first_downs is not None and 'first_downs' not in already_processed:
            already_processed.add('first_downs')
            outfile.write(' first_downs="%s"' % self.gds_format_integer(self.first_downs, input_name='first_downs'))
        if self.gain is not None and 'gain' not in already_processed:
            already_processed.add('gain')
            outfile.write(' gain="%s"' % self.gds_format_integer(self.gain, input_name='gain'))
        if self.inside_20 is not None and 'inside_20' not in already_processed:
            already_processed.add('inside_20')
            outfile.write(' inside_20="%s"' % self.gds_format_boolean(self.inside_20, input_name='inside_20'))
        if self.penalty_yards is not None and 'penalty_yards' not in already_processed:
            already_processed.add('penalty_yards')
            outfile.write(' penalty_yards="%s"' % self.gds_format_integer(self.penalty_yards, input_name='penalty_yards'))
        if self.play_count is not None and 'play_count' not in already_processed:
            already_processed.add('play_count')
            outfile.write(' play_count="%s"' % self.gds_format_integer(self.play_count, input_name='play_count'))
        if self.scoring_drive is not None and 'scoring_drive' not in already_processed:
            already_processed.add('scoring_drive')
            outfile.write(' scoring_drive="%s"' % self.gds_format_boolean(self.scoring_drive, input_name='scoring_drive'))
        if self.created_at is not None and 'created_at' not in already_processed:
            already_processed.add('created_at')
            outfile.write(' created_at=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.created_at), input_name='created_at')), ))
        if self.updated_at is not None and 'updated_at' not in already_processed:
            already_processed.add('updated_at')
            outfile.write(' updated_at=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.updated_at), input_name='updated_at')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='gameDetailsDriveType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for event_ in self.event:
            namespaceprefix_ = self.event_nsprefix_ + ':' if (UseCapturedNS_ and self.event_nsprefix_) else ''
            event_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='event', pretty_print=pretty_print)
        for play_ in self.play:
            namespaceprefix_ = self.play_nsprefix_ + ':' if (UseCapturedNS_ and self.play_nsprefix_) else ''
            play_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='play', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('sequence', node)
        if value is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            self.sequence = self.gds_parse_integer(value, node, 'sequence')
        value = find_attr_value_('start_reason', node)
        if value is not None and 'start_reason' not in already_processed:
            already_processed.add('start_reason')
            self.start_reason = value
            self.validate_driveReason(self.start_reason)    # validate type driveReason
        value = find_attr_value_('end_reason', node)
        if value is not None and 'end_reason' not in already_processed:
            already_processed.add('end_reason')
            self.end_reason = value
            self.validate_driveReason(self.end_reason)    # validate type driveReason
        value = find_attr_value_('duration', node)
        if value is not None and 'duration' not in already_processed:
            already_processed.add('duration')
            self.duration = value
        value = find_attr_value_('first_downs', node)
        if value is not None and 'first_downs' not in already_processed:
            already_processed.add('first_downs')
            self.first_downs = self.gds_parse_integer(value, node, 'first_downs')
        value = find_attr_value_('gain', node)
        if value is not None and 'gain' not in already_processed:
            already_processed.add('gain')
            self.gain = self.gds_parse_integer(value, node, 'gain')
        value = find_attr_value_('inside_20', node)
        if value is not None and 'inside_20' not in already_processed:
            already_processed.add('inside_20')
            if value in ('true', '1'):
                self.inside_20 = True
            elif value in ('false', '0'):
                self.inside_20 = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('penalty_yards', node)
        if value is not None and 'penalty_yards' not in already_processed:
            already_processed.add('penalty_yards')
            self.penalty_yards = self.gds_parse_integer(value, node, 'penalty_yards')
        value = find_attr_value_('play_count', node)
        if value is not None and 'play_count' not in already_processed:
            already_processed.add('play_count')
            self.play_count = self.gds_parse_integer(value, node, 'play_count')
        value = find_attr_value_('scoring_drive', node)
        if value is not None and 'scoring_drive' not in already_processed:
            already_processed.add('scoring_drive')
            if value in ('true', '1'):
                self.scoring_drive = True
            elif value in ('false', '0'):
                self.scoring_drive = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('created_at', node)
        if value is not None and 'created_at' not in already_processed:
            already_processed.add('created_at')
            self.created_at = value
        value = find_attr_value_('updated_at', node)
        if value is not None and 'updated_at' not in already_processed:
            already_processed.add('updated_at')
            self.updated_at = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'event':
            obj_ = gameEventType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.event.append(obj_)
            obj_.original_tagname_ = 'event'
        elif nodeName_ == 'play':
            obj_ = gamePlayDetailsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.play.append(obj_)
            obj_.original_tagname_ = 'play'
# end class gameDetailsDriveType


class coinTossType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, quarter=None, home=None, away=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "b"
        self.quarter = _cast(None, quarter)
        self.quarter_nsprefix_ = None
        self.home = home
        self.home_nsprefix_ = "b"
        self.away = away
        self.away_nsprefix_ = "b"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, coinTossType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if coinTossType.subclass:
            return coinTossType.subclass(*args_, **kwargs_)
        else:
            return coinTossType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_home(self):
        return self.home
    def set_home(self, home):
        self.home = home
    def get_away(self):
        return self.away
    def set_away(self, away):
        self.away = away
    def get_quarter(self):
        return self.quarter
    def set_quarter(self, quarter):
        self.quarter = quarter
    def has__content(self):
        if (
            self.home is not None or
            self.away is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='coinTossType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('coinTossType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'coinTossType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='coinTossType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='coinTossType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='coinTossType'):
        if self.quarter is not None and 'quarter' not in already_processed:
            already_processed.add('quarter')
            outfile.write(' quarter=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.quarter), input_name='quarter')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='coinTossType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.home is not None:
            namespaceprefix_ = self.home_nsprefix_ + ':' if (UseCapturedNS_ and self.home_nsprefix_) else ''
            self.home.export(outfile, level, namespaceprefix_, namespacedef_='', name_='home', pretty_print=pretty_print)
        if self.away is not None:
            namespaceprefix_ = self.away_nsprefix_ + ':' if (UseCapturedNS_ and self.away_nsprefix_) else ''
            self.away.export(outfile, level, namespaceprefix_, namespacedef_='', name_='away', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('quarter', node)
        if value is not None and 'quarter' not in already_processed:
            already_processed.add('quarter')
            self.quarter = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'home':
            obj_ = homeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.home = obj_
            obj_.original_tagname_ = 'home'
        elif nodeName_ == 'away':
            obj_ = awayType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.away = obj_
            obj_.original_tagname_ = 'away'
# end class coinTossType


class weatherType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, condition=None, humidity=None, temp=None, wind=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "b"
        self.condition = _cast(None, condition)
        self.condition_nsprefix_ = None
        self.humidity = _cast(int, humidity)
        self.humidity_nsprefix_ = None
        self.temp = _cast(int, temp)
        self.temp_nsprefix_ = None
        self.wind = wind
        self.wind_nsprefix_ = "b"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, weatherType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if weatherType.subclass:
            return weatherType.subclass(*args_, **kwargs_)
        else:
            return weatherType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_wind(self):
        return self.wind
    def set_wind(self, wind):
        self.wind = wind
    def get_condition(self):
        return self.condition
    def set_condition(self, condition):
        self.condition = condition
    def get_humidity(self):
        return self.humidity
    def set_humidity(self, humidity):
        self.humidity = humidity
    def get_temp(self):
        return self.temp
    def set_temp(self, temp):
        self.temp = temp
    def has__content(self):
        if (
            self.wind is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='weatherType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('weatherType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'weatherType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='weatherType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='weatherType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='weatherType'):
        if self.condition is not None and 'condition' not in already_processed:
            already_processed.add('condition')
            outfile.write(' condition=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.condition), input_name='condition')), ))
        if self.humidity is not None and 'humidity' not in already_processed:
            already_processed.add('humidity')
            outfile.write(' humidity="%s"' % self.gds_format_integer(self.humidity, input_name='humidity'))
        if self.temp is not None and 'temp' not in already_processed:
            already_processed.add('temp')
            outfile.write(' temp="%s"' % self.gds_format_integer(self.temp, input_name='temp'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='weatherType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.wind is not None:
            namespaceprefix_ = self.wind_nsprefix_ + ':' if (UseCapturedNS_ and self.wind_nsprefix_) else ''
            self.wind.export(outfile, level, namespaceprefix_, namespacedef_='', name_='wind', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('condition', node)
        if value is not None and 'condition' not in already_processed:
            already_processed.add('condition')
            self.condition = value
        value = find_attr_value_('humidity', node)
        if value is not None and 'humidity' not in already_processed:
            already_processed.add('humidity')
            self.humidity = self.gds_parse_integer(value, node, 'humidity')
        value = find_attr_value_('temp', node)
        if value is not None and 'temp' not in already_processed:
            already_processed.add('temp')
            self.temp = self.gds_parse_integer(value, node, 'temp')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'wind':
            obj_ = windType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.wind = obj_
            obj_.original_tagname_ = 'wind'
# end class weatherType


class referenceType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, origin=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "b"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.origin = _cast(None, origin)
        self.origin_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, referenceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if referenceType.subclass:
            return referenceType.subclass(*args_, **kwargs_)
        else:
            return referenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_origin(self):
        return self.origin
    def set_origin(self, origin):
        self.origin = origin
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='referenceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('referenceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'referenceType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='referenceType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='referenceType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='referenceType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.origin is not None and 'origin' not in already_processed:
            already_processed.add('origin')
            outfile.write(' origin=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.origin), input_name='origin')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='referenceType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('origin', node)
        if value is not None and 'origin' not in already_processed:
            already_processed.add('origin')
            self.origin = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class referenceType


class venueType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, sr_id=None, name=None, address=None, capacity=None, city=None, country=None, state=None, zip=None, roof_type=None, surface=None, location=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "b"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.sr_id = _cast(None, sr_id)
        self.sr_id_nsprefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.address = _cast(None, address)
        self.address_nsprefix_ = None
        self.capacity = _cast(int, capacity)
        self.capacity_nsprefix_ = None
        self.city = _cast(None, city)
        self.city_nsprefix_ = None
        self.country = _cast(None, country)
        self.country_nsprefix_ = None
        self.state = _cast(None, state)
        self.state_nsprefix_ = None
        self.zip = _cast(None, zip)
        self.zip_nsprefix_ = None
        self.roof_type = _cast(None, roof_type)
        self.roof_type_nsprefix_ = None
        self.surface = _cast(None, surface)
        self.surface_nsprefix_ = None
        self.location = location
        self.location_nsprefix_ = "b"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, venueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if venueType.subclass:
            return venueType.subclass(*args_, **kwargs_)
        else:
            return venueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_location(self):
        return self.location
    def set_location(self, location):
        self.location = location
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_sr_id(self):
        return self.sr_id
    def set_sr_id(self, sr_id):
        self.sr_id = sr_id
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_address(self):
        return self.address
    def set_address(self, address):
        self.address = address
    def get_capacity(self):
        return self.capacity
    def set_capacity(self, capacity):
        self.capacity = capacity
    def get_city(self):
        return self.city
    def set_city(self, city):
        self.city = city
    def get_country(self):
        return self.country
    def set_country(self, country):
        self.country = country
    def get_state(self):
        return self.state
    def set_state(self, state):
        self.state = state
    def get_zip(self):
        return self.zip
    def set_zip(self, zip):
        self.zip = zip
    def get_roof_type(self):
        return self.roof_type
    def set_roof_type(self, roof_type):
        self.roof_type = roof_type
    def get_surface(self):
        return self.surface
    def set_surface(self, surface):
        self.surface = surface
    def validate_roof_typeType(self, value):
        # Validate type roof_typeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['outdoor', 'dome', 'retractable_dome']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on roof_typeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_surfaceType(self, value):
        # Validate type surfaceType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['turf', 'artificial']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on surfaceType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.location is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='venueType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('venueType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'venueType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='venueType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='venueType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='venueType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.sr_id is not None and 'sr_id' not in already_processed:
            already_processed.add('sr_id')
            outfile.write(' sr_id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.sr_id), input_name='sr_id')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.address is not None and 'address' not in already_processed:
            already_processed.add('address')
            outfile.write(' address=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.address), input_name='address')), ))
        if self.capacity is not None and 'capacity' not in already_processed:
            already_processed.add('capacity')
            outfile.write(' capacity="%s"' % self.gds_format_integer(self.capacity, input_name='capacity'))
        if self.city is not None and 'city' not in already_processed:
            already_processed.add('city')
            outfile.write(' city=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.city), input_name='city')), ))
        if self.country is not None and 'country' not in already_processed:
            already_processed.add('country')
            outfile.write(' country=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.country), input_name='country')), ))
        if self.state is not None and 'state' not in already_processed:
            already_processed.add('state')
            outfile.write(' state=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.state), input_name='state')), ))
        if self.zip is not None and 'zip' not in already_processed:
            already_processed.add('zip')
            outfile.write(' zip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.zip), input_name='zip')), ))
        if self.roof_type is not None and 'roof_type' not in already_processed:
            already_processed.add('roof_type')
            outfile.write(' roof_type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.roof_type), input_name='roof_type')), ))
        if self.surface is not None and 'surface' not in already_processed:
            already_processed.add('surface')
            outfile.write(' surface=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.surface), input_name='surface')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='venueType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.location is not None:
            namespaceprefix_ = self.location_nsprefix_ + ':' if (UseCapturedNS_ and self.location_nsprefix_) else ''
            self.location.export(outfile, level, namespaceprefix_, namespacedef_='', name_='location', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('sr_id', node)
        if value is not None and 'sr_id' not in already_processed:
            already_processed.add('sr_id')
            self.sr_id = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('address', node)
        if value is not None and 'address' not in already_processed:
            already_processed.add('address')
            self.address = value
        value = find_attr_value_('capacity', node)
        if value is not None and 'capacity' not in already_processed:
            already_processed.add('capacity')
            self.capacity = self.gds_parse_integer(value, node, 'capacity')
        value = find_attr_value_('city', node)
        if value is not None and 'city' not in already_processed:
            already_processed.add('city')
            self.city = value
        value = find_attr_value_('country', node)
        if value is not None and 'country' not in already_processed:
            already_processed.add('country')
            self.country = value
        value = find_attr_value_('state', node)
        if value is not None and 'state' not in already_processed:
            already_processed.add('state')
            self.state = value
        value = find_attr_value_('zip', node)
        if value is not None and 'zip' not in already_processed:
            already_processed.add('zip')
            self.zip = value
        value = find_attr_value_('roof_type', node)
        if value is not None and 'roof_type' not in already_processed:
            already_processed.add('roof_type')
            self.roof_type = value
            self.validate_roof_typeType(self.roof_type)    # validate type roof_typeType
        value = find_attr_value_('surface', node)
        if value is not None and 'surface' not in already_processed:
            already_processed.add('surface')
            self.surface = value
            self.validate_surfaceType(self.surface)    # validate type surfaceType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'location':
            obj_ = locationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.location = obj_
            obj_.original_tagname_ = 'location'
# end class venueType


class teamType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, sr_id=None, alias=None, name=None, market=None, founded=None, reference=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "b"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.sr_id = _cast(None, sr_id)
        self.sr_id_nsprefix_ = None
        self.alias = _cast(None, alias)
        self.alias_nsprefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.market = _cast(None, market)
        self.market_nsprefix_ = None
        self.founded = _cast(int, founded)
        self.founded_nsprefix_ = None
        self.reference = _cast(None, reference)
        self.reference_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, teamType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if teamType.subclass:
            return teamType.subclass(*args_, **kwargs_)
        else:
            return teamType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_sr_id(self):
        return self.sr_id
    def set_sr_id(self, sr_id):
        self.sr_id = sr_id
    def get_alias(self):
        return self.alias
    def set_alias(self, alias):
        self.alias = alias
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_market(self):
        return self.market
    def set_market(self, market):
        self.market = market
    def get_founded(self):
        return self.founded
    def set_founded(self, founded):
        self.founded = founded
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='teamType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('teamType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'teamType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='teamType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='teamType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='teamType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.sr_id is not None and 'sr_id' not in already_processed:
            already_processed.add('sr_id')
            outfile.write(' sr_id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.sr_id), input_name='sr_id')), ))
        if self.alias is not None and 'alias' not in already_processed:
            already_processed.add('alias')
            outfile.write(' alias=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.alias), input_name='alias')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.market is not None and 'market' not in already_processed:
            already_processed.add('market')
            outfile.write(' market=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.market), input_name='market')), ))
        if self.founded is not None and 'founded' not in already_processed:
            already_processed.add('founded')
            outfile.write(' founded="%s"' % self.gds_format_integer(self.founded, input_name='founded'))
        if self.reference is not None and 'reference' not in already_processed:
            already_processed.add('reference')
            outfile.write(' reference=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.reference), input_name='reference')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='teamType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('sr_id', node)
        if value is not None and 'sr_id' not in already_processed:
            already_processed.add('sr_id')
            self.sr_id = value
        value = find_attr_value_('alias', node)
        if value is not None and 'alias' not in already_processed:
            already_processed.add('alias')
            self.alias = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('market', node)
        if value is not None and 'market' not in already_processed:
            already_processed.add('market')
            self.market = value
        value = find_attr_value_('founded', node)
        if value is not None and 'founded' not in already_processed:
            already_processed.add('founded')
            self.founded = self.gds_parse_integer(value, node, 'founded')
        value = find_attr_value_('reference', node)
        if value is not None and 'reference' not in already_processed:
            already_processed.add('reference')
            self.reference = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class teamType


class references(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, reference=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "b"
        if reference is None:
            self.reference = []
        else:
            self.reference = reference
        self.reference_nsprefix_ = "b"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, references)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if references.subclass:
            return references.subclass(*args_, **kwargs_)
        else:
            return references(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def add_reference(self, value):
        self.reference.append(value)
    def insert_reference_at(self, index, value):
        self.reference.insert(index, value)
    def replace_reference_at(self, index, value):
        self.reference[index] = value
    def has__content(self):
        if (
            self.reference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='references', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('references')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'references':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='references')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='references', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='references'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='references', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for reference_ in self.reference:
            namespaceprefix_ = self.reference_nsprefix_ + ':' if (UseCapturedNS_ and self.reference_nsprefix_) else ''
            reference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reference', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'reference':
            obj_ = referenceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reference.append(obj_)
            obj_.original_tagname_ = 'reference'
# end class references


class franchise(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, sr_id=None, alias=None, name=None, references=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "b"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.sr_id = _cast(None, sr_id)
        self.sr_id_nsprefix_ = None
        self.alias = _cast(None, alias)
        self.alias_nsprefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        if references is None:
            self.references = []
        else:
            self.references = references
        self.references_nsprefix_ = "b"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, franchise)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if franchise.subclass:
            return franchise.subclass(*args_, **kwargs_)
        else:
            return franchise(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_references(self):
        return self.references
    def set_references(self, references):
        self.references = references
    def add_references(self, value):
        self.references.append(value)
    def insert_references_at(self, index, value):
        self.references.insert(index, value)
    def replace_references_at(self, index, value):
        self.references[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_sr_id(self):
        return self.sr_id
    def set_sr_id(self, sr_id):
        self.sr_id = sr_id
    def get_alias(self):
        return self.alias
    def set_alias(self, alias):
        self.alias = alias
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def has__content(self):
        if (
            self.references
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='franchise', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('franchise')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'franchise':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='franchise')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='franchise', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='franchise'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.sr_id is not None and 'sr_id' not in already_processed:
            already_processed.add('sr_id')
            outfile.write(' sr_id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.sr_id), input_name='sr_id')), ))
        if self.alias is not None and 'alias' not in already_processed:
            already_processed.add('alias')
            outfile.write(' alias=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.alias), input_name='alias')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='franchise', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for references_ in self.references:
            namespaceprefix_ = self.references_nsprefix_ + ':' if (UseCapturedNS_ and self.references_nsprefix_) else ''
            references_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='references', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('sr_id', node)
        if value is not None and 'sr_id' not in already_processed:
            already_processed.add('sr_id')
            self.sr_id = value
        value = find_attr_value_('alias', node)
        if value is not None and 'alias' not in already_processed:
            already_processed.add('alias')
            self.alias = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'references':
            obj_ = references.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.references.append(obj_)
            obj_.original_tagname_ = 'references'
# end class franchise


class teamColorType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, hex_color=None, alpha=None, rgb_color=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "b"
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.hex_color = _cast(None, hex_color)
        self.hex_color_nsprefix_ = None
        self.alpha = _cast(float, alpha)
        self.alpha_nsprefix_ = None
        self.rgb_color = rgb_color
        self.rgb_color_nsprefix_ = "b"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, teamColorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if teamColorType.subclass:
            return teamColorType.subclass(*args_, **kwargs_)
        else:
            return teamColorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_rgb_color(self):
        return self.rgb_color
    def set_rgb_color(self, rgb_color):
        self.rgb_color = rgb_color
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_hex_color(self):
        return self.hex_color
    def set_hex_color(self, hex_color):
        self.hex_color = hex_color
    def get_alpha(self):
        return self.alpha
    def set_alpha(self, alpha):
        self.alpha = alpha
    def has__content(self):
        if (
            self.rgb_color is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='teamColorType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('teamColorType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'teamColorType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='teamColorType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='teamColorType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='teamColorType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.hex_color is not None and 'hex_color' not in already_processed:
            already_processed.add('hex_color')
            outfile.write(' hex_color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.hex_color), input_name='hex_color')), ))
        if self.alpha is not None and 'alpha' not in already_processed:
            already_processed.add('alpha')
            outfile.write(' alpha="%s"' % self.gds_format_float(self.alpha, input_name='alpha'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='teamColorType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.rgb_color is not None:
            namespaceprefix_ = self.rgb_color_nsprefix_ + ':' if (UseCapturedNS_ and self.rgb_color_nsprefix_) else ''
            self.rgb_color.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rgb_color', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('hex_color', node)
        if value is not None and 'hex_color' not in already_processed:
            already_processed.add('hex_color')
            self.hex_color = value
        value = find_attr_value_('alpha', node)
        if value is not None and 'alpha' not in already_processed:
            already_processed.add('alpha')
            value = self.gds_parse_float(value, node, 'alpha')
            self.alpha = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'rgb_color':
            obj_ = rgb_colorType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rgb_color = obj_
            obj_.original_tagname_ = 'rgb_color'
# end class teamColorType


class teamColorsType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, team_color=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "b"
        if team_color is None:
            self.team_color = []
        else:
            self.team_color = team_color
        self.team_color_nsprefix_ = "b"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, teamColorsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if teamColorsType.subclass:
            return teamColorsType.subclass(*args_, **kwargs_)
        else:
            return teamColorsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_team_color(self):
        return self.team_color
    def set_team_color(self, team_color):
        self.team_color = team_color
    def add_team_color(self, value):
        self.team_color.append(value)
    def insert_team_color_at(self, index, value):
        self.team_color.insert(index, value)
    def replace_team_color_at(self, index, value):
        self.team_color[index] = value
    def has__content(self):
        if (
            self.team_color
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='teamColorsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('teamColorsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'teamColorsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='teamColorsType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='teamColorsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='teamColorsType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='teamColorsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for team_color_ in self.team_color:
            namespaceprefix_ = self.team_color_nsprefix_ + ':' if (UseCapturedNS_ and self.team_color_nsprefix_) else ''
            team_color_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='team_color', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'team_color':
            obj_ = teamColorType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.team_color.append(obj_)
            obj_.original_tagname_ = 'team_color'
# end class teamColorsType


class last_eventType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, event=None, play=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.event = event
        self.event_nsprefix_ = None
        self.play = play
        self.play_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, last_eventType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if last_eventType.subclass:
            return last_eventType.subclass(*args_, **kwargs_)
        else:
            return last_eventType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_event(self):
        return self.event
    def set_event(self, event):
        self.event = event
    def get_play(self):
        return self.play
    def set_play(self, play):
        self.play = play
    def has__content(self):
        if (
            self.event is not None or
            self.play is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='last_eventType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('last_eventType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'last_eventType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='last_eventType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='last_eventType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='last_eventType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='last_eventType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.event is not None:
            namespaceprefix_ = self.event_nsprefix_ + ':' if (UseCapturedNS_ and self.event_nsprefix_) else ''
            self.event.export(outfile, level, namespaceprefix_, namespacedef_='', name_='event', pretty_print=pretty_print)
        if self.play is not None:
            namespaceprefix_ = self.play_nsprefix_ + ':' if (UseCapturedNS_ and self.play_nsprefix_) else ''
            self.play.export(outfile, level, namespaceprefix_, namespacedef_='', name_='play', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'event':
            obj_ = gameEventType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.event = obj_
            obj_.original_tagname_ = 'event'
        elif nodeName_ == 'play':
            obj_ = gamePlayDetailsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.play = obj_
            obj_.original_tagname_ = 'play'
# end class last_eventType


class scoringType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, quarter=None, overtime=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if quarter is None:
            self.quarter = []
        else:
            self.quarter = quarter
        self.quarter_nsprefix_ = None
        if overtime is None:
            self.overtime = []
        else:
            self.overtime = overtime
        self.overtime_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, scoringType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if scoringType.subclass:
            return scoringType.subclass(*args_, **kwargs_)
        else:
            return scoringType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_quarter(self):
        return self.quarter
    def set_quarter(self, quarter):
        self.quarter = quarter
    def add_quarter(self, value):
        self.quarter.append(value)
    def insert_quarter_at(self, index, value):
        self.quarter.insert(index, value)
    def replace_quarter_at(self, index, value):
        self.quarter[index] = value
    def get_overtime(self):
        return self.overtime
    def set_overtime(self, overtime):
        self.overtime = overtime
    def add_overtime(self, value):
        self.overtime.append(value)
    def insert_overtime_at(self, index, value):
        self.overtime.insert(index, value)
    def replace_overtime_at(self, index, value):
        self.overtime[index] = value
    def has__content(self):
        if (
            self.quarter or
            self.overtime
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='scoringType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('scoringType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'scoringType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='scoringType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='scoringType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='scoringType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='scoringType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for quarter_ in self.quarter:
            namespaceprefix_ = self.quarter_nsprefix_ + ':' if (UseCapturedNS_ and self.quarter_nsprefix_) else ''
            quarter_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='quarter', pretty_print=pretty_print)
        for overtime_ in self.overtime:
            namespaceprefix_ = self.overtime_nsprefix_ + ':' if (UseCapturedNS_ and self.overtime_nsprefix_) else ''
            overtime_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='overtime', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'quarter':
            obj_ = periodType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.quarter.append(obj_)
            obj_.original_tagname_ = 'quarter'
        elif nodeName_ == 'overtime':
            obj_ = periodType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.overtime.append(obj_)
            obj_.original_tagname_ = 'overtime'
# end class scoringType


class scoring_drivesType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, drive=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if drive is None:
            self.drive = []
        else:
            self.drive = drive
        self.drive_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, scoring_drivesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if scoring_drivesType.subclass:
            return scoring_drivesType.subclass(*args_, **kwargs_)
        else:
            return scoring_drivesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_drive(self):
        return self.drive
    def set_drive(self, drive):
        self.drive = drive
    def add_drive(self, value):
        self.drive.append(value)
    def insert_drive_at(self, index, value):
        self.drive.insert(index, value)
    def replace_drive_at(self, index, value):
        self.drive[index] = value
    def has__content(self):
        if (
            self.drive
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='scoring_drivesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('scoring_drivesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'scoring_drivesType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='scoring_drivesType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='scoring_drivesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='scoring_drivesType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='scoring_drivesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for drive_ in self.drive:
            namespaceprefix_ = self.drive_nsprefix_ + ':' if (UseCapturedNS_ and self.drive_nsprefix_) else ''
            drive_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='drive', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'drive':
            obj_ = scoringDriveType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.drive.append(obj_)
            obj_.original_tagname_ = 'drive'
# end class scoring_drivesType


class scoring_playsType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, play=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if play is None:
            self.play = []
        else:
            self.play = play
        self.play_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, scoring_playsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if scoring_playsType.subclass:
            return scoring_playsType.subclass(*args_, **kwargs_)
        else:
            return scoring_playsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_play(self):
        return self.play
    def set_play(self, play):
        self.play = play
    def add_play(self, value):
        self.play.append(value)
    def insert_play_at(self, index, value):
        self.play.insert(index, value)
    def replace_play_at(self, index, value):
        self.play[index] = value
    def has__content(self):
        if (
            self.play
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='scoring_playsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('scoring_playsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'scoring_playsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='scoring_playsType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='scoring_playsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='scoring_playsType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='scoring_playsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for play_ in self.play:
            namespaceprefix_ = self.play_nsprefix_ + ':' if (UseCapturedNS_ and self.play_nsprefix_) else ''
            play_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='play', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'play':
            obj_ = gamePlayScoresType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.play.append(obj_)
            obj_.original_tagname_ = 'play'
# end class scoring_playsType


class quarterType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, number=None, sequence=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.number = _cast(int, number)
        self.number_nsprefix_ = None
        self.sequence = _cast(int, sequence)
        self.sequence_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, quarterType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if quarterType.subclass:
            return quarterType.subclass(*args_, **kwargs_)
        else:
            return quarterType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_number(self):
        return self.number
    def set_number(self, number):
        self.number = number
    def get_sequence(self):
        return self.sequence
    def set_sequence(self, sequence):
        self.sequence = sequence
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='quarterType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('quarterType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'quarterType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='quarterType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='quarterType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='quarterType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number="%s"' % self.gds_format_integer(self.number, input_name='number'))
        if self.sequence is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            outfile.write(' sequence="%s"' % self.gds_format_integer(self.sequence, input_name='sequence'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='quarterType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            self.number = self.gds_parse_integer(value, node, 'number')
        value = find_attr_value_('sequence', node)
        if value is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            self.sequence = self.gds_parse_integer(value, node, 'sequence')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class quarterType


class overtimeType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, number=None, sequence=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.number = _cast(int, number)
        self.number_nsprefix_ = None
        self.sequence = _cast(int, sequence)
        self.sequence_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, overtimeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if overtimeType.subclass:
            return overtimeType.subclass(*args_, **kwargs_)
        else:
            return overtimeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_number(self):
        return self.number
    def set_number(self, number):
        self.number = number
    def get_sequence(self):
        return self.sequence
    def set_sequence(self, sequence):
        self.sequence = sequence
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='overtimeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('overtimeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'overtimeType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='overtimeType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='overtimeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='overtimeType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number="%s"' % self.gds_format_integer(self.number, input_name='number'))
        if self.sequence is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            outfile.write(' sequence="%s"' % self.gds_format_integer(self.sequence, input_name='sequence'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='overtimeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            self.number = self.gds_parse_integer(value, node, 'number')
        value = find_attr_value_('sequence', node)
        if value is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            self.sequence = self.gds_parse_integer(value, node, 'sequence')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class overtimeType


class teamType1(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, sr_id=None, alias=None, name=None, market=None, founded=None, reference=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.sr_id = _cast(None, sr_id)
        self.sr_id_nsprefix_ = None
        self.alias = _cast(None, alias)
        self.alias_nsprefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.market = _cast(None, market)
        self.market_nsprefix_ = None
        self.founded = _cast(int, founded)
        self.founded_nsprefix_ = None
        self.reference = _cast(None, reference)
        self.reference_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, teamType1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if teamType1.subclass:
            return teamType1.subclass(*args_, **kwargs_)
        else:
            return teamType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_sr_id(self):
        return self.sr_id
    def set_sr_id(self, sr_id):
        self.sr_id = sr_id
    def get_alias(self):
        return self.alias
    def set_alias(self, alias):
        self.alias = alias
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_market(self):
        return self.market
    def set_market(self, market):
        self.market = market
    def get_founded(self):
        return self.founded
    def set_founded(self, founded):
        self.founded = founded
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='teamType1', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('teamType1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'teamType1':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='teamType1')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='teamType1', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='teamType1'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.sr_id is not None and 'sr_id' not in already_processed:
            already_processed.add('sr_id')
            outfile.write(' sr_id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.sr_id), input_name='sr_id')), ))
        if self.alias is not None and 'alias' not in already_processed:
            already_processed.add('alias')
            outfile.write(' alias=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.alias), input_name='alias')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.market is not None and 'market' not in already_processed:
            already_processed.add('market')
            outfile.write(' market=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.market), input_name='market')), ))
        if self.founded is not None and 'founded' not in already_processed:
            already_processed.add('founded')
            outfile.write(' founded="%s"' % self.gds_format_integer(self.founded, input_name='founded'))
        if self.reference is not None and 'reference' not in already_processed:
            already_processed.add('reference')
            outfile.write(' reference=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.reference), input_name='reference')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='teamType1', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('sr_id', node)
        if value is not None and 'sr_id' not in already_processed:
            already_processed.add('sr_id')
            self.sr_id = value
        value = find_attr_value_('alias', node)
        if value is not None and 'alias' not in already_processed:
            already_processed.add('alias')
            self.alias = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('market', node)
        if value is not None and 'market' not in already_processed:
            already_processed.add('market')
            self.market = value
        value = find_attr_value_('founded', node)
        if value is not None and 'founded' not in already_processed:
            already_processed.add('founded')
            self.founded = self.gds_parse_integer(value, node, 'founded')
        value = find_attr_value_('reference', node)
        if value is not None and 'reference' not in already_processed:
            already_processed.add('reference')
            self.reference = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class teamType1


class playsType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, event=None, play=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if event is None:
            self.event = []
        else:
            self.event = event
        self.event_nsprefix_ = None
        if play is None:
            self.play = []
        else:
            self.play = play
        self.play_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, playsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if playsType.subclass:
            return playsType.subclass(*args_, **kwargs_)
        else:
            return playsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_event(self):
        return self.event
    def set_event(self, event):
        self.event = event
    def add_event(self, value):
        self.event.append(value)
    def insert_event_at(self, index, value):
        self.event.insert(index, value)
    def replace_event_at(self, index, value):
        self.event[index] = value
    def get_play(self):
        return self.play
    def set_play(self, play):
        self.play = play
    def add_play(self, value):
        self.play.append(value)
    def insert_play_at(self, index, value):
        self.play.insert(index, value)
    def replace_play_at(self, index, value):
        self.play[index] = value
    def has__content(self):
        if (
            self.event or
            self.play
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='playsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('playsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'playsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='playsType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='playsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='playsType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='playsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for event_ in self.event:
            namespaceprefix_ = self.event_nsprefix_ + ':' if (UseCapturedNS_ and self.event_nsprefix_) else ''
            event_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='event', pretty_print=pretty_print)
        for play_ in self.play:
            namespaceprefix_ = self.play_nsprefix_ + ':' if (UseCapturedNS_ and self.play_nsprefix_) else ''
            play_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='play', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'event':
            obj_ = gameEventType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.event.append(obj_)
            obj_.original_tagname_ = 'event'
        elif nodeName_ == 'play':
            obj_ = gamePlayDetailsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.play.append(obj_)
            obj_.original_tagname_ = 'play'
# end class playsType


class quarterType2(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, number=None, sequence=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.number = _cast(int, number)
        self.number_nsprefix_ = None
        self.sequence = _cast(int, sequence)
        self.sequence_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, quarterType2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if quarterType2.subclass:
            return quarterType2.subclass(*args_, **kwargs_)
        else:
            return quarterType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_number(self):
        return self.number
    def set_number(self, number):
        self.number = number
    def get_sequence(self):
        return self.sequence
    def set_sequence(self, sequence):
        self.sequence = sequence
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='quarterType2', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('quarterType2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'quarterType2':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='quarterType2')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='quarterType2', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='quarterType2'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number="%s"' % self.gds_format_integer(self.number, input_name='number'))
        if self.sequence is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            outfile.write(' sequence="%s"' % self.gds_format_integer(self.sequence, input_name='sequence'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='quarterType2', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            self.number = self.gds_parse_integer(value, node, 'number')
        value = find_attr_value_('sequence', node)
        if value is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            self.sequence = self.gds_parse_integer(value, node, 'sequence')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class quarterType2


class overtimeType3(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, number=None, sequence=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.number = _cast(int, number)
        self.number_nsprefix_ = None
        self.sequence = _cast(int, sequence)
        self.sequence_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, overtimeType3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if overtimeType3.subclass:
            return overtimeType3.subclass(*args_, **kwargs_)
        else:
            return overtimeType3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_number(self):
        return self.number
    def set_number(self, number):
        self.number = number
    def get_sequence(self):
        return self.sequence
    def set_sequence(self, sequence):
        self.sequence = sequence
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='overtimeType3', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('overtimeType3')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'overtimeType3':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='overtimeType3')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='overtimeType3', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='overtimeType3'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number="%s"' % self.gds_format_integer(self.number, input_name='number'))
        if self.sequence is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            outfile.write(' sequence="%s"' % self.gds_format_integer(self.sequence, input_name='sequence'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='overtimeType3', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            self.number = self.gds_parse_integer(value, node, 'number')
        value = find_attr_value_('sequence', node)
        if value is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            self.sequence = self.gds_parse_integer(value, node, 'sequence')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class overtimeType3


class detailsType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, detail=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if detail is None:
            self.detail = []
        else:
            self.detail = detail
        self.detail_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, detailsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if detailsType.subclass:
            return detailsType.subclass(*args_, **kwargs_)
        else:
            return detailsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_detail(self):
        return self.detail
    def set_detail(self, detail):
        self.detail = detail
    def add_detail(self, value):
        self.detail.append(value)
    def insert_detail_at(self, index, value):
        self.detail.insert(index, value)
    def replace_detail_at(self, index, value):
        self.detail[index] = value
    def has__content(self):
        if (
            self.detail
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='detailsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('detailsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'detailsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='detailsType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='detailsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='detailsType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='detailsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for detail_ in self.detail:
            namespaceprefix_ = self.detail_nsprefix_ + ':' if (UseCapturedNS_ and self.detail_nsprefix_) else ''
            detail_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='detail', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'detail':
            obj_ = playDetailsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.detail.append(obj_)
            obj_.original_tagname_ = 'detail'
# end class detailsType


class seasonType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, year=None, type_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.year = _cast(int, year)
        self.year_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, seasonType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if seasonType.subclass:
            return seasonType.subclass(*args_, **kwargs_)
        else:
            return seasonType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_year(self):
        return self.year
    def set_year(self, year):
        self.year = year
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def validate_typeType40(self, value):
        # Validate type typeType40, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['PRE', 'REG', 'PST']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeType40' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='seasonType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('seasonType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'seasonType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='seasonType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='seasonType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='seasonType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.year is not None and 'year' not in already_processed:
            already_processed.add('year')
            outfile.write(' year="%s"' % self.gds_format_integer(self.year, input_name='year'))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='seasonType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('year', node)
        if value is not None and 'year' not in already_processed:
            already_processed.add('year')
            self.year = self.gds_parse_integer(value, node, 'year')
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_typeType40(self.type_)    # validate type typeType40
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class seasonType


class weekType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, sequence=None, title=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.sequence = _cast(int, sequence)
        self.sequence_nsprefix_ = None
        self.title = _cast(None, title)
        self.title_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, weekType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if weekType.subclass:
            return weekType.subclass(*args_, **kwargs_)
        else:
            return weekType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_sequence(self):
        return self.sequence
    def set_sequence(self, sequence):
        self.sequence = sequence
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='weekType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('weekType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'weekType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='weekType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='weekType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='weekType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.sequence is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            outfile.write(' sequence="%s"' % self.gds_format_integer(self.sequence, input_name='sequence'))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.title), input_name='title')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='weekType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('sequence', node)
        if value is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            self.sequence = self.gds_parse_integer(value, node, 'sequence')
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class weekType


class recordType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, wins=None, losses=None, ties=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.wins = _cast(int, wins)
        self.wins_nsprefix_ = None
        self.losses = _cast(int, losses)
        self.losses_nsprefix_ = None
        self.ties = _cast(int, ties)
        self.ties_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, recordType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if recordType.subclass:
            return recordType.subclass(*args_, **kwargs_)
        else:
            return recordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_wins(self):
        return self.wins
    def set_wins(self, wins):
        self.wins = wins
    def get_losses(self):
        return self.losses
    def set_losses(self, losses):
        self.losses = losses
    def get_ties(self):
        return self.ties
    def set_ties(self, ties):
        self.ties = ties
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='recordType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('recordType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'recordType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='recordType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='recordType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='recordType'):
        if self.wins is not None and 'wins' not in already_processed:
            already_processed.add('wins')
            outfile.write(' wins="%s"' % self.gds_format_integer(self.wins, input_name='wins'))
        if self.losses is not None and 'losses' not in already_processed:
            already_processed.add('losses')
            outfile.write(' losses="%s"' % self.gds_format_integer(self.losses, input_name='losses'))
        if self.ties is not None and 'ties' not in already_processed:
            already_processed.add('ties')
            outfile.write(' ties="%s"' % self.gds_format_integer(self.ties, input_name='ties'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='recordType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('wins', node)
        if value is not None and 'wins' not in already_processed:
            already_processed.add('wins')
            self.wins = self.gds_parse_integer(value, node, 'wins')
        value = find_attr_value_('losses', node)
        if value is not None and 'losses' not in already_processed:
            already_processed.add('losses')
            self.losses = self.gds_parse_integer(value, node, 'losses')
        value = find_attr_value_('ties', node)
        if value is not None and 'ties' not in already_processed:
            already_processed.add('ties')
            self.ties = self.gds_parse_integer(value, node, 'ties')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class recordType


class drive_infoType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, duration=None, net_yards=None, play_count=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.duration = _cast(None, duration)
        self.duration_nsprefix_ = None
        self.net_yards = _cast(int, net_yards)
        self.net_yards_nsprefix_ = None
        self.play_count = _cast(int, play_count)
        self.play_count_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, drive_infoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if drive_infoType.subclass:
            return drive_infoType.subclass(*args_, **kwargs_)
        else:
            return drive_infoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_duration(self):
        return self.duration
    def set_duration(self, duration):
        self.duration = duration
    def get_net_yards(self):
        return self.net_yards
    def set_net_yards(self, net_yards):
        self.net_yards = net_yards
    def get_play_count(self):
        return self.play_count
    def set_play_count(self, play_count):
        self.play_count = play_count
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='drive-infoType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('drive-infoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'drive-infoType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='drive-infoType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='drive-infoType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='drive-infoType'):
        if self.duration is not None and 'duration' not in already_processed:
            already_processed.add('duration')
            outfile.write(' duration=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.duration), input_name='duration')), ))
        if self.net_yards is not None and 'net_yards' not in already_processed:
            already_processed.add('net_yards')
            outfile.write(' net_yards="%s"' % self.gds_format_integer(self.net_yards, input_name='net_yards'))
        if self.play_count is not None and 'play_count' not in already_processed:
            already_processed.add('play_count')
            outfile.write(' play_count="%s"' % self.gds_format_integer(self.play_count, input_name='play_count'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='drive-infoType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('duration', node)
        if value is not None and 'duration' not in already_processed:
            already_processed.add('duration')
            self.duration = value
        value = find_attr_value_('net_yards', node)
        if value is not None and 'net_yards' not in already_processed:
            already_processed.add('net_yards')
            self.net_yards = self.gds_parse_integer(value, node, 'net_yards')
        value = find_attr_value_('play_count', node)
        if value is not None and 'play_count' not in already_processed:
            already_processed.add('play_count')
            self.play_count = self.gds_parse_integer(value, node, 'play_count')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class drive_infoType


class points_after_playType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, id=None, sequence=None, reference=None, clock=None, wall_clock=None, deleted=None, source=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.sequence = _cast(float, sequence)
        self.sequence_nsprefix_ = None
        self.reference = _cast(int, reference)
        self.reference_nsprefix_ = None
        self.clock = _cast(None, clock)
        self.clock_nsprefix_ = None
        if isinstance(wall_clock, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(wall_clock, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = wall_clock
        self.wall_clock = initvalue_
        self.deleted = _cast(bool, deleted)
        self.deleted_nsprefix_ = None
        self.source = _cast(None, source)
        self.source_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, points_after_playType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if points_after_playType.subclass:
            return points_after_playType.subclass(*args_, **kwargs_)
        else:
            return points_after_playType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_sequence(self):
        return self.sequence
    def set_sequence(self, sequence):
        self.sequence = sequence
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def get_clock(self):
        return self.clock
    def set_clock(self, clock):
        self.clock = clock
    def get_wall_clock(self):
        return self.wall_clock
    def set_wall_clock(self, wall_clock):
        self.wall_clock = wall_clock
    def get_deleted(self):
        return self.deleted
    def set_deleted(self, deleted):
        self.deleted = deleted
    def get_source(self):
        return self.source
    def set_source(self, source):
        self.source = source
    def validate_typeType5(self, value):
        # Validate type typeType5, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['extra_point', 'conversion', 'penalty']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeType5' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='points-after-playType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('points-after-playType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'points-after-playType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='points-after-playType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='points-after-playType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='points-after-playType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.sequence is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            outfile.write(' sequence="%s"' % self.gds_format_decimal(self.sequence, input_name='sequence'))
        if self.reference is not None and 'reference' not in already_processed:
            already_processed.add('reference')
            outfile.write(' reference="%s"' % self.gds_format_integer(self.reference, input_name='reference'))
        if self.clock is not None and 'clock' not in already_processed:
            already_processed.add('clock')
            outfile.write(' clock=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.clock), input_name='clock')), ))
        if self.wall_clock is not None and 'wall_clock' not in already_processed:
            already_processed.add('wall_clock')
            outfile.write(' wall_clock="%s"' % self.gds_format_datetime(self.wall_clock, input_name='wall_clock'))
        if self.deleted is not None and 'deleted' not in already_processed:
            already_processed.add('deleted')
            outfile.write(' deleted="%s"' % self.gds_format_boolean(self.deleted, input_name='deleted'))
        if self.source is not None and 'source' not in already_processed:
            already_processed.add('source')
            outfile.write(' source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.source), input_name='source')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='points-after-playType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_typeType5(self.type_)    # validate type typeType5
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('sequence', node)
        if value is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            value = self.gds_parse_decimal(value, node, 'sequence')
            self.sequence = value
        value = find_attr_value_('reference', node)
        if value is not None and 'reference' not in already_processed:
            already_processed.add('reference')
            self.reference = self.gds_parse_integer(value, node, 'reference')
        value = find_attr_value_('clock', node)
        if value is not None and 'clock' not in already_processed:
            already_processed.add('clock')
            self.clock = value
        value = find_attr_value_('wall_clock', node)
        if value is not None and 'wall_clock' not in already_processed:
            already_processed.add('wall_clock')
            try:
                self.wall_clock = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (wall_clock): %s' % exp)
        value = find_attr_value_('deleted', node)
        if value is not None and 'deleted' not in already_processed:
            already_processed.add('deleted')
            if value in ('true', '1'):
                self.deleted = True
            elif value in ('false', '0'):
                self.deleted = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('source', node)
        if value is not None and 'source' not in already_processed:
            already_processed.add('source')
            self.source = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class points_after_playType


class timeoutType(basePlayStatisticType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = basePlayStatisticType
    def __init__(self, nullified=None, team=None, player=None, description=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("timeoutType"), self).__init__(nullified, team, player,  **kwargs_)
        self.description = _cast(None, description)
        self.description_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, timeoutType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if timeoutType.subclass:
            return timeoutType.subclass(*args_, **kwargs_)
        else:
            return timeoutType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def has__content(self):
        if (
            super(timeoutType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='timeoutType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('timeoutType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'timeoutType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='timeoutType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='timeoutType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='timeoutType'):
        super(timeoutType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='timeoutType')
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            outfile.write(' description=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.description), input_name='description')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='timeoutType', fromsubclass_=False, pretty_print=True):
        super(timeoutType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.add('description')
            self.description = value
        super(timeoutType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(timeoutType, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class timeoutType


class miscType(basePlayStatisticType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = basePlayStatisticType
    def __init__(self, nullified=None, team=None, player=None, yards=None, touchdown=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("miscType"), self).__init__(nullified, team, player,  **kwargs_)
        self.yards = _cast(int, yards)
        self.yards_nsprefix_ = None
        self.touchdown = _cast(int, touchdown)
        self.touchdown_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, miscType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if miscType.subclass:
            return miscType.subclass(*args_, **kwargs_)
        else:
            return miscType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_yards(self):
        return self.yards
    def set_yards(self, yards):
        self.yards = yards
    def get_touchdown(self):
        return self.touchdown
    def set_touchdown(self, touchdown):
        self.touchdown = touchdown
    def has__content(self):
        if (
            super(miscType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='miscType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('miscType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'miscType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='miscType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='miscType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='miscType'):
        super(miscType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='miscType')
        if self.yards is not None and 'yards' not in already_processed:
            already_processed.add('yards')
            outfile.write(' yards="%s"' % self.gds_format_integer(self.yards, input_name='yards'))
        if self.touchdown is not None and 'touchdown' not in already_processed:
            already_processed.add('touchdown')
            outfile.write(' touchdown="%s"' % self.gds_format_integer(self.touchdown, input_name='touchdown'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='miscType', fromsubclass_=False, pretty_print=True):
        super(miscType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('yards', node)
        if value is not None and 'yards' not in already_processed:
            already_processed.add('yards')
            self.yards = self.gds_parse_integer(value, node, 'yards')
        value = find_attr_value_('touchdown', node)
        if value is not None and 'touchdown' not in already_processed:
            already_processed.add('touchdown')
            self.touchdown = self.gds_parse_integer(value, node, 'touchdown')
        super(miscType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(miscType, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class miscType


class passType(basePlayStatisticType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = basePlayStatisticType
    def __init__(self, nullified=None, team=None, player=None, attempt=None, complete=None, yards=None, att_yards=None, interception=None, firstdown=None, touchdown=None, sack=None, sack_yards=None, inside_20=None, goaltogo=None, safety=None, int_touchdown=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("passType"), self).__init__(nullified, team, player,  **kwargs_)
        self.attempt = _cast(int, attempt)
        self.attempt_nsprefix_ = None
        self.complete = _cast(int, complete)
        self.complete_nsprefix_ = None
        self.yards = _cast(int, yards)
        self.yards_nsprefix_ = None
        self.att_yards = _cast(int, att_yards)
        self.att_yards_nsprefix_ = None
        self.interception = _cast(int, interception)
        self.interception_nsprefix_ = None
        self.firstdown = _cast(int, firstdown)
        self.firstdown_nsprefix_ = None
        self.touchdown = _cast(int, touchdown)
        self.touchdown_nsprefix_ = None
        self.sack = _cast(int, sack)
        self.sack_nsprefix_ = None
        self.sack_yards = _cast(float, sack_yards)
        self.sack_yards_nsprefix_ = None
        self.inside_20 = _cast(int, inside_20)
        self.inside_20_nsprefix_ = None
        self.goaltogo = _cast(int, goaltogo)
        self.goaltogo_nsprefix_ = None
        self.safety = _cast(int, safety)
        self.safety_nsprefix_ = None
        self.int_touchdown = _cast(int, int_touchdown)
        self.int_touchdown_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, passType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if passType.subclass:
            return passType.subclass(*args_, **kwargs_)
        else:
            return passType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_attempt(self):
        return self.attempt
    def set_attempt(self, attempt):
        self.attempt = attempt
    def get_complete(self):
        return self.complete
    def set_complete(self, complete):
        self.complete = complete
    def get_yards(self):
        return self.yards
    def set_yards(self, yards):
        self.yards = yards
    def get_att_yards(self):
        return self.att_yards
    def set_att_yards(self, att_yards):
        self.att_yards = att_yards
    def get_interception(self):
        return self.interception
    def set_interception(self, interception):
        self.interception = interception
    def get_firstdown(self):
        return self.firstdown
    def set_firstdown(self, firstdown):
        self.firstdown = firstdown
    def get_touchdown(self):
        return self.touchdown
    def set_touchdown(self, touchdown):
        self.touchdown = touchdown
    def get_sack(self):
        return self.sack
    def set_sack(self, sack):
        self.sack = sack
    def get_sack_yards(self):
        return self.sack_yards
    def set_sack_yards(self, sack_yards):
        self.sack_yards = sack_yards
    def get_inside_20(self):
        return self.inside_20
    def set_inside_20(self, inside_20):
        self.inside_20 = inside_20
    def get_goaltogo(self):
        return self.goaltogo
    def set_goaltogo(self, goaltogo):
        self.goaltogo = goaltogo
    def get_safety(self):
        return self.safety
    def set_safety(self, safety):
        self.safety = safety
    def get_int_touchdown(self):
        return self.int_touchdown
    def set_int_touchdown(self, int_touchdown):
        self.int_touchdown = int_touchdown
    def has__content(self):
        if (
            super(passType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='passType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('passType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'passType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='passType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='passType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='passType'):
        super(passType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='passType')
        if self.attempt is not None and 'attempt' not in already_processed:
            already_processed.add('attempt')
            outfile.write(' attempt="%s"' % self.gds_format_integer(self.attempt, input_name='attempt'))
        if self.complete is not None and 'complete' not in already_processed:
            already_processed.add('complete')
            outfile.write(' complete="%s"' % self.gds_format_integer(self.complete, input_name='complete'))
        if self.yards is not None and 'yards' not in already_processed:
            already_processed.add('yards')
            outfile.write(' yards="%s"' % self.gds_format_integer(self.yards, input_name='yards'))
        if self.att_yards is not None and 'att_yards' not in already_processed:
            already_processed.add('att_yards')
            outfile.write(' att_yards="%s"' % self.gds_format_integer(self.att_yards, input_name='att_yards'))
        if self.interception is not None and 'interception' not in already_processed:
            already_processed.add('interception')
            outfile.write(' interception="%s"' % self.gds_format_integer(self.interception, input_name='interception'))
        if self.firstdown is not None and 'firstdown' not in already_processed:
            already_processed.add('firstdown')
            outfile.write(' firstdown="%s"' % self.gds_format_integer(self.firstdown, input_name='firstdown'))
        if self.touchdown is not None and 'touchdown' not in already_processed:
            already_processed.add('touchdown')
            outfile.write(' touchdown="%s"' % self.gds_format_integer(self.touchdown, input_name='touchdown'))
        if self.sack is not None and 'sack' not in already_processed:
            already_processed.add('sack')
            outfile.write(' sack="%s"' % self.gds_format_integer(self.sack, input_name='sack'))
        if self.sack_yards is not None and 'sack_yards' not in already_processed:
            already_processed.add('sack_yards')
            outfile.write(' sack_yards="%s"' % self.gds_format_double(self.sack_yards, input_name='sack_yards'))
        if self.inside_20 is not None and 'inside_20' not in already_processed:
            already_processed.add('inside_20')
            outfile.write(' inside_20="%s"' % self.gds_format_integer(self.inside_20, input_name='inside_20'))
        if self.goaltogo is not None and 'goaltogo' not in already_processed:
            already_processed.add('goaltogo')
            outfile.write(' goaltogo="%s"' % self.gds_format_integer(self.goaltogo, input_name='goaltogo'))
        if self.safety is not None and 'safety' not in already_processed:
            already_processed.add('safety')
            outfile.write(' safety="%s"' % self.gds_format_integer(self.safety, input_name='safety'))
        if self.int_touchdown is not None and 'int_touchdown' not in already_processed:
            already_processed.add('int_touchdown')
            outfile.write(' int_touchdown="%s"' % self.gds_format_integer(self.int_touchdown, input_name='int_touchdown'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='passType', fromsubclass_=False, pretty_print=True):
        super(passType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('attempt', node)
        if value is not None and 'attempt' not in already_processed:
            already_processed.add('attempt')
            self.attempt = self.gds_parse_integer(value, node, 'attempt')
        value = find_attr_value_('complete', node)
        if value is not None and 'complete' not in already_processed:
            already_processed.add('complete')
            self.complete = self.gds_parse_integer(value, node, 'complete')
        value = find_attr_value_('yards', node)
        if value is not None and 'yards' not in already_processed:
            already_processed.add('yards')
            self.yards = self.gds_parse_integer(value, node, 'yards')
        value = find_attr_value_('att_yards', node)
        if value is not None and 'att_yards' not in already_processed:
            already_processed.add('att_yards')
            self.att_yards = self.gds_parse_integer(value, node, 'att_yards')
        value = find_attr_value_('interception', node)
        if value is not None and 'interception' not in already_processed:
            already_processed.add('interception')
            self.interception = self.gds_parse_integer(value, node, 'interception')
        value = find_attr_value_('firstdown', node)
        if value is not None and 'firstdown' not in already_processed:
            already_processed.add('firstdown')
            self.firstdown = self.gds_parse_integer(value, node, 'firstdown')
        value = find_attr_value_('touchdown', node)
        if value is not None and 'touchdown' not in already_processed:
            already_processed.add('touchdown')
            self.touchdown = self.gds_parse_integer(value, node, 'touchdown')
        value = find_attr_value_('sack', node)
        if value is not None and 'sack' not in already_processed:
            already_processed.add('sack')
            self.sack = self.gds_parse_integer(value, node, 'sack')
        value = find_attr_value_('sack_yards', node)
        if value is not None and 'sack_yards' not in already_processed:
            already_processed.add('sack_yards')
            value = self.gds_parse_double(value, node, 'sack_yards')
            self.sack_yards = value
        value = find_attr_value_('inside_20', node)
        if value is not None and 'inside_20' not in already_processed:
            already_processed.add('inside_20')
            self.inside_20 = self.gds_parse_integer(value, node, 'inside_20')
        value = find_attr_value_('goaltogo', node)
        if value is not None and 'goaltogo' not in already_processed:
            already_processed.add('goaltogo')
            self.goaltogo = self.gds_parse_integer(value, node, 'goaltogo')
        value = find_attr_value_('safety', node)
        if value is not None and 'safety' not in already_processed:
            already_processed.add('safety')
            self.safety = self.gds_parse_integer(value, node, 'safety')
        value = find_attr_value_('int_touchdown', node)
        if value is not None and 'int_touchdown' not in already_processed:
            already_processed.add('int_touchdown')
            self.int_touchdown = self.gds_parse_integer(value, node, 'int_touchdown')
        super(passType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(passType, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class passType


class receiveType(basePlayStatisticType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = basePlayStatisticType
    def __init__(self, nullified=None, team=None, player=None, firstdown=None, touchdown=None, safety=None, target=None, reception=None, yards=None, yards_after_catch=None, fumble=None, dropped=None, inside_20=None, goaltogo=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("receiveType"), self).__init__(nullified, team, player,  **kwargs_)
        self.firstdown = _cast(int, firstdown)
        self.firstdown_nsprefix_ = None
        self.touchdown = _cast(int, touchdown)
        self.touchdown_nsprefix_ = None
        self.safety = _cast(int, safety)
        self.safety_nsprefix_ = None
        self.target = _cast(int, target)
        self.target_nsprefix_ = None
        self.reception = _cast(int, reception)
        self.reception_nsprefix_ = None
        self.yards = _cast(int, yards)
        self.yards_nsprefix_ = None
        self.yards_after_catch = _cast(int, yards_after_catch)
        self.yards_after_catch_nsprefix_ = None
        self.fumble = _cast(int, fumble)
        self.fumble_nsprefix_ = None
        self.dropped = _cast(int, dropped)
        self.dropped_nsprefix_ = None
        self.inside_20 = _cast(int, inside_20)
        self.inside_20_nsprefix_ = None
        self.goaltogo = _cast(int, goaltogo)
        self.goaltogo_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, receiveType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if receiveType.subclass:
            return receiveType.subclass(*args_, **kwargs_)
        else:
            return receiveType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_firstdown(self):
        return self.firstdown
    def set_firstdown(self, firstdown):
        self.firstdown = firstdown
    def get_touchdown(self):
        return self.touchdown
    def set_touchdown(self, touchdown):
        self.touchdown = touchdown
    def get_safety(self):
        return self.safety
    def set_safety(self, safety):
        self.safety = safety
    def get_target(self):
        return self.target
    def set_target(self, target):
        self.target = target
    def get_reception(self):
        return self.reception
    def set_reception(self, reception):
        self.reception = reception
    def get_yards(self):
        return self.yards
    def set_yards(self, yards):
        self.yards = yards
    def get_yards_after_catch(self):
        return self.yards_after_catch
    def set_yards_after_catch(self, yards_after_catch):
        self.yards_after_catch = yards_after_catch
    def get_fumble(self):
        return self.fumble
    def set_fumble(self, fumble):
        self.fumble = fumble
    def get_dropped(self):
        return self.dropped
    def set_dropped(self, dropped):
        self.dropped = dropped
    def get_inside_20(self):
        return self.inside_20
    def set_inside_20(self, inside_20):
        self.inside_20 = inside_20
    def get_goaltogo(self):
        return self.goaltogo
    def set_goaltogo(self, goaltogo):
        self.goaltogo = goaltogo
    def has__content(self):
        if (
            super(receiveType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='receiveType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('receiveType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'receiveType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='receiveType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='receiveType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='receiveType'):
        super(receiveType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='receiveType')
        if self.firstdown is not None and 'firstdown' not in already_processed:
            already_processed.add('firstdown')
            outfile.write(' firstdown="%s"' % self.gds_format_integer(self.firstdown, input_name='firstdown'))
        if self.touchdown is not None and 'touchdown' not in already_processed:
            already_processed.add('touchdown')
            outfile.write(' touchdown="%s"' % self.gds_format_integer(self.touchdown, input_name='touchdown'))
        if self.safety is not None and 'safety' not in already_processed:
            already_processed.add('safety')
            outfile.write(' safety="%s"' % self.gds_format_integer(self.safety, input_name='safety'))
        if self.target is not None and 'target' not in already_processed:
            already_processed.add('target')
            outfile.write(' target="%s"' % self.gds_format_integer(self.target, input_name='target'))
        if self.reception is not None and 'reception' not in already_processed:
            already_processed.add('reception')
            outfile.write(' reception="%s"' % self.gds_format_integer(self.reception, input_name='reception'))
        if self.yards is not None and 'yards' not in already_processed:
            already_processed.add('yards')
            outfile.write(' yards="%s"' % self.gds_format_integer(self.yards, input_name='yards'))
        if self.yards_after_catch is not None and 'yards_after_catch' not in already_processed:
            already_processed.add('yards_after_catch')
            outfile.write(' yards_after_catch="%s"' % self.gds_format_integer(self.yards_after_catch, input_name='yards_after_catch'))
        if self.fumble is not None and 'fumble' not in already_processed:
            already_processed.add('fumble')
            outfile.write(' fumble="%s"' % self.gds_format_integer(self.fumble, input_name='fumble'))
        if self.dropped is not None and 'dropped' not in already_processed:
            already_processed.add('dropped')
            outfile.write(' dropped="%s"' % self.gds_format_integer(self.dropped, input_name='dropped'))
        if self.inside_20 is not None and 'inside_20' not in already_processed:
            already_processed.add('inside_20')
            outfile.write(' inside_20="%s"' % self.gds_format_integer(self.inside_20, input_name='inside_20'))
        if self.goaltogo is not None and 'goaltogo' not in already_processed:
            already_processed.add('goaltogo')
            outfile.write(' goaltogo="%s"' % self.gds_format_integer(self.goaltogo, input_name='goaltogo'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='receiveType', fromsubclass_=False, pretty_print=True):
        super(receiveType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('firstdown', node)
        if value is not None and 'firstdown' not in already_processed:
            already_processed.add('firstdown')
            self.firstdown = self.gds_parse_integer(value, node, 'firstdown')
        value = find_attr_value_('touchdown', node)
        if value is not None and 'touchdown' not in already_processed:
            already_processed.add('touchdown')
            self.touchdown = self.gds_parse_integer(value, node, 'touchdown')
        value = find_attr_value_('safety', node)
        if value is not None and 'safety' not in already_processed:
            already_processed.add('safety')
            self.safety = self.gds_parse_integer(value, node, 'safety')
        value = find_attr_value_('target', node)
        if value is not None and 'target' not in already_processed:
            already_processed.add('target')
            self.target = self.gds_parse_integer(value, node, 'target')
        value = find_attr_value_('reception', node)
        if value is not None and 'reception' not in already_processed:
            already_processed.add('reception')
            self.reception = self.gds_parse_integer(value, node, 'reception')
        value = find_attr_value_('yards', node)
        if value is not None and 'yards' not in already_processed:
            already_processed.add('yards')
            self.yards = self.gds_parse_integer(value, node, 'yards')
        value = find_attr_value_('yards_after_catch', node)
        if value is not None and 'yards_after_catch' not in already_processed:
            already_processed.add('yards_after_catch')
            self.yards_after_catch = self.gds_parse_integer(value, node, 'yards_after_catch')
        value = find_attr_value_('fumble', node)
        if value is not None and 'fumble' not in already_processed:
            already_processed.add('fumble')
            self.fumble = self.gds_parse_integer(value, node, 'fumble')
        value = find_attr_value_('dropped', node)
        if value is not None and 'dropped' not in already_processed:
            already_processed.add('dropped')
            self.dropped = self.gds_parse_integer(value, node, 'dropped')
        value = find_attr_value_('inside_20', node)
        if value is not None and 'inside_20' not in already_processed:
            already_processed.add('inside_20')
            self.inside_20 = self.gds_parse_integer(value, node, 'inside_20')
        value = find_attr_value_('goaltogo', node)
        if value is not None and 'goaltogo' not in already_processed:
            already_processed.add('goaltogo')
            self.goaltogo = self.gds_parse_integer(value, node, 'goaltogo')
        super(receiveType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(receiveType, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class receiveType


class rushType(basePlayStatisticType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = basePlayStatisticType
    def __init__(self, nullified=None, team=None, player=None, attempt=None, yards=None, touchdown=None, firstdown=None, safety=None, fumble=None, inside_20=None, goaltogo=None, lateral=None, tlost=None, tlost_yards=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("rushType"), self).__init__(nullified, team, player,  **kwargs_)
        self.attempt = _cast(int, attempt)
        self.attempt_nsprefix_ = None
        self.yards = _cast(int, yards)
        self.yards_nsprefix_ = None
        self.touchdown = _cast(int, touchdown)
        self.touchdown_nsprefix_ = None
        self.firstdown = _cast(int, firstdown)
        self.firstdown_nsprefix_ = None
        self.safety = _cast(int, safety)
        self.safety_nsprefix_ = None
        self.fumble = _cast(int, fumble)
        self.fumble_nsprefix_ = None
        self.inside_20 = _cast(int, inside_20)
        self.inside_20_nsprefix_ = None
        self.goaltogo = _cast(int, goaltogo)
        self.goaltogo_nsprefix_ = None
        self.lateral = _cast(int, lateral)
        self.lateral_nsprefix_ = None
        self.tlost = _cast(int, tlost)
        self.tlost_nsprefix_ = None
        self.tlost_yards = _cast(int, tlost_yards)
        self.tlost_yards_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, rushType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if rushType.subclass:
            return rushType.subclass(*args_, **kwargs_)
        else:
            return rushType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_attempt(self):
        return self.attempt
    def set_attempt(self, attempt):
        self.attempt = attempt
    def get_yards(self):
        return self.yards
    def set_yards(self, yards):
        self.yards = yards
    def get_touchdown(self):
        return self.touchdown
    def set_touchdown(self, touchdown):
        self.touchdown = touchdown
    def get_firstdown(self):
        return self.firstdown
    def set_firstdown(self, firstdown):
        self.firstdown = firstdown
    def get_safety(self):
        return self.safety
    def set_safety(self, safety):
        self.safety = safety
    def get_fumble(self):
        return self.fumble
    def set_fumble(self, fumble):
        self.fumble = fumble
    def get_inside_20(self):
        return self.inside_20
    def set_inside_20(self, inside_20):
        self.inside_20 = inside_20
    def get_goaltogo(self):
        return self.goaltogo
    def set_goaltogo(self, goaltogo):
        self.goaltogo = goaltogo
    def get_lateral(self):
        return self.lateral
    def set_lateral(self, lateral):
        self.lateral = lateral
    def get_tlost(self):
        return self.tlost
    def set_tlost(self, tlost):
        self.tlost = tlost
    def get_tlost_yards(self):
        return self.tlost_yards
    def set_tlost_yards(self, tlost_yards):
        self.tlost_yards = tlost_yards
    def has__content(self):
        if (
            super(rushType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='rushType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('rushType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'rushType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='rushType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='rushType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='rushType'):
        super(rushType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='rushType')
        if self.attempt is not None and 'attempt' not in already_processed:
            already_processed.add('attempt')
            outfile.write(' attempt="%s"' % self.gds_format_integer(self.attempt, input_name='attempt'))
        if self.yards is not None and 'yards' not in already_processed:
            already_processed.add('yards')
            outfile.write(' yards="%s"' % self.gds_format_integer(self.yards, input_name='yards'))
        if self.touchdown is not None and 'touchdown' not in already_processed:
            already_processed.add('touchdown')
            outfile.write(' touchdown="%s"' % self.gds_format_integer(self.touchdown, input_name='touchdown'))
        if self.firstdown is not None and 'firstdown' not in already_processed:
            already_processed.add('firstdown')
            outfile.write(' firstdown="%s"' % self.gds_format_integer(self.firstdown, input_name='firstdown'))
        if self.safety is not None and 'safety' not in already_processed:
            already_processed.add('safety')
            outfile.write(' safety="%s"' % self.gds_format_integer(self.safety, input_name='safety'))
        if self.fumble is not None and 'fumble' not in already_processed:
            already_processed.add('fumble')
            outfile.write(' fumble="%s"' % self.gds_format_integer(self.fumble, input_name='fumble'))
        if self.inside_20 is not None and 'inside_20' not in already_processed:
            already_processed.add('inside_20')
            outfile.write(' inside_20="%s"' % self.gds_format_integer(self.inside_20, input_name='inside_20'))
        if self.goaltogo is not None and 'goaltogo' not in already_processed:
            already_processed.add('goaltogo')
            outfile.write(' goaltogo="%s"' % self.gds_format_integer(self.goaltogo, input_name='goaltogo'))
        if self.lateral is not None and 'lateral' not in already_processed:
            already_processed.add('lateral')
            outfile.write(' lateral="%s"' % self.gds_format_integer(self.lateral, input_name='lateral'))
        if self.tlost is not None and 'tlost' not in already_processed:
            already_processed.add('tlost')
            outfile.write(' tlost="%s"' % self.gds_format_integer(self.tlost, input_name='tlost'))
        if self.tlost_yards is not None and 'tlost_yards' not in already_processed:
            already_processed.add('tlost_yards')
            outfile.write(' tlost_yards="%s"' % self.gds_format_integer(self.tlost_yards, input_name='tlost_yards'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='rushType', fromsubclass_=False, pretty_print=True):
        super(rushType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('attempt', node)
        if value is not None and 'attempt' not in already_processed:
            already_processed.add('attempt')
            self.attempt = self.gds_parse_integer(value, node, 'attempt')
        value = find_attr_value_('yards', node)
        if value is not None and 'yards' not in already_processed:
            already_processed.add('yards')
            self.yards = self.gds_parse_integer(value, node, 'yards')
        value = find_attr_value_('touchdown', node)
        if value is not None and 'touchdown' not in already_processed:
            already_processed.add('touchdown')
            self.touchdown = self.gds_parse_integer(value, node, 'touchdown')
        value = find_attr_value_('firstdown', node)
        if value is not None and 'firstdown' not in already_processed:
            already_processed.add('firstdown')
            self.firstdown = self.gds_parse_integer(value, node, 'firstdown')
        value = find_attr_value_('safety', node)
        if value is not None and 'safety' not in already_processed:
            already_processed.add('safety')
            self.safety = self.gds_parse_integer(value, node, 'safety')
        value = find_attr_value_('fumble', node)
        if value is not None and 'fumble' not in already_processed:
            already_processed.add('fumble')
            self.fumble = self.gds_parse_integer(value, node, 'fumble')
        value = find_attr_value_('inside_20', node)
        if value is not None and 'inside_20' not in already_processed:
            already_processed.add('inside_20')
            self.inside_20 = self.gds_parse_integer(value, node, 'inside_20')
        value = find_attr_value_('goaltogo', node)
        if value is not None and 'goaltogo' not in already_processed:
            already_processed.add('goaltogo')
            self.goaltogo = self.gds_parse_integer(value, node, 'goaltogo')
        value = find_attr_value_('lateral', node)
        if value is not None and 'lateral' not in already_processed:
            already_processed.add('lateral')
            self.lateral = self.gds_parse_integer(value, node, 'lateral')
        value = find_attr_value_('tlost', node)
        if value is not None and 'tlost' not in already_processed:
            already_processed.add('tlost')
            self.tlost = self.gds_parse_integer(value, node, 'tlost')
        value = find_attr_value_('tlost_yards', node)
        if value is not None and 'tlost_yards' not in already_processed:
            already_processed.add('tlost_yards')
            self.tlost_yards = self.gds_parse_integer(value, node, 'tlost_yards')
        super(rushType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(rushType, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class rushType


class kickType(basePlayStatisticType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = basePlayStatisticType
    def __init__(self, nullified=None, team=None, player=None, attempt=None, yards=None, net_yards=None, gross_yards=None, inside_20=None, endzone=None, touchback=None, own_rec=None, own_rec_td=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("kickType"), self).__init__(nullified, team, player,  **kwargs_)
        self.attempt = _cast(int, attempt)
        self.attempt_nsprefix_ = None
        self.yards = _cast(int, yards)
        self.yards_nsprefix_ = None
        self.net_yards = _cast(int, net_yards)
        self.net_yards_nsprefix_ = None
        self.gross_yards = _cast(int, gross_yards)
        self.gross_yards_nsprefix_ = None
        self.inside_20 = _cast(int, inside_20)
        self.inside_20_nsprefix_ = None
        self.endzone = _cast(int, endzone)
        self.endzone_nsprefix_ = None
        self.touchback = _cast(int, touchback)
        self.touchback_nsprefix_ = None
        self.own_rec = _cast(int, own_rec)
        self.own_rec_nsprefix_ = None
        self.own_rec_td = _cast(int, own_rec_td)
        self.own_rec_td_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, kickType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if kickType.subclass:
            return kickType.subclass(*args_, **kwargs_)
        else:
            return kickType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_attempt(self):
        return self.attempt
    def set_attempt(self, attempt):
        self.attempt = attempt
    def get_yards(self):
        return self.yards
    def set_yards(self, yards):
        self.yards = yards
    def get_net_yards(self):
        return self.net_yards
    def set_net_yards(self, net_yards):
        self.net_yards = net_yards
    def get_gross_yards(self):
        return self.gross_yards
    def set_gross_yards(self, gross_yards):
        self.gross_yards = gross_yards
    def get_inside_20(self):
        return self.inside_20
    def set_inside_20(self, inside_20):
        self.inside_20 = inside_20
    def get_endzone(self):
        return self.endzone
    def set_endzone(self, endzone):
        self.endzone = endzone
    def get_touchback(self):
        return self.touchback
    def set_touchback(self, touchback):
        self.touchback = touchback
    def get_own_rec(self):
        return self.own_rec
    def set_own_rec(self, own_rec):
        self.own_rec = own_rec
    def get_own_rec_td(self):
        return self.own_rec_td
    def set_own_rec_td(self, own_rec_td):
        self.own_rec_td = own_rec_td
    def has__content(self):
        if (
            super(kickType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='kickType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('kickType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'kickType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='kickType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='kickType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='kickType'):
        super(kickType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='kickType')
        if self.attempt is not None and 'attempt' not in already_processed:
            already_processed.add('attempt')
            outfile.write(' attempt="%s"' % self.gds_format_integer(self.attempt, input_name='attempt'))
        if self.yards is not None and 'yards' not in already_processed:
            already_processed.add('yards')
            outfile.write(' yards="%s"' % self.gds_format_integer(self.yards, input_name='yards'))
        if self.net_yards is not None and 'net_yards' not in already_processed:
            already_processed.add('net_yards')
            outfile.write(' net_yards="%s"' % self.gds_format_integer(self.net_yards, input_name='net_yards'))
        if self.gross_yards is not None and 'gross_yards' not in already_processed:
            already_processed.add('gross_yards')
            outfile.write(' gross_yards="%s"' % self.gds_format_integer(self.gross_yards, input_name='gross_yards'))
        if self.inside_20 is not None and 'inside_20' not in already_processed:
            already_processed.add('inside_20')
            outfile.write(' inside_20="%s"' % self.gds_format_integer(self.inside_20, input_name='inside_20'))
        if self.endzone is not None and 'endzone' not in already_processed:
            already_processed.add('endzone')
            outfile.write(' endzone="%s"' % self.gds_format_integer(self.endzone, input_name='endzone'))
        if self.touchback is not None and 'touchback' not in already_processed:
            already_processed.add('touchback')
            outfile.write(' touchback="%s"' % self.gds_format_integer(self.touchback, input_name='touchback'))
        if self.own_rec is not None and 'own_rec' not in already_processed:
            already_processed.add('own_rec')
            outfile.write(' own_rec="%s"' % self.gds_format_integer(self.own_rec, input_name='own_rec'))
        if self.own_rec_td is not None and 'own_rec_td' not in already_processed:
            already_processed.add('own_rec_td')
            outfile.write(' own_rec_td="%s"' % self.gds_format_integer(self.own_rec_td, input_name='own_rec_td'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='kickType', fromsubclass_=False, pretty_print=True):
        super(kickType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('attempt', node)
        if value is not None and 'attempt' not in already_processed:
            already_processed.add('attempt')
            self.attempt = self.gds_parse_integer(value, node, 'attempt')
        value = find_attr_value_('yards', node)
        if value is not None and 'yards' not in already_processed:
            already_processed.add('yards')
            self.yards = self.gds_parse_integer(value, node, 'yards')
        value = find_attr_value_('net_yards', node)
        if value is not None and 'net_yards' not in already_processed:
            already_processed.add('net_yards')
            self.net_yards = self.gds_parse_integer(value, node, 'net_yards')
        value = find_attr_value_('gross_yards', node)
        if value is not None and 'gross_yards' not in already_processed:
            already_processed.add('gross_yards')
            self.gross_yards = self.gds_parse_integer(value, node, 'gross_yards')
        value = find_attr_value_('inside_20', node)
        if value is not None and 'inside_20' not in already_processed:
            already_processed.add('inside_20')
            self.inside_20 = self.gds_parse_integer(value, node, 'inside_20')
        value = find_attr_value_('endzone', node)
        if value is not None and 'endzone' not in already_processed:
            already_processed.add('endzone')
            self.endzone = self.gds_parse_integer(value, node, 'endzone')
        value = find_attr_value_('touchback', node)
        if value is not None and 'touchback' not in already_processed:
            already_processed.add('touchback')
            self.touchback = self.gds_parse_integer(value, node, 'touchback')
        value = find_attr_value_('own_rec', node)
        if value is not None and 'own_rec' not in already_processed:
            already_processed.add('own_rec')
            self.own_rec = self.gds_parse_integer(value, node, 'own_rec')
        value = find_attr_value_('own_rec_td', node)
        if value is not None and 'own_rec_td' not in already_processed:
            already_processed.add('own_rec_td')
            self.own_rec_td = self.gds_parse_integer(value, node, 'own_rec_td')
        super(kickType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(kickType, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class kickType


class puntType(basePlayStatisticType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = basePlayStatisticType
    def __init__(self, nullified=None, team=None, player=None, attempt=None, yards=None, net_yards=None, inside_20=None, endzone=None, touchback=None, blocked=None, safety=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("puntType"), self).__init__(nullified, team, player,  **kwargs_)
        self.attempt = _cast(int, attempt)
        self.attempt_nsprefix_ = None
        self.yards = _cast(int, yards)
        self.yards_nsprefix_ = None
        self.net_yards = _cast(int, net_yards)
        self.net_yards_nsprefix_ = None
        self.inside_20 = _cast(int, inside_20)
        self.inside_20_nsprefix_ = None
        self.endzone = _cast(int, endzone)
        self.endzone_nsprefix_ = None
        self.touchback = _cast(int, touchback)
        self.touchback_nsprefix_ = None
        self.blocked = _cast(int, blocked)
        self.blocked_nsprefix_ = None
        self.safety = _cast(int, safety)
        self.safety_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, puntType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if puntType.subclass:
            return puntType.subclass(*args_, **kwargs_)
        else:
            return puntType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_attempt(self):
        return self.attempt
    def set_attempt(self, attempt):
        self.attempt = attempt
    def get_yards(self):
        return self.yards
    def set_yards(self, yards):
        self.yards = yards
    def get_net_yards(self):
        return self.net_yards
    def set_net_yards(self, net_yards):
        self.net_yards = net_yards
    def get_inside_20(self):
        return self.inside_20
    def set_inside_20(self, inside_20):
        self.inside_20 = inside_20
    def get_endzone(self):
        return self.endzone
    def set_endzone(self, endzone):
        self.endzone = endzone
    def get_touchback(self):
        return self.touchback
    def set_touchback(self, touchback):
        self.touchback = touchback
    def get_blocked(self):
        return self.blocked
    def set_blocked(self, blocked):
        self.blocked = blocked
    def get_safety(self):
        return self.safety
    def set_safety(self, safety):
        self.safety = safety
    def has__content(self):
        if (
            super(puntType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='puntType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('puntType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'puntType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='puntType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='puntType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='puntType'):
        super(puntType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='puntType')
        if self.attempt is not None and 'attempt' not in already_processed:
            already_processed.add('attempt')
            outfile.write(' attempt="%s"' % self.gds_format_integer(self.attempt, input_name='attempt'))
        if self.yards is not None and 'yards' not in already_processed:
            already_processed.add('yards')
            outfile.write(' yards="%s"' % self.gds_format_integer(self.yards, input_name='yards'))
        if self.net_yards is not None and 'net_yards' not in already_processed:
            already_processed.add('net_yards')
            outfile.write(' net_yards="%s"' % self.gds_format_integer(self.net_yards, input_name='net_yards'))
        if self.inside_20 is not None and 'inside_20' not in already_processed:
            already_processed.add('inside_20')
            outfile.write(' inside_20="%s"' % self.gds_format_integer(self.inside_20, input_name='inside_20'))
        if self.endzone is not None and 'endzone' not in already_processed:
            already_processed.add('endzone')
            outfile.write(' endzone="%s"' % self.gds_format_integer(self.endzone, input_name='endzone'))
        if self.touchback is not None and 'touchback' not in already_processed:
            already_processed.add('touchback')
            outfile.write(' touchback="%s"' % self.gds_format_integer(self.touchback, input_name='touchback'))
        if self.blocked is not None and 'blocked' not in already_processed:
            already_processed.add('blocked')
            outfile.write(' blocked="%s"' % self.gds_format_integer(self.blocked, input_name='blocked'))
        if self.safety is not None and 'safety' not in already_processed:
            already_processed.add('safety')
            outfile.write(' safety="%s"' % self.gds_format_integer(self.safety, input_name='safety'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='puntType', fromsubclass_=False, pretty_print=True):
        super(puntType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('attempt', node)
        if value is not None and 'attempt' not in already_processed:
            already_processed.add('attempt')
            self.attempt = self.gds_parse_integer(value, node, 'attempt')
        value = find_attr_value_('yards', node)
        if value is not None and 'yards' not in already_processed:
            already_processed.add('yards')
            self.yards = self.gds_parse_integer(value, node, 'yards')
        value = find_attr_value_('net_yards', node)
        if value is not None and 'net_yards' not in already_processed:
            already_processed.add('net_yards')
            self.net_yards = self.gds_parse_integer(value, node, 'net_yards')
        value = find_attr_value_('inside_20', node)
        if value is not None and 'inside_20' not in already_processed:
            already_processed.add('inside_20')
            self.inside_20 = self.gds_parse_integer(value, node, 'inside_20')
        value = find_attr_value_('endzone', node)
        if value is not None and 'endzone' not in already_processed:
            already_processed.add('endzone')
            self.endzone = self.gds_parse_integer(value, node, 'endzone')
        value = find_attr_value_('touchback', node)
        if value is not None and 'touchback' not in already_processed:
            already_processed.add('touchback')
            self.touchback = self.gds_parse_integer(value, node, 'touchback')
        value = find_attr_value_('blocked', node)
        if value is not None and 'blocked' not in already_processed:
            already_processed.add('blocked')
            self.blocked = self.gds_parse_integer(value, node, 'blocked')
        value = find_attr_value_('safety', node)
        if value is not None and 'safety' not in already_processed:
            already_processed.add('safety')
            self.safety = self.gds_parse_integer(value, node, 'safety')
        super(puntType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(puntType, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class puntType


class field_goalType(basePlayStatisticType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = basePlayStatisticType
    def __init__(self, nullified=None, team=None, player=None, attempt=None, att_yards=None, yards=None, missed=None, blocked=None, returned=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("field_goalType"), self).__init__(nullified, team, player,  **kwargs_)
        self.attempt = _cast(int, attempt)
        self.attempt_nsprefix_ = None
        self.att_yards = _cast(int, att_yards)
        self.att_yards_nsprefix_ = None
        self.yards = _cast(int, yards)
        self.yards_nsprefix_ = None
        self.missed = _cast(int, missed)
        self.missed_nsprefix_ = None
        self.blocked = _cast(int, blocked)
        self.blocked_nsprefix_ = None
        self.returned = _cast(int, returned)
        self.returned_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, field_goalType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if field_goalType.subclass:
            return field_goalType.subclass(*args_, **kwargs_)
        else:
            return field_goalType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_attempt(self):
        return self.attempt
    def set_attempt(self, attempt):
        self.attempt = attempt
    def get_att_yards(self):
        return self.att_yards
    def set_att_yards(self, att_yards):
        self.att_yards = att_yards
    def get_yards(self):
        return self.yards
    def set_yards(self, yards):
        self.yards = yards
    def get_missed(self):
        return self.missed
    def set_missed(self, missed):
        self.missed = missed
    def get_blocked(self):
        return self.blocked
    def set_blocked(self, blocked):
        self.blocked = blocked
    def get_returned(self):
        return self.returned
    def set_returned(self, returned):
        self.returned = returned
    def has__content(self):
        if (
            super(field_goalType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='field_goalType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('field_goalType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'field_goalType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='field_goalType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='field_goalType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='field_goalType'):
        super(field_goalType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='field_goalType')
        if self.attempt is not None and 'attempt' not in already_processed:
            already_processed.add('attempt')
            outfile.write(' attempt="%s"' % self.gds_format_integer(self.attempt, input_name='attempt'))
        if self.att_yards is not None and 'att_yards' not in already_processed:
            already_processed.add('att_yards')
            outfile.write(' att_yards="%s"' % self.gds_format_integer(self.att_yards, input_name='att_yards'))
        if self.yards is not None and 'yards' not in already_processed:
            already_processed.add('yards')
            outfile.write(' yards="%s"' % self.gds_format_integer(self.yards, input_name='yards'))
        if self.missed is not None and 'missed' not in already_processed:
            already_processed.add('missed')
            outfile.write(' missed="%s"' % self.gds_format_integer(self.missed, input_name='missed'))
        if self.blocked is not None and 'blocked' not in already_processed:
            already_processed.add('blocked')
            outfile.write(' blocked="%s"' % self.gds_format_integer(self.blocked, input_name='blocked'))
        if self.returned is not None and 'returned' not in already_processed:
            already_processed.add('returned')
            outfile.write(' returned="%s"' % self.gds_format_integer(self.returned, input_name='returned'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='field_goalType', fromsubclass_=False, pretty_print=True):
        super(field_goalType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('attempt', node)
        if value is not None and 'attempt' not in already_processed:
            already_processed.add('attempt')
            self.attempt = self.gds_parse_integer(value, node, 'attempt')
        value = find_attr_value_('att_yards', node)
        if value is not None and 'att_yards' not in already_processed:
            already_processed.add('att_yards')
            self.att_yards = self.gds_parse_integer(value, node, 'att_yards')
        value = find_attr_value_('yards', node)
        if value is not None and 'yards' not in already_processed:
            already_processed.add('yards')
            self.yards = self.gds_parse_integer(value, node, 'yards')
        value = find_attr_value_('missed', node)
        if value is not None and 'missed' not in already_processed:
            already_processed.add('missed')
            self.missed = self.gds_parse_integer(value, node, 'missed')
        value = find_attr_value_('blocked', node)
        if value is not None and 'blocked' not in already_processed:
            already_processed.add('blocked')
            self.blocked = self.gds_parse_integer(value, node, 'blocked')
        value = find_attr_value_('returned', node)
        if value is not None and 'returned' not in already_processed:
            already_processed.add('returned')
            self.returned = self.gds_parse_integer(value, node, 'returned')
        super(field_goalType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(field_goalType, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class field_goalType


class extra_pointType(basePlayStatisticType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = basePlayStatisticType
    def __init__(self, nullified=None, team=None, player=None, attempt=None, missed=None, blocked=None, returned=None, safety=None, aborted=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("extra_pointType"), self).__init__(nullified, team, player,  **kwargs_)
        self.attempt = _cast(int, attempt)
        self.attempt_nsprefix_ = None
        self.missed = _cast(int, missed)
        self.missed_nsprefix_ = None
        self.blocked = _cast(int, blocked)
        self.blocked_nsprefix_ = None
        self.returned = _cast(int, returned)
        self.returned_nsprefix_ = None
        self.safety = _cast(int, safety)
        self.safety_nsprefix_ = None
        self.aborted = _cast(int, aborted)
        self.aborted_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, extra_pointType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if extra_pointType.subclass:
            return extra_pointType.subclass(*args_, **kwargs_)
        else:
            return extra_pointType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_attempt(self):
        return self.attempt
    def set_attempt(self, attempt):
        self.attempt = attempt
    def get_missed(self):
        return self.missed
    def set_missed(self, missed):
        self.missed = missed
    def get_blocked(self):
        return self.blocked
    def set_blocked(self, blocked):
        self.blocked = blocked
    def get_returned(self):
        return self.returned
    def set_returned(self, returned):
        self.returned = returned
    def get_safety(self):
        return self.safety
    def set_safety(self, safety):
        self.safety = safety
    def get_aborted(self):
        return self.aborted
    def set_aborted(self, aborted):
        self.aborted = aborted
    def has__content(self):
        if (
            super(extra_pointType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='extra_pointType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('extra_pointType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'extra_pointType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='extra_pointType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='extra_pointType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='extra_pointType'):
        super(extra_pointType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='extra_pointType')
        if self.attempt is not None and 'attempt' not in already_processed:
            already_processed.add('attempt')
            outfile.write(' attempt="%s"' % self.gds_format_integer(self.attempt, input_name='attempt'))
        if self.missed is not None and 'missed' not in already_processed:
            already_processed.add('missed')
            outfile.write(' missed="%s"' % self.gds_format_integer(self.missed, input_name='missed'))
        if self.blocked is not None and 'blocked' not in already_processed:
            already_processed.add('blocked')
            outfile.write(' blocked="%s"' % self.gds_format_integer(self.blocked, input_name='blocked'))
        if self.returned is not None and 'returned' not in already_processed:
            already_processed.add('returned')
            outfile.write(' returned="%s"' % self.gds_format_integer(self.returned, input_name='returned'))
        if self.safety is not None and 'safety' not in already_processed:
            already_processed.add('safety')
            outfile.write(' safety="%s"' % self.gds_format_integer(self.safety, input_name='safety'))
        if self.aborted is not None and 'aborted' not in already_processed:
            already_processed.add('aborted')
            outfile.write(' aborted="%s"' % self.gds_format_integer(self.aborted, input_name='aborted'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='extra_pointType', fromsubclass_=False, pretty_print=True):
        super(extra_pointType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('attempt', node)
        if value is not None and 'attempt' not in already_processed:
            already_processed.add('attempt')
            self.attempt = self.gds_parse_integer(value, node, 'attempt')
        value = find_attr_value_('missed', node)
        if value is not None and 'missed' not in already_processed:
            already_processed.add('missed')
            self.missed = self.gds_parse_integer(value, node, 'missed')
        value = find_attr_value_('blocked', node)
        if value is not None and 'blocked' not in already_processed:
            already_processed.add('blocked')
            self.blocked = self.gds_parse_integer(value, node, 'blocked')
        value = find_attr_value_('returned', node)
        if value is not None and 'returned' not in already_processed:
            already_processed.add('returned')
            self.returned = self.gds_parse_integer(value, node, 'returned')
        value = find_attr_value_('safety', node)
        if value is not None and 'safety' not in already_processed:
            already_processed.add('safety')
            self.safety = self.gds_parse_integer(value, node, 'safety')
        value = find_attr_value_('aborted', node)
        if value is not None and 'aborted' not in already_processed:
            already_processed.add('aborted')
            self.aborted = self.gds_parse_integer(value, node, 'aborted')
        super(extra_pointType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(extra_pointType, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class extra_pointType


class penaltyType(basePlayStatisticType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = basePlayStatisticType
    def __init__(self, nullified=None, team=None, player=None, penalty=None, yards=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("penaltyType"), self).__init__(nullified, team, player,  **kwargs_)
        self.penalty = _cast(int, penalty)
        self.penalty_nsprefix_ = None
        self.yards = _cast(int, yards)
        self.yards_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, penaltyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if penaltyType.subclass:
            return penaltyType.subclass(*args_, **kwargs_)
        else:
            return penaltyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_penalty(self):
        return self.penalty
    def set_penalty(self, penalty):
        self.penalty = penalty
    def get_yards(self):
        return self.yards
    def set_yards(self, yards):
        self.yards = yards
    def has__content(self):
        if (
            super(penaltyType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='penaltyType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('penaltyType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'penaltyType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='penaltyType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='penaltyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='penaltyType'):
        super(penaltyType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='penaltyType')
        if self.penalty is not None and 'penalty' not in already_processed:
            already_processed.add('penalty')
            outfile.write(' penalty="%s"' % self.gds_format_integer(self.penalty, input_name='penalty'))
        if self.yards is not None and 'yards' not in already_processed:
            already_processed.add('yards')
            outfile.write(' yards="%s"' % self.gds_format_integer(self.yards, input_name='yards'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='penaltyType', fromsubclass_=False, pretty_print=True):
        super(penaltyType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('penalty', node)
        if value is not None and 'penalty' not in already_processed:
            already_processed.add('penalty')
            self.penalty = self.gds_parse_integer(value, node, 'penalty')
        value = find_attr_value_('yards', node)
        if value is not None and 'yards' not in already_processed:
            already_processed.add('yards')
            self.yards = self.gds_parse_integer(value, node, 'yards')
        super(penaltyType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(penaltyType, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class penaltyType


class fumbleType(basePlayStatisticType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = basePlayStatisticType
    def __init__(self, nullified=None, team=None, player=None, fumble=None, forced=None, out_of_bounds=None, own_rec=None, opp_rec=None, own_rec_yards=None, opp_rec_yards=None, own_rec_td=None, opp_rec_td=None, lost=None, play_category=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("fumbleType"), self).__init__(nullified, team, player,  **kwargs_)
        self.fumble = _cast(int, fumble)
        self.fumble_nsprefix_ = None
        self.forced = _cast(int, forced)
        self.forced_nsprefix_ = None
        self.out_of_bounds = _cast(int, out_of_bounds)
        self.out_of_bounds_nsprefix_ = None
        self.own_rec = _cast(int, own_rec)
        self.own_rec_nsprefix_ = None
        self.opp_rec = _cast(int, opp_rec)
        self.opp_rec_nsprefix_ = None
        self.own_rec_yards = _cast(int, own_rec_yards)
        self.own_rec_yards_nsprefix_ = None
        self.opp_rec_yards = _cast(int, opp_rec_yards)
        self.opp_rec_yards_nsprefix_ = None
        self.own_rec_td = _cast(int, own_rec_td)
        self.own_rec_td_nsprefix_ = None
        self.opp_rec_td = _cast(int, opp_rec_td)
        self.opp_rec_td_nsprefix_ = None
        self.lost = _cast(int, lost)
        self.lost_nsprefix_ = None
        self.play_category = _cast(None, play_category)
        self.play_category_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fumbleType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fumbleType.subclass:
            return fumbleType.subclass(*args_, **kwargs_)
        else:
            return fumbleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_fumble(self):
        return self.fumble
    def set_fumble(self, fumble):
        self.fumble = fumble
    def get_forced(self):
        return self.forced
    def set_forced(self, forced):
        self.forced = forced
    def get_out_of_bounds(self):
        return self.out_of_bounds
    def set_out_of_bounds(self, out_of_bounds):
        self.out_of_bounds = out_of_bounds
    def get_own_rec(self):
        return self.own_rec
    def set_own_rec(self, own_rec):
        self.own_rec = own_rec
    def get_opp_rec(self):
        return self.opp_rec
    def set_opp_rec(self, opp_rec):
        self.opp_rec = opp_rec
    def get_own_rec_yards(self):
        return self.own_rec_yards
    def set_own_rec_yards(self, own_rec_yards):
        self.own_rec_yards = own_rec_yards
    def get_opp_rec_yards(self):
        return self.opp_rec_yards
    def set_opp_rec_yards(self, opp_rec_yards):
        self.opp_rec_yards = opp_rec_yards
    def get_own_rec_td(self):
        return self.own_rec_td
    def set_own_rec_td(self, own_rec_td):
        self.own_rec_td = own_rec_td
    def get_opp_rec_td(self):
        return self.opp_rec_td
    def set_opp_rec_td(self, opp_rec_td):
        self.opp_rec_td = opp_rec_td
    def get_lost(self):
        return self.lost
    def set_lost(self, lost):
        self.lost = lost
    def get_play_category(self):
        return self.play_category
    def set_play_category(self, play_category):
        self.play_category = play_category
    def has__content(self):
        if (
            super(fumbleType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='fumbleType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fumbleType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'fumbleType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='fumbleType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='fumbleType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='fumbleType'):
        super(fumbleType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='fumbleType')
        if self.fumble is not None and 'fumble' not in already_processed:
            already_processed.add('fumble')
            outfile.write(' fumble="%s"' % self.gds_format_integer(self.fumble, input_name='fumble'))
        if self.forced is not None and 'forced' not in already_processed:
            already_processed.add('forced')
            outfile.write(' forced="%s"' % self.gds_format_integer(self.forced, input_name='forced'))
        if self.out_of_bounds is not None and 'out_of_bounds' not in already_processed:
            already_processed.add('out_of_bounds')
            outfile.write(' out_of_bounds="%s"' % self.gds_format_integer(self.out_of_bounds, input_name='out_of_bounds'))
        if self.own_rec is not None and 'own_rec' not in already_processed:
            already_processed.add('own_rec')
            outfile.write(' own_rec="%s"' % self.gds_format_integer(self.own_rec, input_name='own_rec'))
        if self.opp_rec is not None and 'opp_rec' not in already_processed:
            already_processed.add('opp_rec')
            outfile.write(' opp_rec="%s"' % self.gds_format_integer(self.opp_rec, input_name='opp_rec'))
        if self.own_rec_yards is not None and 'own_rec_yards' not in already_processed:
            already_processed.add('own_rec_yards')
            outfile.write(' own_rec_yards="%s"' % self.gds_format_integer(self.own_rec_yards, input_name='own_rec_yards'))
        if self.opp_rec_yards is not None and 'opp_rec_yards' not in already_processed:
            already_processed.add('opp_rec_yards')
            outfile.write(' opp_rec_yards="%s"' % self.gds_format_integer(self.opp_rec_yards, input_name='opp_rec_yards'))
        if self.own_rec_td is not None and 'own_rec_td' not in already_processed:
            already_processed.add('own_rec_td')
            outfile.write(' own_rec_td="%s"' % self.gds_format_integer(self.own_rec_td, input_name='own_rec_td'))
        if self.opp_rec_td is not None and 'opp_rec_td' not in already_processed:
            already_processed.add('opp_rec_td')
            outfile.write(' opp_rec_td="%s"' % self.gds_format_integer(self.opp_rec_td, input_name='opp_rec_td'))
        if self.lost is not None and 'lost' not in already_processed:
            already_processed.add('lost')
            outfile.write(' lost="%s"' % self.gds_format_integer(self.lost, input_name='lost'))
        if self.play_category is not None and 'play_category' not in already_processed:
            already_processed.add('play_category')
            outfile.write(' play_category=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.play_category), input_name='play_category')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='fumbleType', fromsubclass_=False, pretty_print=True):
        super(fumbleType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('fumble', node)
        if value is not None and 'fumble' not in already_processed:
            already_processed.add('fumble')
            self.fumble = self.gds_parse_integer(value, node, 'fumble')
        value = find_attr_value_('forced', node)
        if value is not None and 'forced' not in already_processed:
            already_processed.add('forced')
            self.forced = self.gds_parse_integer(value, node, 'forced')
        value = find_attr_value_('out_of_bounds', node)
        if value is not None and 'out_of_bounds' not in already_processed:
            already_processed.add('out_of_bounds')
            self.out_of_bounds = self.gds_parse_integer(value, node, 'out_of_bounds')
        value = find_attr_value_('own_rec', node)
        if value is not None and 'own_rec' not in already_processed:
            already_processed.add('own_rec')
            self.own_rec = self.gds_parse_integer(value, node, 'own_rec')
        value = find_attr_value_('opp_rec', node)
        if value is not None and 'opp_rec' not in already_processed:
            already_processed.add('opp_rec')
            self.opp_rec = self.gds_parse_integer(value, node, 'opp_rec')
        value = find_attr_value_('own_rec_yards', node)
        if value is not None and 'own_rec_yards' not in already_processed:
            already_processed.add('own_rec_yards')
            self.own_rec_yards = self.gds_parse_integer(value, node, 'own_rec_yards')
        value = find_attr_value_('opp_rec_yards', node)
        if value is not None and 'opp_rec_yards' not in already_processed:
            already_processed.add('opp_rec_yards')
            self.opp_rec_yards = self.gds_parse_integer(value, node, 'opp_rec_yards')
        value = find_attr_value_('own_rec_td', node)
        if value is not None and 'own_rec_td' not in already_processed:
            already_processed.add('own_rec_td')
            self.own_rec_td = self.gds_parse_integer(value, node, 'own_rec_td')
        value = find_attr_value_('opp_rec_td', node)
        if value is not None and 'opp_rec_td' not in already_processed:
            already_processed.add('opp_rec_td')
            self.opp_rec_td = self.gds_parse_integer(value, node, 'opp_rec_td')
        value = find_attr_value_('lost', node)
        if value is not None and 'lost' not in already_processed:
            already_processed.add('lost')
            self.lost = self.gds_parse_integer(value, node, 'lost')
        value = find_attr_value_('play_category', node)
        if value is not None and 'play_category' not in already_processed:
            already_processed.add('play_category')
            self.play_category = value
        super(fumbleType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(fumbleType, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class fumbleType


class returnType(basePlayStatisticType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = basePlayStatisticType
    def __init__(self, nullified=None, team=None, player=None, return_=None, yards=None, touchdown=None, firstdown=None, faircatch=None, out_of_bounds=None, downed=None, touchback=None, lateral=None, category=None, play_category=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("returnType"), self).__init__(nullified, team, player,  **kwargs_)
        self.return_ = _cast(int, return_)
        self.return__nsprefix_ = None
        self.yards = _cast(int, yards)
        self.yards_nsprefix_ = None
        self.touchdown = _cast(int, touchdown)
        self.touchdown_nsprefix_ = None
        self.firstdown = _cast(int, firstdown)
        self.firstdown_nsprefix_ = None
        self.faircatch = _cast(int, faircatch)
        self.faircatch_nsprefix_ = None
        self.out_of_bounds = _cast(int, out_of_bounds)
        self.out_of_bounds_nsprefix_ = None
        self.downed = _cast(int, downed)
        self.downed_nsprefix_ = None
        self.touchback = _cast(int, touchback)
        self.touchback_nsprefix_ = None
        self.lateral = _cast(int, lateral)
        self.lateral_nsprefix_ = None
        self.category = _cast(None, category)
        self.category_nsprefix_ = None
        self.play_category = _cast(None, play_category)
        self.play_category_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, returnType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if returnType.subclass:
            return returnType.subclass(*args_, **kwargs_)
        else:
            return returnType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_return(self):
        return self.return_
    def set_return(self, return_):
        self.return_ = return_
    def get_yards(self):
        return self.yards
    def set_yards(self, yards):
        self.yards = yards
    def get_touchdown(self):
        return self.touchdown
    def set_touchdown(self, touchdown):
        self.touchdown = touchdown
    def get_firstdown(self):
        return self.firstdown
    def set_firstdown(self, firstdown):
        self.firstdown = firstdown
    def get_faircatch(self):
        return self.faircatch
    def set_faircatch(self, faircatch):
        self.faircatch = faircatch
    def get_out_of_bounds(self):
        return self.out_of_bounds
    def set_out_of_bounds(self, out_of_bounds):
        self.out_of_bounds = out_of_bounds
    def get_downed(self):
        return self.downed
    def set_downed(self, downed):
        self.downed = downed
    def get_touchback(self):
        return self.touchback
    def set_touchback(self, touchback):
        self.touchback = touchback
    def get_lateral(self):
        return self.lateral
    def set_lateral(self, lateral):
        self.lateral = lateral
    def get_category(self):
        return self.category
    def set_category(self, category):
        self.category = category
    def get_play_category(self):
        return self.play_category
    def set_play_category(self, play_category):
        self.play_category = play_category
    def validate_categoryType(self, value):
        # Validate type categoryType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['punt_return', 'kick_return']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on categoryType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            super(returnType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='returnType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('returnType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'returnType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='returnType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='returnType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='returnType'):
        super(returnType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='returnType')
        if self.return_ is not None and 'return_' not in already_processed:
            already_processed.add('return_')
            outfile.write(' return="%s"' % self.gds_format_integer(self.return_, input_name='return'))
        if self.yards is not None and 'yards' not in already_processed:
            already_processed.add('yards')
            outfile.write(' yards="%s"' % self.gds_format_integer(self.yards, input_name='yards'))
        if self.touchdown is not None and 'touchdown' not in already_processed:
            already_processed.add('touchdown')
            outfile.write(' touchdown="%s"' % self.gds_format_integer(self.touchdown, input_name='touchdown'))
        if self.firstdown is not None and 'firstdown' not in already_processed:
            already_processed.add('firstdown')
            outfile.write(' firstdown="%s"' % self.gds_format_integer(self.firstdown, input_name='firstdown'))
        if self.faircatch is not None and 'faircatch' not in already_processed:
            already_processed.add('faircatch')
            outfile.write(' faircatch="%s"' % self.gds_format_integer(self.faircatch, input_name='faircatch'))
        if self.out_of_bounds is not None and 'out_of_bounds' not in already_processed:
            already_processed.add('out_of_bounds')
            outfile.write(' out_of_bounds="%s"' % self.gds_format_integer(self.out_of_bounds, input_name='out_of_bounds'))
        if self.downed is not None and 'downed' not in already_processed:
            already_processed.add('downed')
            outfile.write(' downed="%s"' % self.gds_format_integer(self.downed, input_name='downed'))
        if self.touchback is not None and 'touchback' not in already_processed:
            already_processed.add('touchback')
            outfile.write(' touchback="%s"' % self.gds_format_integer(self.touchback, input_name='touchback'))
        if self.lateral is not None and 'lateral' not in already_processed:
            already_processed.add('lateral')
            outfile.write(' lateral="%s"' % self.gds_format_integer(self.lateral, input_name='lateral'))
        if self.category is not None and 'category' not in already_processed:
            already_processed.add('category')
            outfile.write(' category=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.category), input_name='category')), ))
        if self.play_category is not None and 'play_category' not in already_processed:
            already_processed.add('play_category')
            outfile.write(' play_category=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.play_category), input_name='play_category')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='returnType', fromsubclass_=False, pretty_print=True):
        super(returnType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('return', node)
        if value is not None and 'return' not in already_processed:
            already_processed.add('return')
            self.return_ = self.gds_parse_integer(value, node, 'return')
        value = find_attr_value_('yards', node)
        if value is not None and 'yards' not in already_processed:
            already_processed.add('yards')
            self.yards = self.gds_parse_integer(value, node, 'yards')
        value = find_attr_value_('touchdown', node)
        if value is not None and 'touchdown' not in already_processed:
            already_processed.add('touchdown')
            self.touchdown = self.gds_parse_integer(value, node, 'touchdown')
        value = find_attr_value_('firstdown', node)
        if value is not None and 'firstdown' not in already_processed:
            already_processed.add('firstdown')
            self.firstdown = self.gds_parse_integer(value, node, 'firstdown')
        value = find_attr_value_('faircatch', node)
        if value is not None and 'faircatch' not in already_processed:
            already_processed.add('faircatch')
            self.faircatch = self.gds_parse_integer(value, node, 'faircatch')
        value = find_attr_value_('out_of_bounds', node)
        if value is not None and 'out_of_bounds' not in already_processed:
            already_processed.add('out_of_bounds')
            self.out_of_bounds = self.gds_parse_integer(value, node, 'out_of_bounds')
        value = find_attr_value_('downed', node)
        if value is not None and 'downed' not in already_processed:
            already_processed.add('downed')
            self.downed = self.gds_parse_integer(value, node, 'downed')
        value = find_attr_value_('touchback', node)
        if value is not None and 'touchback' not in already_processed:
            already_processed.add('touchback')
            self.touchback = self.gds_parse_integer(value, node, 'touchback')
        value = find_attr_value_('lateral', node)
        if value is not None and 'lateral' not in already_processed:
            already_processed.add('lateral')
            self.lateral = self.gds_parse_integer(value, node, 'lateral')
        value = find_attr_value_('category', node)
        if value is not None and 'category' not in already_processed:
            already_processed.add('category')
            self.category = value
            self.validate_categoryType(self.category)    # validate type categoryType
        value = find_attr_value_('play_category', node)
        if value is not None and 'play_category' not in already_processed:
            already_processed.add('play_category')
            self.play_category = value
        super(returnType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(returnType, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class returnType


class blockType(basePlayStatisticType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = basePlayStatisticType
    def __init__(self, nullified=None, team=None, player=None, block=None, category=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("blockType"), self).__init__(nullified, team, player,  **kwargs_)
        self.block = _cast(int, block)
        self.block_nsprefix_ = None
        self.category = _cast(None, category)
        self.category_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, blockType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if blockType.subclass:
            return blockType.subclass(*args_, **kwargs_)
        else:
            return blockType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_block(self):
        return self.block
    def set_block(self, block):
        self.block = block
    def get_category(self):
        return self.category
    def set_category(self, category):
        self.category = category
    def validate_categoryType6(self, value):
        # Validate type categoryType6, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['field_goal', 'extra_point', 'punt']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on categoryType6' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            super(blockType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='blockType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('blockType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'blockType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='blockType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='blockType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='blockType'):
        super(blockType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='blockType')
        if self.block is not None and 'block' not in already_processed:
            already_processed.add('block')
            outfile.write(' block="%s"' % self.gds_format_integer(self.block, input_name='block'))
        if self.category is not None and 'category' not in already_processed:
            already_processed.add('category')
            outfile.write(' category=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.category), input_name='category')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='blockType', fromsubclass_=False, pretty_print=True):
        super(blockType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('block', node)
        if value is not None and 'block' not in already_processed:
            already_processed.add('block')
            self.block = self.gds_parse_integer(value, node, 'block')
        value = find_attr_value_('category', node)
        if value is not None and 'category' not in already_processed:
            already_processed.add('category')
            self.category = value
            self.validate_categoryType6(self.category)    # validate type categoryType6
        super(blockType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(blockType, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class blockType


class defenseType(basePlayStatisticType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = basePlayStatisticType
    def __init__(self, nullified=None, team=None, player=None, tackle=None, ast_tackle=None, primary=None, sack=None, ast_sack=None, sack_yards=None, block=None, pass_defended=None, qb_hit=None, interception=None, int_yards=None, int_touchdown=None, tlost=None, ast_tlost=None, tlost_yards=None, forced_fumble=None, safety=None, category=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("defenseType"), self).__init__(nullified, team, player,  **kwargs_)
        self.tackle = _cast(int, tackle)
        self.tackle_nsprefix_ = None
        self.ast_tackle = _cast(int, ast_tackle)
        self.ast_tackle_nsprefix_ = None
        self.primary = _cast(int, primary)
        self.primary_nsprefix_ = None
        self.sack = _cast(int, sack)
        self.sack_nsprefix_ = None
        self.ast_sack = _cast(int, ast_sack)
        self.ast_sack_nsprefix_ = None
        self.sack_yards = _cast(float, sack_yards)
        self.sack_yards_nsprefix_ = None
        self.block = _cast(int, block)
        self.block_nsprefix_ = None
        self.pass_defended = _cast(int, pass_defended)
        self.pass_defended_nsprefix_ = None
        self.qb_hit = _cast(int, qb_hit)
        self.qb_hit_nsprefix_ = None
        self.interception = _cast(int, interception)
        self.interception_nsprefix_ = None
        self.int_yards = _cast(int, int_yards)
        self.int_yards_nsprefix_ = None
        self.int_touchdown = _cast(int, int_touchdown)
        self.int_touchdown_nsprefix_ = None
        self.tlost = _cast(int, tlost)
        self.tlost_nsprefix_ = None
        self.ast_tlost = _cast(int, ast_tlost)
        self.ast_tlost_nsprefix_ = None
        self.tlost_yards = _cast(int, tlost_yards)
        self.tlost_yards_nsprefix_ = None
        self.forced_fumble = _cast(int, forced_fumble)
        self.forced_fumble_nsprefix_ = None
        self.safety = _cast(int, safety)
        self.safety_nsprefix_ = None
        self.category = _cast(None, category)
        self.category_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, defenseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if defenseType.subclass:
            return defenseType.subclass(*args_, **kwargs_)
        else:
            return defenseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_tackle(self):
        return self.tackle
    def set_tackle(self, tackle):
        self.tackle = tackle
    def get_ast_tackle(self):
        return self.ast_tackle
    def set_ast_tackle(self, ast_tackle):
        self.ast_tackle = ast_tackle
    def get_primary(self):
        return self.primary
    def set_primary(self, primary):
        self.primary = primary
    def get_sack(self):
        return self.sack
    def set_sack(self, sack):
        self.sack = sack
    def get_ast_sack(self):
        return self.ast_sack
    def set_ast_sack(self, ast_sack):
        self.ast_sack = ast_sack
    def get_sack_yards(self):
        return self.sack_yards
    def set_sack_yards(self, sack_yards):
        self.sack_yards = sack_yards
    def get_block(self):
        return self.block
    def set_block(self, block):
        self.block = block
    def get_pass_defended(self):
        return self.pass_defended
    def set_pass_defended(self, pass_defended):
        self.pass_defended = pass_defended
    def get_qb_hit(self):
        return self.qb_hit
    def set_qb_hit(self, qb_hit):
        self.qb_hit = qb_hit
    def get_interception(self):
        return self.interception
    def set_interception(self, interception):
        self.interception = interception
    def get_int_yards(self):
        return self.int_yards
    def set_int_yards(self, int_yards):
        self.int_yards = int_yards
    def get_int_touchdown(self):
        return self.int_touchdown
    def set_int_touchdown(self, int_touchdown):
        self.int_touchdown = int_touchdown
    def get_tlost(self):
        return self.tlost
    def set_tlost(self, tlost):
        self.tlost = tlost
    def get_ast_tlost(self):
        return self.ast_tlost
    def set_ast_tlost(self, ast_tlost):
        self.ast_tlost = ast_tlost
    def get_tlost_yards(self):
        return self.tlost_yards
    def set_tlost_yards(self, tlost_yards):
        self.tlost_yards = tlost_yards
    def get_forced_fumble(self):
        return self.forced_fumble
    def set_forced_fumble(self, forced_fumble):
        self.forced_fumble = forced_fumble
    def get_safety(self):
        return self.safety
    def set_safety(self, safety):
        self.safety = safety
    def get_category(self):
        return self.category
    def set_category(self, category):
        self.category = category
    def has__content(self):
        if (
            super(defenseType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='defenseType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('defenseType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'defenseType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='defenseType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='defenseType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='defenseType'):
        super(defenseType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='defenseType')
        if self.tackle is not None and 'tackle' not in already_processed:
            already_processed.add('tackle')
            outfile.write(' tackle="%s"' % self.gds_format_integer(self.tackle, input_name='tackle'))
        if self.ast_tackle is not None and 'ast_tackle' not in already_processed:
            already_processed.add('ast_tackle')
            outfile.write(' ast_tackle="%s"' % self.gds_format_integer(self.ast_tackle, input_name='ast_tackle'))
        if self.primary is not None and 'primary' not in already_processed:
            already_processed.add('primary')
            outfile.write(' primary="%s"' % self.gds_format_integer(self.primary, input_name='primary'))
        if self.sack is not None and 'sack' not in already_processed:
            already_processed.add('sack')
            outfile.write(' sack="%s"' % self.gds_format_integer(self.sack, input_name='sack'))
        if self.ast_sack is not None and 'ast_sack' not in already_processed:
            already_processed.add('ast_sack')
            outfile.write(' ast_sack="%s"' % self.gds_format_integer(self.ast_sack, input_name='ast_sack'))
        if self.sack_yards is not None and 'sack_yards' not in already_processed:
            already_processed.add('sack_yards')
            outfile.write(' sack_yards="%s"' % self.gds_format_double(self.sack_yards, input_name='sack_yards'))
        if self.block is not None and 'block' not in already_processed:
            already_processed.add('block')
            outfile.write(' block="%s"' % self.gds_format_integer(self.block, input_name='block'))
        if self.pass_defended is not None and 'pass_defended' not in already_processed:
            already_processed.add('pass_defended')
            outfile.write(' pass_defended="%s"' % self.gds_format_integer(self.pass_defended, input_name='pass_defended'))
        if self.qb_hit is not None and 'qb_hit' not in already_processed:
            already_processed.add('qb_hit')
            outfile.write(' qb_hit="%s"' % self.gds_format_integer(self.qb_hit, input_name='qb_hit'))
        if self.interception is not None and 'interception' not in already_processed:
            already_processed.add('interception')
            outfile.write(' interception="%s"' % self.gds_format_integer(self.interception, input_name='interception'))
        if self.int_yards is not None and 'int_yards' not in already_processed:
            already_processed.add('int_yards')
            outfile.write(' int_yards="%s"' % self.gds_format_integer(self.int_yards, input_name='int_yards'))
        if self.int_touchdown is not None and 'int_touchdown' not in already_processed:
            already_processed.add('int_touchdown')
            outfile.write(' int_touchdown="%s"' % self.gds_format_integer(self.int_touchdown, input_name='int_touchdown'))
        if self.tlost is not None and 'tlost' not in already_processed:
            already_processed.add('tlost')
            outfile.write(' tlost="%s"' % self.gds_format_integer(self.tlost, input_name='tlost'))
        if self.ast_tlost is not None and 'ast_tlost' not in already_processed:
            already_processed.add('ast_tlost')
            outfile.write(' ast_tlost="%s"' % self.gds_format_integer(self.ast_tlost, input_name='ast_tlost'))
        if self.tlost_yards is not None and 'tlost_yards' not in already_processed:
            already_processed.add('tlost_yards')
            outfile.write(' tlost_yards="%s"' % self.gds_format_integer(self.tlost_yards, input_name='tlost_yards'))
        if self.forced_fumble is not None and 'forced_fumble' not in already_processed:
            already_processed.add('forced_fumble')
            outfile.write(' forced_fumble="%s"' % self.gds_format_integer(self.forced_fumble, input_name='forced_fumble'))
        if self.safety is not None and 'safety' not in already_processed:
            already_processed.add('safety')
            outfile.write(' safety="%s"' % self.gds_format_integer(self.safety, input_name='safety'))
        if self.category is not None and 'category' not in already_processed:
            already_processed.add('category')
            outfile.write(' category=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.category), input_name='category')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='defenseType', fromsubclass_=False, pretty_print=True):
        super(defenseType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('tackle', node)
        if value is not None and 'tackle' not in already_processed:
            already_processed.add('tackle')
            self.tackle = self.gds_parse_integer(value, node, 'tackle')
        value = find_attr_value_('ast_tackle', node)
        if value is not None and 'ast_tackle' not in already_processed:
            already_processed.add('ast_tackle')
            self.ast_tackle = self.gds_parse_integer(value, node, 'ast_tackle')
        value = find_attr_value_('primary', node)
        if value is not None and 'primary' not in already_processed:
            already_processed.add('primary')
            self.primary = self.gds_parse_integer(value, node, 'primary')
        value = find_attr_value_('sack', node)
        if value is not None and 'sack' not in already_processed:
            already_processed.add('sack')
            self.sack = self.gds_parse_integer(value, node, 'sack')
        value = find_attr_value_('ast_sack', node)
        if value is not None and 'ast_sack' not in already_processed:
            already_processed.add('ast_sack')
            self.ast_sack = self.gds_parse_integer(value, node, 'ast_sack')
        value = find_attr_value_('sack_yards', node)
        if value is not None and 'sack_yards' not in already_processed:
            already_processed.add('sack_yards')
            value = self.gds_parse_double(value, node, 'sack_yards')
            self.sack_yards = value
        value = find_attr_value_('block', node)
        if value is not None and 'block' not in already_processed:
            already_processed.add('block')
            self.block = self.gds_parse_integer(value, node, 'block')
        value = find_attr_value_('pass_defended', node)
        if value is not None and 'pass_defended' not in already_processed:
            already_processed.add('pass_defended')
            self.pass_defended = self.gds_parse_integer(value, node, 'pass_defended')
        value = find_attr_value_('qb_hit', node)
        if value is not None and 'qb_hit' not in already_processed:
            already_processed.add('qb_hit')
            self.qb_hit = self.gds_parse_integer(value, node, 'qb_hit')
        value = find_attr_value_('interception', node)
        if value is not None and 'interception' not in already_processed:
            already_processed.add('interception')
            self.interception = self.gds_parse_integer(value, node, 'interception')
        value = find_attr_value_('int_yards', node)
        if value is not None and 'int_yards' not in already_processed:
            already_processed.add('int_yards')
            self.int_yards = self.gds_parse_integer(value, node, 'int_yards')
        value = find_attr_value_('int_touchdown', node)
        if value is not None and 'int_touchdown' not in already_processed:
            already_processed.add('int_touchdown')
            self.int_touchdown = self.gds_parse_integer(value, node, 'int_touchdown')
        value = find_attr_value_('tlost', node)
        if value is not None and 'tlost' not in already_processed:
            already_processed.add('tlost')
            self.tlost = self.gds_parse_integer(value, node, 'tlost')
        value = find_attr_value_('ast_tlost', node)
        if value is not None and 'ast_tlost' not in already_processed:
            already_processed.add('ast_tlost')
            self.ast_tlost = self.gds_parse_integer(value, node, 'ast_tlost')
        value = find_attr_value_('tlost_yards', node)
        if value is not None and 'tlost_yards' not in already_processed:
            already_processed.add('tlost_yards')
            self.tlost_yards = self.gds_parse_integer(value, node, 'tlost_yards')
        value = find_attr_value_('forced_fumble', node)
        if value is not None and 'forced_fumble' not in already_processed:
            already_processed.add('forced_fumble')
            self.forced_fumble = self.gds_parse_integer(value, node, 'forced_fumble')
        value = find_attr_value_('safety', node)
        if value is not None and 'safety' not in already_processed:
            already_processed.add('safety')
            self.safety = self.gds_parse_integer(value, node, 'safety')
        value = find_attr_value_('category', node)
        if value is not None and 'category' not in already_processed:
            already_processed.add('category')
            self.category = value
        super(defenseType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(defenseType, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class defenseType


class conversionType(basePlayStatisticType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = basePlayStatisticType
    def __init__(self, nullified=None, team=None, player=None, attempt=None, complete=None, safety=None, category=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("conversionType"), self).__init__(nullified, team, player,  **kwargs_)
        self.attempt = _cast(int, attempt)
        self.attempt_nsprefix_ = None
        self.complete = _cast(int, complete)
        self.complete_nsprefix_ = None
        self.safety = _cast(int, safety)
        self.safety_nsprefix_ = None
        self.category = _cast(None, category)
        self.category_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, conversionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if conversionType.subclass:
            return conversionType.subclass(*args_, **kwargs_)
        else:
            return conversionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_attempt(self):
        return self.attempt
    def set_attempt(self, attempt):
        self.attempt = attempt
    def get_complete(self):
        return self.complete
    def set_complete(self, complete):
        self.complete = complete
    def get_safety(self):
        return self.safety
    def set_safety(self, safety):
        self.safety = safety
    def get_category(self):
        return self.category
    def set_category(self, category):
        self.category = category
    def validate_categoryType7(self, value):
        # Validate type categoryType7, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['pass', 'receive', 'rush', 'turnover']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on categoryType7' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            super(conversionType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='conversionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('conversionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'conversionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='conversionType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='conversionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='conversionType'):
        super(conversionType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='conversionType')
        if self.attempt is not None and 'attempt' not in already_processed:
            already_processed.add('attempt')
            outfile.write(' attempt="%s"' % self.gds_format_integer(self.attempt, input_name='attempt'))
        if self.complete is not None and 'complete' not in already_processed:
            already_processed.add('complete')
            outfile.write(' complete="%s"' % self.gds_format_integer(self.complete, input_name='complete'))
        if self.safety is not None and 'safety' not in already_processed:
            already_processed.add('safety')
            outfile.write(' safety="%s"' % self.gds_format_integer(self.safety, input_name='safety'))
        if self.category is not None and 'category' not in already_processed:
            already_processed.add('category')
            outfile.write(' category=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.category), input_name='category')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='conversionType', fromsubclass_=False, pretty_print=True):
        super(conversionType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('attempt', node)
        if value is not None and 'attempt' not in already_processed:
            already_processed.add('attempt')
            self.attempt = self.gds_parse_integer(value, node, 'attempt')
        value = find_attr_value_('complete', node)
        if value is not None and 'complete' not in already_processed:
            already_processed.add('complete')
            self.complete = self.gds_parse_integer(value, node, 'complete')
        value = find_attr_value_('safety', node)
        if value is not None and 'safety' not in already_processed:
            already_processed.add('safety')
            self.safety = self.gds_parse_integer(value, node, 'safety')
        value = find_attr_value_('category', node)
        if value is not None and 'category' not in already_processed:
            already_processed.add('category')
            self.category = value
            self.validate_categoryType7(self.category)    # validate type categoryType7
        super(conversionType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(conversionType, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class conversionType


class defense_conversionType(basePlayStatisticType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = basePlayStatisticType
    def __init__(self, nullified=None, team=None, player=None, attempt=None, complete=None, category=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("defense_conversionType"), self).__init__(nullified, team, player,  **kwargs_)
        self.attempt = _cast(int, attempt)
        self.attempt_nsprefix_ = None
        self.complete = _cast(int, complete)
        self.complete_nsprefix_ = None
        self.category = _cast(None, category)
        self.category_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, defense_conversionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if defense_conversionType.subclass:
            return defense_conversionType.subclass(*args_, **kwargs_)
        else:
            return defense_conversionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_attempt(self):
        return self.attempt
    def set_attempt(self, attempt):
        self.attempt = attempt
    def get_complete(self):
        return self.complete
    def set_complete(self, complete):
        self.complete = complete
    def get_category(self):
        return self.category
    def set_category(self, category):
        self.category = category
    def validate_categoryType8(self, value):
        # Validate type categoryType8, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['conversion', 'extra_point']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on categoryType8' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            super(defense_conversionType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='defense_conversionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('defense_conversionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'defense_conversionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='defense_conversionType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='defense_conversionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='defense_conversionType'):
        super(defense_conversionType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='defense_conversionType')
        if self.attempt is not None and 'attempt' not in already_processed:
            already_processed.add('attempt')
            outfile.write(' attempt="%s"' % self.gds_format_integer(self.attempt, input_name='attempt'))
        if self.complete is not None and 'complete' not in already_processed:
            already_processed.add('complete')
            outfile.write(' complete="%s"' % self.gds_format_integer(self.complete, input_name='complete'))
        if self.category is not None and 'category' not in already_processed:
            already_processed.add('category')
            outfile.write(' category=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.category), input_name='category')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='defense_conversionType', fromsubclass_=False, pretty_print=True):
        super(defense_conversionType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('attempt', node)
        if value is not None and 'attempt' not in already_processed:
            already_processed.add('attempt')
            self.attempt = self.gds_parse_integer(value, node, 'attempt')
        value = find_attr_value_('complete', node)
        if value is not None and 'complete' not in already_processed:
            already_processed.add('complete')
            self.complete = self.gds_parse_integer(value, node, 'complete')
        value = find_attr_value_('category', node)
        if value is not None and 'category' not in already_processed:
            already_processed.add('category')
            self.category = value
            self.validate_categoryType8(self.category)    # validate type categoryType8
        super(defense_conversionType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(defense_conversionType, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class defense_conversionType


class down_conversionType(basePlayStatisticType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = basePlayStatisticType
    def __init__(self, nullified=None, team=None, player=None, down=None, attempt=None, complete=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("down_conversionType"), self).__init__(nullified, team, player,  **kwargs_)
        self.down = _cast(int, down)
        self.down_nsprefix_ = None
        self.attempt = _cast(int, attempt)
        self.attempt_nsprefix_ = None
        self.complete = _cast(int, complete)
        self.complete_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, down_conversionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if down_conversionType.subclass:
            return down_conversionType.subclass(*args_, **kwargs_)
        else:
            return down_conversionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_down(self):
        return self.down
    def set_down(self, down):
        self.down = down
    def get_attempt(self):
        return self.attempt
    def set_attempt(self, attempt):
        self.attempt = attempt
    def get_complete(self):
        return self.complete
    def set_complete(self, complete):
        self.complete = complete
    def has__content(self):
        if (
            super(down_conversionType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='down_conversionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('down_conversionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'down_conversionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='down_conversionType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='down_conversionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='down_conversionType'):
        super(down_conversionType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='down_conversionType')
        if self.down is not None and 'down' not in already_processed:
            already_processed.add('down')
            outfile.write(' down="%s"' % self.gds_format_integer(self.down, input_name='down'))
        if self.attempt is not None and 'attempt' not in already_processed:
            already_processed.add('attempt')
            outfile.write(' attempt="%s"' % self.gds_format_integer(self.attempt, input_name='attempt'))
        if self.complete is not None and 'complete' not in already_processed:
            already_processed.add('complete')
            outfile.write(' complete="%s"' % self.gds_format_integer(self.complete, input_name='complete'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='down_conversionType', fromsubclass_=False, pretty_print=True):
        super(down_conversionType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('down', node)
        if value is not None and 'down' not in already_processed:
            already_processed.add('down')
            self.down = self.gds_parse_integer(value, node, 'down')
        value = find_attr_value_('attempt', node)
        if value is not None and 'attempt' not in already_processed:
            already_processed.add('attempt')
            self.attempt = self.gds_parse_integer(value, node, 'attempt')
        value = find_attr_value_('complete', node)
        if value is not None and 'complete' not in already_processed:
            already_processed.add('complete')
            self.complete = self.gds_parse_integer(value, node, 'complete')
        super(down_conversionType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(down_conversionType, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class down_conversionType


class first_downType(basePlayStatisticType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = basePlayStatisticType
    def __init__(self, nullified=None, team=None, player=None, category=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("first_downType"), self).__init__(nullified, team, player,  **kwargs_)
        self.category = _cast(None, category)
        self.category_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, first_downType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if first_downType.subclass:
            return first_downType.subclass(*args_, **kwargs_)
        else:
            return first_downType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_category(self):
        return self.category
    def set_category(self, category):
        self.category = category
    def validate_categoryType9(self, value):
        # Validate type categoryType9, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['pass', 'rush', 'penalty']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on categoryType9' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            super(first_downType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='first_downType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('first_downType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'first_downType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='first_downType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='first_downType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='first_downType'):
        super(first_downType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='first_downType')
        if self.category is not None and 'category' not in already_processed:
            already_processed.add('category')
            outfile.write(' category=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.category), input_name='category')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='first_downType', fromsubclass_=False, pretty_print=True):
        super(first_downType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('category', node)
        if value is not None and 'category' not in already_processed:
            already_processed.add('category')
            self.category = value
            self.validate_categoryType9(self.category)    # validate type categoryType9
        super(first_downType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(first_downType, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class first_downType


class playerType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, sr_id=None, name=None, jersey=None, reference=None, position=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.sr_id = _cast(None, sr_id)
        self.sr_id_nsprefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.jersey = _cast(None, jersey)
        self.jersey_nsprefix_ = None
        self.reference = _cast(None, reference)
        self.reference_nsprefix_ = None
        self.position = _cast(None, position)
        self.position_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, playerType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if playerType.subclass:
            return playerType.subclass(*args_, **kwargs_)
        else:
            return playerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_sr_id(self):
        return self.sr_id
    def set_sr_id(self, sr_id):
        self.sr_id = sr_id
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_jersey(self):
        return self.jersey
    def set_jersey(self, jersey):
        self.jersey = jersey
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def get_position(self):
        return self.position
    def set_position(self, position):
        self.position = position
    def validate_positionType(self, value):
        # Validate type positionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ATH', 'C', 'C/G', 'CB', 'CB/RS', 'CB/S', 'DB', 'DE', 'DE/LB', 'DL', 'DT', 'FB', 'FB/RB', 'FS', 'G', 'G/C', 'G/T', 'H/B', 'H/B/T', 'HB', 'ILB', 'K', 'K/P', 'KR', 'L', 'LB', 'LB/DE', 'LS', 'MLB', 'NT', 'OG', 'OL', 'OLB', 'OT', 'P', 'QB', 'QB/WR', 'RB', 'RB/ST', 'RB/WR', 'RS', 'S', 'SS', 'SAF', 'T', 'T/G', 'TE', 'TE/DT', 'TE/FB', 'TE/LS', 'TEW', 'WR', 'WR/CB', 'WR/KR', 'WR/PR', 'WR/RB', 'WR/RS', 'QB/WR', 'DB/LB', 'FB/DL', 'DE/DT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on positionType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='playerType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('playerType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'playerType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='playerType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='playerType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='playerType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.sr_id is not None and 'sr_id' not in already_processed:
            already_processed.add('sr_id')
            outfile.write(' sr_id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.sr_id), input_name='sr_id')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.jersey is not None and 'jersey' not in already_processed:
            already_processed.add('jersey')
            outfile.write(' jersey=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.jersey), input_name='jersey')), ))
        if self.reference is not None and 'reference' not in already_processed:
            already_processed.add('reference')
            outfile.write(' reference=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.reference), input_name='reference')), ))
        if self.position is not None and 'position' not in already_processed:
            already_processed.add('position')
            outfile.write(' position=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.position), input_name='position')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='playerType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('sr_id', node)
        if value is not None and 'sr_id' not in already_processed:
            already_processed.add('sr_id')
            self.sr_id = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('jersey', node)
        if value is not None and 'jersey' not in already_processed:
            already_processed.add('jersey')
            self.jersey = value
        value = find_attr_value_('reference', node)
        if value is not None and 'reference' not in already_processed:
            already_processed.add('reference')
            self.reference = value
        value = find_attr_value_('position', node)
        if value is not None and 'position' not in already_processed:
            already_processed.add('position')
            self.position = value
            self.validate_positionType(self.position)    # validate type positionType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class playerType


class timeoutType10(basePlayStatisticType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = basePlayStatisticType
    def __init__(self, nullified=None, team=None, player=None, description=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("timeoutType10"), self).__init__(nullified, team, player,  **kwargs_)
        self.description = _cast(None, description)
        self.description_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, timeoutType10)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if timeoutType10.subclass:
            return timeoutType10.subclass(*args_, **kwargs_)
        else:
            return timeoutType10(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def has__content(self):
        if (
            super(timeoutType10, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='timeoutType10', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('timeoutType10')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'timeoutType10':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='timeoutType10')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='timeoutType10', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='timeoutType10'):
        super(timeoutType10, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='timeoutType10')
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            outfile.write(' description=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.description), input_name='description')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='timeoutType10', fromsubclass_=False, pretty_print=True):
        super(timeoutType10, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.add('description')
            self.description = value
        super(timeoutType10, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(timeoutType10, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class timeoutType10


class miscType11(basePlayStatisticType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = basePlayStatisticType
    def __init__(self, nullified=None, team=None, player=None, yards=None, touchdown=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("miscType11"), self).__init__(nullified, team, player,  **kwargs_)
        self.yards = _cast(int, yards)
        self.yards_nsprefix_ = None
        self.touchdown = _cast(int, touchdown)
        self.touchdown_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, miscType11)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if miscType11.subclass:
            return miscType11.subclass(*args_, **kwargs_)
        else:
            return miscType11(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_yards(self):
        return self.yards
    def set_yards(self, yards):
        self.yards = yards
    def get_touchdown(self):
        return self.touchdown
    def set_touchdown(self, touchdown):
        self.touchdown = touchdown
    def has__content(self):
        if (
            super(miscType11, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='miscType11', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('miscType11')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'miscType11':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='miscType11')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='miscType11', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='miscType11'):
        super(miscType11, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='miscType11')
        if self.yards is not None and 'yards' not in already_processed:
            already_processed.add('yards')
            outfile.write(' yards="%s"' % self.gds_format_integer(self.yards, input_name='yards'))
        if self.touchdown is not None and 'touchdown' not in already_processed:
            already_processed.add('touchdown')
            outfile.write(' touchdown="%s"' % self.gds_format_integer(self.touchdown, input_name='touchdown'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='miscType11', fromsubclass_=False, pretty_print=True):
        super(miscType11, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('yards', node)
        if value is not None and 'yards' not in already_processed:
            already_processed.add('yards')
            self.yards = self.gds_parse_integer(value, node, 'yards')
        value = find_attr_value_('touchdown', node)
        if value is not None and 'touchdown' not in already_processed:
            already_processed.add('touchdown')
            self.touchdown = self.gds_parse_integer(value, node, 'touchdown')
        super(miscType11, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(miscType11, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class miscType11


class passType12(basePlayStatisticType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = basePlayStatisticType
    def __init__(self, nullified=None, team=None, player=None, attempt=None, complete=None, yards=None, att_yards=None, interception=None, firstdown=None, touchdown=None, sack=None, sack_yards=None, inside_20=None, goaltogo=None, safety=None, incompletion_type=None, blitz=None, hurry=None, knockdown=None, pocket_time=None, batted_pass=None, on_target_throw=None, int_touchdown=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("passType12"), self).__init__(nullified, team, player,  **kwargs_)
        self.attempt = _cast(int, attempt)
        self.attempt_nsprefix_ = None
        self.complete = _cast(int, complete)
        self.complete_nsprefix_ = None
        self.yards = _cast(int, yards)
        self.yards_nsprefix_ = None
        self.att_yards = _cast(int, att_yards)
        self.att_yards_nsprefix_ = None
        self.interception = _cast(int, interception)
        self.interception_nsprefix_ = None
        self.firstdown = _cast(int, firstdown)
        self.firstdown_nsprefix_ = None
        self.touchdown = _cast(int, touchdown)
        self.touchdown_nsprefix_ = None
        self.sack = _cast(int, sack)
        self.sack_nsprefix_ = None
        self.sack_yards = _cast(int, sack_yards)
        self.sack_yards_nsprefix_ = None
        self.inside_20 = _cast(int, inside_20)
        self.inside_20_nsprefix_ = None
        self.goaltogo = _cast(int, goaltogo)
        self.goaltogo_nsprefix_ = None
        self.safety = _cast(int, safety)
        self.safety_nsprefix_ = None
        self.incompletion_type = _cast(None, incompletion_type)
        self.incompletion_type_nsprefix_ = None
        self.blitz = _cast(int, blitz)
        self.blitz_nsprefix_ = None
        self.hurry = _cast(int, hurry)
        self.hurry_nsprefix_ = None
        self.knockdown = _cast(int, knockdown)
        self.knockdown_nsprefix_ = None
        self.pocket_time = _cast(float, pocket_time)
        self.pocket_time_nsprefix_ = None
        self.batted_pass = _cast(int, batted_pass)
        self.batted_pass_nsprefix_ = None
        self.on_target_throw = _cast(int, on_target_throw)
        self.on_target_throw_nsprefix_ = None
        self.int_touchdown = _cast(int, int_touchdown)
        self.int_touchdown_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, passType12)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if passType12.subclass:
            return passType12.subclass(*args_, **kwargs_)
        else:
            return passType12(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_attempt(self):
        return self.attempt
    def set_attempt(self, attempt):
        self.attempt = attempt
    def get_complete(self):
        return self.complete
    def set_complete(self, complete):
        self.complete = complete
    def get_yards(self):
        return self.yards
    def set_yards(self, yards):
        self.yards = yards
    def get_att_yards(self):
        return self.att_yards
    def set_att_yards(self, att_yards):
        self.att_yards = att_yards
    def get_interception(self):
        return self.interception
    def set_interception(self, interception):
        self.interception = interception
    def get_firstdown(self):
        return self.firstdown
    def set_firstdown(self, firstdown):
        self.firstdown = firstdown
    def get_touchdown(self):
        return self.touchdown
    def set_touchdown(self, touchdown):
        self.touchdown = touchdown
    def get_sack(self):
        return self.sack
    def set_sack(self, sack):
        self.sack = sack
    def get_sack_yards(self):
        return self.sack_yards
    def set_sack_yards(self, sack_yards):
        self.sack_yards = sack_yards
    def get_inside_20(self):
        return self.inside_20
    def set_inside_20(self, inside_20):
        self.inside_20 = inside_20
    def get_goaltogo(self):
        return self.goaltogo
    def set_goaltogo(self, goaltogo):
        self.goaltogo = goaltogo
    def get_safety(self):
        return self.safety
    def set_safety(self, safety):
        self.safety = safety
    def get_incompletion_type(self):
        return self.incompletion_type
    def set_incompletion_type(self, incompletion_type):
        self.incompletion_type = incompletion_type
    def get_blitz(self):
        return self.blitz
    def set_blitz(self, blitz):
        self.blitz = blitz
    def get_hurry(self):
        return self.hurry
    def set_hurry(self, hurry):
        self.hurry = hurry
    def get_knockdown(self):
        return self.knockdown
    def set_knockdown(self, knockdown):
        self.knockdown = knockdown
    def get_pocket_time(self):
        return self.pocket_time
    def set_pocket_time(self, pocket_time):
        self.pocket_time = pocket_time
    def get_batted_pass(self):
        return self.batted_pass
    def set_batted_pass(self, batted_pass):
        self.batted_pass = batted_pass
    def get_on_target_throw(self):
        return self.on_target_throw
    def set_on_target_throw(self, on_target_throw):
        self.on_target_throw = on_target_throw
    def get_int_touchdown(self):
        return self.int_touchdown
    def set_int_touchdown(self, int_touchdown):
        self.int_touchdown = int_touchdown
    def validate_incompletion_typeType(self, value):
        # Validate type incompletion_typeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Thrown Away', 'Pass Defended', 'Dropped Pass', 'Spike', 'Poorly Thrown']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on incompletion_typeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            super(passType12, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='passType12', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('passType12')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'passType12':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='passType12')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='passType12', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='passType12'):
        super(passType12, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='passType12')
        if self.attempt is not None and 'attempt' not in already_processed:
            already_processed.add('attempt')
            outfile.write(' attempt="%s"' % self.gds_format_integer(self.attempt, input_name='attempt'))
        if self.complete is not None and 'complete' not in already_processed:
            already_processed.add('complete')
            outfile.write(' complete="%s"' % self.gds_format_integer(self.complete, input_name='complete'))
        if self.yards is not None and 'yards' not in already_processed:
            already_processed.add('yards')
            outfile.write(' yards="%s"' % self.gds_format_integer(self.yards, input_name='yards'))
        if self.att_yards is not None and 'att_yards' not in already_processed:
            already_processed.add('att_yards')
            outfile.write(' att_yards="%s"' % self.gds_format_integer(self.att_yards, input_name='att_yards'))
        if self.interception is not None and 'interception' not in already_processed:
            already_processed.add('interception')
            outfile.write(' interception="%s"' % self.gds_format_integer(self.interception, input_name='interception'))
        if self.firstdown is not None and 'firstdown' not in already_processed:
            already_processed.add('firstdown')
            outfile.write(' firstdown="%s"' % self.gds_format_integer(self.firstdown, input_name='firstdown'))
        if self.touchdown is not None and 'touchdown' not in already_processed:
            already_processed.add('touchdown')
            outfile.write(' touchdown="%s"' % self.gds_format_integer(self.touchdown, input_name='touchdown'))
        if self.sack is not None and 'sack' not in already_processed:
            already_processed.add('sack')
            outfile.write(' sack="%s"' % self.gds_format_integer(self.sack, input_name='sack'))
        if self.sack_yards is not None and 'sack_yards' not in already_processed:
            already_processed.add('sack_yards')
            outfile.write(' sack_yards="%s"' % self.gds_format_integer(self.sack_yards, input_name='sack_yards'))
        if self.inside_20 is not None and 'inside_20' not in already_processed:
            already_processed.add('inside_20')
            outfile.write(' inside_20="%s"' % self.gds_format_integer(self.inside_20, input_name='inside_20'))
        if self.goaltogo is not None and 'goaltogo' not in already_processed:
            already_processed.add('goaltogo')
            outfile.write(' goaltogo="%s"' % self.gds_format_integer(self.goaltogo, input_name='goaltogo'))
        if self.safety is not None and 'safety' not in already_processed:
            already_processed.add('safety')
            outfile.write(' safety="%s"' % self.gds_format_integer(self.safety, input_name='safety'))
        if self.incompletion_type is not None and 'incompletion_type' not in already_processed:
            already_processed.add('incompletion_type')
            outfile.write(' incompletion_type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.incompletion_type), input_name='incompletion_type')), ))
        if self.blitz is not None and 'blitz' not in already_processed:
            already_processed.add('blitz')
            outfile.write(' blitz="%s"' % self.gds_format_integer(self.blitz, input_name='blitz'))
        if self.hurry is not None and 'hurry' not in already_processed:
            already_processed.add('hurry')
            outfile.write(' hurry="%s"' % self.gds_format_integer(self.hurry, input_name='hurry'))
        if self.knockdown is not None and 'knockdown' not in already_processed:
            already_processed.add('knockdown')
            outfile.write(' knockdown="%s"' % self.gds_format_integer(self.knockdown, input_name='knockdown'))
        if self.pocket_time is not None and 'pocket_time' not in already_processed:
            already_processed.add('pocket_time')
            outfile.write(' pocket_time="%s"' % self.gds_format_double(self.pocket_time, input_name='pocket_time'))
        if self.batted_pass is not None and 'batted_pass' not in already_processed:
            already_processed.add('batted_pass')
            outfile.write(' batted_pass="%s"' % self.gds_format_integer(self.batted_pass, input_name='batted_pass'))
        if self.on_target_throw is not None and 'on_target_throw' not in already_processed:
            already_processed.add('on_target_throw')
            outfile.write(' on_target_throw="%s"' % self.gds_format_integer(self.on_target_throw, input_name='on_target_throw'))
        if self.int_touchdown is not None and 'int_touchdown' not in already_processed:
            already_processed.add('int_touchdown')
            outfile.write(' int_touchdown="%s"' % self.gds_format_integer(self.int_touchdown, input_name='int_touchdown'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='passType12', fromsubclass_=False, pretty_print=True):
        super(passType12, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('attempt', node)
        if value is not None and 'attempt' not in already_processed:
            already_processed.add('attempt')
            self.attempt = self.gds_parse_integer(value, node, 'attempt')
        value = find_attr_value_('complete', node)
        if value is not None and 'complete' not in already_processed:
            already_processed.add('complete')
            self.complete = self.gds_parse_integer(value, node, 'complete')
        value = find_attr_value_('yards', node)
        if value is not None and 'yards' not in already_processed:
            already_processed.add('yards')
            self.yards = self.gds_parse_integer(value, node, 'yards')
        value = find_attr_value_('att_yards', node)
        if value is not None and 'att_yards' not in already_processed:
            already_processed.add('att_yards')
            self.att_yards = self.gds_parse_integer(value, node, 'att_yards')
        value = find_attr_value_('interception', node)
        if value is not None and 'interception' not in already_processed:
            already_processed.add('interception')
            self.interception = self.gds_parse_integer(value, node, 'interception')
        value = find_attr_value_('firstdown', node)
        if value is not None and 'firstdown' not in already_processed:
            already_processed.add('firstdown')
            self.firstdown = self.gds_parse_integer(value, node, 'firstdown')
        value = find_attr_value_('touchdown', node)
        if value is not None and 'touchdown' not in already_processed:
            already_processed.add('touchdown')
            self.touchdown = self.gds_parse_integer(value, node, 'touchdown')
        value = find_attr_value_('sack', node)
        if value is not None and 'sack' not in already_processed:
            already_processed.add('sack')
            self.sack = self.gds_parse_integer(value, node, 'sack')
        value = find_attr_value_('sack_yards', node)
        if value is not None and 'sack_yards' not in already_processed:
            already_processed.add('sack_yards')
            self.sack_yards = self.gds_parse_integer(value, node, 'sack_yards')
        value = find_attr_value_('inside_20', node)
        if value is not None and 'inside_20' not in already_processed:
            already_processed.add('inside_20')
            self.inside_20 = self.gds_parse_integer(value, node, 'inside_20')
        value = find_attr_value_('goaltogo', node)
        if value is not None and 'goaltogo' not in already_processed:
            already_processed.add('goaltogo')
            self.goaltogo = self.gds_parse_integer(value, node, 'goaltogo')
        value = find_attr_value_('safety', node)
        if value is not None and 'safety' not in already_processed:
            already_processed.add('safety')
            self.safety = self.gds_parse_integer(value, node, 'safety')
        value = find_attr_value_('incompletion_type', node)
        if value is not None and 'incompletion_type' not in already_processed:
            already_processed.add('incompletion_type')
            self.incompletion_type = value
            self.validate_incompletion_typeType(self.incompletion_type)    # validate type incompletion_typeType
        value = find_attr_value_('blitz', node)
        if value is not None and 'blitz' not in already_processed:
            already_processed.add('blitz')
            self.blitz = self.gds_parse_integer(value, node, 'blitz')
        value = find_attr_value_('hurry', node)
        if value is not None and 'hurry' not in already_processed:
            already_processed.add('hurry')
            self.hurry = self.gds_parse_integer(value, node, 'hurry')
        value = find_attr_value_('knockdown', node)
        if value is not None and 'knockdown' not in already_processed:
            already_processed.add('knockdown')
            self.knockdown = self.gds_parse_integer(value, node, 'knockdown')
        value = find_attr_value_('pocket_time', node)
        if value is not None and 'pocket_time' not in already_processed:
            already_processed.add('pocket_time')
            value = self.gds_parse_double(value, node, 'pocket_time')
            self.pocket_time = value
        value = find_attr_value_('batted_pass', node)
        if value is not None and 'batted_pass' not in already_processed:
            already_processed.add('batted_pass')
            self.batted_pass = self.gds_parse_integer(value, node, 'batted_pass')
        value = find_attr_value_('on_target_throw', node)
        if value is not None and 'on_target_throw' not in already_processed:
            already_processed.add('on_target_throw')
            self.on_target_throw = self.gds_parse_integer(value, node, 'on_target_throw')
        value = find_attr_value_('int_touchdown', node)
        if value is not None and 'int_touchdown' not in already_processed:
            already_processed.add('int_touchdown')
            self.int_touchdown = self.gds_parse_integer(value, node, 'int_touchdown')
        super(passType12, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(passType12, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class passType12


class receiveType13(basePlayStatisticType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = basePlayStatisticType
    def __init__(self, nullified=None, team=None, player=None, firstdown=None, touchdown=None, safety=None, target=None, reception=None, yards=None, yards_after_catch=None, fumble=None, dropped=None, inside_20=None, goaltogo=None, broken_tackles=None, catchable=None, yards_after_contact=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("receiveType13"), self).__init__(nullified, team, player,  **kwargs_)
        self.firstdown = _cast(int, firstdown)
        self.firstdown_nsprefix_ = None
        self.touchdown = _cast(int, touchdown)
        self.touchdown_nsprefix_ = None
        self.safety = _cast(int, safety)
        self.safety_nsprefix_ = None
        self.target = _cast(int, target)
        self.target_nsprefix_ = None
        self.reception = _cast(int, reception)
        self.reception_nsprefix_ = None
        self.yards = _cast(int, yards)
        self.yards_nsprefix_ = None
        self.yards_after_catch = _cast(int, yards_after_catch)
        self.yards_after_catch_nsprefix_ = None
        self.fumble = _cast(int, fumble)
        self.fumble_nsprefix_ = None
        self.dropped = _cast(int, dropped)
        self.dropped_nsprefix_ = None
        self.inside_20 = _cast(int, inside_20)
        self.inside_20_nsprefix_ = None
        self.goaltogo = _cast(int, goaltogo)
        self.goaltogo_nsprefix_ = None
        self.broken_tackles = _cast(int, broken_tackles)
        self.broken_tackles_nsprefix_ = None
        self.catchable = _cast(int, catchable)
        self.catchable_nsprefix_ = None
        self.yards_after_contact = _cast(int, yards_after_contact)
        self.yards_after_contact_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, receiveType13)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if receiveType13.subclass:
            return receiveType13.subclass(*args_, **kwargs_)
        else:
            return receiveType13(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_firstdown(self):
        return self.firstdown
    def set_firstdown(self, firstdown):
        self.firstdown = firstdown
    def get_touchdown(self):
        return self.touchdown
    def set_touchdown(self, touchdown):
        self.touchdown = touchdown
    def get_safety(self):
        return self.safety
    def set_safety(self, safety):
        self.safety = safety
    def get_target(self):
        return self.target
    def set_target(self, target):
        self.target = target
    def get_reception(self):
        return self.reception
    def set_reception(self, reception):
        self.reception = reception
    def get_yards(self):
        return self.yards
    def set_yards(self, yards):
        self.yards = yards
    def get_yards_after_catch(self):
        return self.yards_after_catch
    def set_yards_after_catch(self, yards_after_catch):
        self.yards_after_catch = yards_after_catch
    def get_fumble(self):
        return self.fumble
    def set_fumble(self, fumble):
        self.fumble = fumble
    def get_dropped(self):
        return self.dropped
    def set_dropped(self, dropped):
        self.dropped = dropped
    def get_inside_20(self):
        return self.inside_20
    def set_inside_20(self, inside_20):
        self.inside_20 = inside_20
    def get_goaltogo(self):
        return self.goaltogo
    def set_goaltogo(self, goaltogo):
        self.goaltogo = goaltogo
    def get_broken_tackles(self):
        return self.broken_tackles
    def set_broken_tackles(self, broken_tackles):
        self.broken_tackles = broken_tackles
    def get_catchable(self):
        return self.catchable
    def set_catchable(self, catchable):
        self.catchable = catchable
    def get_yards_after_contact(self):
        return self.yards_after_contact
    def set_yards_after_contact(self, yards_after_contact):
        self.yards_after_contact = yards_after_contact
    def has__content(self):
        if (
            super(receiveType13, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='receiveType13', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('receiveType13')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'receiveType13':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='receiveType13')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='receiveType13', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='receiveType13'):
        super(receiveType13, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='receiveType13')
        if self.firstdown is not None and 'firstdown' not in already_processed:
            already_processed.add('firstdown')
            outfile.write(' firstdown="%s"' % self.gds_format_integer(self.firstdown, input_name='firstdown'))
        if self.touchdown is not None and 'touchdown' not in already_processed:
            already_processed.add('touchdown')
            outfile.write(' touchdown="%s"' % self.gds_format_integer(self.touchdown, input_name='touchdown'))
        if self.safety is not None and 'safety' not in already_processed:
            already_processed.add('safety')
            outfile.write(' safety="%s"' % self.gds_format_integer(self.safety, input_name='safety'))
        if self.target is not None and 'target' not in already_processed:
            already_processed.add('target')
            outfile.write(' target="%s"' % self.gds_format_integer(self.target, input_name='target'))
        if self.reception is not None and 'reception' not in already_processed:
            already_processed.add('reception')
            outfile.write(' reception="%s"' % self.gds_format_integer(self.reception, input_name='reception'))
        if self.yards is not None and 'yards' not in already_processed:
            already_processed.add('yards')
            outfile.write(' yards="%s"' % self.gds_format_integer(self.yards, input_name='yards'))
        if self.yards_after_catch is not None and 'yards_after_catch' not in already_processed:
            already_processed.add('yards_after_catch')
            outfile.write(' yards_after_catch="%s"' % self.gds_format_integer(self.yards_after_catch, input_name='yards_after_catch'))
        if self.fumble is not None and 'fumble' not in already_processed:
            already_processed.add('fumble')
            outfile.write(' fumble="%s"' % self.gds_format_integer(self.fumble, input_name='fumble'))
        if self.dropped is not None and 'dropped' not in already_processed:
            already_processed.add('dropped')
            outfile.write(' dropped="%s"' % self.gds_format_integer(self.dropped, input_name='dropped'))
        if self.inside_20 is not None and 'inside_20' not in already_processed:
            already_processed.add('inside_20')
            outfile.write(' inside_20="%s"' % self.gds_format_integer(self.inside_20, input_name='inside_20'))
        if self.goaltogo is not None and 'goaltogo' not in already_processed:
            already_processed.add('goaltogo')
            outfile.write(' goaltogo="%s"' % self.gds_format_integer(self.goaltogo, input_name='goaltogo'))
        if self.broken_tackles is not None and 'broken_tackles' not in already_processed:
            already_processed.add('broken_tackles')
            outfile.write(' broken_tackles="%s"' % self.gds_format_integer(self.broken_tackles, input_name='broken_tackles'))
        if self.catchable is not None and 'catchable' not in already_processed:
            already_processed.add('catchable')
            outfile.write(' catchable="%s"' % self.gds_format_integer(self.catchable, input_name='catchable'))
        if self.yards_after_contact is not None and 'yards_after_contact' not in already_processed:
            already_processed.add('yards_after_contact')
            outfile.write(' yards_after_contact="%s"' % self.gds_format_integer(self.yards_after_contact, input_name='yards_after_contact'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='receiveType13', fromsubclass_=False, pretty_print=True):
        super(receiveType13, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('firstdown', node)
        if value is not None and 'firstdown' not in already_processed:
            already_processed.add('firstdown')
            self.firstdown = self.gds_parse_integer(value, node, 'firstdown')
        value = find_attr_value_('touchdown', node)
        if value is not None and 'touchdown' not in already_processed:
            already_processed.add('touchdown')
            self.touchdown = self.gds_parse_integer(value, node, 'touchdown')
        value = find_attr_value_('safety', node)
        if value is not None and 'safety' not in already_processed:
            already_processed.add('safety')
            self.safety = self.gds_parse_integer(value, node, 'safety')
        value = find_attr_value_('target', node)
        if value is not None and 'target' not in already_processed:
            already_processed.add('target')
            self.target = self.gds_parse_integer(value, node, 'target')
        value = find_attr_value_('reception', node)
        if value is not None and 'reception' not in already_processed:
            already_processed.add('reception')
            self.reception = self.gds_parse_integer(value, node, 'reception')
        value = find_attr_value_('yards', node)
        if value is not None and 'yards' not in already_processed:
            already_processed.add('yards')
            self.yards = self.gds_parse_integer(value, node, 'yards')
        value = find_attr_value_('yards_after_catch', node)
        if value is not None and 'yards_after_catch' not in already_processed:
            already_processed.add('yards_after_catch')
            self.yards_after_catch = self.gds_parse_integer(value, node, 'yards_after_catch')
        value = find_attr_value_('fumble', node)
        if value is not None and 'fumble' not in already_processed:
            already_processed.add('fumble')
            self.fumble = self.gds_parse_integer(value, node, 'fumble')
        value = find_attr_value_('dropped', node)
        if value is not None and 'dropped' not in already_processed:
            already_processed.add('dropped')
            self.dropped = self.gds_parse_integer(value, node, 'dropped')
        value = find_attr_value_('inside_20', node)
        if value is not None and 'inside_20' not in already_processed:
            already_processed.add('inside_20')
            self.inside_20 = self.gds_parse_integer(value, node, 'inside_20')
        value = find_attr_value_('goaltogo', node)
        if value is not None and 'goaltogo' not in already_processed:
            already_processed.add('goaltogo')
            self.goaltogo = self.gds_parse_integer(value, node, 'goaltogo')
        value = find_attr_value_('broken_tackles', node)
        if value is not None and 'broken_tackles' not in already_processed:
            already_processed.add('broken_tackles')
            self.broken_tackles = self.gds_parse_integer(value, node, 'broken_tackles')
        value = find_attr_value_('catchable', node)
        if value is not None and 'catchable' not in already_processed:
            already_processed.add('catchable')
            self.catchable = self.gds_parse_integer(value, node, 'catchable')
        value = find_attr_value_('yards_after_contact', node)
        if value is not None and 'yards_after_contact' not in already_processed:
            already_processed.add('yards_after_contact')
            self.yards_after_contact = self.gds_parse_integer(value, node, 'yards_after_contact')
        super(receiveType13, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(receiveType13, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class receiveType13


class rushType14(basePlayStatisticType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = basePlayStatisticType
    def __init__(self, nullified=None, team=None, player=None, attempt=None, yards=None, touchdown=None, firstdown=None, safety=None, fumble=None, inside_20=None, goaltogo=None, lateral=None, tlost=None, tlost_yards=None, broken_tackles=None, kneel_down=None, scramble=None, yards_after_contact=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("rushType14"), self).__init__(nullified, team, player,  **kwargs_)
        self.attempt = _cast(int, attempt)
        self.attempt_nsprefix_ = None
        self.yards = _cast(int, yards)
        self.yards_nsprefix_ = None
        self.touchdown = _cast(int, touchdown)
        self.touchdown_nsprefix_ = None
        self.firstdown = _cast(int, firstdown)
        self.firstdown_nsprefix_ = None
        self.safety = _cast(int, safety)
        self.safety_nsprefix_ = None
        self.fumble = _cast(int, fumble)
        self.fumble_nsprefix_ = None
        self.inside_20 = _cast(int, inside_20)
        self.inside_20_nsprefix_ = None
        self.goaltogo = _cast(int, goaltogo)
        self.goaltogo_nsprefix_ = None
        self.lateral = _cast(int, lateral)
        self.lateral_nsprefix_ = None
        self.tlost = _cast(int, tlost)
        self.tlost_nsprefix_ = None
        self.tlost_yards = _cast(int, tlost_yards)
        self.tlost_yards_nsprefix_ = None
        self.broken_tackles = _cast(int, broken_tackles)
        self.broken_tackles_nsprefix_ = None
        self.kneel_down = _cast(int, kneel_down)
        self.kneel_down_nsprefix_ = None
        self.scramble = _cast(int, scramble)
        self.scramble_nsprefix_ = None
        self.yards_after_contact = _cast(int, yards_after_contact)
        self.yards_after_contact_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, rushType14)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if rushType14.subclass:
            return rushType14.subclass(*args_, **kwargs_)
        else:
            return rushType14(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_attempt(self):
        return self.attempt
    def set_attempt(self, attempt):
        self.attempt = attempt
    def get_yards(self):
        return self.yards
    def set_yards(self, yards):
        self.yards = yards
    def get_touchdown(self):
        return self.touchdown
    def set_touchdown(self, touchdown):
        self.touchdown = touchdown
    def get_firstdown(self):
        return self.firstdown
    def set_firstdown(self, firstdown):
        self.firstdown = firstdown
    def get_safety(self):
        return self.safety
    def set_safety(self, safety):
        self.safety = safety
    def get_fumble(self):
        return self.fumble
    def set_fumble(self, fumble):
        self.fumble = fumble
    def get_inside_20(self):
        return self.inside_20
    def set_inside_20(self, inside_20):
        self.inside_20 = inside_20
    def get_goaltogo(self):
        return self.goaltogo
    def set_goaltogo(self, goaltogo):
        self.goaltogo = goaltogo
    def get_lateral(self):
        return self.lateral
    def set_lateral(self, lateral):
        self.lateral = lateral
    def get_tlost(self):
        return self.tlost
    def set_tlost(self, tlost):
        self.tlost = tlost
    def get_tlost_yards(self):
        return self.tlost_yards
    def set_tlost_yards(self, tlost_yards):
        self.tlost_yards = tlost_yards
    def get_broken_tackles(self):
        return self.broken_tackles
    def set_broken_tackles(self, broken_tackles):
        self.broken_tackles = broken_tackles
    def get_kneel_down(self):
        return self.kneel_down
    def set_kneel_down(self, kneel_down):
        self.kneel_down = kneel_down
    def get_scramble(self):
        return self.scramble
    def set_scramble(self, scramble):
        self.scramble = scramble
    def get_yards_after_contact(self):
        return self.yards_after_contact
    def set_yards_after_contact(self, yards_after_contact):
        self.yards_after_contact = yards_after_contact
    def has__content(self):
        if (
            super(rushType14, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='rushType14', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('rushType14')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'rushType14':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='rushType14')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='rushType14', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='rushType14'):
        super(rushType14, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='rushType14')
        if self.attempt is not None and 'attempt' not in already_processed:
            already_processed.add('attempt')
            outfile.write(' attempt="%s"' % self.gds_format_integer(self.attempt, input_name='attempt'))
        if self.yards is not None and 'yards' not in already_processed:
            already_processed.add('yards')
            outfile.write(' yards="%s"' % self.gds_format_integer(self.yards, input_name='yards'))
        if self.touchdown is not None and 'touchdown' not in already_processed:
            already_processed.add('touchdown')
            outfile.write(' touchdown="%s"' % self.gds_format_integer(self.touchdown, input_name='touchdown'))
        if self.firstdown is not None and 'firstdown' not in already_processed:
            already_processed.add('firstdown')
            outfile.write(' firstdown="%s"' % self.gds_format_integer(self.firstdown, input_name='firstdown'))
        if self.safety is not None and 'safety' not in already_processed:
            already_processed.add('safety')
            outfile.write(' safety="%s"' % self.gds_format_integer(self.safety, input_name='safety'))
        if self.fumble is not None and 'fumble' not in already_processed:
            already_processed.add('fumble')
            outfile.write(' fumble="%s"' % self.gds_format_integer(self.fumble, input_name='fumble'))
        if self.inside_20 is not None and 'inside_20' not in already_processed:
            already_processed.add('inside_20')
            outfile.write(' inside_20="%s"' % self.gds_format_integer(self.inside_20, input_name='inside_20'))
        if self.goaltogo is not None and 'goaltogo' not in already_processed:
            already_processed.add('goaltogo')
            outfile.write(' goaltogo="%s"' % self.gds_format_integer(self.goaltogo, input_name='goaltogo'))
        if self.lateral is not None and 'lateral' not in already_processed:
            already_processed.add('lateral')
            outfile.write(' lateral="%s"' % self.gds_format_integer(self.lateral, input_name='lateral'))
        if self.tlost is not None and 'tlost' not in already_processed:
            already_processed.add('tlost')
            outfile.write(' tlost="%s"' % self.gds_format_integer(self.tlost, input_name='tlost'))
        if self.tlost_yards is not None and 'tlost_yards' not in already_processed:
            already_processed.add('tlost_yards')
            outfile.write(' tlost_yards="%s"' % self.gds_format_integer(self.tlost_yards, input_name='tlost_yards'))
        if self.broken_tackles is not None and 'broken_tackles' not in already_processed:
            already_processed.add('broken_tackles')
            outfile.write(' broken_tackles="%s"' % self.gds_format_integer(self.broken_tackles, input_name='broken_tackles'))
        if self.kneel_down is not None and 'kneel_down' not in already_processed:
            already_processed.add('kneel_down')
            outfile.write(' kneel_down="%s"' % self.gds_format_integer(self.kneel_down, input_name='kneel_down'))
        if self.scramble is not None and 'scramble' not in already_processed:
            already_processed.add('scramble')
            outfile.write(' scramble="%s"' % self.gds_format_integer(self.scramble, input_name='scramble'))
        if self.yards_after_contact is not None and 'yards_after_contact' not in already_processed:
            already_processed.add('yards_after_contact')
            outfile.write(' yards_after_contact="%s"' % self.gds_format_integer(self.yards_after_contact, input_name='yards_after_contact'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='rushType14', fromsubclass_=False, pretty_print=True):
        super(rushType14, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('attempt', node)
        if value is not None and 'attempt' not in already_processed:
            already_processed.add('attempt')
            self.attempt = self.gds_parse_integer(value, node, 'attempt')
        value = find_attr_value_('yards', node)
        if value is not None and 'yards' not in already_processed:
            already_processed.add('yards')
            self.yards = self.gds_parse_integer(value, node, 'yards')
        value = find_attr_value_('touchdown', node)
        if value is not None and 'touchdown' not in already_processed:
            already_processed.add('touchdown')
            self.touchdown = self.gds_parse_integer(value, node, 'touchdown')
        value = find_attr_value_('firstdown', node)
        if value is not None and 'firstdown' not in already_processed:
            already_processed.add('firstdown')
            self.firstdown = self.gds_parse_integer(value, node, 'firstdown')
        value = find_attr_value_('safety', node)
        if value is not None and 'safety' not in already_processed:
            already_processed.add('safety')
            self.safety = self.gds_parse_integer(value, node, 'safety')
        value = find_attr_value_('fumble', node)
        if value is not None and 'fumble' not in already_processed:
            already_processed.add('fumble')
            self.fumble = self.gds_parse_integer(value, node, 'fumble')
        value = find_attr_value_('inside_20', node)
        if value is not None and 'inside_20' not in already_processed:
            already_processed.add('inside_20')
            self.inside_20 = self.gds_parse_integer(value, node, 'inside_20')
        value = find_attr_value_('goaltogo', node)
        if value is not None and 'goaltogo' not in already_processed:
            already_processed.add('goaltogo')
            self.goaltogo = self.gds_parse_integer(value, node, 'goaltogo')
        value = find_attr_value_('lateral', node)
        if value is not None and 'lateral' not in already_processed:
            already_processed.add('lateral')
            self.lateral = self.gds_parse_integer(value, node, 'lateral')
        value = find_attr_value_('tlost', node)
        if value is not None and 'tlost' not in already_processed:
            already_processed.add('tlost')
            self.tlost = self.gds_parse_integer(value, node, 'tlost')
        value = find_attr_value_('tlost_yards', node)
        if value is not None and 'tlost_yards' not in already_processed:
            already_processed.add('tlost_yards')
            self.tlost_yards = self.gds_parse_integer(value, node, 'tlost_yards')
        value = find_attr_value_('broken_tackles', node)
        if value is not None and 'broken_tackles' not in already_processed:
            already_processed.add('broken_tackles')
            self.broken_tackles = self.gds_parse_integer(value, node, 'broken_tackles')
        value = find_attr_value_('kneel_down', node)
        if value is not None and 'kneel_down' not in already_processed:
            already_processed.add('kneel_down')
            self.kneel_down = self.gds_parse_integer(value, node, 'kneel_down')
        value = find_attr_value_('scramble', node)
        if value is not None and 'scramble' not in already_processed:
            already_processed.add('scramble')
            self.scramble = self.gds_parse_integer(value, node, 'scramble')
        value = find_attr_value_('yards_after_contact', node)
        if value is not None and 'yards_after_contact' not in already_processed:
            already_processed.add('yards_after_contact')
            self.yards_after_contact = self.gds_parse_integer(value, node, 'yards_after_contact')
        super(rushType14, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(rushType14, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class rushType14


class kickType15(basePlayStatisticType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = basePlayStatisticType
    def __init__(self, nullified=None, team=None, player=None, attempt=None, yards=None, net_yards=None, gross_yards=None, inside_20=None, endzone=None, touchback=None, own_rec=None, own_rec_td=None, onside_attempt=None, onside_success=None, squib_kick=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("kickType15"), self).__init__(nullified, team, player,  **kwargs_)
        self.attempt = _cast(int, attempt)
        self.attempt_nsprefix_ = None
        self.yards = _cast(int, yards)
        self.yards_nsprefix_ = None
        self.net_yards = _cast(int, net_yards)
        self.net_yards_nsprefix_ = None
        self.gross_yards = _cast(int, gross_yards)
        self.gross_yards_nsprefix_ = None
        self.inside_20 = _cast(int, inside_20)
        self.inside_20_nsprefix_ = None
        self.endzone = _cast(int, endzone)
        self.endzone_nsprefix_ = None
        self.touchback = _cast(int, touchback)
        self.touchback_nsprefix_ = None
        self.own_rec = _cast(int, own_rec)
        self.own_rec_nsprefix_ = None
        self.own_rec_td = _cast(int, own_rec_td)
        self.own_rec_td_nsprefix_ = None
        self.onside_attempt = _cast(int, onside_attempt)
        self.onside_attempt_nsprefix_ = None
        self.onside_success = _cast(int, onside_success)
        self.onside_success_nsprefix_ = None
        self.squib_kick = _cast(int, squib_kick)
        self.squib_kick_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, kickType15)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if kickType15.subclass:
            return kickType15.subclass(*args_, **kwargs_)
        else:
            return kickType15(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_attempt(self):
        return self.attempt
    def set_attempt(self, attempt):
        self.attempt = attempt
    def get_yards(self):
        return self.yards
    def set_yards(self, yards):
        self.yards = yards
    def get_net_yards(self):
        return self.net_yards
    def set_net_yards(self, net_yards):
        self.net_yards = net_yards
    def get_gross_yards(self):
        return self.gross_yards
    def set_gross_yards(self, gross_yards):
        self.gross_yards = gross_yards
    def get_inside_20(self):
        return self.inside_20
    def set_inside_20(self, inside_20):
        self.inside_20 = inside_20
    def get_endzone(self):
        return self.endzone
    def set_endzone(self, endzone):
        self.endzone = endzone
    def get_touchback(self):
        return self.touchback
    def set_touchback(self, touchback):
        self.touchback = touchback
    def get_own_rec(self):
        return self.own_rec
    def set_own_rec(self, own_rec):
        self.own_rec = own_rec
    def get_own_rec_td(self):
        return self.own_rec_td
    def set_own_rec_td(self, own_rec_td):
        self.own_rec_td = own_rec_td
    def get_onside_attempt(self):
        return self.onside_attempt
    def set_onside_attempt(self, onside_attempt):
        self.onside_attempt = onside_attempt
    def get_onside_success(self):
        return self.onside_success
    def set_onside_success(self, onside_success):
        self.onside_success = onside_success
    def get_squib_kick(self):
        return self.squib_kick
    def set_squib_kick(self, squib_kick):
        self.squib_kick = squib_kick
    def has__content(self):
        if (
            super(kickType15, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='kickType15', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('kickType15')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'kickType15':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='kickType15')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='kickType15', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='kickType15'):
        super(kickType15, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='kickType15')
        if self.attempt is not None and 'attempt' not in already_processed:
            already_processed.add('attempt')
            outfile.write(' attempt="%s"' % self.gds_format_integer(self.attempt, input_name='attempt'))
        if self.yards is not None and 'yards' not in already_processed:
            already_processed.add('yards')
            outfile.write(' yards="%s"' % self.gds_format_integer(self.yards, input_name='yards'))
        if self.net_yards is not None and 'net_yards' not in already_processed:
            already_processed.add('net_yards')
            outfile.write(' net_yards="%s"' % self.gds_format_integer(self.net_yards, input_name='net_yards'))
        if self.gross_yards is not None and 'gross_yards' not in already_processed:
            already_processed.add('gross_yards')
            outfile.write(' gross_yards="%s"' % self.gds_format_integer(self.gross_yards, input_name='gross_yards'))
        if self.inside_20 is not None and 'inside_20' not in already_processed:
            already_processed.add('inside_20')
            outfile.write(' inside_20="%s"' % self.gds_format_integer(self.inside_20, input_name='inside_20'))
        if self.endzone is not None and 'endzone' not in already_processed:
            already_processed.add('endzone')
            outfile.write(' endzone="%s"' % self.gds_format_integer(self.endzone, input_name='endzone'))
        if self.touchback is not None and 'touchback' not in already_processed:
            already_processed.add('touchback')
            outfile.write(' touchback="%s"' % self.gds_format_integer(self.touchback, input_name='touchback'))
        if self.own_rec is not None and 'own_rec' not in already_processed:
            already_processed.add('own_rec')
            outfile.write(' own_rec="%s"' % self.gds_format_integer(self.own_rec, input_name='own_rec'))
        if self.own_rec_td is not None and 'own_rec_td' not in already_processed:
            already_processed.add('own_rec_td')
            outfile.write(' own_rec_td="%s"' % self.gds_format_integer(self.own_rec_td, input_name='own_rec_td'))
        if self.onside_attempt is not None and 'onside_attempt' not in already_processed:
            already_processed.add('onside_attempt')
            outfile.write(' onside_attempt="%s"' % self.gds_format_integer(self.onside_attempt, input_name='onside_attempt'))
        if self.onside_success is not None and 'onside_success' not in already_processed:
            already_processed.add('onside_success')
            outfile.write(' onside_success="%s"' % self.gds_format_integer(self.onside_success, input_name='onside_success'))
        if self.squib_kick is not None and 'squib_kick' not in already_processed:
            already_processed.add('squib_kick')
            outfile.write(' squib_kick="%s"' % self.gds_format_integer(self.squib_kick, input_name='squib_kick'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='kickType15', fromsubclass_=False, pretty_print=True):
        super(kickType15, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('attempt', node)
        if value is not None and 'attempt' not in already_processed:
            already_processed.add('attempt')
            self.attempt = self.gds_parse_integer(value, node, 'attempt')
        value = find_attr_value_('yards', node)
        if value is not None and 'yards' not in already_processed:
            already_processed.add('yards')
            self.yards = self.gds_parse_integer(value, node, 'yards')
        value = find_attr_value_('net_yards', node)
        if value is not None and 'net_yards' not in already_processed:
            already_processed.add('net_yards')
            self.net_yards = self.gds_parse_integer(value, node, 'net_yards')
        value = find_attr_value_('gross_yards', node)
        if value is not None and 'gross_yards' not in already_processed:
            already_processed.add('gross_yards')
            self.gross_yards = self.gds_parse_integer(value, node, 'gross_yards')
        value = find_attr_value_('inside_20', node)
        if value is not None and 'inside_20' not in already_processed:
            already_processed.add('inside_20')
            self.inside_20 = self.gds_parse_integer(value, node, 'inside_20')
        value = find_attr_value_('endzone', node)
        if value is not None and 'endzone' not in already_processed:
            already_processed.add('endzone')
            self.endzone = self.gds_parse_integer(value, node, 'endzone')
        value = find_attr_value_('touchback', node)
        if value is not None and 'touchback' not in already_processed:
            already_processed.add('touchback')
            self.touchback = self.gds_parse_integer(value, node, 'touchback')
        value = find_attr_value_('own_rec', node)
        if value is not None and 'own_rec' not in already_processed:
            already_processed.add('own_rec')
            self.own_rec = self.gds_parse_integer(value, node, 'own_rec')
        value = find_attr_value_('own_rec_td', node)
        if value is not None and 'own_rec_td' not in already_processed:
            already_processed.add('own_rec_td')
            self.own_rec_td = self.gds_parse_integer(value, node, 'own_rec_td')
        value = find_attr_value_('onside_attempt', node)
        if value is not None and 'onside_attempt' not in already_processed:
            already_processed.add('onside_attempt')
            self.onside_attempt = self.gds_parse_integer(value, node, 'onside_attempt')
        value = find_attr_value_('onside_success', node)
        if value is not None and 'onside_success' not in already_processed:
            already_processed.add('onside_success')
            self.onside_success = self.gds_parse_integer(value, node, 'onside_success')
        value = find_attr_value_('squib_kick', node)
        if value is not None and 'squib_kick' not in already_processed:
            already_processed.add('squib_kick')
            self.squib_kick = self.gds_parse_integer(value, node, 'squib_kick')
        super(kickType15, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(kickType15, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class kickType15


class puntType16(basePlayStatisticType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = basePlayStatisticType
    def __init__(self, nullified=None, team=None, player=None, attempt=None, yards=None, net_yards=None, inside_20=None, endzone=None, touchback=None, blocked=None, safety=None, hang_time=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("puntType16"), self).__init__(nullified, team, player,  **kwargs_)
        self.attempt = _cast(int, attempt)
        self.attempt_nsprefix_ = None
        self.yards = _cast(int, yards)
        self.yards_nsprefix_ = None
        self.net_yards = _cast(int, net_yards)
        self.net_yards_nsprefix_ = None
        self.inside_20 = _cast(int, inside_20)
        self.inside_20_nsprefix_ = None
        self.endzone = _cast(int, endzone)
        self.endzone_nsprefix_ = None
        self.touchback = _cast(int, touchback)
        self.touchback_nsprefix_ = None
        self.blocked = _cast(int, blocked)
        self.blocked_nsprefix_ = None
        self.safety = _cast(int, safety)
        self.safety_nsprefix_ = None
        self.hang_time = _cast(float, hang_time)
        self.hang_time_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, puntType16)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if puntType16.subclass:
            return puntType16.subclass(*args_, **kwargs_)
        else:
            return puntType16(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_attempt(self):
        return self.attempt
    def set_attempt(self, attempt):
        self.attempt = attempt
    def get_yards(self):
        return self.yards
    def set_yards(self, yards):
        self.yards = yards
    def get_net_yards(self):
        return self.net_yards
    def set_net_yards(self, net_yards):
        self.net_yards = net_yards
    def get_inside_20(self):
        return self.inside_20
    def set_inside_20(self, inside_20):
        self.inside_20 = inside_20
    def get_endzone(self):
        return self.endzone
    def set_endzone(self, endzone):
        self.endzone = endzone
    def get_touchback(self):
        return self.touchback
    def set_touchback(self, touchback):
        self.touchback = touchback
    def get_blocked(self):
        return self.blocked
    def set_blocked(self, blocked):
        self.blocked = blocked
    def get_safety(self):
        return self.safety
    def set_safety(self, safety):
        self.safety = safety
    def get_hang_time(self):
        return self.hang_time
    def set_hang_time(self, hang_time):
        self.hang_time = hang_time
    def has__content(self):
        if (
            super(puntType16, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='puntType16', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('puntType16')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'puntType16':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='puntType16')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='puntType16', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='puntType16'):
        super(puntType16, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='puntType16')
        if self.attempt is not None and 'attempt' not in already_processed:
            already_processed.add('attempt')
            outfile.write(' attempt="%s"' % self.gds_format_integer(self.attempt, input_name='attempt'))
        if self.yards is not None and 'yards' not in already_processed:
            already_processed.add('yards')
            outfile.write(' yards="%s"' % self.gds_format_integer(self.yards, input_name='yards'))
        if self.net_yards is not None and 'net_yards' not in already_processed:
            already_processed.add('net_yards')
            outfile.write(' net_yards="%s"' % self.gds_format_integer(self.net_yards, input_name='net_yards'))
        if self.inside_20 is not None and 'inside_20' not in already_processed:
            already_processed.add('inside_20')
            outfile.write(' inside_20="%s"' % self.gds_format_integer(self.inside_20, input_name='inside_20'))
        if self.endzone is not None and 'endzone' not in already_processed:
            already_processed.add('endzone')
            outfile.write(' endzone="%s"' % self.gds_format_integer(self.endzone, input_name='endzone'))
        if self.touchback is not None and 'touchback' not in already_processed:
            already_processed.add('touchback')
            outfile.write(' touchback="%s"' % self.gds_format_integer(self.touchback, input_name='touchback'))
        if self.blocked is not None and 'blocked' not in already_processed:
            already_processed.add('blocked')
            outfile.write(' blocked="%s"' % self.gds_format_integer(self.blocked, input_name='blocked'))
        if self.safety is not None and 'safety' not in already_processed:
            already_processed.add('safety')
            outfile.write(' safety="%s"' % self.gds_format_integer(self.safety, input_name='safety'))
        if self.hang_time is not None and 'hang_time' not in already_processed:
            already_processed.add('hang_time')
            outfile.write(' hang_time="%s"' % self.gds_format_double(self.hang_time, input_name='hang_time'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='puntType16', fromsubclass_=False, pretty_print=True):
        super(puntType16, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('attempt', node)
        if value is not None and 'attempt' not in already_processed:
            already_processed.add('attempt')
            self.attempt = self.gds_parse_integer(value, node, 'attempt')
        value = find_attr_value_('yards', node)
        if value is not None and 'yards' not in already_processed:
            already_processed.add('yards')
            self.yards = self.gds_parse_integer(value, node, 'yards')
        value = find_attr_value_('net_yards', node)
        if value is not None and 'net_yards' not in already_processed:
            already_processed.add('net_yards')
            self.net_yards = self.gds_parse_integer(value, node, 'net_yards')
        value = find_attr_value_('inside_20', node)
        if value is not None and 'inside_20' not in already_processed:
            already_processed.add('inside_20')
            self.inside_20 = self.gds_parse_integer(value, node, 'inside_20')
        value = find_attr_value_('endzone', node)
        if value is not None and 'endzone' not in already_processed:
            already_processed.add('endzone')
            self.endzone = self.gds_parse_integer(value, node, 'endzone')
        value = find_attr_value_('touchback', node)
        if value is not None and 'touchback' not in already_processed:
            already_processed.add('touchback')
            self.touchback = self.gds_parse_integer(value, node, 'touchback')
        value = find_attr_value_('blocked', node)
        if value is not None and 'blocked' not in already_processed:
            already_processed.add('blocked')
            self.blocked = self.gds_parse_integer(value, node, 'blocked')
        value = find_attr_value_('safety', node)
        if value is not None and 'safety' not in already_processed:
            already_processed.add('safety')
            self.safety = self.gds_parse_integer(value, node, 'safety')
        value = find_attr_value_('hang_time', node)
        if value is not None and 'hang_time' not in already_processed:
            already_processed.add('hang_time')
            value = self.gds_parse_double(value, node, 'hang_time')
            self.hang_time = value
        super(puntType16, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(puntType16, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class puntType16


class field_goalType17(basePlayStatisticType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = basePlayStatisticType
    def __init__(self, nullified=None, team=None, player=None, attempt=None, att_yards=None, yards=None, missed=None, made=None, blocked=None, returned=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("field_goalType17"), self).__init__(nullified, team, player,  **kwargs_)
        self.attempt = _cast(int, attempt)
        self.attempt_nsprefix_ = None
        self.att_yards = _cast(int, att_yards)
        self.att_yards_nsprefix_ = None
        self.yards = _cast(int, yards)
        self.yards_nsprefix_ = None
        self.missed = _cast(int, missed)
        self.missed_nsprefix_ = None
        self.made = _cast(int, made)
        self.made_nsprefix_ = None
        self.blocked = _cast(int, blocked)
        self.blocked_nsprefix_ = None
        self.returned = _cast(int, returned)
        self.returned_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, field_goalType17)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if field_goalType17.subclass:
            return field_goalType17.subclass(*args_, **kwargs_)
        else:
            return field_goalType17(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_attempt(self):
        return self.attempt
    def set_attempt(self, attempt):
        self.attempt = attempt
    def get_att_yards(self):
        return self.att_yards
    def set_att_yards(self, att_yards):
        self.att_yards = att_yards
    def get_yards(self):
        return self.yards
    def set_yards(self, yards):
        self.yards = yards
    def get_missed(self):
        return self.missed
    def set_missed(self, missed):
        self.missed = missed
    def get_made(self):
        return self.made
    def set_made(self, made):
        self.made = made
    def get_blocked(self):
        return self.blocked
    def set_blocked(self, blocked):
        self.blocked = blocked
    def get_returned(self):
        return self.returned
    def set_returned(self, returned):
        self.returned = returned
    def has__content(self):
        if (
            super(field_goalType17, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='field_goalType17', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('field_goalType17')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'field_goalType17':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='field_goalType17')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='field_goalType17', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='field_goalType17'):
        super(field_goalType17, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='field_goalType17')
        if self.attempt is not None and 'attempt' not in already_processed:
            already_processed.add('attempt')
            outfile.write(' attempt="%s"' % self.gds_format_integer(self.attempt, input_name='attempt'))
        if self.att_yards is not None and 'att_yards' not in already_processed:
            already_processed.add('att_yards')
            outfile.write(' att_yards="%s"' % self.gds_format_integer(self.att_yards, input_name='att_yards'))
        if self.yards is not None and 'yards' not in already_processed:
            already_processed.add('yards')
            outfile.write(' yards="%s"' % self.gds_format_integer(self.yards, input_name='yards'))
        if self.missed is not None and 'missed' not in already_processed:
            already_processed.add('missed')
            outfile.write(' missed="%s"' % self.gds_format_integer(self.missed, input_name='missed'))
        if self.made is not None and 'made' not in already_processed:
            already_processed.add('made')
            outfile.write(' made="%s"' % self.gds_format_integer(self.made, input_name='made'))
        if self.blocked is not None and 'blocked' not in already_processed:
            already_processed.add('blocked')
            outfile.write(' blocked="%s"' % self.gds_format_integer(self.blocked, input_name='blocked'))
        if self.returned is not None and 'returned' not in already_processed:
            already_processed.add('returned')
            outfile.write(' returned="%s"' % self.gds_format_integer(self.returned, input_name='returned'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='field_goalType17', fromsubclass_=False, pretty_print=True):
        super(field_goalType17, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('attempt', node)
        if value is not None and 'attempt' not in already_processed:
            already_processed.add('attempt')
            self.attempt = self.gds_parse_integer(value, node, 'attempt')
        value = find_attr_value_('att_yards', node)
        if value is not None and 'att_yards' not in already_processed:
            already_processed.add('att_yards')
            self.att_yards = self.gds_parse_integer(value, node, 'att_yards')
        value = find_attr_value_('yards', node)
        if value is not None and 'yards' not in already_processed:
            already_processed.add('yards')
            self.yards = self.gds_parse_integer(value, node, 'yards')
        value = find_attr_value_('missed', node)
        if value is not None and 'missed' not in already_processed:
            already_processed.add('missed')
            self.missed = self.gds_parse_integer(value, node, 'missed')
        value = find_attr_value_('made', node)
        if value is not None and 'made' not in already_processed:
            already_processed.add('made')
            self.made = self.gds_parse_integer(value, node, 'made')
        value = find_attr_value_('blocked', node)
        if value is not None and 'blocked' not in already_processed:
            already_processed.add('blocked')
            self.blocked = self.gds_parse_integer(value, node, 'blocked')
        value = find_attr_value_('returned', node)
        if value is not None and 'returned' not in already_processed:
            already_processed.add('returned')
            self.returned = self.gds_parse_integer(value, node, 'returned')
        super(field_goalType17, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(field_goalType17, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class field_goalType17


class extra_pointType18(basePlayStatisticType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = basePlayStatisticType
    def __init__(self, nullified=None, team=None, player=None, attempt=None, missed=None, made=None, blocked=None, returned=None, safety=None, aborted=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("extra_pointType18"), self).__init__(nullified, team, player,  **kwargs_)
        self.attempt = _cast(int, attempt)
        self.attempt_nsprefix_ = None
        self.missed = _cast(int, missed)
        self.missed_nsprefix_ = None
        self.made = _cast(int, made)
        self.made_nsprefix_ = None
        self.blocked = _cast(int, blocked)
        self.blocked_nsprefix_ = None
        self.returned = _cast(int, returned)
        self.returned_nsprefix_ = None
        self.safety = _cast(int, safety)
        self.safety_nsprefix_ = None
        self.aborted = _cast(int, aborted)
        self.aborted_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, extra_pointType18)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if extra_pointType18.subclass:
            return extra_pointType18.subclass(*args_, **kwargs_)
        else:
            return extra_pointType18(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_attempt(self):
        return self.attempt
    def set_attempt(self, attempt):
        self.attempt = attempt
    def get_missed(self):
        return self.missed
    def set_missed(self, missed):
        self.missed = missed
    def get_made(self):
        return self.made
    def set_made(self, made):
        self.made = made
    def get_blocked(self):
        return self.blocked
    def set_blocked(self, blocked):
        self.blocked = blocked
    def get_returned(self):
        return self.returned
    def set_returned(self, returned):
        self.returned = returned
    def get_safety(self):
        return self.safety
    def set_safety(self, safety):
        self.safety = safety
    def get_aborted(self):
        return self.aborted
    def set_aborted(self, aborted):
        self.aborted = aborted
    def has__content(self):
        if (
            super(extra_pointType18, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='extra_pointType18', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('extra_pointType18')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'extra_pointType18':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='extra_pointType18')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='extra_pointType18', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='extra_pointType18'):
        super(extra_pointType18, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='extra_pointType18')
        if self.attempt is not None and 'attempt' not in already_processed:
            already_processed.add('attempt')
            outfile.write(' attempt="%s"' % self.gds_format_integer(self.attempt, input_name='attempt'))
        if self.missed is not None and 'missed' not in already_processed:
            already_processed.add('missed')
            outfile.write(' missed="%s"' % self.gds_format_integer(self.missed, input_name='missed'))
        if self.made is not None and 'made' not in already_processed:
            already_processed.add('made')
            outfile.write(' made="%s"' % self.gds_format_integer(self.made, input_name='made'))
        if self.blocked is not None and 'blocked' not in already_processed:
            already_processed.add('blocked')
            outfile.write(' blocked="%s"' % self.gds_format_integer(self.blocked, input_name='blocked'))
        if self.returned is not None and 'returned' not in already_processed:
            already_processed.add('returned')
            outfile.write(' returned="%s"' % self.gds_format_integer(self.returned, input_name='returned'))
        if self.safety is not None and 'safety' not in already_processed:
            already_processed.add('safety')
            outfile.write(' safety="%s"' % self.gds_format_integer(self.safety, input_name='safety'))
        if self.aborted is not None and 'aborted' not in already_processed:
            already_processed.add('aborted')
            outfile.write(' aborted="%s"' % self.gds_format_integer(self.aborted, input_name='aborted'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='extra_pointType18', fromsubclass_=False, pretty_print=True):
        super(extra_pointType18, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('attempt', node)
        if value is not None and 'attempt' not in already_processed:
            already_processed.add('attempt')
            self.attempt = self.gds_parse_integer(value, node, 'attempt')
        value = find_attr_value_('missed', node)
        if value is not None and 'missed' not in already_processed:
            already_processed.add('missed')
            self.missed = self.gds_parse_integer(value, node, 'missed')
        value = find_attr_value_('made', node)
        if value is not None and 'made' not in already_processed:
            already_processed.add('made')
            self.made = self.gds_parse_integer(value, node, 'made')
        value = find_attr_value_('blocked', node)
        if value is not None and 'blocked' not in already_processed:
            already_processed.add('blocked')
            self.blocked = self.gds_parse_integer(value, node, 'blocked')
        value = find_attr_value_('returned', node)
        if value is not None and 'returned' not in already_processed:
            already_processed.add('returned')
            self.returned = self.gds_parse_integer(value, node, 'returned')
        value = find_attr_value_('safety', node)
        if value is not None and 'safety' not in already_processed:
            already_processed.add('safety')
            self.safety = self.gds_parse_integer(value, node, 'safety')
        value = find_attr_value_('aborted', node)
        if value is not None and 'aborted' not in already_processed:
            already_processed.add('aborted')
            self.aborted = self.gds_parse_integer(value, node, 'aborted')
        super(extra_pointType18, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(extra_pointType18, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class extra_pointType18


class penaltyType19(basePlayStatisticType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = basePlayStatisticType
    def __init__(self, nullified=None, team=None, player=None, penalty=None, yards=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("penaltyType19"), self).__init__(nullified, team, player,  **kwargs_)
        self.penalty = _cast(int, penalty)
        self.penalty_nsprefix_ = None
        self.yards = _cast(int, yards)
        self.yards_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, penaltyType19)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if penaltyType19.subclass:
            return penaltyType19.subclass(*args_, **kwargs_)
        else:
            return penaltyType19(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_penalty(self):
        return self.penalty
    def set_penalty(self, penalty):
        self.penalty = penalty
    def get_yards(self):
        return self.yards
    def set_yards(self, yards):
        self.yards = yards
    def has__content(self):
        if (
            super(penaltyType19, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='penaltyType19', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('penaltyType19')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'penaltyType19':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='penaltyType19')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='penaltyType19', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='penaltyType19'):
        super(penaltyType19, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='penaltyType19')
        if self.penalty is not None and 'penalty' not in already_processed:
            already_processed.add('penalty')
            outfile.write(' penalty="%s"' % self.gds_format_integer(self.penalty, input_name='penalty'))
        if self.yards is not None and 'yards' not in already_processed:
            already_processed.add('yards')
            outfile.write(' yards="%s"' % self.gds_format_integer(self.yards, input_name='yards'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='penaltyType19', fromsubclass_=False, pretty_print=True):
        super(penaltyType19, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('penalty', node)
        if value is not None and 'penalty' not in already_processed:
            already_processed.add('penalty')
            self.penalty = self.gds_parse_integer(value, node, 'penalty')
        value = find_attr_value_('yards', node)
        if value is not None and 'yards' not in already_processed:
            already_processed.add('yards')
            self.yards = self.gds_parse_integer(value, node, 'yards')
        super(penaltyType19, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(penaltyType19, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class penaltyType19


class fumbleType20(basePlayStatisticType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = basePlayStatisticType
    def __init__(self, nullified=None, team=None, player=None, fumble=None, forced=None, out_of_bounds=None, own_rec=None, opp_rec=None, own_rec_yards=None, opp_rec_yards=None, own_rec_td=None, opp_rec_td=None, lost=None, play_category=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("fumbleType20"), self).__init__(nullified, team, player,  **kwargs_)
        self.fumble = _cast(int, fumble)
        self.fumble_nsprefix_ = None
        self.forced = _cast(int, forced)
        self.forced_nsprefix_ = None
        self.out_of_bounds = _cast(int, out_of_bounds)
        self.out_of_bounds_nsprefix_ = None
        self.own_rec = _cast(int, own_rec)
        self.own_rec_nsprefix_ = None
        self.opp_rec = _cast(int, opp_rec)
        self.opp_rec_nsprefix_ = None
        self.own_rec_yards = _cast(int, own_rec_yards)
        self.own_rec_yards_nsprefix_ = None
        self.opp_rec_yards = _cast(int, opp_rec_yards)
        self.opp_rec_yards_nsprefix_ = None
        self.own_rec_td = _cast(int, own_rec_td)
        self.own_rec_td_nsprefix_ = None
        self.opp_rec_td = _cast(int, opp_rec_td)
        self.opp_rec_td_nsprefix_ = None
        self.lost = _cast(int, lost)
        self.lost_nsprefix_ = None
        self.play_category = _cast(None, play_category)
        self.play_category_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fumbleType20)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fumbleType20.subclass:
            return fumbleType20.subclass(*args_, **kwargs_)
        else:
            return fumbleType20(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_fumble(self):
        return self.fumble
    def set_fumble(self, fumble):
        self.fumble = fumble
    def get_forced(self):
        return self.forced
    def set_forced(self, forced):
        self.forced = forced
    def get_out_of_bounds(self):
        return self.out_of_bounds
    def set_out_of_bounds(self, out_of_bounds):
        self.out_of_bounds = out_of_bounds
    def get_own_rec(self):
        return self.own_rec
    def set_own_rec(self, own_rec):
        self.own_rec = own_rec
    def get_opp_rec(self):
        return self.opp_rec
    def set_opp_rec(self, opp_rec):
        self.opp_rec = opp_rec
    def get_own_rec_yards(self):
        return self.own_rec_yards
    def set_own_rec_yards(self, own_rec_yards):
        self.own_rec_yards = own_rec_yards
    def get_opp_rec_yards(self):
        return self.opp_rec_yards
    def set_opp_rec_yards(self, opp_rec_yards):
        self.opp_rec_yards = opp_rec_yards
    def get_own_rec_td(self):
        return self.own_rec_td
    def set_own_rec_td(self, own_rec_td):
        self.own_rec_td = own_rec_td
    def get_opp_rec_td(self):
        return self.opp_rec_td
    def set_opp_rec_td(self, opp_rec_td):
        self.opp_rec_td = opp_rec_td
    def get_lost(self):
        return self.lost
    def set_lost(self, lost):
        self.lost = lost
    def get_play_category(self):
        return self.play_category
    def set_play_category(self, play_category):
        self.play_category = play_category
    def has__content(self):
        if (
            super(fumbleType20, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='fumbleType20', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fumbleType20')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'fumbleType20':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='fumbleType20')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='fumbleType20', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='fumbleType20'):
        super(fumbleType20, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='fumbleType20')
        if self.fumble is not None and 'fumble' not in already_processed:
            already_processed.add('fumble')
            outfile.write(' fumble="%s"' % self.gds_format_integer(self.fumble, input_name='fumble'))
        if self.forced is not None and 'forced' not in already_processed:
            already_processed.add('forced')
            outfile.write(' forced="%s"' % self.gds_format_integer(self.forced, input_name='forced'))
        if self.out_of_bounds is not None and 'out_of_bounds' not in already_processed:
            already_processed.add('out_of_bounds')
            outfile.write(' out_of_bounds="%s"' % self.gds_format_integer(self.out_of_bounds, input_name='out_of_bounds'))
        if self.own_rec is not None and 'own_rec' not in already_processed:
            already_processed.add('own_rec')
            outfile.write(' own_rec="%s"' % self.gds_format_integer(self.own_rec, input_name='own_rec'))
        if self.opp_rec is not None and 'opp_rec' not in already_processed:
            already_processed.add('opp_rec')
            outfile.write(' opp_rec="%s"' % self.gds_format_integer(self.opp_rec, input_name='opp_rec'))
        if self.own_rec_yards is not None and 'own_rec_yards' not in already_processed:
            already_processed.add('own_rec_yards')
            outfile.write(' own_rec_yards="%s"' % self.gds_format_integer(self.own_rec_yards, input_name='own_rec_yards'))
        if self.opp_rec_yards is not None and 'opp_rec_yards' not in already_processed:
            already_processed.add('opp_rec_yards')
            outfile.write(' opp_rec_yards="%s"' % self.gds_format_integer(self.opp_rec_yards, input_name='opp_rec_yards'))
        if self.own_rec_td is not None and 'own_rec_td' not in already_processed:
            already_processed.add('own_rec_td')
            outfile.write(' own_rec_td="%s"' % self.gds_format_integer(self.own_rec_td, input_name='own_rec_td'))
        if self.opp_rec_td is not None and 'opp_rec_td' not in already_processed:
            already_processed.add('opp_rec_td')
            outfile.write(' opp_rec_td="%s"' % self.gds_format_integer(self.opp_rec_td, input_name='opp_rec_td'))
        if self.lost is not None and 'lost' not in already_processed:
            already_processed.add('lost')
            outfile.write(' lost="%s"' % self.gds_format_integer(self.lost, input_name='lost'))
        if self.play_category is not None and 'play_category' not in already_processed:
            already_processed.add('play_category')
            outfile.write(' play_category=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.play_category), input_name='play_category')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='fumbleType20', fromsubclass_=False, pretty_print=True):
        super(fumbleType20, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('fumble', node)
        if value is not None and 'fumble' not in already_processed:
            already_processed.add('fumble')
            self.fumble = self.gds_parse_integer(value, node, 'fumble')
        value = find_attr_value_('forced', node)
        if value is not None and 'forced' not in already_processed:
            already_processed.add('forced')
            self.forced = self.gds_parse_integer(value, node, 'forced')
        value = find_attr_value_('out_of_bounds', node)
        if value is not None and 'out_of_bounds' not in already_processed:
            already_processed.add('out_of_bounds')
            self.out_of_bounds = self.gds_parse_integer(value, node, 'out_of_bounds')
        value = find_attr_value_('own_rec', node)
        if value is not None and 'own_rec' not in already_processed:
            already_processed.add('own_rec')
            self.own_rec = self.gds_parse_integer(value, node, 'own_rec')
        value = find_attr_value_('opp_rec', node)
        if value is not None and 'opp_rec' not in already_processed:
            already_processed.add('opp_rec')
            self.opp_rec = self.gds_parse_integer(value, node, 'opp_rec')
        value = find_attr_value_('own_rec_yards', node)
        if value is not None and 'own_rec_yards' not in already_processed:
            already_processed.add('own_rec_yards')
            self.own_rec_yards = self.gds_parse_integer(value, node, 'own_rec_yards')
        value = find_attr_value_('opp_rec_yards', node)
        if value is not None and 'opp_rec_yards' not in already_processed:
            already_processed.add('opp_rec_yards')
            self.opp_rec_yards = self.gds_parse_integer(value, node, 'opp_rec_yards')
        value = find_attr_value_('own_rec_td', node)
        if value is not None and 'own_rec_td' not in already_processed:
            already_processed.add('own_rec_td')
            self.own_rec_td = self.gds_parse_integer(value, node, 'own_rec_td')
        value = find_attr_value_('opp_rec_td', node)
        if value is not None and 'opp_rec_td' not in already_processed:
            already_processed.add('opp_rec_td')
            self.opp_rec_td = self.gds_parse_integer(value, node, 'opp_rec_td')
        value = find_attr_value_('lost', node)
        if value is not None and 'lost' not in already_processed:
            already_processed.add('lost')
            self.lost = self.gds_parse_integer(value, node, 'lost')
        value = find_attr_value_('play_category', node)
        if value is not None and 'play_category' not in already_processed:
            already_processed.add('play_category')
            self.play_category = value
        super(fumbleType20, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(fumbleType20, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class fumbleType20


class returnType21(basePlayStatisticType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = basePlayStatisticType
    def __init__(self, nullified=None, team=None, player=None, return_=None, yards=None, touchdown=None, firstdown=None, faircatch=None, out_of_bounds=None, downed=None, touchback=None, lateral=None, category=None, play_category=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("returnType21"), self).__init__(nullified, team, player,  **kwargs_)
        self.return_ = _cast(int, return_)
        self.return__nsprefix_ = None
        self.yards = _cast(int, yards)
        self.yards_nsprefix_ = None
        self.touchdown = _cast(int, touchdown)
        self.touchdown_nsprefix_ = None
        self.firstdown = _cast(int, firstdown)
        self.firstdown_nsprefix_ = None
        self.faircatch = _cast(int, faircatch)
        self.faircatch_nsprefix_ = None
        self.out_of_bounds = _cast(int, out_of_bounds)
        self.out_of_bounds_nsprefix_ = None
        self.downed = _cast(int, downed)
        self.downed_nsprefix_ = None
        self.touchback = _cast(int, touchback)
        self.touchback_nsprefix_ = None
        self.lateral = _cast(int, lateral)
        self.lateral_nsprefix_ = None
        self.category = _cast(None, category)
        self.category_nsprefix_ = None
        self.play_category = _cast(None, play_category)
        self.play_category_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, returnType21)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if returnType21.subclass:
            return returnType21.subclass(*args_, **kwargs_)
        else:
            return returnType21(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_return(self):
        return self.return_
    def set_return(self, return_):
        self.return_ = return_
    def get_yards(self):
        return self.yards
    def set_yards(self, yards):
        self.yards = yards
    def get_touchdown(self):
        return self.touchdown
    def set_touchdown(self, touchdown):
        self.touchdown = touchdown
    def get_firstdown(self):
        return self.firstdown
    def set_firstdown(self, firstdown):
        self.firstdown = firstdown
    def get_faircatch(self):
        return self.faircatch
    def set_faircatch(self, faircatch):
        self.faircatch = faircatch
    def get_out_of_bounds(self):
        return self.out_of_bounds
    def set_out_of_bounds(self, out_of_bounds):
        self.out_of_bounds = out_of_bounds
    def get_downed(self):
        return self.downed
    def set_downed(self, downed):
        self.downed = downed
    def get_touchback(self):
        return self.touchback
    def set_touchback(self, touchback):
        self.touchback = touchback
    def get_lateral(self):
        return self.lateral
    def set_lateral(self, lateral):
        self.lateral = lateral
    def get_category(self):
        return self.category
    def set_category(self, category):
        self.category = category
    def get_play_category(self):
        return self.play_category
    def set_play_category(self, play_category):
        self.play_category = play_category
    def validate_categoryType22(self, value):
        # Validate type categoryType22, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['punt_return', 'kick_return']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on categoryType22' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            super(returnType21, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='returnType21', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('returnType21')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'returnType21':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='returnType21')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='returnType21', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='returnType21'):
        super(returnType21, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='returnType21')
        if self.return_ is not None and 'return_' not in already_processed:
            already_processed.add('return_')
            outfile.write(' return="%s"' % self.gds_format_integer(self.return_, input_name='return'))
        if self.yards is not None and 'yards' not in already_processed:
            already_processed.add('yards')
            outfile.write(' yards="%s"' % self.gds_format_integer(self.yards, input_name='yards'))
        if self.touchdown is not None and 'touchdown' not in already_processed:
            already_processed.add('touchdown')
            outfile.write(' touchdown="%s"' % self.gds_format_integer(self.touchdown, input_name='touchdown'))
        if self.firstdown is not None and 'firstdown' not in already_processed:
            already_processed.add('firstdown')
            outfile.write(' firstdown="%s"' % self.gds_format_integer(self.firstdown, input_name='firstdown'))
        if self.faircatch is not None and 'faircatch' not in already_processed:
            already_processed.add('faircatch')
            outfile.write(' faircatch="%s"' % self.gds_format_integer(self.faircatch, input_name='faircatch'))
        if self.out_of_bounds is not None and 'out_of_bounds' not in already_processed:
            already_processed.add('out_of_bounds')
            outfile.write(' out_of_bounds="%s"' % self.gds_format_integer(self.out_of_bounds, input_name='out_of_bounds'))
        if self.downed is not None and 'downed' not in already_processed:
            already_processed.add('downed')
            outfile.write(' downed="%s"' % self.gds_format_integer(self.downed, input_name='downed'))
        if self.touchback is not None and 'touchback' not in already_processed:
            already_processed.add('touchback')
            outfile.write(' touchback="%s"' % self.gds_format_integer(self.touchback, input_name='touchback'))
        if self.lateral is not None and 'lateral' not in already_processed:
            already_processed.add('lateral')
            outfile.write(' lateral="%s"' % self.gds_format_integer(self.lateral, input_name='lateral'))
        if self.category is not None and 'category' not in already_processed:
            already_processed.add('category')
            outfile.write(' category=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.category), input_name='category')), ))
        if self.play_category is not None and 'play_category' not in already_processed:
            already_processed.add('play_category')
            outfile.write(' play_category=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.play_category), input_name='play_category')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='returnType21', fromsubclass_=False, pretty_print=True):
        super(returnType21, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('return', node)
        if value is not None and 'return' not in already_processed:
            already_processed.add('return')
            self.return_ = self.gds_parse_integer(value, node, 'return')
        value = find_attr_value_('yards', node)
        if value is not None and 'yards' not in already_processed:
            already_processed.add('yards')
            self.yards = self.gds_parse_integer(value, node, 'yards')
        value = find_attr_value_('touchdown', node)
        if value is not None and 'touchdown' not in already_processed:
            already_processed.add('touchdown')
            self.touchdown = self.gds_parse_integer(value, node, 'touchdown')
        value = find_attr_value_('firstdown', node)
        if value is not None and 'firstdown' not in already_processed:
            already_processed.add('firstdown')
            self.firstdown = self.gds_parse_integer(value, node, 'firstdown')
        value = find_attr_value_('faircatch', node)
        if value is not None and 'faircatch' not in already_processed:
            already_processed.add('faircatch')
            self.faircatch = self.gds_parse_integer(value, node, 'faircatch')
        value = find_attr_value_('out_of_bounds', node)
        if value is not None and 'out_of_bounds' not in already_processed:
            already_processed.add('out_of_bounds')
            self.out_of_bounds = self.gds_parse_integer(value, node, 'out_of_bounds')
        value = find_attr_value_('downed', node)
        if value is not None and 'downed' not in already_processed:
            already_processed.add('downed')
            self.downed = self.gds_parse_integer(value, node, 'downed')
        value = find_attr_value_('touchback', node)
        if value is not None and 'touchback' not in already_processed:
            already_processed.add('touchback')
            self.touchback = self.gds_parse_integer(value, node, 'touchback')
        value = find_attr_value_('lateral', node)
        if value is not None and 'lateral' not in already_processed:
            already_processed.add('lateral')
            self.lateral = self.gds_parse_integer(value, node, 'lateral')
        value = find_attr_value_('category', node)
        if value is not None and 'category' not in already_processed:
            already_processed.add('category')
            self.category = value
            self.validate_categoryType22(self.category)    # validate type categoryType22
        value = find_attr_value_('play_category', node)
        if value is not None and 'play_category' not in already_processed:
            already_processed.add('play_category')
            self.play_category = value
        super(returnType21, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(returnType21, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class returnType21


class blockType23(basePlayStatisticType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = basePlayStatisticType
    def __init__(self, nullified=None, team=None, player=None, block=None, category=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("blockType23"), self).__init__(nullified, team, player,  **kwargs_)
        self.block = _cast(int, block)
        self.block_nsprefix_ = None
        self.category = _cast(None, category)
        self.category_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, blockType23)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if blockType23.subclass:
            return blockType23.subclass(*args_, **kwargs_)
        else:
            return blockType23(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_block(self):
        return self.block
    def set_block(self, block):
        self.block = block
    def get_category(self):
        return self.category
    def set_category(self, category):
        self.category = category
    def validate_categoryType24(self, value):
        # Validate type categoryType24, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['field_goal', 'extra_point', 'punt']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on categoryType24' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            super(blockType23, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='blockType23', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('blockType23')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'blockType23':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='blockType23')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='blockType23', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='blockType23'):
        super(blockType23, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='blockType23')
        if self.block is not None and 'block' not in already_processed:
            already_processed.add('block')
            outfile.write(' block="%s"' % self.gds_format_integer(self.block, input_name='block'))
        if self.category is not None and 'category' not in already_processed:
            already_processed.add('category')
            outfile.write(' category=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.category), input_name='category')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='blockType23', fromsubclass_=False, pretty_print=True):
        super(blockType23, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('block', node)
        if value is not None and 'block' not in already_processed:
            already_processed.add('block')
            self.block = self.gds_parse_integer(value, node, 'block')
        value = find_attr_value_('category', node)
        if value is not None and 'category' not in already_processed:
            already_processed.add('category')
            self.category = value
            self.validate_categoryType24(self.category)    # validate type categoryType24
        super(blockType23, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(blockType23, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class blockType23


class defenseType25(basePlayStatisticType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = basePlayStatisticType
    def __init__(self, nullified=None, team=None, player=None, tackle=None, ast_tackle=None, primary=None, sack=None, ast_sack=None, sack_yards=None, block=None, pass_defended=None, qb_hit=None, interception=None, int_yards=None, int_touchdown=None, tlost=None, ast_tlost=None, tlost_yards=None, forced_fumble=None, safety=None, category=None, def_target=None, def_comp=None, blitz=None, hurry=None, knockdown=None, missed_tackles=None, batted_pass=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("defenseType25"), self).__init__(nullified, team, player,  **kwargs_)
        self.tackle = _cast(int, tackle)
        self.tackle_nsprefix_ = None
        self.ast_tackle = _cast(int, ast_tackle)
        self.ast_tackle_nsprefix_ = None
        self.primary = _cast(int, primary)
        self.primary_nsprefix_ = None
        self.sack = _cast(int, sack)
        self.sack_nsprefix_ = None
        self.ast_sack = _cast(int, ast_sack)
        self.ast_sack_nsprefix_ = None
        self.sack_yards = _cast(float, sack_yards)
        self.sack_yards_nsprefix_ = None
        self.block = _cast(int, block)
        self.block_nsprefix_ = None
        self.pass_defended = _cast(int, pass_defended)
        self.pass_defended_nsprefix_ = None
        self.qb_hit = _cast(int, qb_hit)
        self.qb_hit_nsprefix_ = None
        self.interception = _cast(int, interception)
        self.interception_nsprefix_ = None
        self.int_yards = _cast(int, int_yards)
        self.int_yards_nsprefix_ = None
        self.int_touchdown = _cast(int, int_touchdown)
        self.int_touchdown_nsprefix_ = None
        self.tlost = _cast(int, tlost)
        self.tlost_nsprefix_ = None
        self.ast_tlost = _cast(int, ast_tlost)
        self.ast_tlost_nsprefix_ = None
        self.tlost_yards = _cast(int, tlost_yards)
        self.tlost_yards_nsprefix_ = None
        self.forced_fumble = _cast(int, forced_fumble)
        self.forced_fumble_nsprefix_ = None
        self.safety = _cast(int, safety)
        self.safety_nsprefix_ = None
        self.category = _cast(None, category)
        self.category_nsprefix_ = None
        self.def_target = _cast(int, def_target)
        self.def_target_nsprefix_ = None
        self.def_comp = _cast(int, def_comp)
        self.def_comp_nsprefix_ = None
        self.blitz = _cast(int, blitz)
        self.blitz_nsprefix_ = None
        self.hurry = _cast(int, hurry)
        self.hurry_nsprefix_ = None
        self.knockdown = _cast(int, knockdown)
        self.knockdown_nsprefix_ = None
        self.missed_tackles = _cast(int, missed_tackles)
        self.missed_tackles_nsprefix_ = None
        self.batted_pass = _cast(int, batted_pass)
        self.batted_pass_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, defenseType25)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if defenseType25.subclass:
            return defenseType25.subclass(*args_, **kwargs_)
        else:
            return defenseType25(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_tackle(self):
        return self.tackle
    def set_tackle(self, tackle):
        self.tackle = tackle
    def get_ast_tackle(self):
        return self.ast_tackle
    def set_ast_tackle(self, ast_tackle):
        self.ast_tackle = ast_tackle
    def get_primary(self):
        return self.primary
    def set_primary(self, primary):
        self.primary = primary
    def get_sack(self):
        return self.sack
    def set_sack(self, sack):
        self.sack = sack
    def get_ast_sack(self):
        return self.ast_sack
    def set_ast_sack(self, ast_sack):
        self.ast_sack = ast_sack
    def get_sack_yards(self):
        return self.sack_yards
    def set_sack_yards(self, sack_yards):
        self.sack_yards = sack_yards
    def get_block(self):
        return self.block
    def set_block(self, block):
        self.block = block
    def get_pass_defended(self):
        return self.pass_defended
    def set_pass_defended(self, pass_defended):
        self.pass_defended = pass_defended
    def get_qb_hit(self):
        return self.qb_hit
    def set_qb_hit(self, qb_hit):
        self.qb_hit = qb_hit
    def get_interception(self):
        return self.interception
    def set_interception(self, interception):
        self.interception = interception
    def get_int_yards(self):
        return self.int_yards
    def set_int_yards(self, int_yards):
        self.int_yards = int_yards
    def get_int_touchdown(self):
        return self.int_touchdown
    def set_int_touchdown(self, int_touchdown):
        self.int_touchdown = int_touchdown
    def get_tlost(self):
        return self.tlost
    def set_tlost(self, tlost):
        self.tlost = tlost
    def get_ast_tlost(self):
        return self.ast_tlost
    def set_ast_tlost(self, ast_tlost):
        self.ast_tlost = ast_tlost
    def get_tlost_yards(self):
        return self.tlost_yards
    def set_tlost_yards(self, tlost_yards):
        self.tlost_yards = tlost_yards
    def get_forced_fumble(self):
        return self.forced_fumble
    def set_forced_fumble(self, forced_fumble):
        self.forced_fumble = forced_fumble
    def get_safety(self):
        return self.safety
    def set_safety(self, safety):
        self.safety = safety
    def get_category(self):
        return self.category
    def set_category(self, category):
        self.category = category
    def get_def_target(self):
        return self.def_target
    def set_def_target(self, def_target):
        self.def_target = def_target
    def get_def_comp(self):
        return self.def_comp
    def set_def_comp(self, def_comp):
        self.def_comp = def_comp
    def get_blitz(self):
        return self.blitz
    def set_blitz(self, blitz):
        self.blitz = blitz
    def get_hurry(self):
        return self.hurry
    def set_hurry(self, hurry):
        self.hurry = hurry
    def get_knockdown(self):
        return self.knockdown
    def set_knockdown(self, knockdown):
        self.knockdown = knockdown
    def get_missed_tackles(self):
        return self.missed_tackles
    def set_missed_tackles(self, missed_tackles):
        self.missed_tackles = missed_tackles
    def get_batted_pass(self):
        return self.batted_pass
    def set_batted_pass(self, batted_pass):
        self.batted_pass = batted_pass
    def has__content(self):
        if (
            super(defenseType25, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='defenseType25', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('defenseType25')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'defenseType25':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='defenseType25')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='defenseType25', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='defenseType25'):
        super(defenseType25, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='defenseType25')
        if self.tackle is not None and 'tackle' not in already_processed:
            already_processed.add('tackle')
            outfile.write(' tackle="%s"' % self.gds_format_integer(self.tackle, input_name='tackle'))
        if self.ast_tackle is not None and 'ast_tackle' not in already_processed:
            already_processed.add('ast_tackle')
            outfile.write(' ast_tackle="%s"' % self.gds_format_integer(self.ast_tackle, input_name='ast_tackle'))
        if self.primary is not None and 'primary' not in already_processed:
            already_processed.add('primary')
            outfile.write(' primary="%s"' % self.gds_format_integer(self.primary, input_name='primary'))
        if self.sack is not None and 'sack' not in already_processed:
            already_processed.add('sack')
            outfile.write(' sack="%s"' % self.gds_format_integer(self.sack, input_name='sack'))
        if self.ast_sack is not None and 'ast_sack' not in already_processed:
            already_processed.add('ast_sack')
            outfile.write(' ast_sack="%s"' % self.gds_format_integer(self.ast_sack, input_name='ast_sack'))
        if self.sack_yards is not None and 'sack_yards' not in already_processed:
            already_processed.add('sack_yards')
            outfile.write(' sack_yards="%s"' % self.gds_format_double(self.sack_yards, input_name='sack_yards'))
        if self.block is not None and 'block' not in already_processed:
            already_processed.add('block')
            outfile.write(' block="%s"' % self.gds_format_integer(self.block, input_name='block'))
        if self.pass_defended is not None and 'pass_defended' not in already_processed:
            already_processed.add('pass_defended')
            outfile.write(' pass_defended="%s"' % self.gds_format_integer(self.pass_defended, input_name='pass_defended'))
        if self.qb_hit is not None and 'qb_hit' not in already_processed:
            already_processed.add('qb_hit')
            outfile.write(' qb_hit="%s"' % self.gds_format_integer(self.qb_hit, input_name='qb_hit'))
        if self.interception is not None and 'interception' not in already_processed:
            already_processed.add('interception')
            outfile.write(' interception="%s"' % self.gds_format_integer(self.interception, input_name='interception'))
        if self.int_yards is not None and 'int_yards' not in already_processed:
            already_processed.add('int_yards')
            outfile.write(' int_yards="%s"' % self.gds_format_integer(self.int_yards, input_name='int_yards'))
        if self.int_touchdown is not None and 'int_touchdown' not in already_processed:
            already_processed.add('int_touchdown')
            outfile.write(' int_touchdown="%s"' % self.gds_format_integer(self.int_touchdown, input_name='int_touchdown'))
        if self.tlost is not None and 'tlost' not in already_processed:
            already_processed.add('tlost')
            outfile.write(' tlost="%s"' % self.gds_format_integer(self.tlost, input_name='tlost'))
        if self.ast_tlost is not None and 'ast_tlost' not in already_processed:
            already_processed.add('ast_tlost')
            outfile.write(' ast_tlost="%s"' % self.gds_format_integer(self.ast_tlost, input_name='ast_tlost'))
        if self.tlost_yards is not None and 'tlost_yards' not in already_processed:
            already_processed.add('tlost_yards')
            outfile.write(' tlost_yards="%s"' % self.gds_format_integer(self.tlost_yards, input_name='tlost_yards'))
        if self.forced_fumble is not None and 'forced_fumble' not in already_processed:
            already_processed.add('forced_fumble')
            outfile.write(' forced_fumble="%s"' % self.gds_format_integer(self.forced_fumble, input_name='forced_fumble'))
        if self.safety is not None and 'safety' not in already_processed:
            already_processed.add('safety')
            outfile.write(' safety="%s"' % self.gds_format_integer(self.safety, input_name='safety'))
        if self.category is not None and 'category' not in already_processed:
            already_processed.add('category')
            outfile.write(' category=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.category), input_name='category')), ))
        if self.def_target is not None and 'def_target' not in already_processed:
            already_processed.add('def_target')
            outfile.write(' def_target="%s"' % self.gds_format_integer(self.def_target, input_name='def_target'))
        if self.def_comp is not None and 'def_comp' not in already_processed:
            already_processed.add('def_comp')
            outfile.write(' def_comp="%s"' % self.gds_format_integer(self.def_comp, input_name='def_comp'))
        if self.blitz is not None and 'blitz' not in already_processed:
            already_processed.add('blitz')
            outfile.write(' blitz="%s"' % self.gds_format_integer(self.blitz, input_name='blitz'))
        if self.hurry is not None and 'hurry' not in already_processed:
            already_processed.add('hurry')
            outfile.write(' hurry="%s"' % self.gds_format_integer(self.hurry, input_name='hurry'))
        if self.knockdown is not None and 'knockdown' not in already_processed:
            already_processed.add('knockdown')
            outfile.write(' knockdown="%s"' % self.gds_format_integer(self.knockdown, input_name='knockdown'))
        if self.missed_tackles is not None and 'missed_tackles' not in already_processed:
            already_processed.add('missed_tackles')
            outfile.write(' missed_tackles="%s"' % self.gds_format_integer(self.missed_tackles, input_name='missed_tackles'))
        if self.batted_pass is not None and 'batted_pass' not in already_processed:
            already_processed.add('batted_pass')
            outfile.write(' batted_pass="%s"' % self.gds_format_integer(self.batted_pass, input_name='batted_pass'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='defenseType25', fromsubclass_=False, pretty_print=True):
        super(defenseType25, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('tackle', node)
        if value is not None and 'tackle' not in already_processed:
            already_processed.add('tackle')
            self.tackle = self.gds_parse_integer(value, node, 'tackle')
        value = find_attr_value_('ast_tackle', node)
        if value is not None and 'ast_tackle' not in already_processed:
            already_processed.add('ast_tackle')
            self.ast_tackle = self.gds_parse_integer(value, node, 'ast_tackle')
        value = find_attr_value_('primary', node)
        if value is not None and 'primary' not in already_processed:
            already_processed.add('primary')
            self.primary = self.gds_parse_integer(value, node, 'primary')
        value = find_attr_value_('sack', node)
        if value is not None and 'sack' not in already_processed:
            already_processed.add('sack')
            self.sack = self.gds_parse_integer(value, node, 'sack')
        value = find_attr_value_('ast_sack', node)
        if value is not None and 'ast_sack' not in already_processed:
            already_processed.add('ast_sack')
            self.ast_sack = self.gds_parse_integer(value, node, 'ast_sack')
        value = find_attr_value_('sack_yards', node)
        if value is not None and 'sack_yards' not in already_processed:
            already_processed.add('sack_yards')
            value = self.gds_parse_double(value, node, 'sack_yards')
            self.sack_yards = value
        value = find_attr_value_('block', node)
        if value is not None and 'block' not in already_processed:
            already_processed.add('block')
            self.block = self.gds_parse_integer(value, node, 'block')
        value = find_attr_value_('pass_defended', node)
        if value is not None and 'pass_defended' not in already_processed:
            already_processed.add('pass_defended')
            self.pass_defended = self.gds_parse_integer(value, node, 'pass_defended')
        value = find_attr_value_('qb_hit', node)
        if value is not None and 'qb_hit' not in already_processed:
            already_processed.add('qb_hit')
            self.qb_hit = self.gds_parse_integer(value, node, 'qb_hit')
        value = find_attr_value_('interception', node)
        if value is not None and 'interception' not in already_processed:
            already_processed.add('interception')
            self.interception = self.gds_parse_integer(value, node, 'interception')
        value = find_attr_value_('int_yards', node)
        if value is not None and 'int_yards' not in already_processed:
            already_processed.add('int_yards')
            self.int_yards = self.gds_parse_integer(value, node, 'int_yards')
        value = find_attr_value_('int_touchdown', node)
        if value is not None and 'int_touchdown' not in already_processed:
            already_processed.add('int_touchdown')
            self.int_touchdown = self.gds_parse_integer(value, node, 'int_touchdown')
        value = find_attr_value_('tlost', node)
        if value is not None and 'tlost' not in already_processed:
            already_processed.add('tlost')
            self.tlost = self.gds_parse_integer(value, node, 'tlost')
        value = find_attr_value_('ast_tlost', node)
        if value is not None and 'ast_tlost' not in already_processed:
            already_processed.add('ast_tlost')
            self.ast_tlost = self.gds_parse_integer(value, node, 'ast_tlost')
        value = find_attr_value_('tlost_yards', node)
        if value is not None and 'tlost_yards' not in already_processed:
            already_processed.add('tlost_yards')
            self.tlost_yards = self.gds_parse_integer(value, node, 'tlost_yards')
        value = find_attr_value_('forced_fumble', node)
        if value is not None and 'forced_fumble' not in already_processed:
            already_processed.add('forced_fumble')
            self.forced_fumble = self.gds_parse_integer(value, node, 'forced_fumble')
        value = find_attr_value_('safety', node)
        if value is not None and 'safety' not in already_processed:
            already_processed.add('safety')
            self.safety = self.gds_parse_integer(value, node, 'safety')
        value = find_attr_value_('category', node)
        if value is not None and 'category' not in already_processed:
            already_processed.add('category')
            self.category = value
        value = find_attr_value_('def_target', node)
        if value is not None and 'def_target' not in already_processed:
            already_processed.add('def_target')
            self.def_target = self.gds_parse_integer(value, node, 'def_target')
        value = find_attr_value_('def_comp', node)
        if value is not None and 'def_comp' not in already_processed:
            already_processed.add('def_comp')
            self.def_comp = self.gds_parse_integer(value, node, 'def_comp')
        value = find_attr_value_('blitz', node)
        if value is not None and 'blitz' not in already_processed:
            already_processed.add('blitz')
            self.blitz = self.gds_parse_integer(value, node, 'blitz')
        value = find_attr_value_('hurry', node)
        if value is not None and 'hurry' not in already_processed:
            already_processed.add('hurry')
            self.hurry = self.gds_parse_integer(value, node, 'hurry')
        value = find_attr_value_('knockdown', node)
        if value is not None and 'knockdown' not in already_processed:
            already_processed.add('knockdown')
            self.knockdown = self.gds_parse_integer(value, node, 'knockdown')
        value = find_attr_value_('missed_tackles', node)
        if value is not None and 'missed_tackles' not in already_processed:
            already_processed.add('missed_tackles')
            self.missed_tackles = self.gds_parse_integer(value, node, 'missed_tackles')
        value = find_attr_value_('batted_pass', node)
        if value is not None and 'batted_pass' not in already_processed:
            already_processed.add('batted_pass')
            self.batted_pass = self.gds_parse_integer(value, node, 'batted_pass')
        super(defenseType25, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(defenseType25, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class defenseType25


class conversionType26(basePlayStatisticType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = basePlayStatisticType
    def __init__(self, nullified=None, team=None, player=None, attempt=None, complete=None, safety=None, category=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("conversionType26"), self).__init__(nullified, team, player,  **kwargs_)
        self.attempt = _cast(int, attempt)
        self.attempt_nsprefix_ = None
        self.complete = _cast(int, complete)
        self.complete_nsprefix_ = None
        self.safety = _cast(int, safety)
        self.safety_nsprefix_ = None
        self.category = _cast(None, category)
        self.category_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, conversionType26)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if conversionType26.subclass:
            return conversionType26.subclass(*args_, **kwargs_)
        else:
            return conversionType26(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_attempt(self):
        return self.attempt
    def set_attempt(self, attempt):
        self.attempt = attempt
    def get_complete(self):
        return self.complete
    def set_complete(self, complete):
        self.complete = complete
    def get_safety(self):
        return self.safety
    def set_safety(self, safety):
        self.safety = safety
    def get_category(self):
        return self.category
    def set_category(self, category):
        self.category = category
    def validate_categoryType27(self, value):
        # Validate type categoryType27, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['pass', 'receive', 'rush', 'turnover']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on categoryType27' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            super(conversionType26, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='conversionType26', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('conversionType26')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'conversionType26':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='conversionType26')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='conversionType26', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='conversionType26'):
        super(conversionType26, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='conversionType26')
        if self.attempt is not None and 'attempt' not in already_processed:
            already_processed.add('attempt')
            outfile.write(' attempt="%s"' % self.gds_format_integer(self.attempt, input_name='attempt'))
        if self.complete is not None and 'complete' not in already_processed:
            already_processed.add('complete')
            outfile.write(' complete="%s"' % self.gds_format_integer(self.complete, input_name='complete'))
        if self.safety is not None and 'safety' not in already_processed:
            already_processed.add('safety')
            outfile.write(' safety="%s"' % self.gds_format_integer(self.safety, input_name='safety'))
        if self.category is not None and 'category' not in already_processed:
            already_processed.add('category')
            outfile.write(' category=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.category), input_name='category')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='conversionType26', fromsubclass_=False, pretty_print=True):
        super(conversionType26, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('attempt', node)
        if value is not None and 'attempt' not in already_processed:
            already_processed.add('attempt')
            self.attempt = self.gds_parse_integer(value, node, 'attempt')
        value = find_attr_value_('complete', node)
        if value is not None and 'complete' not in already_processed:
            already_processed.add('complete')
            self.complete = self.gds_parse_integer(value, node, 'complete')
        value = find_attr_value_('safety', node)
        if value is not None and 'safety' not in already_processed:
            already_processed.add('safety')
            self.safety = self.gds_parse_integer(value, node, 'safety')
        value = find_attr_value_('category', node)
        if value is not None and 'category' not in already_processed:
            already_processed.add('category')
            self.category = value
            self.validate_categoryType27(self.category)    # validate type categoryType27
        super(conversionType26, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(conversionType26, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class conversionType26


class defense_conversionType28(basePlayStatisticType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = basePlayStatisticType
    def __init__(self, nullified=None, team=None, player=None, attempt=None, complete=None, category=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("defense_conversionType28"), self).__init__(nullified, team, player,  **kwargs_)
        self.attempt = _cast(int, attempt)
        self.attempt_nsprefix_ = None
        self.complete = _cast(int, complete)
        self.complete_nsprefix_ = None
        self.category = _cast(None, category)
        self.category_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, defense_conversionType28)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if defense_conversionType28.subclass:
            return defense_conversionType28.subclass(*args_, **kwargs_)
        else:
            return defense_conversionType28(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_attempt(self):
        return self.attempt
    def set_attempt(self, attempt):
        self.attempt = attempt
    def get_complete(self):
        return self.complete
    def set_complete(self, complete):
        self.complete = complete
    def get_category(self):
        return self.category
    def set_category(self, category):
        self.category = category
    def validate_categoryType29(self, value):
        # Validate type categoryType29, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['conversion', 'extra_point']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on categoryType29' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            super(defense_conversionType28, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='defense_conversionType28', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('defense_conversionType28')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'defense_conversionType28':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='defense_conversionType28')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='defense_conversionType28', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='defense_conversionType28'):
        super(defense_conversionType28, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='defense_conversionType28')
        if self.attempt is not None and 'attempt' not in already_processed:
            already_processed.add('attempt')
            outfile.write(' attempt="%s"' % self.gds_format_integer(self.attempt, input_name='attempt'))
        if self.complete is not None and 'complete' not in already_processed:
            already_processed.add('complete')
            outfile.write(' complete="%s"' % self.gds_format_integer(self.complete, input_name='complete'))
        if self.category is not None and 'category' not in already_processed:
            already_processed.add('category')
            outfile.write(' category=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.category), input_name='category')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='defense_conversionType28', fromsubclass_=False, pretty_print=True):
        super(defense_conversionType28, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('attempt', node)
        if value is not None and 'attempt' not in already_processed:
            already_processed.add('attempt')
            self.attempt = self.gds_parse_integer(value, node, 'attempt')
        value = find_attr_value_('complete', node)
        if value is not None and 'complete' not in already_processed:
            already_processed.add('complete')
            self.complete = self.gds_parse_integer(value, node, 'complete')
        value = find_attr_value_('category', node)
        if value is not None and 'category' not in already_processed:
            already_processed.add('category')
            self.category = value
            self.validate_categoryType29(self.category)    # validate type categoryType29
        super(defense_conversionType28, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(defense_conversionType28, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class defense_conversionType28


class down_conversionType30(basePlayStatisticType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = basePlayStatisticType
    def __init__(self, nullified=None, team=None, player=None, down=None, attempt=None, complete=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("down_conversionType30"), self).__init__(nullified, team, player,  **kwargs_)
        self.down = _cast(int, down)
        self.down_nsprefix_ = None
        self.attempt = _cast(int, attempt)
        self.attempt_nsprefix_ = None
        self.complete = _cast(int, complete)
        self.complete_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, down_conversionType30)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if down_conversionType30.subclass:
            return down_conversionType30.subclass(*args_, **kwargs_)
        else:
            return down_conversionType30(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_down(self):
        return self.down
    def set_down(self, down):
        self.down = down
    def get_attempt(self):
        return self.attempt
    def set_attempt(self, attempt):
        self.attempt = attempt
    def get_complete(self):
        return self.complete
    def set_complete(self, complete):
        self.complete = complete
    def has__content(self):
        if (
            super(down_conversionType30, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='down_conversionType30', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('down_conversionType30')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'down_conversionType30':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='down_conversionType30')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='down_conversionType30', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='down_conversionType30'):
        super(down_conversionType30, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='down_conversionType30')
        if self.down is not None and 'down' not in already_processed:
            already_processed.add('down')
            outfile.write(' down="%s"' % self.gds_format_integer(self.down, input_name='down'))
        if self.attempt is not None and 'attempt' not in already_processed:
            already_processed.add('attempt')
            outfile.write(' attempt="%s"' % self.gds_format_integer(self.attempt, input_name='attempt'))
        if self.complete is not None and 'complete' not in already_processed:
            already_processed.add('complete')
            outfile.write(' complete="%s"' % self.gds_format_integer(self.complete, input_name='complete'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='down_conversionType30', fromsubclass_=False, pretty_print=True):
        super(down_conversionType30, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('down', node)
        if value is not None and 'down' not in already_processed:
            already_processed.add('down')
            self.down = self.gds_parse_integer(value, node, 'down')
        value = find_attr_value_('attempt', node)
        if value is not None and 'attempt' not in already_processed:
            already_processed.add('attempt')
            self.attempt = self.gds_parse_integer(value, node, 'attempt')
        value = find_attr_value_('complete', node)
        if value is not None and 'complete' not in already_processed:
            already_processed.add('complete')
            self.complete = self.gds_parse_integer(value, node, 'complete')
        super(down_conversionType30, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(down_conversionType30, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class down_conversionType30


class first_downType31(basePlayStatisticType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = basePlayStatisticType
    def __init__(self, nullified=None, team=None, player=None, category=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("first_downType31"), self).__init__(nullified, team, player,  **kwargs_)
        self.category = _cast(None, category)
        self.category_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, first_downType31)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if first_downType31.subclass:
            return first_downType31.subclass(*args_, **kwargs_)
        else:
            return first_downType31(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_category(self):
        return self.category
    def set_category(self, category):
        self.category = category
    def validate_categoryType32(self, value):
        # Validate type categoryType32, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['pass', 'rush', 'penalty']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on categoryType32' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            super(first_downType31, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='first_downType31', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('first_downType31')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'first_downType31':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='first_downType31')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='first_downType31', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='first_downType31'):
        super(first_downType31, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='first_downType31')
        if self.category is not None and 'category' not in already_processed:
            already_processed.add('category')
            outfile.write(' category=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.category), input_name='category')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='first_downType31', fromsubclass_=False, pretty_print=True):
        super(first_downType31, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('category', node)
        if value is not None and 'category' not in already_processed:
            already_processed.add('category')
            self.category = value
            self.validate_categoryType32(self.category)    # validate type categoryType32
        super(first_downType31, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(first_downType31, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class first_downType31


class drive_infoType33(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, duration=None, net_yards=None, play_count=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.duration = _cast(None, duration)
        self.duration_nsprefix_ = None
        self.net_yards = _cast(int, net_yards)
        self.net_yards_nsprefix_ = None
        self.play_count = _cast(int, play_count)
        self.play_count_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, drive_infoType33)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if drive_infoType33.subclass:
            return drive_infoType33.subclass(*args_, **kwargs_)
        else:
            return drive_infoType33(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_duration(self):
        return self.duration
    def set_duration(self, duration):
        self.duration = duration
    def get_net_yards(self):
        return self.net_yards
    def set_net_yards(self, net_yards):
        self.net_yards = net_yards
    def get_play_count(self):
        return self.play_count
    def set_play_count(self, play_count):
        self.play_count = play_count
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='drive-infoType33', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('drive-infoType33')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'drive-infoType33':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='drive-infoType33')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='drive-infoType33', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='drive-infoType33'):
        if self.duration is not None and 'duration' not in already_processed:
            already_processed.add('duration')
            outfile.write(' duration=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.duration), input_name='duration')), ))
        if self.net_yards is not None and 'net_yards' not in already_processed:
            already_processed.add('net_yards')
            outfile.write(' net_yards="%s"' % self.gds_format_integer(self.net_yards, input_name='net_yards'))
        if self.play_count is not None and 'play_count' not in already_processed:
            already_processed.add('play_count')
            outfile.write(' play_count="%s"' % self.gds_format_integer(self.play_count, input_name='play_count'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='drive-infoType33', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('duration', node)
        if value is not None and 'duration' not in already_processed:
            already_processed.add('duration')
            self.duration = value
        value = find_attr_value_('net_yards', node)
        if value is not None and 'net_yards' not in already_processed:
            already_processed.add('net_yards')
            self.net_yards = self.gds_parse_integer(value, node, 'net_yards')
        value = find_attr_value_('play_count', node)
        if value is not None and 'play_count' not in already_processed:
            already_processed.add('play_count')
            self.play_count = self.gds_parse_integer(value, node, 'play_count')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class drive_infoType33


class penaltyType34(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, description=None, result=None, yards=None, no_play=None, team=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.description = _cast(None, description)
        self.description_nsprefix_ = None
        self.result = _cast(None, result)
        self.result_nsprefix_ = None
        self.yards = _cast(None, yards)
        self.yards_nsprefix_ = None
        self.no_play = _cast(None, no_play)
        self.no_play_nsprefix_ = None
        self.team = team
        self.team_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, penaltyType34)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if penaltyType34.subclass:
            return penaltyType34.subclass(*args_, **kwargs_)
        else:
            return penaltyType34(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_team(self):
        return self.team
    def set_team(self, team):
        self.team = team
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_result(self):
        return self.result
    def set_result(self, result):
        self.result = result
    def get_yards(self):
        return self.yards
    def set_yards(self, yards):
        self.yards = yards
    def get_no_play(self):
        return self.no_play
    def set_no_play(self, no_play):
        self.no_play = no_play
    def has__content(self):
        if (
            self.team is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='penaltyType34', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('penaltyType34')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'penaltyType34':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='penaltyType34')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='penaltyType34', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='penaltyType34'):
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            outfile.write(' description=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.description), input_name='description')), ))
        if self.result is not None and 'result' not in already_processed:
            already_processed.add('result')
            outfile.write(' result=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.result), input_name='result')), ))
        if self.yards is not None and 'yards' not in already_processed:
            already_processed.add('yards')
            outfile.write(' yards=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.yards), input_name='yards')), ))
        if self.no_play is not None and 'no_play' not in already_processed:
            already_processed.add('no_play')
            outfile.write(' no_play=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.no_play), input_name='no_play')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='penaltyType34', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.team is not None:
            namespaceprefix_ = self.team_nsprefix_ + ':' if (UseCapturedNS_ and self.team_nsprefix_) else ''
            self.team.export(outfile, level, namespaceprefix_, namespacedef_='', name_='team', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.add('description')
            self.description = value
        value = find_attr_value_('result', node)
        if value is not None and 'result' not in already_processed:
            already_processed.add('result')
            self.result = value
        value = find_attr_value_('yards', node)
        if value is not None and 'yards' not in already_processed:
            already_processed.add('yards')
            self.yards = value
        value = find_attr_value_('no_play', node)
        if value is not None and 'no_play' not in already_processed:
            already_processed.add('no_play')
            self.no_play = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'team':
            class_obj_ = self.get_class_obj_(child_, teamType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.team = obj_
            obj_.original_tagname_ = 'team'
# end class penaltyType34


class recoveryType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, first_touch=None, team=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.first_touch = _cast(None, first_touch)
        self.first_touch_nsprefix_ = None
        self.team = team
        self.team_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, recoveryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if recoveryType.subclass:
            return recoveryType.subclass(*args_, **kwargs_)
        else:
            return recoveryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_team(self):
        return self.team
    def set_team(self, team):
        self.team = team
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_first_touch(self):
        return self.first_touch
    def set_first_touch(self, first_touch):
        self.first_touch = first_touch
    def has__content(self):
        if (
            self.team is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='recoveryType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('recoveryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'recoveryType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='recoveryType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='recoveryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='recoveryType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.first_touch is not None and 'first_touch' not in already_processed:
            already_processed.add('first_touch')
            outfile.write(' first_touch=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.first_touch), input_name='first_touch')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='recoveryType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.team is not None:
            namespaceprefix_ = self.team_nsprefix_ + ':' if (UseCapturedNS_ and self.team_nsprefix_) else ''
            self.team.export(outfile, level, namespaceprefix_, namespacedef_='', name_='team', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('first_touch', node)
        if value is not None and 'first_touch' not in already_processed:
            already_processed.add('first_touch')
            self.first_touch = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'team':
            class_obj_ = self.get_class_obj_(child_, teamType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.team = obj_
            obj_.original_tagname_ = 'team'
# end class recoveryType


class reviewType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, result=None, reversed=None, team=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.result = _cast(None, result)
        self.result_nsprefix_ = None
        self.reversed = _cast(None, reversed)
        self.reversed_nsprefix_ = None
        self.team = team
        self.team_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, reviewType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if reviewType.subclass:
            return reviewType.subclass(*args_, **kwargs_)
        else:
            return reviewType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_team(self):
        return self.team
    def set_team(self, team):
        self.team = team
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_result(self):
        return self.result
    def set_result(self, result):
        self.result = result
    def get_reversed(self):
        return self.reversed
    def set_reversed(self, reversed):
        self.reversed = reversed
    def has__content(self):
        if (
            self.team is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='reviewType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('reviewType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'reviewType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='reviewType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='reviewType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='reviewType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.result is not None and 'result' not in already_processed:
            already_processed.add('result')
            outfile.write(' result=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.result), input_name='result')), ))
        if self.reversed is not None and 'reversed' not in already_processed:
            already_processed.add('reversed')
            outfile.write(' reversed=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.reversed), input_name='reversed')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='reviewType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.team is not None:
            namespaceprefix_ = self.team_nsprefix_ + ':' if (UseCapturedNS_ and self.team_nsprefix_) else ''
            self.team.export(outfile, level, namespaceprefix_, namespacedef_='', name_='team', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('result', node)
        if value is not None and 'result' not in already_processed:
            already_processed.add('result')
            self.result = value
        value = find_attr_value_('reversed', node)
        if value is not None and 'reversed' not in already_processed:
            already_processed.add('reversed')
            self.reversed = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'team':
            class_obj_ = self.get_class_obj_(child_, teamType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.team = obj_
            obj_.original_tagname_ = 'team'
# end class reviewType


class playersType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, player=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if player is None:
            self.player = []
        else:
            self.player = player
        self.player_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, playersType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if playersType.subclass:
            return playersType.subclass(*args_, **kwargs_)
        else:
            return playersType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_player(self):
        return self.player
    def set_player(self, player):
        self.player = player
    def add_player(self, value):
        self.player.append(value)
    def insert_player_at(self, index, value):
        self.player.insert(index, value)
    def replace_player_at(self, index, value):
        self.player[index] = value
    def has__content(self):
        if (
            self.player
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='playersType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('playersType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'playersType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='playersType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='playersType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='playersType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='playersType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for player_ in self.player:
            namespaceprefix_ = self.player_nsprefix_ + ':' if (UseCapturedNS_ and self.player_nsprefix_) else ''
            player_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='player', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'player':
            obj_ = playerType35.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.player.append(obj_)
            obj_.original_tagname_ = 'player'
# end class playersType


class playerType35(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, role=None, id=None, sr_id=None, name=None, jersey=None, reference=None, position=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.role = _cast(None, role)
        self.role_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.sr_id = _cast(None, sr_id)
        self.sr_id_nsprefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.jersey = _cast(None, jersey)
        self.jersey_nsprefix_ = None
        self.reference = _cast(None, reference)
        self.reference_nsprefix_ = None
        self.position = _cast(None, position)
        self.position_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, playerType35)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if playerType35.subclass:
            return playerType35.subclass(*args_, **kwargs_)
        else:
            return playerType35(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_role(self):
        return self.role
    def set_role(self, role):
        self.role = role
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_sr_id(self):
        return self.sr_id
    def set_sr_id(self, sr_id):
        self.sr_id = sr_id
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_jersey(self):
        return self.jersey
    def set_jersey(self, jersey):
        self.jersey = jersey
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def get_position(self):
        return self.position
    def set_position(self, position):
        self.position = position
    def validate_positionType(self, value):
        # Validate type positionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ATH', 'C', 'C/G', 'CB', 'CB/RS', 'CB/S', 'DB', 'DE', 'DE/LB', 'DL', 'DT', 'FB', 'FB/RB', 'FS', 'G', 'G/C', 'G/T', 'H/B', 'H/B/T', 'HB', 'ILB', 'K', 'K/P', 'KR', 'L', 'LB', 'LB/DE', 'LS', 'MLB', 'NT', 'OG', 'OL', 'OLB', 'OT', 'P', 'QB', 'QB/WR', 'RB', 'RB/ST', 'RB/WR', 'RS', 'S', 'SS', 'SAF', 'T', 'T/G', 'TE', 'TE/DT', 'TE/FB', 'TE/LS', 'TEW', 'WR', 'WR/CB', 'WR/KR', 'WR/PR', 'WR/RB', 'WR/RS', 'QB/WR', 'DB/LB', 'FB/DL', 'DE/DT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on positionType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='playerType35', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('playerType35')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'playerType35':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='playerType35')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='playerType35', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='playerType35'):
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.role), input_name='role')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.sr_id is not None and 'sr_id' not in already_processed:
            already_processed.add('sr_id')
            outfile.write(' sr_id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.sr_id), input_name='sr_id')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.jersey is not None and 'jersey' not in already_processed:
            already_processed.add('jersey')
            outfile.write(' jersey=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.jersey), input_name='jersey')), ))
        if self.reference is not None and 'reference' not in already_processed:
            already_processed.add('reference')
            outfile.write(' reference=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.reference), input_name='reference')), ))
        if self.position is not None and 'position' not in already_processed:
            already_processed.add('position')
            outfile.write(' position=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.position), input_name='position')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='playerType35', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('sr_id', node)
        if value is not None and 'sr_id' not in already_processed:
            already_processed.add('sr_id')
            self.sr_id = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('jersey', node)
        if value is not None and 'jersey' not in already_processed:
            already_processed.add('jersey')
            self.jersey = value
        value = find_attr_value_('reference', node)
        if value is not None and 'reference' not in already_processed:
            already_processed.add('reference')
            self.reference = value
        value = find_attr_value_('position', node)
        if value is not None and 'position' not in already_processed:
            already_processed.add('position')
            self.position = value
            self.validate_positionType(self.position)    # validate type positionType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class playerType35


class drive_infoType36(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, duration=None, net_yards=None, play_count=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.duration = _cast(None, duration)
        self.duration_nsprefix_ = None
        self.net_yards = _cast(int, net_yards)
        self.net_yards_nsprefix_ = None
        self.play_count = _cast(int, play_count)
        self.play_count_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, drive_infoType36)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if drive_infoType36.subclass:
            return drive_infoType36.subclass(*args_, **kwargs_)
        else:
            return drive_infoType36(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_duration(self):
        return self.duration
    def set_duration(self, duration):
        self.duration = duration
    def get_net_yards(self):
        return self.net_yards
    def set_net_yards(self, net_yards):
        self.net_yards = net_yards
    def get_play_count(self):
        return self.play_count
    def set_play_count(self, play_count):
        self.play_count = play_count
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='drive-infoType36', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('drive-infoType36')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'drive-infoType36':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='drive-infoType36')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='drive-infoType36', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='drive-infoType36'):
        if self.duration is not None and 'duration' not in already_processed:
            already_processed.add('duration')
            outfile.write(' duration=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.duration), input_name='duration')), ))
        if self.net_yards is not None and 'net_yards' not in already_processed:
            already_processed.add('net_yards')
            outfile.write(' net_yards="%s"' % self.gds_format_integer(self.net_yards, input_name='net_yards'))
        if self.play_count is not None and 'play_count' not in already_processed:
            already_processed.add('play_count')
            outfile.write(' play_count="%s"' % self.gds_format_integer(self.play_count, input_name='play_count'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='drive-infoType36', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('duration', node)
        if value is not None and 'duration' not in already_processed:
            already_processed.add('duration')
            self.duration = value
        value = find_attr_value_('net_yards', node)
        if value is not None and 'net_yards' not in already_processed:
            already_processed.add('net_yards')
            self.net_yards = self.gds_parse_integer(value, node, 'net_yards')
        value = find_attr_value_('play_count', node)
        if value is not None and 'play_count' not in already_processed:
            already_processed.add('play_count')
            self.play_count = self.gds_parse_integer(value, node, 'play_count')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class drive_infoType36


class quarterType37(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, number=None, sequence=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.number = _cast(int, number)
        self.number_nsprefix_ = None
        self.sequence = _cast(int, sequence)
        self.sequence_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, quarterType37)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if quarterType37.subclass:
            return quarterType37.subclass(*args_, **kwargs_)
        else:
            return quarterType37(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_number(self):
        return self.number
    def set_number(self, number):
        self.number = number
    def get_sequence(self):
        return self.sequence
    def set_sequence(self, sequence):
        self.sequence = sequence
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='quarterType37', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('quarterType37')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'quarterType37':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='quarterType37')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='quarterType37', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='quarterType37'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number="%s"' % self.gds_format_integer(self.number, input_name='number'))
        if self.sequence is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            outfile.write(' sequence="%s"' % self.gds_format_integer(self.sequence, input_name='sequence'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='quarterType37', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            self.number = self.gds_parse_integer(value, node, 'number')
        value = find_attr_value_('sequence', node)
        if value is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            self.sequence = self.gds_parse_integer(value, node, 'sequence')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class quarterType37


class overtimeType38(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, number=None, sequence=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.number = _cast(int, number)
        self.number_nsprefix_ = None
        self.sequence = _cast(int, sequence)
        self.sequence_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, overtimeType38)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if overtimeType38.subclass:
            return overtimeType38.subclass(*args_, **kwargs_)
        else:
            return overtimeType38(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_number(self):
        return self.number
    def set_number(self, number):
        self.number = number
    def get_sequence(self):
        return self.sequence
    def set_sequence(self, sequence):
        self.sequence = sequence
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='overtimeType38', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('overtimeType38')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'overtimeType38':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='overtimeType38')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='overtimeType38', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='overtimeType38'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number="%s"' % self.gds_format_integer(self.number, input_name='number'))
        if self.sequence is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            outfile.write(' sequence="%s"' % self.gds_format_integer(self.sequence, input_name='sequence'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='overtimeType38', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            self.number = self.gds_parse_integer(value, node, 'number')
        value = find_attr_value_('sequence', node)
        if value is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            self.sequence = self.gds_parse_integer(value, node, 'sequence')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class overtimeType38


class detailsType39(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, detail=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if detail is None:
            self.detail = []
        else:
            self.detail = detail
        self.detail_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, detailsType39)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if detailsType39.subclass:
            return detailsType39.subclass(*args_, **kwargs_)
        else:
            return detailsType39(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_detail(self):
        return self.detail
    def set_detail(self, detail):
        self.detail = detail
    def add_detail(self, value):
        self.detail.append(value)
    def insert_detail_at(self, index, value):
        self.detail.insert(index, value)
    def replace_detail_at(self, index, value):
        self.detail[index] = value
    def has__content(self):
        if (
            self.detail
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='detailsType39', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('detailsType39')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'detailsType39':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='detailsType39')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='detailsType39', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='detailsType39'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='detailsType39', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for detail_ in self.detail:
            namespaceprefix_ = self.detail_nsprefix_ + ':' if (UseCapturedNS_ and self.detail_nsprefix_) else ''
            detail_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='detail', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'detail':
            obj_ = playDetailsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.detail.append(obj_)
            obj_.original_tagname_ = 'detail'
# end class detailsType39


class homeType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, outcome=None, decision=None, direction=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.outcome = _cast(None, outcome)
        self.outcome_nsprefix_ = None
        self.decision = _cast(None, decision)
        self.decision_nsprefix_ = None
        self.direction = _cast(None, direction)
        self.direction_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, homeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if homeType.subclass:
            return homeType.subclass(*args_, **kwargs_)
        else:
            return homeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_outcome(self):
        return self.outcome
    def set_outcome(self, outcome):
        self.outcome = outcome
    def get_decision(self):
        return self.decision
    def set_decision(self, decision):
        self.decision = decision
    def get_direction(self):
        return self.direction
    def set_direction(self, direction):
        self.direction = direction
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='homeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('homeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'homeType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='homeType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='homeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='homeType'):
        if self.outcome is not None and 'outcome' not in already_processed:
            already_processed.add('outcome')
            outfile.write(' outcome=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.outcome), input_name='outcome')), ))
        if self.decision is not None and 'decision' not in already_processed:
            already_processed.add('decision')
            outfile.write(' decision=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.decision), input_name='decision')), ))
        if self.direction is not None and 'direction' not in already_processed:
            already_processed.add('direction')
            outfile.write(' direction=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.direction), input_name='direction')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='homeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('outcome', node)
        if value is not None and 'outcome' not in already_processed:
            already_processed.add('outcome')
            self.outcome = value
        value = find_attr_value_('decision', node)
        if value is not None and 'decision' not in already_processed:
            already_processed.add('decision')
            self.decision = value
        value = find_attr_value_('direction', node)
        if value is not None and 'direction' not in already_processed:
            already_processed.add('direction')
            self.direction = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class homeType


class awayType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, outcome=None, decision=None, direction=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.outcome = _cast(None, outcome)
        self.outcome_nsprefix_ = None
        self.decision = _cast(None, decision)
        self.decision_nsprefix_ = None
        self.direction = _cast(None, direction)
        self.direction_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, awayType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if awayType.subclass:
            return awayType.subclass(*args_, **kwargs_)
        else:
            return awayType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_outcome(self):
        return self.outcome
    def set_outcome(self, outcome):
        self.outcome = outcome
    def get_decision(self):
        return self.decision
    def set_decision(self, decision):
        self.decision = decision
    def get_direction(self):
        return self.direction
    def set_direction(self, direction):
        self.direction = direction
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='awayType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('awayType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'awayType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='awayType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='awayType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='awayType'):
        if self.outcome is not None and 'outcome' not in already_processed:
            already_processed.add('outcome')
            outfile.write(' outcome=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.outcome), input_name='outcome')), ))
        if self.decision is not None and 'decision' not in already_processed:
            already_processed.add('decision')
            outfile.write(' decision=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.decision), input_name='decision')), ))
        if self.direction is not None and 'direction' not in already_processed:
            already_processed.add('direction')
            outfile.write(' direction=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.direction), input_name='direction')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='awayType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('outcome', node)
        if value is not None and 'outcome' not in already_processed:
            already_processed.add('outcome')
            self.outcome = value
        value = find_attr_value_('decision', node)
        if value is not None and 'decision' not in already_processed:
            already_processed.add('decision')
            self.decision = value
        value = find_attr_value_('direction', node)
        if value is not None and 'direction' not in already_processed:
            already_processed.add('direction')
            self.direction = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class awayType


class windType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, speed=None, direction=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.speed = _cast(int, speed)
        self.speed_nsprefix_ = None
        self.direction = _cast(None, direction)
        self.direction_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, windType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if windType.subclass:
            return windType.subclass(*args_, **kwargs_)
        else:
            return windType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_speed(self):
        return self.speed
    def set_speed(self, speed):
        self.speed = speed
    def get_direction(self):
        return self.direction
    def set_direction(self, direction):
        self.direction = direction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def has__content(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='windType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('windType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'windType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='windType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='windType'):
        if self.speed is not None and 'speed' not in already_processed:
            already_processed.add('speed')
            outfile.write(' speed="%s"' % self.gds_format_integer(self.speed, input_name='speed'))
        if self.direction is not None and 'direction' not in already_processed:
            already_processed.add('direction')
            outfile.write(' direction=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.direction), input_name='direction')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='windType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('speed', node)
        if value is not None and 'speed' not in already_processed:
            already_processed.add('speed')
            self.speed = self.gds_parse_integer(value, node, 'speed')
        value = find_attr_value_('direction', node)
        if value is not None and 'direction' not in already_processed:
            already_processed.add('direction')
            self.direction = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class windType


class locationType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, lat=None, lng=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.lat = _cast(float, lat)
        self.lat_nsprefix_ = None
        self.lng = _cast(float, lng)
        self.lng_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, locationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if locationType.subclass:
            return locationType.subclass(*args_, **kwargs_)
        else:
            return locationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_lat(self):
        return self.lat
    def set_lat(self, lat):
        self.lat = lat
    def get_lng(self):
        return self.lng
    def set_lng(self, lng):
        self.lng = lng
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='locationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('locationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'locationType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='locationType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='locationType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='locationType'):
        if self.lat is not None and 'lat' not in already_processed:
            already_processed.add('lat')
            outfile.write(' lat="%s"' % self.gds_format_float(self.lat, input_name='lat'))
        if self.lng is not None and 'lng' not in already_processed:
            already_processed.add('lng')
            outfile.write(' lng="%s"' % self.gds_format_float(self.lng, input_name='lng'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='locationType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lat', node)
        if value is not None and 'lat' not in already_processed:
            already_processed.add('lat')
            value = self.gds_parse_float(value, node, 'lat')
            self.lat = value
        value = find_attr_value_('lng', node)
        if value is not None and 'lng' not in already_processed:
            already_processed.add('lng')
            value = self.gds_parse_float(value, node, 'lng')
            self.lng = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class locationType


class rgb_colorType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, red=None, green=None, blue=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.red = _cast(int, red)
        self.red_nsprefix_ = None
        self.green = _cast(int, green)
        self.green_nsprefix_ = None
        self.blue = _cast(int, blue)
        self.blue_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, rgb_colorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if rgb_colorType.subclass:
            return rgb_colorType.subclass(*args_, **kwargs_)
        else:
            return rgb_colorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_red(self):
        return self.red
    def set_red(self, red):
        self.red = red
    def get_green(self):
        return self.green
    def set_green(self, green):
        self.green = green
    def get_blue(self):
        return self.blue
    def set_blue(self, blue):
        self.blue = blue
    def has__content(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='rgb_colorType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('rgb_colorType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'rgb_colorType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='rgb_colorType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='rgb_colorType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='rgb_colorType'):
        if self.red is not None and 'red' not in already_processed:
            already_processed.add('red')
            outfile.write(' red="%s"' % self.gds_format_integer(self.red, input_name='red'))
        if self.green is not None and 'green' not in already_processed:
            already_processed.add('green')
            outfile.write(' green="%s"' % self.gds_format_integer(self.green, input_name='green'))
        if self.blue is not None and 'blue' not in already_processed:
            already_processed.add('blue')
            outfile.write(' blue="%s"' % self.gds_format_integer(self.blue, input_name='blue'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='rgb_colorType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('red', node)
        if value is not None and 'red' not in already_processed:
            already_processed.add('red')
            self.red = self.gds_parse_integer(value, node, 'red')
        value = find_attr_value_('green', node)
        if value is not None and 'green' not in already_processed:
            already_processed.add('green')
            self.green = self.gds_parse_integer(value, node, 'green')
        value = find_attr_value_('blue', node)
        if value is not None and 'blue' not in already_processed:
            already_processed.add('blue')
            self.blue = self.gds_parse_integer(value, node, 'blue')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class rgb_colorType


class gameTeamType(teamType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = teamType
    def __init__(self, id=None, sr_id=None, alias=None, name=None, market=None, founded=None, reference=None, points=None, remaining_timeouts=None, used_timeouts=None, remaining_challenges=None, used_challenges=None, record=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "b"
        super(globals().get("gameTeamType"), self).__init__(id, sr_id, alias, name, market, founded, reference,  **kwargs_)
        self.points = _cast(int, points)
        self.points_nsprefix_ = None
        self.remaining_timeouts = _cast(int, remaining_timeouts)
        self.remaining_timeouts_nsprefix_ = None
        self.used_timeouts = _cast(int, used_timeouts)
        self.used_timeouts_nsprefix_ = None
        self.remaining_challenges = _cast(int, remaining_challenges)
        self.remaining_challenges_nsprefix_ = None
        self.used_challenges = _cast(int, used_challenges)
        self.used_challenges_nsprefix_ = None
        self.record = record
        self.record_nsprefix_ = "b"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, gameTeamType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if gameTeamType.subclass:
            return gameTeamType.subclass(*args_, **kwargs_)
        else:
            return gameTeamType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_record(self):
        return self.record
    def set_record(self, record):
        self.record = record
    def get_points(self):
        return self.points
    def set_points(self, points):
        self.points = points
    def get_remaining_timeouts(self):
        return self.remaining_timeouts
    def set_remaining_timeouts(self, remaining_timeouts):
        self.remaining_timeouts = remaining_timeouts
    def get_used_timeouts(self):
        return self.used_timeouts
    def set_used_timeouts(self, used_timeouts):
        self.used_timeouts = used_timeouts
    def get_remaining_challenges(self):
        return self.remaining_challenges
    def set_remaining_challenges(self, remaining_challenges):
        self.remaining_challenges = remaining_challenges
    def get_used_challenges(self):
        return self.used_challenges
    def set_used_challenges(self, used_challenges):
        self.used_challenges = used_challenges
    def has__content(self):
        if (
            self.record is not None or
            super(gameTeamType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='gameTeamType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('gameTeamType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'gameTeamType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='gameTeamType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='gameTeamType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='gameTeamType'):
        super(gameTeamType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='gameTeamType')
        if self.points is not None and 'points' not in already_processed:
            already_processed.add('points')
            outfile.write(' points="%s"' % self.gds_format_integer(self.points, input_name='points'))
        if self.remaining_timeouts is not None and 'remaining_timeouts' not in already_processed:
            already_processed.add('remaining_timeouts')
            outfile.write(' remaining_timeouts="%s"' % self.gds_format_integer(self.remaining_timeouts, input_name='remaining_timeouts'))
        if self.used_timeouts is not None and 'used_timeouts' not in already_processed:
            already_processed.add('used_timeouts')
            outfile.write(' used_timeouts="%s"' % self.gds_format_integer(self.used_timeouts, input_name='used_timeouts'))
        if self.remaining_challenges is not None and 'remaining_challenges' not in already_processed:
            already_processed.add('remaining_challenges')
            outfile.write(' remaining_challenges="%s"' % self.gds_format_integer(self.remaining_challenges, input_name='remaining_challenges'))
        if self.used_challenges is not None and 'used_challenges' not in already_processed:
            already_processed.add('used_challenges')
            outfile.write(' used_challenges="%s"' % self.gds_format_integer(self.used_challenges, input_name='used_challenges'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='gameTeamType', fromsubclass_=False, pretty_print=True):
        super(gameTeamType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.record is not None:
            namespaceprefix_ = self.record_nsprefix_ + ':' if (UseCapturedNS_ and self.record_nsprefix_) else ''
            self.record.export(outfile, level, namespaceprefix_, namespacedef_='', name_='record', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('points', node)
        if value is not None and 'points' not in already_processed:
            already_processed.add('points')
            self.points = self.gds_parse_integer(value, node, 'points')
        value = find_attr_value_('remaining_timeouts', node)
        if value is not None and 'remaining_timeouts' not in already_processed:
            already_processed.add('remaining_timeouts')
            self.remaining_timeouts = self.gds_parse_integer(value, node, 'remaining_timeouts')
        value = find_attr_value_('used_timeouts', node)
        if value is not None and 'used_timeouts' not in already_processed:
            already_processed.add('used_timeouts')
            self.used_timeouts = self.gds_parse_integer(value, node, 'used_timeouts')
        value = find_attr_value_('remaining_challenges', node)
        if value is not None and 'remaining_challenges' not in already_processed:
            already_processed.add('remaining_challenges')
            self.remaining_challenges = self.gds_parse_integer(value, node, 'remaining_challenges')
        value = find_attr_value_('used_challenges', node)
        if value is not None and 'used_challenges' not in already_processed:
            already_processed.add('used_challenges')
            self.used_challenges = self.gds_parse_integer(value, node, 'used_challenges')
        super(gameTeamType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'record':
            obj_ = recordType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.record = obj_
            obj_.original_tagname_ = 'record'
        super(gameTeamType, self)._buildChildren(child_, node, nodeName_, True)
# end class gameTeamType


class gamePlayScoresType(basePlayType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = basePlayType
    def __init__(self, away_points=None, home_points=None, play_clock=None, scoring_play=None, goaltogo=None, created_at=None, updated_at=None, id=None, sequence=None, reference=None, clock=None, wall_clock=None, deleted=None, source=None, type_=None, start_situation=None, end_situation=None, description=None, alt_description=None, scoring_description=None, play_action=None, run_pass_option=None, qb_at_snap=None, fake_punt=None, fake_field_goal=None, players_rushed=None, men_in_box=None, play_direction=None, left_tightends=None, right_tightends=None, hash_mark=None, screen_pass=None, pocket_location=None, blitz=None, huddle=None, pass_route=None, running_lane=None, score=None, quarter=None, overtime=None, statistics=None, details=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "b"
        super(globals().get("gamePlayScoresType"), self).__init__(away_points, home_points, play_clock, scoring_play, goaltogo, created_at, updated_at, id, sequence, reference, clock, wall_clock, deleted, source, type_, start_situation, end_situation, description, alt_description, scoring_description,  **kwargs_)
        self.play_action = _cast(bool, play_action)
        self.play_action_nsprefix_ = None
        self.run_pass_option = _cast(bool, run_pass_option)
        self.run_pass_option_nsprefix_ = None
        self.qb_at_snap = _cast(None, qb_at_snap)
        self.qb_at_snap_nsprefix_ = None
        self.fake_punt = _cast(bool, fake_punt)
        self.fake_punt_nsprefix_ = None
        self.fake_field_goal = _cast(bool, fake_field_goal)
        self.fake_field_goal_nsprefix_ = None
        self.players_rushed = _cast(int, players_rushed)
        self.players_rushed_nsprefix_ = None
        self.men_in_box = _cast(int, men_in_box)
        self.men_in_box_nsprefix_ = None
        self.play_direction = _cast(None, play_direction)
        self.play_direction_nsprefix_ = None
        self.left_tightends = _cast(int, left_tightends)
        self.left_tightends_nsprefix_ = None
        self.right_tightends = _cast(int, right_tightends)
        self.right_tightends_nsprefix_ = None
        self.hash_mark = _cast(None, hash_mark)
        self.hash_mark_nsprefix_ = None
        self.screen_pass = _cast(bool, screen_pass)
        self.screen_pass_nsprefix_ = None
        self.pocket_location = _cast(None, pocket_location)
        self.pocket_location_nsprefix_ = None
        self.blitz = _cast(bool, blitz)
        self.blitz_nsprefix_ = None
        self.huddle = _cast(None, huddle)
        self.huddle_nsprefix_ = None
        self.pass_route = _cast(None, pass_route)
        self.pass_route_nsprefix_ = None
        self.running_lane = _cast(int, running_lane)
        self.running_lane_nsprefix_ = None
        self.score = score
        self.score_nsprefix_ = "b"
        self.quarter = quarter
        self.quarter_nsprefix_ = "b"
        self.overtime = overtime
        self.overtime_nsprefix_ = "b"
        self.statistics = statistics
        self.statistics_nsprefix_ = "b"
        self.details = details
        self.details_nsprefix_ = "b"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, gamePlayScoresType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if gamePlayScoresType.subclass:
            return gamePlayScoresType.subclass(*args_, **kwargs_)
        else:
            return gamePlayScoresType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_score(self):
        return self.score
    def set_score(self, score):
        self.score = score
    def get_quarter(self):
        return self.quarter
    def set_quarter(self, quarter):
        self.quarter = quarter
    def get_overtime(self):
        return self.overtime
    def set_overtime(self, overtime):
        self.overtime = overtime
    def get_statistics(self):
        return self.statistics
    def set_statistics(self, statistics):
        self.statistics = statistics
    def get_details(self):
        return self.details
    def set_details(self, details):
        self.details = details
    def get_play_action(self):
        return self.play_action
    def set_play_action(self, play_action):
        self.play_action = play_action
    def get_run_pass_option(self):
        return self.run_pass_option
    def set_run_pass_option(self, run_pass_option):
        self.run_pass_option = run_pass_option
    def get_qb_at_snap(self):
        return self.qb_at_snap
    def set_qb_at_snap(self, qb_at_snap):
        self.qb_at_snap = qb_at_snap
    def get_fake_punt(self):
        return self.fake_punt
    def set_fake_punt(self, fake_punt):
        self.fake_punt = fake_punt
    def get_fake_field_goal(self):
        return self.fake_field_goal
    def set_fake_field_goal(self, fake_field_goal):
        self.fake_field_goal = fake_field_goal
    def get_players_rushed(self):
        return self.players_rushed
    def set_players_rushed(self, players_rushed):
        self.players_rushed = players_rushed
    def get_men_in_box(self):
        return self.men_in_box
    def set_men_in_box(self, men_in_box):
        self.men_in_box = men_in_box
    def get_play_direction(self):
        return self.play_direction
    def set_play_direction(self, play_direction):
        self.play_direction = play_direction
    def get_left_tightends(self):
        return self.left_tightends
    def set_left_tightends(self, left_tightends):
        self.left_tightends = left_tightends
    def get_right_tightends(self):
        return self.right_tightends
    def set_right_tightends(self, right_tightends):
        self.right_tightends = right_tightends
    def get_hash_mark(self):
        return self.hash_mark
    def set_hash_mark(self, hash_mark):
        self.hash_mark = hash_mark
    def get_screen_pass(self):
        return self.screen_pass
    def set_screen_pass(self, screen_pass):
        self.screen_pass = screen_pass
    def get_pocket_location(self):
        return self.pocket_location
    def set_pocket_location(self, pocket_location):
        self.pocket_location = pocket_location
    def get_blitz(self):
        return self.blitz
    def set_blitz(self, blitz):
        self.blitz = blitz
    def get_huddle(self):
        return self.huddle
    def set_huddle(self, huddle):
        self.huddle = huddle
    def get_pass_route(self):
        return self.pass_route
    def set_pass_route(self, pass_route):
        self.pass_route = pass_route
    def get_running_lane(self):
        return self.running_lane
    def set_running_lane(self, running_lane):
        self.running_lane = running_lane
    def validate_qb_at_snapType(self, value):
        # Validate type qb_at_snapType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Shotgun', 'Under Center', 'Pistol']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on qb_at_snapType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_play_directionType(self, value):
        # Validate type play_directionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Left Sideline', 'Left', 'Middle', 'Right', 'Right Sideline']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on play_directionType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_hash_markType(self, value):
        # Validate type hash_markType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Left Hash', 'Right Hash', 'Middle']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on hash_markType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_pocket_locationType(self, value):
        # Validate type pocket_locationType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Scramble Left', 'Scramble Right', 'Boot Left', 'Boot Right', 'Rollout Left', 'Rollout Right', 'Middle']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on pocket_locationType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def has__content(self):
        if (
            self.score is not None or
            self.quarter is not None or
            self.overtime is not None or
            self.statistics is not None or
            self.details is not None or
            super(gamePlayScoresType, self).has__content()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='gamePlayScoresType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('gamePlayScoresType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'gamePlayScoresType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='gamePlayScoresType')
        if self.has__content():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='gamePlayScoresType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='gamePlayScoresType'):
        super(gamePlayScoresType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='gamePlayScoresType')
        if self.play_action is not None and 'play_action' not in already_processed:
            already_processed.add('play_action')
            outfile.write(' play_action="%s"' % self.gds_format_boolean(self.play_action, input_name='play_action'))
        if self.run_pass_option is not None and 'run_pass_option' not in already_processed:
            already_processed.add('run_pass_option')
            outfile.write(' run_pass_option="%s"' % self.gds_format_boolean(self.run_pass_option, input_name='run_pass_option'))
        if self.qb_at_snap is not None and 'qb_at_snap' not in already_processed:
            already_processed.add('qb_at_snap')
            outfile.write(' qb_at_snap=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.qb_at_snap), input_name='qb_at_snap')), ))
        if self.fake_punt is not None and 'fake_punt' not in already_processed:
            already_processed.add('fake_punt')
            outfile.write(' fake_punt="%s"' % self.gds_format_boolean(self.fake_punt, input_name='fake_punt'))
        if self.fake_field_goal is not None and 'fake_field_goal' not in already_processed:
            already_processed.add('fake_field_goal')
            outfile.write(' fake_field_goal="%s"' % self.gds_format_boolean(self.fake_field_goal, input_name='fake_field_goal'))
        if self.players_rushed is not None and 'players_rushed' not in already_processed:
            already_processed.add('players_rushed')
            outfile.write(' players_rushed="%s"' % self.gds_format_integer(self.players_rushed, input_name='players_rushed'))
        if self.men_in_box is not None and 'men_in_box' not in already_processed:
            already_processed.add('men_in_box')
            outfile.write(' men_in_box="%s"' % self.gds_format_integer(self.men_in_box, input_name='men_in_box'))
        if self.play_direction is not None and 'play_direction' not in already_processed:
            already_processed.add('play_direction')
            outfile.write(' play_direction=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.play_direction), input_name='play_direction')), ))
        if self.left_tightends is not None and 'left_tightends' not in already_processed:
            already_processed.add('left_tightends')
            outfile.write(' left_tightends="%s"' % self.gds_format_integer(self.left_tightends, input_name='left_tightends'))
        if self.right_tightends is not None and 'right_tightends' not in already_processed:
            already_processed.add('right_tightends')
            outfile.write(' right_tightends="%s"' % self.gds_format_integer(self.right_tightends, input_name='right_tightends'))
        if self.hash_mark is not None and 'hash_mark' not in already_processed:
            already_processed.add('hash_mark')
            outfile.write(' hash_mark=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.hash_mark), input_name='hash_mark')), ))
        if self.screen_pass is not None and 'screen_pass' not in already_processed:
            already_processed.add('screen_pass')
            outfile.write(' screen_pass="%s"' % self.gds_format_boolean(self.screen_pass, input_name='screen_pass'))
        if self.pocket_location is not None and 'pocket_location' not in already_processed:
            already_processed.add('pocket_location')
            outfile.write(' pocket_location=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.pocket_location), input_name='pocket_location')), ))
        if self.blitz is not None and 'blitz' not in already_processed:
            already_processed.add('blitz')
            outfile.write(' blitz="%s"' % self.gds_format_boolean(self.blitz, input_name='blitz'))
        if self.huddle is not None and 'huddle' not in already_processed:
            already_processed.add('huddle')
            outfile.write(' huddle=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.huddle), input_name='huddle')), ))
        if self.pass_route is not None and 'pass_route' not in already_processed:
            already_processed.add('pass_route')
            outfile.write(' pass_route=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.pass_route), input_name='pass_route')), ))
        if self.running_lane is not None and 'running_lane' not in already_processed:
            already_processed.add('running_lane')
            outfile.write(' running_lane="%s"' % self.gds_format_integer(self.running_lane, input_name='running_lane'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"', name_='gamePlayScoresType', fromsubclass_=False, pretty_print=True):
        super(gamePlayScoresType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.score is not None:
            namespaceprefix_ = self.score_nsprefix_ + ':' if (UseCapturedNS_ and self.score_nsprefix_) else ''
            self.score.export(outfile, level, namespaceprefix_, namespacedef_='', name_='score', pretty_print=pretty_print)
        if self.quarter is not None:
            namespaceprefix_ = self.quarter_nsprefix_ + ':' if (UseCapturedNS_ and self.quarter_nsprefix_) else ''
            self.quarter.export(outfile, level, namespaceprefix_, namespacedef_='', name_='quarter', pretty_print=pretty_print)
        if self.overtime is not None:
            namespaceprefix_ = self.overtime_nsprefix_ + ':' if (UseCapturedNS_ and self.overtime_nsprefix_) else ''
            self.overtime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='overtime', pretty_print=pretty_print)
        if self.statistics is not None:
            namespaceprefix_ = self.statistics_nsprefix_ + ':' if (UseCapturedNS_ and self.statistics_nsprefix_) else ''
            self.statistics.export(outfile, level, namespaceprefix_, namespacedef_='', name_='statistics', pretty_print=pretty_print)
        if self.details is not None:
            namespaceprefix_ = self.details_nsprefix_ + ':' if (UseCapturedNS_ and self.details_nsprefix_) else ''
            self.details.export(outfile, level, namespaceprefix_, namespacedef_='', name_='details', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('play_action', node)
        if value is not None and 'play_action' not in already_processed:
            already_processed.add('play_action')
            if value in ('true', '1'):
                self.play_action = True
            elif value in ('false', '0'):
                self.play_action = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('run_pass_option', node)
        if value is not None and 'run_pass_option' not in already_processed:
            already_processed.add('run_pass_option')
            if value in ('true', '1'):
                self.run_pass_option = True
            elif value in ('false', '0'):
                self.run_pass_option = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('qb_at_snap', node)
        if value is not None and 'qb_at_snap' not in already_processed:
            already_processed.add('qb_at_snap')
            self.qb_at_snap = value
            self.validate_qb_at_snapType(self.qb_at_snap)    # validate type qb_at_snapType
        value = find_attr_value_('fake_punt', node)
        if value is not None and 'fake_punt' not in already_processed:
            already_processed.add('fake_punt')
            if value in ('true', '1'):
                self.fake_punt = True
            elif value in ('false', '0'):
                self.fake_punt = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('fake_field_goal', node)
        if value is not None and 'fake_field_goal' not in already_processed:
            already_processed.add('fake_field_goal')
            if value in ('true', '1'):
                self.fake_field_goal = True
            elif value in ('false', '0'):
                self.fake_field_goal = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('players_rushed', node)
        if value is not None and 'players_rushed' not in already_processed:
            already_processed.add('players_rushed')
            self.players_rushed = self.gds_parse_integer(value, node, 'players_rushed')
        value = find_attr_value_('men_in_box', node)
        if value is not None and 'men_in_box' not in already_processed:
            already_processed.add('men_in_box')
            self.men_in_box = self.gds_parse_integer(value, node, 'men_in_box')
        value = find_attr_value_('play_direction', node)
        if value is not None and 'play_direction' not in already_processed:
            already_processed.add('play_direction')
            self.play_direction = value
            self.validate_play_directionType(self.play_direction)    # validate type play_directionType
        value = find_attr_value_('left_tightends', node)
        if value is not None and 'left_tightends' not in already_processed:
            already_processed.add('left_tightends')
            self.left_tightends = self.gds_parse_integer(value, node, 'left_tightends')
        value = find_attr_value_('right_tightends', node)
        if value is not None and 'right_tightends' not in already_processed:
            already_processed.add('right_tightends')
            self.right_tightends = self.gds_parse_integer(value, node, 'right_tightends')
        value = find_attr_value_('hash_mark', node)
        if value is not None and 'hash_mark' not in already_processed:
            already_processed.add('hash_mark')
            self.hash_mark = value
            self.validate_hash_markType(self.hash_mark)    # validate type hash_markType
        value = find_attr_value_('screen_pass', node)
        if value is not None and 'screen_pass' not in already_processed:
            already_processed.add('screen_pass')
            if value in ('true', '1'):
                self.screen_pass = True
            elif value in ('false', '0'):
                self.screen_pass = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('pocket_location', node)
        if value is not None and 'pocket_location' not in already_processed:
            already_processed.add('pocket_location')
            self.pocket_location = value
            self.validate_pocket_locationType(self.pocket_location)    # validate type pocket_locationType
        value = find_attr_value_('blitz', node)
        if value is not None and 'blitz' not in already_processed:
            already_processed.add('blitz')
            if value in ('true', '1'):
                self.blitz = True
            elif value in ('false', '0'):
                self.blitz = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('huddle', node)
        if value is not None and 'huddle' not in already_processed:
            already_processed.add('huddle')
            self.huddle = value
        value = find_attr_value_('pass_route', node)
        if value is not None and 'pass_route' not in already_processed:
            already_processed.add('pass_route')
            self.pass_route = value
        value = find_attr_value_('running_lane', node)
        if value is not None and 'running_lane' not in already_processed:
            already_processed.add('running_lane')
            self.running_lane = self.gds_parse_integer(value, node, 'running_lane')
        super(gamePlayScoresType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'score':
            obj_ = playScoreType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.score = obj_
            obj_.original_tagname_ = 'score'
        elif nodeName_ == 'quarter':
            obj_ = quarterType2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.quarter = obj_
            obj_.original_tagname_ = 'quarter'
        elif nodeName_ == 'overtime':
            obj_ = overtimeType3.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.overtime = obj_
            obj_.original_tagname_ = 'overtime'
        elif nodeName_ == 'statistics':
            obj_ = extPlayStatisticsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.statistics = obj_
            obj_.original_tagname_ = 'statistics'
        elif nodeName_ == 'details':
            obj_ = detailsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.details = obj_
            obj_.original_tagname_ = 'details'
        super(gamePlayScoresType, self)._buildChildren(child_, node, nodeName_, True)
# end class gamePlayScoresType


#
# End data representation classes.
#


GDSClassesMapping = {
    'game': gameType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    prefix_tag = TagNamePrefix + tag
    rootClass = GDSClassesMapping.get(prefix_tag)
    if rootClass is None:
        rootClass = globals().get(prefix_tag)
    return tag, rootClass


def get_required_ns_prefix_defs(rootNode):
    '''Get all name space prefix definitions required in this XML doc.
    Return a dictionary of definitions and a char string of definitions.
    '''
    nsmap = {
        prefix: uri
        for node in rootNode.iter()
        for (prefix, uri) in node.nsmap.items()
        if prefix is not None
    }
    namespacedefs = ' '.join([
        'xmlns:{}="{}"'.format(prefix, uri)
        for prefix, uri in nsmap.items()
    ])
    return nsmap, namespacedefs


def parse(inFileName, silence=False, print_warnings=True):
    global CapturedNsmap_
    gds_collector = GdsCollector_()
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'gameType'
        rootClass = gameType
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    CapturedNsmap_, namespacedefs = get_required_ns_prefix_defs(rootNode)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_=namespacedefs,
            pretty_print=True)
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseEtree(inFileName, silence=False, print_warnings=True,
               mapping=None, reverse_mapping=None, nsmap=None):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'gameType'
        rootClass = gameType
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    if mapping is None:
        mapping = {}
    if reverse_mapping is None:
        reverse_mapping = {}
    rootElement = rootObj.to_etree(
        None, name_=rootTag, mapping_=mapping,
        reverse_mapping_=reverse_mapping, nsmap_=nsmap)
    reverse_node_mapping = rootObj.gds_reverse_node_mapping(mapping)
    # Enable Python to collect the space used by the DOM.
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(str(content))
        sys.stdout.write('\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj, rootElement, mapping, reverse_node_mapping


def parseString(inString, silence=False, print_warnings=True):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    gds_collector = GdsCollector_()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'gameType'
        rootClass = gameType
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    if not SaveElementTreeNode:
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:b="http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd"')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseLiteral(inFileName, silence=False, print_warnings=True):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'gameType'
        rootClass = gameType
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('#from boxscore import *\n\n')
        sys.stdout.write('import boxscore as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()

RenameMappings_ = {
}

#
# Mapping of namespaces to types defined in them
# and the file in which each is defined.
# simpleTypes are marked "ST" and complexTypes "CT".
NamespaceToDefMappings_ = {'http://feed.elasticstats.com/schema/football/boxscore-v7.0.xsd': [('gameType',
                                                                     'boxscore-v7.0.xsd',
                                                                     'CT'),
                                                                    ('periodType',
                                                                     'boxscore-v7.0.xsd',
                                                                     'CT'),
                                                                    ('scoringDriveType',
                                                                     'boxscore-v7.0.xsd',
                                                                     'CT'),
                                                                    ('gamePlayScoresType',
                                                                     'boxscore-v7.0.xsd',
                                                                     'CT')]}

__all__ = [
    "awayType",
    "basePlayStatisticType",
    "basePlayType",
    "blockType",
    "blockType23",
    "coinTossType",
    "conversionType",
    "conversionType26",
    "defenseType",
    "defenseType25",
    "defense_conversionType",
    "defense_conversionType28",
    "detailsType",
    "detailsType39",
    "down_conversionType",
    "down_conversionType30",
    "drive_infoType",
    "drive_infoType33",
    "drive_infoType36",
    "extFieldLocationType",
    "extGameDriveType",
    "extGamePlayType",
    "extPlayStatisticsType",
    "extra_pointType",
    "extra_pointType18",
    "fieldLocationType",
    "fieldSituationType",
    "field_goalType",
    "field_goalType17",
    "first_downType",
    "first_downType31",
    "franchise",
    "fumbleType",
    "fumbleType20",
    "gameDetailsDriveType",
    "gameDriveType",
    "gameEventType",
    "gamePlayDetailsType",
    "gamePlayScoresType",
    "gamePlayType",
    "gameTeamType",
    "gameType",
    "homeType",
    "kickType",
    "kickType15",
    "last_eventType",
    "locationType",
    "miscType",
    "miscType11",
    "overtimeType",
    "overtimeType3",
    "overtimeType38",
    "passType",
    "passType12",
    "penaltyType",
    "penaltyType19",
    "penaltyType34",
    "periodType",
    "playDetailsType",
    "playScoreType",
    "playStatisticsType",
    "playerType",
    "playerType35",
    "playersType",
    "playsType",
    "points_after_playType",
    "puntType",
    "puntType16",
    "quarterType",
    "quarterType2",
    "quarterType37",
    "receiveType",
    "receiveType13",
    "recordType",
    "recoveryType",
    "referenceType",
    "references",
    "returnType",
    "returnType21",
    "reviewType",
    "rgb_colorType",
    "rushType",
    "rushType14",
    "scoringDriveType",
    "scoringType",
    "scoring_drivesType",
    "scoring_playsType",
    "seasonType",
    "summaryType",
    "teamColorType",
    "teamColorsType",
    "teamType",
    "teamType1",
    "timeoutType",
    "timeoutType10",
    "venueType",
    "weatherType",
    "weekType",
    "windType"
]
