{
  "resolvedId": "/app/node_modules/.vite/deps/@auth0_auth0-react.js?v=63508976",
  "transforms": [
    {
      "name": "vite:optimized-deps",
      "result": "\"use strict\";\n(() => {\n  var __create = Object.create;\n  var __defProp = Object.defineProperty;\n  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n  var __getOwnPropNames = Object.getOwnPropertyNames;\n  var __getProtoOf = Object.getPrototypeOf;\n  var __hasOwnProp = Object.prototype.hasOwnProperty;\n  var __esm = (fn, res) => function __init() {\n    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;\n  };\n  var __commonJS = (cb, mod) => function __require() {\n    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n  };\n  var __copyProps = (to, from, except, desc) => {\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n      for (let key of __getOwnPropNames(from))\n        if (!__hasOwnProp.call(to, key) && key !== except)\n          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n    }\n    return to;\n  };\n  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n    // If the importer is in node compatibility mode or this is not an ESM\n    // file that has been converted to a CommonJS file using a Babel-\n    // compatible transform (i.e. \"__esModule\" has not been set), then set\n    // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n    isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n    mod\n  ));\n\n  // node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js\n  var require_base64_js = __commonJS({\n    \"node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js\"(exports) {\n      \"use strict\";\n      init_dist();\n      exports.byteLength = byteLength;\n      exports.toByteArray = toByteArray;\n      exports.fromByteArray = fromByteArray;\n      var lookup = [];\n      var revLookup = [];\n      var Arr = typeof Uint8Array !== \"undefined\" ? Uint8Array : Array;\n      var code = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n      for (i = 0, len = code.length; i < len; ++i) {\n        lookup[i] = code[i];\n        revLookup[code.charCodeAt(i)] = i;\n      }\n      var i;\n      var len;\n      revLookup[\"-\".charCodeAt(0)] = 62;\n      revLookup[\"_\".charCodeAt(0)] = 63;\n      function getLens(b64) {\n        var len2 = b64.length;\n        if (len2 % 4 > 0) {\n          throw new Error(\"Invalid string. Length must be a multiple of 4\");\n        }\n        var validLen = b64.indexOf(\"=\");\n        if (validLen === -1)\n          validLen = len2;\n        var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;\n        return [validLen, placeHoldersLen];\n      }\n      function byteLength(b64) {\n        var lens = getLens(b64);\n        var validLen = lens[0];\n        var placeHoldersLen = lens[1];\n        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n      }\n      function _byteLength(b64, validLen, placeHoldersLen) {\n        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n      }\n      function toByteArray(b64) {\n        var tmp;\n        var lens = getLens(b64);\n        var validLen = lens[0];\n        var placeHoldersLen = lens[1];\n        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n        var curByte = 0;\n        var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;\n        var i2;\n        for (i2 = 0; i2 < len2; i2 += 4) {\n          tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];\n          arr[curByte++] = tmp >> 16 & 255;\n          arr[curByte++] = tmp >> 8 & 255;\n          arr[curByte++] = tmp & 255;\n        }\n        if (placeHoldersLen === 2) {\n          tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;\n          arr[curByte++] = tmp & 255;\n        }\n        if (placeHoldersLen === 1) {\n          tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;\n          arr[curByte++] = tmp >> 8 & 255;\n          arr[curByte++] = tmp & 255;\n        }\n        return arr;\n      }\n      function tripletToBase64(num) {\n        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];\n      }\n      function encodeChunk(uint8, start, end) {\n        var tmp;\n        var output = [];\n        for (var i2 = start; i2 < end; i2 += 3) {\n          tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);\n          output.push(tripletToBase64(tmp));\n        }\n        return output.join(\"\");\n      }\n      function fromByteArray(uint8) {\n        var tmp;\n        var len2 = uint8.length;\n        var extraBytes = len2 % 3;\n        var parts = [];\n        var maxChunkLength = 16383;\n        for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {\n          parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));\n        }\n        if (extraBytes === 1) {\n          tmp = uint8[len2 - 1];\n          parts.push(\n            lookup[tmp >> 2] + lookup[tmp << 4 & 63] + \"==\"\n          );\n        } else if (extraBytes === 2) {\n          tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];\n          parts.push(\n            lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + \"=\"\n          );\n        }\n        return parts.join(\"\");\n      }\n    }\n  });\n\n  // node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js\n  var require_ieee754 = __commonJS({\n    \"node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js\"(exports) {\n      init_dist();\n      exports.read = function(buffer, offset, isLE, mLen, nBytes) {\n        var e, m;\n        var eLen = nBytes * 8 - mLen - 1;\n        var eMax = (1 << eLen) - 1;\n        var eBias = eMax >> 1;\n        var nBits = -7;\n        var i = isLE ? nBytes - 1 : 0;\n        var d = isLE ? -1 : 1;\n        var s2 = buffer[offset + i];\n        i += d;\n        e = s2 & (1 << -nBits) - 1;\n        s2 >>= -nBits;\n        nBits += eLen;\n        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {\n        }\n        m = e & (1 << -nBits) - 1;\n        e >>= -nBits;\n        nBits += mLen;\n        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {\n        }\n        if (e === 0) {\n          e = 1 - eBias;\n        } else if (e === eMax) {\n          return m ? NaN : (s2 ? -1 : 1) * Infinity;\n        } else {\n          m = m + Math.pow(2, mLen);\n          e = e - eBias;\n        }\n        return (s2 ? -1 : 1) * m * Math.pow(2, e - mLen);\n      };\n      exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {\n        var e, m, c;\n        var eLen = nBytes * 8 - mLen - 1;\n        var eMax = (1 << eLen) - 1;\n        var eBias = eMax >> 1;\n        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n        var i = isLE ? 0 : nBytes - 1;\n        var d = isLE ? 1 : -1;\n        var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n        value = Math.abs(value);\n        if (isNaN(value) || value === Infinity) {\n          m = isNaN(value) ? 1 : 0;\n          e = eMax;\n        } else {\n          e = Math.floor(Math.log(value) / Math.LN2);\n          if (value * (c = Math.pow(2, -e)) < 1) {\n            e--;\n            c *= 2;\n          }\n          if (e + eBias >= 1) {\n            value += rt / c;\n          } else {\n            value += rt * Math.pow(2, 1 - eBias);\n          }\n          if (value * c >= 2) {\n            e++;\n            c /= 2;\n          }\n          if (e + eBias >= eMax) {\n            m = 0;\n            e = eMax;\n          } else if (e + eBias >= 1) {\n            m = (value * c - 1) * Math.pow(2, mLen);\n            e = e + eBias;\n          } else {\n            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n            e = 0;\n          }\n        }\n        for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {\n        }\n        e = e << mLen | m;\n        eLen += mLen;\n        for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {\n        }\n        buffer[offset + i - d] |= s2 * 128;\n      };\n    }\n  });\n\n  // node_modules/.pnpm/buffer@6.0.3_patch_hash=zkkuxompt5d553skpnegwi5wuy/node_modules/buffer/index.js\n  var require_buffer = __commonJS({\n    \"node_modules/.pnpm/buffer@6.0.3_patch_hash=zkkuxompt5d553skpnegwi5wuy/node_modules/buffer/index.js\"(exports) {\n      \"use strict\";\n      init_dist();\n      var base64 = require_base64_js();\n      var ieee754 = require_ieee754();\n      var customInspectSymbol = typeof Symbol === \"function\" && typeof Symbol[\"for\"] === \"function\" ? Symbol[\"for\"](\"nodejs.util.inspect.custom\") : null;\n      exports.Buffer = Buffer2;\n      exports.SlowBuffer = SlowBuffer;\n      exports.INSPECT_MAX_BYTES = 50;\n      var K_MAX_LENGTH = 2147483647;\n      exports.kMaxLength = K_MAX_LENGTH;\n      var { Uint8Array: GlobalUint8Array, ArrayBuffer: GlobalArrayBuffer, SharedArrayBuffer: GlobalSharedArrayBuffer } = globalThis;\n      Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();\n      if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== \"undefined\" && typeof console.error === \"function\") {\n        console.error(\n          \"This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.\"\n        );\n      }\n      function typedArraySupport() {\n        try {\n          const arr = new GlobalUint8Array(1);\n          const proto = { foo: function() {\n            return 42;\n          } };\n          Object.setPrototypeOf(proto, GlobalUint8Array.prototype);\n          Object.setPrototypeOf(arr, proto);\n          return arr.foo() === 42;\n        } catch (e) {\n          return false;\n        }\n      }\n      Object.defineProperty(Buffer2.prototype, \"parent\", {\n        enumerable: true,\n        get: function() {\n          if (!Buffer2.isBuffer(this))\n            return void 0;\n          return this.buffer;\n        }\n      });\n      Object.defineProperty(Buffer2.prototype, \"offset\", {\n        enumerable: true,\n        get: function() {\n          if (!Buffer2.isBuffer(this))\n            return void 0;\n          return this.byteOffset;\n        }\n      });\n      function createBuffer(length) {\n        if (length > K_MAX_LENGTH) {\n          throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"');\n        }\n        const buf = new GlobalUint8Array(length);\n        Object.setPrototypeOf(buf, Buffer2.prototype);\n        return buf;\n      }\n      function Buffer2(arg, encodingOrOffset, length) {\n        if (typeof arg === \"number\") {\n          if (typeof encodingOrOffset === \"string\") {\n            throw new TypeError(\n              'The \"string\" argument must be of type string. Received type number'\n            );\n          }\n          return allocUnsafe(arg);\n        }\n        return from(arg, encodingOrOffset, length);\n      }\n      Buffer2.poolSize = 8192;\n      function from(value, encodingOrOffset, length) {\n        if (typeof value === \"string\") {\n          return fromString(value, encodingOrOffset);\n        }\n        if (GlobalArrayBuffer.isView(value)) {\n          return fromArrayView(value);\n        }\n        if (value == null) {\n          throw new TypeError(\n            \"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value\n          );\n        }\n        if (isInstance(value, GlobalArrayBuffer) || value && isInstance(value.buffer, GlobalArrayBuffer)) {\n          return fromArrayBuffer(value, encodingOrOffset, length);\n        }\n        if (typeof GlobalSharedArrayBuffer !== \"undefined\" && (isInstance(value, GlobalSharedArrayBuffer) || value && isInstance(value.buffer, GlobalSharedArrayBuffer))) {\n          return fromArrayBuffer(value, encodingOrOffset, length);\n        }\n        if (typeof value === \"number\") {\n          throw new TypeError(\n            'The \"value\" argument must not be of type number. Received type number'\n          );\n        }\n        const valueOf = value.valueOf && value.valueOf();\n        if (valueOf != null && valueOf !== value) {\n          return Buffer2.from(valueOf, encodingOrOffset, length);\n        }\n        const b = fromObject(value);\n        if (b)\n          return b;\n        if (typeof Symbol !== \"undefined\" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === \"function\") {\n          return Buffer2.from(value[Symbol.toPrimitive](\"string\"), encodingOrOffset, length);\n        }\n        throw new TypeError(\n          \"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value\n        );\n      }\n      Buffer2.from = function(value, encodingOrOffset, length) {\n        return from(value, encodingOrOffset, length);\n      };\n      Object.setPrototypeOf(Buffer2.prototype, GlobalUint8Array.prototype);\n      Object.setPrototypeOf(Buffer2, GlobalUint8Array);\n      function assertSize(size) {\n        if (typeof size !== \"number\") {\n          throw new TypeError('\"size\" argument must be of type number');\n        } else if (size < 0) {\n          throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"');\n        }\n      }\n      function alloc(size, fill, encoding) {\n        assertSize(size);\n        if (size <= 0) {\n          return createBuffer(size);\n        }\n        if (fill !== void 0) {\n          return typeof encoding === \"string\" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);\n        }\n        return createBuffer(size);\n      }\n      Buffer2.alloc = function(size, fill, encoding) {\n        return alloc(size, fill, encoding);\n      };\n      function allocUnsafe(size) {\n        assertSize(size);\n        return createBuffer(size < 0 ? 0 : checked(size) | 0);\n      }\n      Buffer2.allocUnsafe = function(size) {\n        return allocUnsafe(size);\n      };\n      Buffer2.allocUnsafeSlow = function(size) {\n        return allocUnsafe(size);\n      };\n      function fromString(string, encoding) {\n        if (typeof encoding !== \"string\" || encoding === \"\") {\n          encoding = \"utf8\";\n        }\n        if (!Buffer2.isEncoding(encoding)) {\n          throw new TypeError(\"Unknown encoding: \" + encoding);\n        }\n        const length = byteLength(string, encoding) | 0;\n        let buf = createBuffer(length);\n        const actual = buf.write(string, encoding);\n        if (actual !== length) {\n          buf = buf.slice(0, actual);\n        }\n        return buf;\n      }\n      function fromArrayLike(array) {\n        const length = array.length < 0 ? 0 : checked(array.length) | 0;\n        const buf = createBuffer(length);\n        for (let i = 0; i < length; i += 1) {\n          buf[i] = array[i] & 255;\n        }\n        return buf;\n      }\n      function fromArrayView(arrayView) {\n        if (isInstance(arrayView, GlobalUint8Array)) {\n          const copy = new GlobalUint8Array(arrayView);\n          return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);\n        }\n        return fromArrayLike(arrayView);\n      }\n      function fromArrayBuffer(array, byteOffset, length) {\n        if (byteOffset < 0 || array.byteLength < byteOffset) {\n          throw new RangeError('\"offset\" is outside of buffer bounds');\n        }\n        if (array.byteLength < byteOffset + (length || 0)) {\n          throw new RangeError('\"length\" is outside of buffer bounds');\n        }\n        let buf;\n        if (byteOffset === void 0 && length === void 0) {\n          buf = new GlobalUint8Array(array);\n        } else if (length === void 0) {\n          buf = new GlobalUint8Array(array, byteOffset);\n        } else {\n          buf = new GlobalUint8Array(array, byteOffset, length);\n        }\n        Object.setPrototypeOf(buf, Buffer2.prototype);\n        return buf;\n      }\n      function fromObject(obj) {\n        if (Buffer2.isBuffer(obj)) {\n          const len = checked(obj.length) | 0;\n          const buf = createBuffer(len);\n          if (buf.length === 0) {\n            return buf;\n          }\n          obj.copy(buf, 0, 0, len);\n          return buf;\n        }\n        if (obj.length !== void 0) {\n          if (typeof obj.length !== \"number\" || numberIsNaN(obj.length)) {\n            return createBuffer(0);\n          }\n          return fromArrayLike(obj);\n        }\n        if (obj.type === \"Buffer\" && Array.isArray(obj.data)) {\n          return fromArrayLike(obj.data);\n        }\n      }\n      function checked(length) {\n        if (length >= K_MAX_LENGTH) {\n          throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\" + K_MAX_LENGTH.toString(16) + \" bytes\");\n        }\n        return length | 0;\n      }\n      function SlowBuffer(length) {\n        if (+length != length) {\n          length = 0;\n        }\n        return Buffer2.alloc(+length);\n      }\n      Buffer2.isBuffer = function isBuffer(b) {\n        return b != null && b._isBuffer === true && b !== Buffer2.prototype;\n      };\n      Buffer2.compare = function compare(a, b) {\n        if (isInstance(a, GlobalUint8Array))\n          a = Buffer2.from(a, a.offset, a.byteLength);\n        if (isInstance(b, GlobalUint8Array))\n          b = Buffer2.from(b, b.offset, b.byteLength);\n        if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {\n          throw new TypeError(\n            'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n          );\n        }\n        if (a === b)\n          return 0;\n        let x = a.length;\n        let y = b.length;\n        for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n          if (a[i] !== b[i]) {\n            x = a[i];\n            y = b[i];\n            break;\n          }\n        }\n        if (x < y)\n          return -1;\n        if (y < x)\n          return 1;\n        return 0;\n      };\n      Buffer2.isEncoding = function isEncoding(encoding) {\n        switch (String(encoding).toLowerCase()) {\n          case \"hex\":\n          case \"utf8\":\n          case \"utf-8\":\n          case \"ascii\":\n          case \"latin1\":\n          case \"binary\":\n          case \"base64\":\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return true;\n          default:\n            return false;\n        }\n      };\n      Buffer2.concat = function concat(list, length) {\n        if (!Array.isArray(list)) {\n          throw new TypeError('\"list\" argument must be an Array of Buffers');\n        }\n        if (list.length === 0) {\n          return Buffer2.alloc(0);\n        }\n        let i;\n        if (length === void 0) {\n          length = 0;\n          for (i = 0; i < list.length; ++i) {\n            length += list[i].length;\n          }\n        }\n        const buffer = Buffer2.allocUnsafe(length);\n        let pos = 0;\n        for (i = 0; i < list.length; ++i) {\n          let buf = list[i];\n          if (isInstance(buf, GlobalUint8Array)) {\n            if (pos + buf.length > buffer.length) {\n              if (!Buffer2.isBuffer(buf))\n                buf = Buffer2.from(buf);\n              buf.copy(buffer, pos);\n            } else {\n              GlobalUint8Array.prototype.set.call(\n                buffer,\n                buf,\n                pos\n              );\n            }\n          } else if (!Buffer2.isBuffer(buf)) {\n            throw new TypeError('\"list\" argument must be an Array of Buffers');\n          } else {\n            buf.copy(buffer, pos);\n          }\n          pos += buf.length;\n        }\n        return buffer;\n      };\n      function byteLength(string, encoding) {\n        if (Buffer2.isBuffer(string)) {\n          return string.length;\n        }\n        if (GlobalArrayBuffer.isView(string) || isInstance(string, GlobalArrayBuffer)) {\n          return string.byteLength;\n        }\n        if (typeof string !== \"string\") {\n          throw new TypeError(\n            'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string\n          );\n        }\n        const len = string.length;\n        const mustMatch = arguments.length > 2 && arguments[2] === true;\n        if (!mustMatch && len === 0)\n          return 0;\n        let loweredCase = false;\n        for (; ; ) {\n          switch (encoding) {\n            case \"ascii\":\n            case \"latin1\":\n            case \"binary\":\n              return len;\n            case \"utf8\":\n            case \"utf-8\":\n              return utf8ToBytes(string).length;\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n              return len * 2;\n            case \"hex\":\n              return len >>> 1;\n            case \"base64\":\n              return base64ToBytes(string).length;\n            default:\n              if (loweredCase) {\n                return mustMatch ? -1 : utf8ToBytes(string).length;\n              }\n              encoding = (\"\" + encoding).toLowerCase();\n              loweredCase = true;\n          }\n        }\n      }\n      Buffer2.byteLength = byteLength;\n      function slowToString(encoding, start, end) {\n        let loweredCase = false;\n        if (start === void 0 || start < 0) {\n          start = 0;\n        }\n        if (start > this.length) {\n          return \"\";\n        }\n        if (end === void 0 || end > this.length) {\n          end = this.length;\n        }\n        if (end <= 0) {\n          return \"\";\n        }\n        end >>>= 0;\n        start >>>= 0;\n        if (end <= start) {\n          return \"\";\n        }\n        if (!encoding)\n          encoding = \"utf8\";\n        while (true) {\n          switch (encoding) {\n            case \"hex\":\n              return hexSlice(this, start, end);\n            case \"utf8\":\n            case \"utf-8\":\n              return utf8Slice(this, start, end);\n            case \"ascii\":\n              return asciiSlice(this, start, end);\n            case \"latin1\":\n            case \"binary\":\n              return latin1Slice(this, start, end);\n            case \"base64\":\n              return base64Slice(this, start, end);\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n              return utf16leSlice(this, start, end);\n            default:\n              if (loweredCase)\n                throw new TypeError(\"Unknown encoding: \" + encoding);\n              encoding = (encoding + \"\").toLowerCase();\n              loweredCase = true;\n          }\n        }\n      }\n      Buffer2.prototype._isBuffer = true;\n      function swap(b, n, m) {\n        const i = b[n];\n        b[n] = b[m];\n        b[m] = i;\n      }\n      Buffer2.prototype.swap16 = function swap16() {\n        const len = this.length;\n        if (len % 2 !== 0) {\n          throw new RangeError(\"Buffer size must be a multiple of 16-bits\");\n        }\n        for (let i = 0; i < len; i += 2) {\n          swap(this, i, i + 1);\n        }\n        return this;\n      };\n      Buffer2.prototype.swap32 = function swap32() {\n        const len = this.length;\n        if (len % 4 !== 0) {\n          throw new RangeError(\"Buffer size must be a multiple of 32-bits\");\n        }\n        for (let i = 0; i < len; i += 4) {\n          swap(this, i, i + 3);\n          swap(this, i + 1, i + 2);\n        }\n        return this;\n      };\n      Buffer2.prototype.swap64 = function swap64() {\n        const len = this.length;\n        if (len % 8 !== 0) {\n          throw new RangeError(\"Buffer size must be a multiple of 64-bits\");\n        }\n        for (let i = 0; i < len; i += 8) {\n          swap(this, i, i + 7);\n          swap(this, i + 1, i + 6);\n          swap(this, i + 2, i + 5);\n          swap(this, i + 3, i + 4);\n        }\n        return this;\n      };\n      Buffer2.prototype.toString = function toString() {\n        const length = this.length;\n        if (length === 0)\n          return \"\";\n        if (arguments.length === 0)\n          return utf8Slice(this, 0, length);\n        return slowToString.apply(this, arguments);\n      };\n      Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;\n      Buffer2.prototype.equals = function equals(b) {\n        if (!Buffer2.isBuffer(b))\n          throw new TypeError(\"Argument must be a Buffer\");\n        if (this === b)\n          return true;\n        return Buffer2.compare(this, b) === 0;\n      };\n      Buffer2.prototype.inspect = function inspect() {\n        let str = \"\";\n        const max = exports.INSPECT_MAX_BYTES;\n        str = this.toString(\"hex\", 0, max).replace(/(.{2})/g, \"$1 \").trim();\n        if (this.length > max)\n          str += \" ... \";\n        return \"<Buffer \" + str + \">\";\n      };\n      if (customInspectSymbol) {\n        Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;\n      }\n      Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n        if (isInstance(target, GlobalUint8Array)) {\n          target = Buffer2.from(target, target.offset, target.byteLength);\n        }\n        if (!Buffer2.isBuffer(target)) {\n          throw new TypeError(\n            'The \"target\" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target\n          );\n        }\n        if (start === void 0) {\n          start = 0;\n        }\n        if (end === void 0) {\n          end = target ? target.length : 0;\n        }\n        if (thisStart === void 0) {\n          thisStart = 0;\n        }\n        if (thisEnd === void 0) {\n          thisEnd = this.length;\n        }\n        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n          throw new RangeError(\"out of range index\");\n        }\n        if (thisStart >= thisEnd && start >= end) {\n          return 0;\n        }\n        if (thisStart >= thisEnd) {\n          return -1;\n        }\n        if (start >= end) {\n          return 1;\n        }\n        start >>>= 0;\n        end >>>= 0;\n        thisStart >>>= 0;\n        thisEnd >>>= 0;\n        if (this === target)\n          return 0;\n        let x = thisEnd - thisStart;\n        let y = end - start;\n        const len = Math.min(x, y);\n        const thisCopy = this.slice(thisStart, thisEnd);\n        const targetCopy = target.slice(start, end);\n        for (let i = 0; i < len; ++i) {\n          if (thisCopy[i] !== targetCopy[i]) {\n            x = thisCopy[i];\n            y = targetCopy[i];\n            break;\n          }\n        }\n        if (x < y)\n          return -1;\n        if (y < x)\n          return 1;\n        return 0;\n      };\n      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n        if (buffer.length === 0)\n          return -1;\n        if (typeof byteOffset === \"string\") {\n          encoding = byteOffset;\n          byteOffset = 0;\n        } else if (byteOffset > 2147483647) {\n          byteOffset = 2147483647;\n        } else if (byteOffset < -2147483648) {\n          byteOffset = -2147483648;\n        }\n        byteOffset = +byteOffset;\n        if (numberIsNaN(byteOffset)) {\n          byteOffset = dir ? 0 : buffer.length - 1;\n        }\n        if (byteOffset < 0)\n          byteOffset = buffer.length + byteOffset;\n        if (byteOffset >= buffer.length) {\n          if (dir)\n            return -1;\n          else\n            byteOffset = buffer.length - 1;\n        } else if (byteOffset < 0) {\n          if (dir)\n            byteOffset = 0;\n          else\n            return -1;\n        }\n        if (typeof val === \"string\") {\n          val = Buffer2.from(val, encoding);\n        }\n        if (Buffer2.isBuffer(val)) {\n          if (val.length === 0) {\n            return -1;\n          }\n          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n        } else if (typeof val === \"number\") {\n          val = val & 255;\n          if (typeof GlobalUint8Array.prototype.indexOf === \"function\") {\n            if (dir) {\n              return GlobalUint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n            } else {\n              return GlobalUint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n            }\n          }\n          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);\n        }\n        throw new TypeError(\"val must be string, number or Buffer\");\n      }\n      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n        let indexSize = 1;\n        let arrLength = arr.length;\n        let valLength = val.length;\n        if (encoding !== void 0) {\n          encoding = String(encoding).toLowerCase();\n          if (encoding === \"ucs2\" || encoding === \"ucs-2\" || encoding === \"utf16le\" || encoding === \"utf-16le\") {\n            if (arr.length < 2 || val.length < 2) {\n              return -1;\n            }\n            indexSize = 2;\n            arrLength /= 2;\n            valLength /= 2;\n            byteOffset /= 2;\n          }\n        }\n        function read(buf, i2) {\n          if (indexSize === 1) {\n            return buf[i2];\n          } else {\n            return buf.readUInt16BE(i2 * indexSize);\n          }\n        }\n        let i;\n        if (dir) {\n          let foundIndex = -1;\n          for (i = byteOffset; i < arrLength; i++) {\n            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n              if (foundIndex === -1)\n                foundIndex = i;\n              if (i - foundIndex + 1 === valLength)\n                return foundIndex * indexSize;\n            } else {\n              if (foundIndex !== -1)\n                i -= i - foundIndex;\n              foundIndex = -1;\n            }\n          }\n        } else {\n          if (byteOffset + valLength > arrLength)\n            byteOffset = arrLength - valLength;\n          for (i = byteOffset; i >= 0; i--) {\n            let found = true;\n            for (let j = 0; j < valLength; j++) {\n              if (read(arr, i + j) !== read(val, j)) {\n                found = false;\n                break;\n              }\n            }\n            if (found)\n              return i;\n          }\n        }\n        return -1;\n      }\n      Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {\n        return this.indexOf(val, byteOffset, encoding) !== -1;\n      };\n      Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n      };\n      Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n      };\n      function hexWrite(buf, string, offset, length) {\n        offset = Number(offset) || 0;\n        const remaining = buf.length - offset;\n        if (!length) {\n          length = remaining;\n        } else {\n          length = Number(length);\n          if (length > remaining) {\n            length = remaining;\n          }\n        }\n        const strLen = string.length;\n        if (length > strLen / 2) {\n          length = strLen / 2;\n        }\n        let i;\n        for (i = 0; i < length; ++i) {\n          const parsed = parseInt(string.substr(i * 2, 2), 16);\n          if (numberIsNaN(parsed))\n            return i;\n          buf[offset + i] = parsed;\n        }\n        return i;\n      }\n      function utf8Write(buf, string, offset, length) {\n        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n      }\n      function asciiWrite(buf, string, offset, length) {\n        return blitBuffer(asciiToBytes(string), buf, offset, length);\n      }\n      function base64Write(buf, string, offset, length) {\n        return blitBuffer(base64ToBytes(string), buf, offset, length);\n      }\n      function ucs2Write(buf, string, offset, length) {\n        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n      }\n      Buffer2.prototype.write = function write(string, offset, length, encoding) {\n        if (offset === void 0) {\n          encoding = \"utf8\";\n          length = this.length;\n          offset = 0;\n        } else if (length === void 0 && typeof offset === \"string\") {\n          encoding = offset;\n          length = this.length;\n          offset = 0;\n        } else if (isFinite(offset)) {\n          offset = offset >>> 0;\n          if (isFinite(length)) {\n            length = length >>> 0;\n            if (encoding === void 0)\n              encoding = \"utf8\";\n          } else {\n            encoding = length;\n            length = void 0;\n          }\n        } else {\n          throw new Error(\n            \"Buffer.write(string, encoding, offset[, length]) is no longer supported\"\n          );\n        }\n        const remaining = this.length - offset;\n        if (length === void 0 || length > remaining)\n          length = remaining;\n        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n          throw new RangeError(\"Attempt to write outside buffer bounds\");\n        }\n        if (!encoding)\n          encoding = \"utf8\";\n        let loweredCase = false;\n        for (; ; ) {\n          switch (encoding) {\n            case \"hex\":\n              return hexWrite(this, string, offset, length);\n            case \"utf8\":\n            case \"utf-8\":\n              return utf8Write(this, string, offset, length);\n            case \"ascii\":\n            case \"latin1\":\n            case \"binary\":\n              return asciiWrite(this, string, offset, length);\n            case \"base64\":\n              return base64Write(this, string, offset, length);\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n              return ucs2Write(this, string, offset, length);\n            default:\n              if (loweredCase)\n                throw new TypeError(\"Unknown encoding: \" + encoding);\n              encoding = (\"\" + encoding).toLowerCase();\n              loweredCase = true;\n          }\n        }\n      };\n      Buffer2.prototype.toJSON = function toJSON() {\n        return {\n          type: \"Buffer\",\n          data: Array.prototype.slice.call(this._arr || this, 0)\n        };\n      };\n      function base64Slice(buf, start, end) {\n        if (start === 0 && end === buf.length) {\n          return base64.fromByteArray(buf);\n        } else {\n          return base64.fromByteArray(buf.slice(start, end));\n        }\n      }\n      function utf8Slice(buf, start, end) {\n        end = Math.min(buf.length, end);\n        const res = [];\n        let i = start;\n        while (i < end) {\n          const firstByte = buf[i];\n          let codePoint = null;\n          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;\n          if (i + bytesPerSequence <= end) {\n            let secondByte, thirdByte, fourthByte, tempCodePoint;\n            switch (bytesPerSequence) {\n              case 1:\n                if (firstByte < 128) {\n                  codePoint = firstByte;\n                }\n                break;\n              case 2:\n                secondByte = buf[i + 1];\n                if ((secondByte & 192) === 128) {\n                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;\n                  if (tempCodePoint > 127) {\n                    codePoint = tempCodePoint;\n                  }\n                }\n                break;\n              case 3:\n                secondByte = buf[i + 1];\n                thirdByte = buf[i + 2];\n                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {\n                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;\n                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {\n                    codePoint = tempCodePoint;\n                  }\n                }\n                break;\n              case 4:\n                secondByte = buf[i + 1];\n                thirdByte = buf[i + 2];\n                fourthByte = buf[i + 3];\n                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {\n                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;\n                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {\n                    codePoint = tempCodePoint;\n                  }\n                }\n            }\n          }\n          if (codePoint === null) {\n            codePoint = 65533;\n            bytesPerSequence = 1;\n          } else if (codePoint > 65535) {\n            codePoint -= 65536;\n            res.push(codePoint >>> 10 & 1023 | 55296);\n            codePoint = 56320 | codePoint & 1023;\n          }\n          res.push(codePoint);\n          i += bytesPerSequence;\n        }\n        return decodeCodePointsArray(res);\n      }\n      var MAX_ARGUMENTS_LENGTH = 4096;\n      function decodeCodePointsArray(codePoints) {\n        const len = codePoints.length;\n        if (len <= MAX_ARGUMENTS_LENGTH) {\n          return String.fromCharCode.apply(String, codePoints);\n        }\n        let res = \"\";\n        let i = 0;\n        while (i < len) {\n          res += String.fromCharCode.apply(\n            String,\n            codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n          );\n        }\n        return res;\n      }\n      function asciiSlice(buf, start, end) {\n        let ret = \"\";\n        end = Math.min(buf.length, end);\n        for (let i = start; i < end; ++i) {\n          ret += String.fromCharCode(buf[i] & 127);\n        }\n        return ret;\n      }\n      function latin1Slice(buf, start, end) {\n        let ret = \"\";\n        end = Math.min(buf.length, end);\n        for (let i = start; i < end; ++i) {\n          ret += String.fromCharCode(buf[i]);\n        }\n        return ret;\n      }\n      function hexSlice(buf, start, end) {\n        const len = buf.length;\n        if (!start || start < 0)\n          start = 0;\n        if (!end || end < 0 || end > len)\n          end = len;\n        let out = \"\";\n        for (let i = start; i < end; ++i) {\n          out += hexSliceLookupTable[buf[i]];\n        }\n        return out;\n      }\n      function utf16leSlice(buf, start, end) {\n        const bytes = buf.slice(start, end);\n        let res = \"\";\n        for (let i = 0; i < bytes.length - 1; i += 2) {\n          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n        }\n        return res;\n      }\n      Buffer2.prototype.slice = function slice(start, end) {\n        const len = this.length;\n        start = ~~start;\n        end = end === void 0 ? len : ~~end;\n        if (start < 0) {\n          start += len;\n          if (start < 0)\n            start = 0;\n        } else if (start > len) {\n          start = len;\n        }\n        if (end < 0) {\n          end += len;\n          if (end < 0)\n            end = 0;\n        } else if (end > len) {\n          end = len;\n        }\n        if (end < start)\n          end = start;\n        const newBuf = this.subarray(start, end);\n        Object.setPrototypeOf(newBuf, Buffer2.prototype);\n        return newBuf;\n      };\n      function checkOffset(offset, ext, length) {\n        if (offset % 1 !== 0 || offset < 0)\n          throw new RangeError(\"offset is not uint\");\n        if (offset + ext > length)\n          throw new RangeError(\"Trying to access beyond buffer length\");\n      }\n      Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert)\n          checkOffset(offset, byteLength2, this.length);\n        let val = this[offset];\n        let mul = 1;\n        let i = 0;\n        while (++i < byteLength2 && (mul *= 256)) {\n          val += this[offset + i] * mul;\n        }\n        return val;\n      };\n      Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert) {\n          checkOffset(offset, byteLength2, this.length);\n        }\n        let val = this[offset + --byteLength2];\n        let mul = 1;\n        while (byteLength2 > 0 && (mul *= 256)) {\n          val += this[offset + --byteLength2] * mul;\n        }\n        return val;\n      };\n      Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 1, this.length);\n        return this[offset];\n      };\n      Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 2, this.length);\n        return this[offset] | this[offset + 1] << 8;\n      };\n      Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 2, this.length);\n        return this[offset] << 8 | this[offset + 1];\n      };\n      Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;\n      };\n      Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n      };\n      Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {\n        offset = offset >>> 0;\n        validateNumber(offset, \"offset\");\n        const first = this[offset];\n        const last = this[offset + 7];\n        if (first === void 0 || last === void 0) {\n          boundsError(offset, this.length - 8);\n        }\n        const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;\n        const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;\n        return BigInt(lo) + (BigInt(hi) << BigInt(32));\n      });\n      Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {\n        offset = offset >>> 0;\n        validateNumber(offset, \"offset\");\n        const first = this[offset];\n        const last = this[offset + 7];\n        if (first === void 0 || last === void 0) {\n          boundsError(offset, this.length - 8);\n        }\n        const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];\n        const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;\n        return (BigInt(hi) << BigInt(32)) + BigInt(lo);\n      });\n      Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert)\n          checkOffset(offset, byteLength2, this.length);\n        let val = this[offset];\n        let mul = 1;\n        let i = 0;\n        while (++i < byteLength2 && (mul *= 256)) {\n          val += this[offset + i] * mul;\n        }\n        mul *= 128;\n        if (val >= mul)\n          val -= Math.pow(2, 8 * byteLength2);\n        return val;\n      };\n      Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert)\n          checkOffset(offset, byteLength2, this.length);\n        let i = byteLength2;\n        let mul = 1;\n        let val = this[offset + --i];\n        while (i > 0 && (mul *= 256)) {\n          val += this[offset + --i] * mul;\n        }\n        mul *= 128;\n        if (val >= mul)\n          val -= Math.pow(2, 8 * byteLength2);\n        return val;\n      };\n      Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 1, this.length);\n        if (!(this[offset] & 128))\n          return this[offset];\n        return (255 - this[offset] + 1) * -1;\n      };\n      Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 2, this.length);\n        const val = this[offset] | this[offset + 1] << 8;\n        return val & 32768 ? val | 4294901760 : val;\n      };\n      Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 2, this.length);\n        const val = this[offset + 1] | this[offset] << 8;\n        return val & 32768 ? val | 4294901760 : val;\n      };\n      Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n      };\n      Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n      };\n      Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {\n        offset = offset >>> 0;\n        validateNumber(offset, \"offset\");\n        const first = this[offset];\n        const last = this[offset + 7];\n        if (first === void 0 || last === void 0) {\n          boundsError(offset, this.length - 8);\n        }\n        const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);\n        return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);\n      });\n      Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {\n        offset = offset >>> 0;\n        validateNumber(offset, \"offset\");\n        const first = this[offset];\n        const last = this[offset + 7];\n        if (first === void 0 || last === void 0) {\n          boundsError(offset, this.length - 8);\n        }\n        const val = (first << 24) + // Overflow\n        this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];\n        return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);\n      });\n      Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return ieee754.read(this, offset, true, 23, 4);\n      };\n      Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return ieee754.read(this, offset, false, 23, 4);\n      };\n      Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 8, this.length);\n        return ieee754.read(this, offset, true, 52, 8);\n      };\n      Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 8, this.length);\n        return ieee754.read(this, offset, false, 52, 8);\n      };\n      function checkInt(buf, value, offset, ext, max, min) {\n        if (!Buffer2.isBuffer(buf))\n          throw new TypeError('\"buffer\" argument must be a Buffer instance');\n        if (value > max || value < min)\n          throw new RangeError('\"value\" argument is out of bounds');\n        if (offset + ext > buf.length)\n          throw new RangeError(\"Index out of range\");\n      }\n      Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert) {\n          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;\n          checkInt(this, value, offset, byteLength2, maxBytes, 0);\n        }\n        let mul = 1;\n        let i = 0;\n        this[offset] = value & 255;\n        while (++i < byteLength2 && (mul *= 256)) {\n          this[offset + i] = value / mul & 255;\n        }\n        return offset + byteLength2;\n      };\n      Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert) {\n          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;\n          checkInt(this, value, offset, byteLength2, maxBytes, 0);\n        }\n        let i = byteLength2 - 1;\n        let mul = 1;\n        this[offset + i] = value & 255;\n        while (--i >= 0 && (mul *= 256)) {\n          this[offset + i] = value / mul & 255;\n        }\n        return offset + byteLength2;\n      };\n      Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 1, 255, 0);\n        this[offset] = value & 255;\n        return offset + 1;\n      };\n      Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 2, 65535, 0);\n        this[offset] = value & 255;\n        this[offset + 1] = value >>> 8;\n        return offset + 2;\n      };\n      Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 2, 65535, 0);\n        this[offset] = value >>> 8;\n        this[offset + 1] = value & 255;\n        return offset + 2;\n      };\n      Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 4, 4294967295, 0);\n        this[offset + 3] = value >>> 24;\n        this[offset + 2] = value >>> 16;\n        this[offset + 1] = value >>> 8;\n        this[offset] = value & 255;\n        return offset + 4;\n      };\n      Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 4, 4294967295, 0);\n        this[offset] = value >>> 24;\n        this[offset + 1] = value >>> 16;\n        this[offset + 2] = value >>> 8;\n        this[offset + 3] = value & 255;\n        return offset + 4;\n      };\n      function wrtBigUInt64LE(buf, value, offset, min, max) {\n        checkIntBI(value, min, max, buf, offset, 7);\n        let lo = Number(value & BigInt(4294967295));\n        buf[offset++] = lo;\n        lo = lo >> 8;\n        buf[offset++] = lo;\n        lo = lo >> 8;\n        buf[offset++] = lo;\n        lo = lo >> 8;\n        buf[offset++] = lo;\n        let hi = Number(value >> BigInt(32) & BigInt(4294967295));\n        buf[offset++] = hi;\n        hi = hi >> 8;\n        buf[offset++] = hi;\n        hi = hi >> 8;\n        buf[offset++] = hi;\n        hi = hi >> 8;\n        buf[offset++] = hi;\n        return offset;\n      }\n      function wrtBigUInt64BE(buf, value, offset, min, max) {\n        checkIntBI(value, min, max, buf, offset, 7);\n        let lo = Number(value & BigInt(4294967295));\n        buf[offset + 7] = lo;\n        lo = lo >> 8;\n        buf[offset + 6] = lo;\n        lo = lo >> 8;\n        buf[offset + 5] = lo;\n        lo = lo >> 8;\n        buf[offset + 4] = lo;\n        let hi = Number(value >> BigInt(32) & BigInt(4294967295));\n        buf[offset + 3] = hi;\n        hi = hi >> 8;\n        buf[offset + 2] = hi;\n        hi = hi >> 8;\n        buf[offset + 1] = hi;\n        hi = hi >> 8;\n        buf[offset] = hi;\n        return offset + 8;\n      }\n      Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {\n        return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n      });\n      Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {\n        return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n      });\n      Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          const limit = Math.pow(2, 8 * byteLength2 - 1);\n          checkInt(this, value, offset, byteLength2, limit - 1, -limit);\n        }\n        let i = 0;\n        let mul = 1;\n        let sub = 0;\n        this[offset] = value & 255;\n        while (++i < byteLength2 && (mul *= 256)) {\n          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n            sub = 1;\n          }\n          this[offset + i] = (value / mul >> 0) - sub & 255;\n        }\n        return offset + byteLength2;\n      };\n      Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          const limit = Math.pow(2, 8 * byteLength2 - 1);\n          checkInt(this, value, offset, byteLength2, limit - 1, -limit);\n        }\n        let i = byteLength2 - 1;\n        let mul = 1;\n        let sub = 0;\n        this[offset + i] = value & 255;\n        while (--i >= 0 && (mul *= 256)) {\n          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n            sub = 1;\n          }\n          this[offset + i] = (value / mul >> 0) - sub & 255;\n        }\n        return offset + byteLength2;\n      };\n      Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 1, 127, -128);\n        if (value < 0)\n          value = 255 + value + 1;\n        this[offset] = value & 255;\n        return offset + 1;\n      };\n      Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 2, 32767, -32768);\n        this[offset] = value & 255;\n        this[offset + 1] = value >>> 8;\n        return offset + 2;\n      };\n      Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 2, 32767, -32768);\n        this[offset] = value >>> 8;\n        this[offset + 1] = value & 255;\n        return offset + 2;\n      };\n      Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 4, 2147483647, -2147483648);\n        this[offset] = value & 255;\n        this[offset + 1] = value >>> 8;\n        this[offset + 2] = value >>> 16;\n        this[offset + 3] = value >>> 24;\n        return offset + 4;\n      };\n      Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 4, 2147483647, -2147483648);\n        if (value < 0)\n          value = 4294967295 + value + 1;\n        this[offset] = value >>> 24;\n        this[offset + 1] = value >>> 16;\n        this[offset + 2] = value >>> 8;\n        this[offset + 3] = value & 255;\n        return offset + 4;\n      };\n      Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {\n        return wrtBigUInt64LE(this, value, offset, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n      });\n      Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {\n        return wrtBigUInt64BE(this, value, offset, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n      });\n      function checkIEEE754(buf, value, offset, ext, max, min) {\n        if (offset + ext > buf.length)\n          throw new RangeError(\"Index out of range\");\n        if (offset < 0)\n          throw new RangeError(\"Index out of range\");\n      }\n      function writeFloat(buf, value, offset, littleEndian, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);\n        }\n        ieee754.write(buf, value, offset, littleEndian, 23, 4);\n        return offset + 4;\n      }\n      Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n        return writeFloat(this, value, offset, true, noAssert);\n      };\n      Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n        return writeFloat(this, value, offset, false, noAssert);\n      };\n      function writeDouble(buf, value, offset, littleEndian, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);\n        }\n        ieee754.write(buf, value, offset, littleEndian, 52, 8);\n        return offset + 8;\n      }\n      Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n        return writeDouble(this, value, offset, true, noAssert);\n      };\n      Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n        return writeDouble(this, value, offset, false, noAssert);\n      };\n      Buffer2.prototype.copy = function copy(target, targetStart, start, end) {\n        if (!Buffer2.isBuffer(target))\n          throw new TypeError(\"argument should be a Buffer\");\n        if (!start)\n          start = 0;\n        if (!end && end !== 0)\n          end = this.length;\n        if (targetStart >= target.length)\n          targetStart = target.length;\n        if (!targetStart)\n          targetStart = 0;\n        if (end > 0 && end < start)\n          end = start;\n        if (end === start)\n          return 0;\n        if (target.length === 0 || this.length === 0)\n          return 0;\n        if (targetStart < 0) {\n          throw new RangeError(\"targetStart out of bounds\");\n        }\n        if (start < 0 || start >= this.length)\n          throw new RangeError(\"Index out of range\");\n        if (end < 0)\n          throw new RangeError(\"sourceEnd out of bounds\");\n        if (end > this.length)\n          end = this.length;\n        if (target.length - targetStart < end - start) {\n          end = target.length - targetStart + start;\n        }\n        const len = end - start;\n        if (this === target && typeof GlobalUint8Array.prototype.copyWithin === \"function\") {\n          this.copyWithin(targetStart, start, end);\n        } else {\n          GlobalUint8Array.prototype.set.call(\n            target,\n            this.subarray(start, end),\n            targetStart\n          );\n        }\n        return len;\n      };\n      Buffer2.prototype.fill = function fill(val, start, end, encoding) {\n        if (typeof val === \"string\") {\n          if (typeof start === \"string\") {\n            encoding = start;\n            start = 0;\n            end = this.length;\n          } else if (typeof end === \"string\") {\n            encoding = end;\n            end = this.length;\n          }\n          if (encoding !== void 0 && typeof encoding !== \"string\") {\n            throw new TypeError(\"encoding must be a string\");\n          }\n          if (typeof encoding === \"string\" && !Buffer2.isEncoding(encoding)) {\n            throw new TypeError(\"Unknown encoding: \" + encoding);\n          }\n          if (val.length === 1) {\n            const code = val.charCodeAt(0);\n            if (encoding === \"utf8\" && code < 128 || encoding === \"latin1\") {\n              val = code;\n            }\n          }\n        } else if (typeof val === \"number\") {\n          val = val & 255;\n        } else if (typeof val === \"boolean\") {\n          val = Number(val);\n        }\n        if (start < 0 || this.length < start || this.length < end) {\n          throw new RangeError(\"Out of range index\");\n        }\n        if (end <= start) {\n          return this;\n        }\n        start = start >>> 0;\n        end = end === void 0 ? this.length : end >>> 0;\n        if (!val)\n          val = 0;\n        let i;\n        if (typeof val === \"number\") {\n          for (i = start; i < end; ++i) {\n            this[i] = val;\n          }\n        } else {\n          const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);\n          const len = bytes.length;\n          if (len === 0) {\n            throw new TypeError('The value \"' + val + '\" is invalid for argument \"value\"');\n          }\n          for (i = 0; i < end - start; ++i) {\n            this[i + start] = bytes[i % len];\n          }\n        }\n        return this;\n      };\n      var errors = {};\n      function E(sym, getMessage, Base) {\n        errors[sym] = class NodeError extends Base {\n          constructor() {\n            super();\n            Object.defineProperty(this, \"message\", {\n              value: getMessage.apply(this, arguments),\n              writable: true,\n              configurable: true\n            });\n            this.name = `${this.name} [${sym}]`;\n            this.stack;\n            delete this.name;\n          }\n          get code() {\n            return sym;\n          }\n          set code(value) {\n            Object.defineProperty(this, \"code\", {\n              configurable: true,\n              enumerable: true,\n              value,\n              writable: true\n            });\n          }\n          toString() {\n            return `${this.name} [${sym}]: ${this.message}`;\n          }\n        };\n      }\n      E(\n        \"ERR_BUFFER_OUT_OF_BOUNDS\",\n        function(name) {\n          if (name) {\n            return `${name} is outside of buffer bounds`;\n          }\n          return \"Attempt to access memory outside buffer bounds\";\n        },\n        RangeError\n      );\n      E(\n        \"ERR_INVALID_ARG_TYPE\",\n        function(name, actual) {\n          return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`;\n        },\n        TypeError\n      );\n      E(\n        \"ERR_OUT_OF_RANGE\",\n        function(str, range, input) {\n          let msg = `The value of \"${str}\" is out of range.`;\n          let received = input;\n          if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n            received = addNumericalSeparator(String(input));\n          } else if (typeof input === \"bigint\") {\n            received = String(input);\n            if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n              received = addNumericalSeparator(received);\n            }\n            received += \"n\";\n          }\n          msg += ` It must be ${range}. Received ${received}`;\n          return msg;\n        },\n        RangeError\n      );\n      function addNumericalSeparator(val) {\n        let res = \"\";\n        let i = val.length;\n        const start = val[0] === \"-\" ? 1 : 0;\n        for (; i >= start + 4; i -= 3) {\n          res = `_${val.slice(i - 3, i)}${res}`;\n        }\n        return `${val.slice(0, i)}${res}`;\n      }\n      function checkBounds(buf, offset, byteLength2) {\n        validateNumber(offset, \"offset\");\n        if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {\n          boundsError(offset, buf.length - (byteLength2 + 1));\n        }\n      }\n      function checkIntBI(value, min, max, buf, offset, byteLength2) {\n        if (value > max || value < min) {\n          const n = typeof min === \"bigint\" ? \"n\" : \"\";\n          let range;\n          if (byteLength2 > 3) {\n            if (min === 0 || min === BigInt(0)) {\n              range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;\n            } else {\n              range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;\n            }\n          } else {\n            range = `>= ${min}${n} and <= ${max}${n}`;\n          }\n          throw new errors.ERR_OUT_OF_RANGE(\"value\", range, value);\n        }\n        checkBounds(buf, offset, byteLength2);\n      }\n      function validateNumber(value, name) {\n        if (typeof value !== \"number\") {\n          throw new errors.ERR_INVALID_ARG_TYPE(name, \"number\", value);\n        }\n      }\n      function boundsError(value, length, type) {\n        if (Math.floor(value) !== value) {\n          validateNumber(value, type);\n          throw new errors.ERR_OUT_OF_RANGE(type || \"offset\", \"an integer\", value);\n        }\n        if (length < 0) {\n          throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();\n        }\n        throw new errors.ERR_OUT_OF_RANGE(\n          type || \"offset\",\n          `>= ${type ? 1 : 0} and <= ${length}`,\n          value\n        );\n      }\n      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;\n      function base64clean(str) {\n        str = str.split(\"=\")[0];\n        str = str.trim().replace(INVALID_BASE64_RE, \"\");\n        if (str.length < 2)\n          return \"\";\n        while (str.length % 4 !== 0) {\n          str = str + \"=\";\n        }\n        return str;\n      }\n      function utf8ToBytes(string, units) {\n        units = units || Infinity;\n        let codePoint;\n        const length = string.length;\n        let leadSurrogate = null;\n        const bytes = [];\n        for (let i = 0; i < length; ++i) {\n          codePoint = string.charCodeAt(i);\n          if (codePoint > 55295 && codePoint < 57344) {\n            if (!leadSurrogate) {\n              if (codePoint > 56319) {\n                if ((units -= 3) > -1)\n                  bytes.push(239, 191, 189);\n                continue;\n              } else if (i + 1 === length) {\n                if ((units -= 3) > -1)\n                  bytes.push(239, 191, 189);\n                continue;\n              }\n              leadSurrogate = codePoint;\n              continue;\n            }\n            if (codePoint < 56320) {\n              if ((units -= 3) > -1)\n                bytes.push(239, 191, 189);\n              leadSurrogate = codePoint;\n              continue;\n            }\n            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;\n          } else if (leadSurrogate) {\n            if ((units -= 3) > -1)\n              bytes.push(239, 191, 189);\n          }\n          leadSurrogate = null;\n          if (codePoint < 128) {\n            if ((units -= 1) < 0)\n              break;\n            bytes.push(codePoint);\n          } else if (codePoint < 2048) {\n            if ((units -= 2) < 0)\n              break;\n            bytes.push(\n              codePoint >> 6 | 192,\n              codePoint & 63 | 128\n            );\n          } else if (codePoint < 65536) {\n            if ((units -= 3) < 0)\n              break;\n            bytes.push(\n              codePoint >> 12 | 224,\n              codePoint >> 6 & 63 | 128,\n              codePoint & 63 | 128\n            );\n          } else if (codePoint < 1114112) {\n            if ((units -= 4) < 0)\n              break;\n            bytes.push(\n              codePoint >> 18 | 240,\n              codePoint >> 12 & 63 | 128,\n              codePoint >> 6 & 63 | 128,\n              codePoint & 63 | 128\n            );\n          } else {\n            throw new Error(\"Invalid code point\");\n          }\n        }\n        return bytes;\n      }\n      function asciiToBytes(str) {\n        const byteArray = [];\n        for (let i = 0; i < str.length; ++i) {\n          byteArray.push(str.charCodeAt(i) & 255);\n        }\n        return byteArray;\n      }\n      function utf16leToBytes(str, units) {\n        let c, hi, lo;\n        const byteArray = [];\n        for (let i = 0; i < str.length; ++i) {\n          if ((units -= 2) < 0)\n            break;\n          c = str.charCodeAt(i);\n          hi = c >> 8;\n          lo = c % 256;\n          byteArray.push(lo);\n          byteArray.push(hi);\n        }\n        return byteArray;\n      }\n      function base64ToBytes(str) {\n        return base64.toByteArray(base64clean(str));\n      }\n      function blitBuffer(src, dst, offset, length) {\n        let i;\n        for (i = 0; i < length; ++i) {\n          if (i + offset >= dst.length || i >= src.length)\n            break;\n          dst[i + offset] = src[i];\n        }\n        return i;\n      }\n      function isInstance(obj, type) {\n        return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;\n      }\n      function numberIsNaN(obj) {\n        return obj !== obj;\n      }\n      var hexSliceLookupTable = function() {\n        const alphabet = \"0123456789abcdef\";\n        const table = new Array(256);\n        for (let i = 0; i < 16; ++i) {\n          const i16 = i * 16;\n          for (let j = 0; j < 16; ++j) {\n            table[i16 + j] = alphabet[i] + alphabet[j];\n          }\n        }\n        return table;\n      }();\n      function defineBigIntMethod(fn) {\n        return typeof BigInt === \"undefined\" ? BufferBigIntNotDefined : fn;\n      }\n      function BufferBigIntNotDefined() {\n        throw new Error(\"BigInt not supported\");\n      }\n    }\n  });\n\n  // node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js\n  var require_browser = __commonJS({\n    \"node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js\"(exports, module) {\n      init_dist();\n      var process = module.exports = {};\n      var cachedSetTimeout;\n      var cachedClearTimeout;\n      function defaultSetTimout() {\n        throw new Error(\"setTimeout has not been defined\");\n      }\n      function defaultClearTimeout() {\n        throw new Error(\"clearTimeout has not been defined\");\n      }\n      (function() {\n        try {\n          if (typeof setTimeout === \"function\") {\n            cachedSetTimeout = setTimeout;\n          } else {\n            cachedSetTimeout = defaultSetTimout;\n          }\n        } catch (e) {\n          cachedSetTimeout = defaultSetTimout;\n        }\n        try {\n          if (typeof clearTimeout === \"function\") {\n            cachedClearTimeout = clearTimeout;\n          } else {\n            cachedClearTimeout = defaultClearTimeout;\n          }\n        } catch (e) {\n          cachedClearTimeout = defaultClearTimeout;\n        }\n      })();\n      function runTimeout(fun) {\n        if (cachedSetTimeout === setTimeout) {\n          return setTimeout(fun, 0);\n        }\n        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n          cachedSetTimeout = setTimeout;\n          return setTimeout(fun, 0);\n        }\n        try {\n          return cachedSetTimeout(fun, 0);\n        } catch (e) {\n          try {\n            return cachedSetTimeout.call(null, fun, 0);\n          } catch (e2) {\n            return cachedSetTimeout.call(this, fun, 0);\n          }\n        }\n      }\n      function runClearTimeout(marker) {\n        if (cachedClearTimeout === clearTimeout) {\n          return clearTimeout(marker);\n        }\n        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n          cachedClearTimeout = clearTimeout;\n          return clearTimeout(marker);\n        }\n        try {\n          return cachedClearTimeout(marker);\n        } catch (e) {\n          try {\n            return cachedClearTimeout.call(null, marker);\n          } catch (e2) {\n            return cachedClearTimeout.call(this, marker);\n          }\n        }\n      }\n      var queue = [];\n      var draining = false;\n      var currentQueue;\n      var queueIndex = -1;\n      function cleanUpNextTick() {\n        if (!draining || !currentQueue) {\n          return;\n        }\n        draining = false;\n        if (currentQueue.length) {\n          queue = currentQueue.concat(queue);\n        } else {\n          queueIndex = -1;\n        }\n        if (queue.length) {\n          drainQueue();\n        }\n      }\n      function drainQueue() {\n        if (draining) {\n          return;\n        }\n        var timeout = runTimeout(cleanUpNextTick);\n        draining = true;\n        var len = queue.length;\n        while (len) {\n          currentQueue = queue;\n          queue = [];\n          while (++queueIndex < len) {\n            if (currentQueue) {\n              currentQueue[queueIndex].run();\n            }\n          }\n          queueIndex = -1;\n          len = queue.length;\n        }\n        currentQueue = null;\n        draining = false;\n        runClearTimeout(timeout);\n      }\n      process.nextTick = function(fun) {\n        var args = new Array(arguments.length - 1);\n        if (arguments.length > 1) {\n          for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n          }\n        }\n        queue.push(new Item(fun, args));\n        if (queue.length === 1 && !draining) {\n          runTimeout(drainQueue);\n        }\n      };\n      function Item(fun, array) {\n        this.fun = fun;\n        this.array = array;\n      }\n      Item.prototype.run = function() {\n        this.fun.apply(null, this.array);\n      };\n      process.title = \"browser\";\n      process.browser = true;\n      process.env = {};\n      process.argv = [];\n      process.version = \"\";\n      process.versions = {};\n      function noop() {\n      }\n      process.on = noop;\n      process.addListener = noop;\n      process.once = noop;\n      process.off = noop;\n      process.removeListener = noop;\n      process.removeAllListeners = noop;\n      process.emit = noop;\n      process.prependListener = noop;\n      process.prependOnceListener = noop;\n      process.listeners = function(name) {\n        return [];\n      };\n      process.binding = function(name) {\n        throw new Error(\"process.binding is not supported\");\n      };\n      process.cwd = function() {\n        return \"/\";\n      };\n      process.chdir = function(dir) {\n        throw new Error(\"process.chdir is not supported\");\n      };\n      process.umask = function() {\n        return 0;\n      };\n    }\n  });\n\n  // shims/dist/index.js\n  var import_buffer_polyfill, import_process, o;\n  var init_dist = __esm({\n    \"shims/dist/index.js\"() {\n      \"use strict\";\n      import_buffer_polyfill = __toESM(require_buffer(), 1);\n      import_process = __toESM(require_browser(), 1);\n      o = globalThis || void 0 || self;\n    }\n  });\n\n  // shims/banner/index.cjs\n  var require_banner = __commonJS({\n    \"shims/banner/index.cjs\"() {\n      init_dist();\n      globalThis.Buffer = globalThis.Buffer || import_buffer_polyfill.Buffer;\n      globalThis.global = globalThis.global || o;\n      globalThis.process = globalThis.process || import_process.default;\n    }\n  });\n  require_banner();\n})();\n/*! Bundled license information:\n\nieee754/index.js:\n  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)\n\nbuffer/index.js:\n  (*!\n   * The buffer module from node.js, for the browser.\n   *\n   * @author   Feross Aboukhadijeh <https://feross.org>\n   * @license  MIT\n   *)\n*/\n\nimport {\n  require_react\n} from \"./chunk-DMLNAHRU.js\";\nimport {\n  __toESM,\n  require_dist\n} from \"./chunk-4KAQPM64.js\";\n\n// node_modules/@auth0/auth0-react/dist/auth0-react.esm.js\nvar import_dist = __toESM(require_dist());\nvar import_react = __toESM(require_react());\nvar extendStatics = function(d2, b2) {\n  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n    d3.__proto__ = b3;\n  } || function(d3, b3) {\n    for (var p2 in b3)\n      if (Object.prototype.hasOwnProperty.call(b3, p2))\n        d3[p2] = b3[p2];\n  };\n  return extendStatics(d2, b2);\n};\nfunction __extends(d2, b2) {\n  if (typeof b2 !== \"function\" && b2 !== null)\n    throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n  extendStatics(d2, b2);\n  function __() {\n    this.constructor = d2;\n  }\n  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n}\nvar __assign = function() {\n  __assign = Object.assign || function __assign2(t2) {\n    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {\n      s2 = arguments[i2];\n      for (var p2 in s2)\n        if (Object.prototype.hasOwnProperty.call(s2, p2))\n          t2[p2] = s2[p2];\n    }\n    return t2;\n  };\n  return __assign.apply(this, arguments);\n};\nfunction __rest(s2, e2) {\n  var t2 = {};\n  for (var p2 in s2)\n    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)\n      t2[p2] = s2[p2];\n  if (s2 != null && typeof Object.getOwnPropertySymbols === \"function\")\n    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {\n      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))\n        t2[p2[i2]] = s2[p2[i2]];\n    }\n  return t2;\n}\nfunction __awaiter(thisArg, _arguments, P2, generator) {\n  function adopt(value) {\n    return value instanceof P2 ? value : new P2(function(resolve) {\n      resolve(value);\n    });\n  }\n  return new (P2 || (P2 = Promise))(function(resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e2) {\n        reject(e2);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e2) {\n        reject(e2);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\nfunction __generator(thisArg, body) {\n  var _2 = { label: 0, sent: function() {\n    if (t2[0] & 1)\n      throw t2[1];\n    return t2[1];\n  }, trys: [], ops: [] }, f2, y2, t2, g2;\n  return g2 = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g2[Symbol.iterator] = function() {\n    return this;\n  }), g2;\n  function verb(n2) {\n    return function(v2) {\n      return step([n2, v2]);\n    };\n  }\n  function step(op) {\n    if (f2)\n      throw new TypeError(\"Generator is already executing.\");\n    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)\n      try {\n        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2[\"return\"] : op[0] ? y2[\"throw\"] || ((t2 = y2[\"return\"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)\n          return t2;\n        if (y2 = 0, t2)\n          op = [op[0] & 2, t2.value];\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t2 = op;\n            break;\n          case 4:\n            _2.label++;\n            return { value: op[1], done: false };\n          case 5:\n            _2.label++;\n            y2 = op[1];\n            op = [0];\n            continue;\n          case 7:\n            op = _2.ops.pop();\n            _2.trys.pop();\n            continue;\n          default:\n            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _2 = 0;\n              continue;\n            }\n            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {\n              _2.label = op[1];\n              break;\n            }\n            if (op[0] === 6 && _2.label < t2[1]) {\n              _2.label = t2[1];\n              t2 = op;\n              break;\n            }\n            if (t2 && _2.label < t2[2]) {\n              _2.label = t2[2];\n              _2.ops.push(op);\n              break;\n            }\n            if (t2[2])\n              _2.ops.pop();\n            _2.trys.pop();\n            continue;\n        }\n        op = body.call(thisArg, _2);\n      } catch (e2) {\n        op = [6, e2];\n        y2 = 0;\n      } finally {\n        f2 = t2 = 0;\n      }\n    if (op[0] & 5)\n      throw op[1];\n    return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\nfunction e(e2, t2) {\n  var i2 = {};\n  for (var o2 in e2)\n    Object.prototype.hasOwnProperty.call(e2, o2) && t2.indexOf(o2) < 0 && (i2[o2] = e2[o2]);\n  if (null != e2 && \"function\" == typeof Object.getOwnPropertySymbols) {\n    var n2 = 0;\n    for (o2 = Object.getOwnPropertySymbols(e2); n2 < o2.length; n2++)\n      t2.indexOf(o2[n2]) < 0 && Object.prototype.propertyIsEnumerable.call(e2, o2[n2]) && (i2[o2[n2]] = e2[o2[n2]]);\n  }\n  return i2;\n}\nvar t = \"undefined\" != typeof globalThis ? globalThis : \"undefined\" != typeof window ? window : \"undefined\" != typeof global ? global : \"undefined\" != typeof self ? self : {};\nfunction i(e2) {\n  return e2 && e2.__esModule && Object.prototype.hasOwnProperty.call(e2, \"default\") ? e2.default : e2;\n}\nfunction o(e2, t2) {\n  return e2(t2 = { exports: {} }, t2.exports), t2.exports;\n}\nvar n = o(function(e2, t2) {\n  Object.defineProperty(t2, \"__esModule\", { value: true });\n  var i2 = function() {\n    function e3() {\n      var e4 = this;\n      this.locked = /* @__PURE__ */ new Map(), this.addToLocked = function(t3, i3) {\n        var o2 = e4.locked.get(t3);\n        void 0 === o2 ? void 0 === i3 ? e4.locked.set(t3, []) : e4.locked.set(t3, [i3]) : void 0 !== i3 && (o2.unshift(i3), e4.locked.set(t3, o2));\n      }, this.isLocked = function(t3) {\n        return e4.locked.has(t3);\n      }, this.lock = function(t3) {\n        return new Promise(function(i3, o2) {\n          e4.isLocked(t3) ? e4.addToLocked(t3, i3) : (e4.addToLocked(t3), i3());\n        });\n      }, this.unlock = function(t3) {\n        var i3 = e4.locked.get(t3);\n        if (void 0 !== i3 && 0 !== i3.length) {\n          var o2 = i3.pop();\n          e4.locked.set(t3, i3), void 0 !== o2 && setTimeout(o2, 0);\n        } else\n          e4.locked.delete(t3);\n      };\n    }\n    return e3.getInstance = function() {\n      return void 0 === e3.instance && (e3.instance = new e3()), e3.instance;\n    }, e3;\n  }();\n  t2.default = function() {\n    return i2.getInstance();\n  };\n});\ni(n);\nvar a = i(o(function(e2, i2) {\n  var o2 = t && t.__awaiter || function(e3, t2, i3, o3) {\n    return new (i3 || (i3 = Promise))(function(n2, a3) {\n      function r3(e4) {\n        try {\n          c3(o3.next(e4));\n        } catch (e5) {\n          a3(e5);\n        }\n      }\n      function s3(e4) {\n        try {\n          c3(o3.throw(e4));\n        } catch (e5) {\n          a3(e5);\n        }\n      }\n      function c3(e4) {\n        e4.done ? n2(e4.value) : new i3(function(t3) {\n          t3(e4.value);\n        }).then(r3, s3);\n      }\n      c3((o3 = o3.apply(e3, t2 || [])).next());\n    });\n  }, a2 = t && t.__generator || function(e3, t2) {\n    var i3, o3, n2, a3, r3 = { label: 0, sent: function() {\n      if (1 & n2[0])\n        throw n2[1];\n      return n2[1];\n    }, trys: [], ops: [] };\n    return a3 = { next: s3(0), throw: s3(1), return: s3(2) }, \"function\" == typeof Symbol && (a3[Symbol.iterator] = function() {\n      return this;\n    }), a3;\n    function s3(a4) {\n      return function(s4) {\n        return function(a5) {\n          if (i3)\n            throw new TypeError(\"Generator is already executing.\");\n          for (; r3; )\n            try {\n              if (i3 = 1, o3 && (n2 = 2 & a5[0] ? o3.return : a5[0] ? o3.throw || ((n2 = o3.return) && n2.call(o3), 0) : o3.next) && !(n2 = n2.call(o3, a5[1])).done)\n                return n2;\n              switch (o3 = 0, n2 && (a5 = [2 & a5[0], n2.value]), a5[0]) {\n                case 0:\n                case 1:\n                  n2 = a5;\n                  break;\n                case 4:\n                  return r3.label++, { value: a5[1], done: false };\n                case 5:\n                  r3.label++, o3 = a5[1], a5 = [0];\n                  continue;\n                case 7:\n                  a5 = r3.ops.pop(), r3.trys.pop();\n                  continue;\n                default:\n                  if (!(n2 = r3.trys, (n2 = n2.length > 0 && n2[n2.length - 1]) || 6 !== a5[0] && 2 !== a5[0])) {\n                    r3 = 0;\n                    continue;\n                  }\n                  if (3 === a5[0] && (!n2 || a5[1] > n2[0] && a5[1] < n2[3])) {\n                    r3.label = a5[1];\n                    break;\n                  }\n                  if (6 === a5[0] && r3.label < n2[1]) {\n                    r3.label = n2[1], n2 = a5;\n                    break;\n                  }\n                  if (n2 && r3.label < n2[2]) {\n                    r3.label = n2[2], r3.ops.push(a5);\n                    break;\n                  }\n                  n2[2] && r3.ops.pop(), r3.trys.pop();\n                  continue;\n              }\n              a5 = t2.call(e3, r3);\n            } catch (e4) {\n              a5 = [6, e4], o3 = 0;\n            } finally {\n              i3 = n2 = 0;\n            }\n          if (5 & a5[0])\n            throw a5[1];\n          return { value: a5[0] ? a5[1] : void 0, done: true };\n        }([a4, s4]);\n      };\n    }\n  }, r2 = t;\n  Object.defineProperty(i2, \"__esModule\", { value: true });\n  var s2 = \"browser-tabs-lock-key\", c2 = { key: function(e3) {\n    return o2(r2, void 0, void 0, function() {\n      return a2(this, function(e4) {\n        throw new Error(\"Unsupported\");\n      });\n    });\n  }, getItem: function(e3) {\n    return o2(r2, void 0, void 0, function() {\n      return a2(this, function(e4) {\n        throw new Error(\"Unsupported\");\n      });\n    });\n  }, clear: function() {\n    return o2(r2, void 0, void 0, function() {\n      return a2(this, function(e3) {\n        return [2, window.localStorage.clear()];\n      });\n    });\n  }, removeItem: function(e3) {\n    return o2(r2, void 0, void 0, function() {\n      return a2(this, function(e4) {\n        throw new Error(\"Unsupported\");\n      });\n    });\n  }, setItem: function(e3, t2) {\n    return o2(r2, void 0, void 0, function() {\n      return a2(this, function(e4) {\n        throw new Error(\"Unsupported\");\n      });\n    });\n  }, keySync: function(e3) {\n    return window.localStorage.key(e3);\n  }, getItemSync: function(e3) {\n    return window.localStorage.getItem(e3);\n  }, clearSync: function() {\n    return window.localStorage.clear();\n  }, removeItemSync: function(e3) {\n    return window.localStorage.removeItem(e3);\n  }, setItemSync: function(e3, t2) {\n    return window.localStorage.setItem(e3, t2);\n  } };\n  function d2(e3) {\n    return new Promise(function(t2) {\n      return setTimeout(t2, e3);\n    });\n  }\n  function u2(e3) {\n    for (var t2 = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz\", i3 = \"\", o3 = 0; o3 < e3; o3++) {\n      i3 += t2[Math.floor(Math.random() * t2.length)];\n    }\n    return i3;\n  }\n  var l2 = function() {\n    function e3(t2) {\n      this.acquiredIatSet = /* @__PURE__ */ new Set(), this.storageHandler = void 0, this.id = Date.now().toString() + u2(15), this.acquireLock = this.acquireLock.bind(this), this.releaseLock = this.releaseLock.bind(this), this.releaseLock__private__ = this.releaseLock__private__.bind(this), this.waitForSomethingToChange = this.waitForSomethingToChange.bind(this), this.refreshLockWhileAcquired = this.refreshLockWhileAcquired.bind(this), this.storageHandler = t2, void 0 === e3.waiters && (e3.waiters = []);\n    }\n    return e3.prototype.acquireLock = function(t2, i3) {\n      return void 0 === i3 && (i3 = 5e3), o2(this, void 0, void 0, function() {\n        var o3, n2, r3, l3, h2, p2, m2;\n        return a2(this, function(a3) {\n          switch (a3.label) {\n            case 0:\n              o3 = Date.now() + u2(4), n2 = Date.now() + i3, r3 = s2 + \"-\" + t2, l3 = void 0 === this.storageHandler ? c2 : this.storageHandler, a3.label = 1;\n            case 1:\n              return Date.now() < n2 ? [4, d2(30)] : [3, 8];\n            case 2:\n              return a3.sent(), null !== l3.getItemSync(r3) ? [3, 5] : (h2 = this.id + \"-\" + t2 + \"-\" + o3, [4, d2(Math.floor(25 * Math.random()))]);\n            case 3:\n              return a3.sent(), l3.setItemSync(r3, JSON.stringify({ id: this.id, iat: o3, timeoutKey: h2, timeAcquired: Date.now(), timeRefreshed: Date.now() })), [4, d2(30)];\n            case 4:\n              return a3.sent(), null !== (p2 = l3.getItemSync(r3)) && (m2 = JSON.parse(p2)).id === this.id && m2.iat === o3 ? (this.acquiredIatSet.add(o3), this.refreshLockWhileAcquired(r3, o3), [2, true]) : [3, 7];\n            case 5:\n              return e3.lockCorrector(void 0 === this.storageHandler ? c2 : this.storageHandler), [4, this.waitForSomethingToChange(n2)];\n            case 6:\n              a3.sent(), a3.label = 7;\n            case 7:\n              return o3 = Date.now() + u2(4), [3, 1];\n            case 8:\n              return [2, false];\n          }\n        });\n      });\n    }, e3.prototype.refreshLockWhileAcquired = function(e4, t2) {\n      return o2(this, void 0, void 0, function() {\n        var i3 = this;\n        return a2(this, function(r3) {\n          return setTimeout(function() {\n            return o2(i3, void 0, void 0, function() {\n              var i4, o3, r4;\n              return a2(this, function(a3) {\n                switch (a3.label) {\n                  case 0:\n                    return [4, n.default().lock(t2)];\n                  case 1:\n                    return a3.sent(), this.acquiredIatSet.has(t2) ? (i4 = void 0 === this.storageHandler ? c2 : this.storageHandler, null === (o3 = i4.getItemSync(e4)) ? (n.default().unlock(t2), [2]) : ((r4 = JSON.parse(o3)).timeRefreshed = Date.now(), i4.setItemSync(e4, JSON.stringify(r4)), n.default().unlock(t2), this.refreshLockWhileAcquired(e4, t2), [2])) : (n.default().unlock(t2), [2]);\n                }\n              });\n            });\n          }, 1e3), [2];\n        });\n      });\n    }, e3.prototype.waitForSomethingToChange = function(t2) {\n      return o2(this, void 0, void 0, function() {\n        return a2(this, function(i3) {\n          switch (i3.label) {\n            case 0:\n              return [4, new Promise(function(i4) {\n                var o3 = false, n2 = Date.now(), a3 = false;\n                function r3() {\n                  if (a3 || (window.removeEventListener(\"storage\", r3), e3.removeFromWaiting(r3), clearTimeout(s3), a3 = true), !o3) {\n                    o3 = true;\n                    var t3 = 50 - (Date.now() - n2);\n                    t3 > 0 ? setTimeout(i4, t3) : i4(null);\n                  }\n                }\n                window.addEventListener(\"storage\", r3), e3.addToWaiting(r3);\n                var s3 = setTimeout(r3, Math.max(0, t2 - Date.now()));\n              })];\n            case 1:\n              return i3.sent(), [2];\n          }\n        });\n      });\n    }, e3.addToWaiting = function(t2) {\n      this.removeFromWaiting(t2), void 0 !== e3.waiters && e3.waiters.push(t2);\n    }, e3.removeFromWaiting = function(t2) {\n      void 0 !== e3.waiters && (e3.waiters = e3.waiters.filter(function(e4) {\n        return e4 !== t2;\n      }));\n    }, e3.notifyWaiters = function() {\n      void 0 !== e3.waiters && e3.waiters.slice().forEach(function(e4) {\n        return e4();\n      });\n    }, e3.prototype.releaseLock = function(e4) {\n      return o2(this, void 0, void 0, function() {\n        return a2(this, function(t2) {\n          switch (t2.label) {\n            case 0:\n              return [4, this.releaseLock__private__(e4)];\n            case 1:\n              return [2, t2.sent()];\n          }\n        });\n      });\n    }, e3.prototype.releaseLock__private__ = function(t2) {\n      return o2(this, void 0, void 0, function() {\n        var i3, o3, r3, d3;\n        return a2(this, function(a3) {\n          switch (a3.label) {\n            case 0:\n              return i3 = void 0 === this.storageHandler ? c2 : this.storageHandler, o3 = s2 + \"-\" + t2, null === (r3 = i3.getItemSync(o3)) ? [2] : (d3 = JSON.parse(r3)).id !== this.id ? [3, 2] : [4, n.default().lock(d3.iat)];\n            case 1:\n              a3.sent(), this.acquiredIatSet.delete(d3.iat), i3.removeItemSync(o3), n.default().unlock(d3.iat), e3.notifyWaiters(), a3.label = 2;\n            case 2:\n              return [2];\n          }\n        });\n      });\n    }, e3.lockCorrector = function(t2) {\n      for (var i3 = Date.now() - 5e3, o3 = t2, n2 = [], a3 = 0; ; ) {\n        var r3 = o3.keySync(a3);\n        if (null === r3)\n          break;\n        n2.push(r3), a3++;\n      }\n      for (var c3 = false, d3 = 0; d3 < n2.length; d3++) {\n        var u3 = n2[d3];\n        if (u3.includes(s2)) {\n          var l3 = o3.getItemSync(u3);\n          if (null !== l3) {\n            var h2 = JSON.parse(l3);\n            (void 0 === h2.timeRefreshed && h2.timeAcquired < i3 || void 0 !== h2.timeRefreshed && h2.timeRefreshed < i3) && (o3.removeItemSync(u3), c3 = true);\n          }\n        }\n      }\n      c3 && e3.notifyWaiters();\n    }, e3.waiters = void 0, e3;\n  }();\n  i2.default = l2;\n}));\nvar r = { timeoutInSeconds: 60 };\nvar s = { name: \"auth0-spa-js\", version: \"2.1.3\" };\nvar c = () => Date.now();\nvar d = class _d extends Error {\n  constructor(e2, t2) {\n    super(t2), this.error = e2, this.error_description = t2, Object.setPrototypeOf(this, _d.prototype);\n  }\n  static fromPayload({ error: e2, error_description: t2 }) {\n    return new _d(e2, t2);\n  }\n};\nvar u = class _u extends d {\n  constructor(e2, t2, i2, o2 = null) {\n    super(e2, t2), this.state = i2, this.appState = o2, Object.setPrototypeOf(this, _u.prototype);\n  }\n};\nvar l = class _l extends d {\n  constructor() {\n    super(\"timeout\", \"Timeout\"), Object.setPrototypeOf(this, _l.prototype);\n  }\n};\nvar h = class _h extends l {\n  constructor(e2) {\n    super(), this.popup = e2, Object.setPrototypeOf(this, _h.prototype);\n  }\n};\nvar p = class _p extends d {\n  constructor(e2) {\n    super(\"cancelled\", \"Popup closed\"), this.popup = e2, Object.setPrototypeOf(this, _p.prototype);\n  }\n};\nvar m = class _m extends d {\n  constructor(e2, t2, i2) {\n    super(e2, t2), this.mfa_token = i2, Object.setPrototypeOf(this, _m.prototype);\n  }\n};\nvar f = class _f extends d {\n  constructor(e2, t2) {\n    super(\"missing_refresh_token\", `Missing Refresh Token (audience: '${g(e2, [\"default\"])}', scope: '${g(t2)}')`), this.audience = e2, this.scope = t2, Object.setPrototypeOf(this, _f.prototype);\n  }\n};\nfunction g(e2, t2 = []) {\n  return e2 && !t2.includes(e2) ? e2 : \"\";\n}\nvar w = () => window.crypto;\nvar y = () => {\n  const e2 = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_~.\";\n  let t2 = \"\";\n  return Array.from(w().getRandomValues(new Uint8Array(43))).forEach((i2) => t2 += e2[i2 % e2.length]), t2;\n};\nvar k = (e2) => btoa(e2);\nvar v = (t2) => {\n  var { clientId: i2 } = t2, o2 = e(t2, [\"clientId\"]);\n  return new URLSearchParams(((e2) => Object.keys(e2).filter((t3) => void 0 !== e2[t3]).reduce((t3, i3) => Object.assign(Object.assign({}, t3), { [i3]: e2[i3] }), {}))(Object.assign({ client_id: i2 }, o2))).toString();\n};\nvar b = (e2) => ((e3) => decodeURIComponent(atob(e3).split(\"\").map((e4) => \"%\" + (\"00\" + e4.charCodeAt(0).toString(16)).slice(-2)).join(\"\")))(e2.replace(/_/g, \"/\").replace(/-/g, \"+\"));\nvar _ = async (e2, t2) => {\n  const i2 = await fetch(e2, t2);\n  return { ok: i2.ok, json: await i2.json() };\n};\nvar I = async (e2, t2, i2) => {\n  const o2 = new AbortController();\n  let n2;\n  return t2.signal = o2.signal, Promise.race([_(e2, t2), new Promise((e3, t3) => {\n    n2 = setTimeout(() => {\n      o2.abort(), t3(new Error(\"Timeout when executing 'fetch'\"));\n    }, i2);\n  })]).finally(() => {\n    clearTimeout(n2);\n  });\n};\nvar S = async (e2, t2, i2, o2, n2, a2, r2) => {\n  return s2 = { auth: { audience: t2, scope: i2 }, timeout: n2, fetchUrl: e2, fetchOptions: o2, useFormData: r2 }, c2 = a2, new Promise(function(e3, t3) {\n    const i3 = new MessageChannel();\n    i3.port1.onmessage = function(o3) {\n      o3.data.error ? t3(new Error(o3.data.error)) : e3(o3.data), i3.port1.close();\n    }, c2.postMessage(s2, [i3.port2]);\n  });\n  var s2, c2;\n};\nvar O = async (e2, t2, i2, o2, n2, a2, r2 = 1e4) => n2 ? S(e2, t2, i2, o2, r2, n2, a2) : I(e2, o2, r2);\nasync function T(t2, i2) {\n  var { baseUrl: o2, timeout: n2, audience: a2, scope: r2, auth0Client: c2, useFormData: u2 } = t2, l2 = e(t2, [\"baseUrl\", \"timeout\", \"audience\", \"scope\", \"auth0Client\", \"useFormData\"]);\n  const h2 = u2 ? v(l2) : JSON.stringify(l2);\n  return await async function(t3, i3, o3, n3, a3, r3, s2) {\n    let c3, u3 = null;\n    for (let e2 = 0; e2 < 3; e2++)\n      try {\n        c3 = await O(t3, o3, n3, a3, r3, s2, i3), u3 = null;\n        break;\n      } catch (e3) {\n        u3 = e3;\n      }\n    if (u3)\n      throw u3;\n    const l3 = c3.json, { error: h3, error_description: p2 } = l3, g2 = e(l3, [\"error\", \"error_description\"]), { ok: w2 } = c3;\n    if (!w2) {\n      const e2 = p2 || `HTTP error. Unable to fetch ${t3}`;\n      if (\"mfa_required\" === h3)\n        throw new m(h3, e2, g2.mfa_token);\n      if (\"missing_refresh_token\" === h3)\n        throw new f(o3, n3);\n      throw new d(h3 || \"request_error\", e2);\n    }\n    return g2;\n  }(`${o2}/oauth/token`, n2, a2 || \"default\", r2, { method: \"POST\", body: h2, headers: { \"Content-Type\": u2 ? \"application/x-www-form-urlencoded\" : \"application/json\", \"Auth0-Client\": btoa(JSON.stringify(c2 || s)) } }, i2, u2);\n}\nvar j = (...e2) => {\n  return (t2 = e2.filter(Boolean).join(\" \").trim().split(/\\s+/), Array.from(new Set(t2))).join(\" \");\n  var t2;\n};\nvar C = class _C {\n  constructor(e2, t2 = \"@@auth0spajs@@\", i2) {\n    this.prefix = t2, this.suffix = i2, this.clientId = e2.clientId, this.scope = e2.scope, this.audience = e2.audience;\n  }\n  toKey() {\n    return [this.prefix, this.clientId, this.audience, this.scope, this.suffix].filter(Boolean).join(\"::\");\n  }\n  static fromKey(e2) {\n    const [t2, i2, o2, n2] = e2.split(\"::\");\n    return new _C({ clientId: i2, scope: n2, audience: o2 }, t2);\n  }\n  static fromCacheEntry(e2) {\n    const { scope: t2, audience: i2, client_id: o2 } = e2;\n    return new _C({ scope: t2, audience: i2, clientId: o2 });\n  }\n};\nvar z = class {\n  set(e2, t2) {\n    localStorage.setItem(e2, JSON.stringify(t2));\n  }\n  get(e2) {\n    const t2 = window.localStorage.getItem(e2);\n    if (t2)\n      try {\n        return JSON.parse(t2);\n      } catch (e3) {\n        return;\n      }\n  }\n  remove(e2) {\n    localStorage.removeItem(e2);\n  }\n  allKeys() {\n    return Object.keys(window.localStorage).filter((e2) => e2.startsWith(\"@@auth0spajs@@\"));\n  }\n};\nvar P = class {\n  constructor() {\n    this.enclosedCache = /* @__PURE__ */ function() {\n      let e2 = {};\n      return { set(t2, i2) {\n        e2[t2] = i2;\n      }, get(t2) {\n        const i2 = e2[t2];\n        if (i2)\n          return i2;\n      }, remove(t2) {\n        delete e2[t2];\n      }, allKeys: () => Object.keys(e2) };\n    }();\n  }\n};\nvar x = class {\n  constructor(e2, t2, i2) {\n    this.cache = e2, this.keyManifest = t2, this.nowProvider = i2 || c;\n  }\n  async setIdToken(e2, t2, i2) {\n    var o2;\n    const n2 = this.getIdTokenCacheKey(e2);\n    await this.cache.set(n2, { id_token: t2, decodedToken: i2 }), await (null === (o2 = this.keyManifest) || void 0 === o2 ? void 0 : o2.add(n2));\n  }\n  async getIdToken(e2) {\n    const t2 = await this.cache.get(this.getIdTokenCacheKey(e2.clientId));\n    if (!t2 && e2.scope && e2.audience) {\n      const t3 = await this.get(e2);\n      if (!t3)\n        return;\n      if (!t3.id_token || !t3.decodedToken)\n        return;\n      return { id_token: t3.id_token, decodedToken: t3.decodedToken };\n    }\n    if (t2)\n      return { id_token: t2.id_token, decodedToken: t2.decodedToken };\n  }\n  async get(e2, t2 = 0) {\n    var i2;\n    let o2 = await this.cache.get(e2.toKey());\n    if (!o2) {\n      const t3 = await this.getCacheKeys();\n      if (!t3)\n        return;\n      const i3 = this.matchExistingCacheKey(e2, t3);\n      i3 && (o2 = await this.cache.get(i3));\n    }\n    if (!o2)\n      return;\n    const n2 = await this.nowProvider(), a2 = Math.floor(n2 / 1e3);\n    return o2.expiresAt - t2 < a2 ? o2.body.refresh_token ? (o2.body = { refresh_token: o2.body.refresh_token }, await this.cache.set(e2.toKey(), o2), o2.body) : (await this.cache.remove(e2.toKey()), void await (null === (i2 = this.keyManifest) || void 0 === i2 ? void 0 : i2.remove(e2.toKey()))) : o2.body;\n  }\n  async set(e2) {\n    var t2;\n    const i2 = new C({ clientId: e2.client_id, scope: e2.scope, audience: e2.audience }), o2 = await this.wrapCacheEntry(e2);\n    await this.cache.set(i2.toKey(), o2), await (null === (t2 = this.keyManifest) || void 0 === t2 ? void 0 : t2.add(i2.toKey()));\n  }\n  async clear(e2) {\n    var t2;\n    const i2 = await this.getCacheKeys();\n    i2 && (await i2.filter((t3) => !e2 || t3.includes(e2)).reduce(async (e3, t3) => {\n      await e3, await this.cache.remove(t3);\n    }, Promise.resolve()), await (null === (t2 = this.keyManifest) || void 0 === t2 ? void 0 : t2.clear()));\n  }\n  async wrapCacheEntry(e2) {\n    const t2 = await this.nowProvider();\n    return { body: e2, expiresAt: Math.floor(t2 / 1e3) + e2.expires_in };\n  }\n  async getCacheKeys() {\n    var e2;\n    return this.keyManifest ? null === (e2 = await this.keyManifest.get()) || void 0 === e2 ? void 0 : e2.keys : this.cache.allKeys ? this.cache.allKeys() : void 0;\n  }\n  getIdTokenCacheKey(e2) {\n    return new C({ clientId: e2 }, \"@@auth0spajs@@\", \"@@user@@\").toKey();\n  }\n  matchExistingCacheKey(e2, t2) {\n    return t2.filter((t3) => {\n      var i2;\n      const o2 = C.fromKey(t3), n2 = new Set(o2.scope && o2.scope.split(\" \")), a2 = (null === (i2 = e2.scope) || void 0 === i2 ? void 0 : i2.split(\" \")) || [], r2 = o2.scope && a2.reduce((e3, t4) => e3 && n2.has(t4), true);\n      return \"@@auth0spajs@@\" === o2.prefix && o2.clientId === e2.clientId && o2.audience === e2.audience && r2;\n    })[0];\n  }\n};\nvar Z = class {\n  constructor(e2, t2, i2) {\n    this.storage = e2, this.clientId = t2, this.cookieDomain = i2, this.storageKey = `a0.spajs.txs.${this.clientId}`;\n  }\n  create(e2) {\n    this.storage.save(this.storageKey, e2, { daysUntilExpire: 1, cookieDomain: this.cookieDomain });\n  }\n  get() {\n    return this.storage.get(this.storageKey);\n  }\n  remove() {\n    this.storage.remove(this.storageKey, { cookieDomain: this.cookieDomain });\n  }\n};\nvar K = (e2) => \"number\" == typeof e2;\nvar W = [\"iss\", \"aud\", \"exp\", \"nbf\", \"iat\", \"jti\", \"azp\", \"nonce\", \"auth_time\", \"at_hash\", \"c_hash\", \"acr\", \"amr\", \"sub_jwk\", \"cnf\", \"sip_from_tag\", \"sip_date\", \"sip_callid\", \"sip_cseq_num\", \"sip_via_branch\", \"orig\", \"dest\", \"mky\", \"events\", \"toe\", \"txn\", \"rph\", \"sid\", \"vot\", \"vtm\"];\nvar E = (e2) => {\n  if (!e2.id_token)\n    throw new Error(\"ID token is required but missing\");\n  const t2 = ((e3) => {\n    const t3 = e3.split(\".\"), [i3, o3, n3] = t3;\n    if (3 !== t3.length || !i3 || !o3 || !n3)\n      throw new Error(\"ID token could not be decoded\");\n    const a2 = JSON.parse(b(o3)), r2 = { __raw: e3 }, s2 = {};\n    return Object.keys(a2).forEach((e4) => {\n      r2[e4] = a2[e4], W.includes(e4) || (s2[e4] = a2[e4]);\n    }), { encoded: { header: i3, payload: o3, signature: n3 }, header: JSON.parse(b(i3)), claims: r2, user: s2 };\n  })(e2.id_token);\n  if (!t2.claims.iss)\n    throw new Error(\"Issuer (iss) claim must be a string present in the ID token\");\n  if (t2.claims.iss !== e2.iss)\n    throw new Error(`Issuer (iss) claim mismatch in the ID token; expected \"${e2.iss}\", found \"${t2.claims.iss}\"`);\n  if (!t2.user.sub)\n    throw new Error(\"Subject (sub) claim must be a string present in the ID token\");\n  if (\"RS256\" !== t2.header.alg)\n    throw new Error(`Signature algorithm of \"${t2.header.alg}\" is not supported. Expected the ID token to be signed with \"RS256\".`);\n  if (!t2.claims.aud || \"string\" != typeof t2.claims.aud && !Array.isArray(t2.claims.aud))\n    throw new Error(\"Audience (aud) claim must be a string or array of strings present in the ID token\");\n  if (Array.isArray(t2.claims.aud)) {\n    if (!t2.claims.aud.includes(e2.aud))\n      throw new Error(`Audience (aud) claim mismatch in the ID token; expected \"${e2.aud}\" but was not one of \"${t2.claims.aud.join(\", \")}\"`);\n    if (t2.claims.aud.length > 1) {\n      if (!t2.claims.azp)\n        throw new Error(\"Authorized Party (azp) claim must be a string present in the ID token when Audience (aud) claim has multiple values\");\n      if (t2.claims.azp !== e2.aud)\n        throw new Error(`Authorized Party (azp) claim mismatch in the ID token; expected \"${e2.aud}\", found \"${t2.claims.azp}\"`);\n    }\n  } else if (t2.claims.aud !== e2.aud)\n    throw new Error(`Audience (aud) claim mismatch in the ID token; expected \"${e2.aud}\" but found \"${t2.claims.aud}\"`);\n  if (e2.nonce) {\n    if (!t2.claims.nonce)\n      throw new Error(\"Nonce (nonce) claim must be a string present in the ID token\");\n    if (t2.claims.nonce !== e2.nonce)\n      throw new Error(`Nonce (nonce) claim mismatch in the ID token; expected \"${e2.nonce}\", found \"${t2.claims.nonce}\"`);\n  }\n  if (e2.max_age && !K(t2.claims.auth_time))\n    throw new Error(\"Authentication Time (auth_time) claim must be a number present in the ID token when Max Age (max_age) is specified\");\n  if (null == t2.claims.exp || !K(t2.claims.exp))\n    throw new Error(\"Expiration Time (exp) claim must be a number present in the ID token\");\n  if (!K(t2.claims.iat))\n    throw new Error(\"Issued At (iat) claim must be a number present in the ID token\");\n  const i2 = e2.leeway || 60, o2 = new Date(e2.now || Date.now()), n2 = /* @__PURE__ */ new Date(0);\n  if (n2.setUTCSeconds(t2.claims.exp + i2), o2 > n2)\n    throw new Error(`Expiration Time (exp) claim error in the ID token; current time (${o2}) is after expiration time (${n2})`);\n  if (null != t2.claims.nbf && K(t2.claims.nbf)) {\n    const e3 = /* @__PURE__ */ new Date(0);\n    if (e3.setUTCSeconds(t2.claims.nbf - i2), o2 < e3)\n      throw new Error(`Not Before time (nbf) claim in the ID token indicates that this token can't be used just yet. Current time (${o2}) is before ${e3}`);\n  }\n  if (null != t2.claims.auth_time && K(t2.claims.auth_time)) {\n    const n3 = /* @__PURE__ */ new Date(0);\n    if (n3.setUTCSeconds(parseInt(t2.claims.auth_time) + e2.max_age + i2), o2 > n3)\n      throw new Error(`Authentication Time (auth_time) claim in the ID token indicates that too much time has passed since the last end-user authentication. Current time (${o2}) is after last auth at ${n3}`);\n  }\n  if (e2.organization) {\n    const i3 = e2.organization.trim();\n    if (i3.startsWith(\"org_\")) {\n      const e3 = i3;\n      if (!t2.claims.org_id)\n        throw new Error(\"Organization ID (org_id) claim must be a string present in the ID token\");\n      if (e3 !== t2.claims.org_id)\n        throw new Error(`Organization ID (org_id) claim mismatch in the ID token; expected \"${e3}\", found \"${t2.claims.org_id}\"`);\n    } else {\n      const e3 = i3.toLowerCase();\n      if (!t2.claims.org_name)\n        throw new Error(\"Organization Name (org_name) claim must be a string present in the ID token\");\n      if (e3 !== t2.claims.org_name)\n        throw new Error(`Organization Name (org_name) claim mismatch in the ID token; expected \"${e3}\", found \"${t2.claims.org_name}\"`);\n    }\n  }\n  return t2;\n};\nvar R = o(function(e2, i2) {\n  var o2 = t && t.__assign || function() {\n    return o2 = Object.assign || function(e3) {\n      for (var t2, i3 = 1, o3 = arguments.length; i3 < o3; i3++)\n        for (var n3 in t2 = arguments[i3])\n          Object.prototype.hasOwnProperty.call(t2, n3) && (e3[n3] = t2[n3]);\n      return e3;\n    }, o2.apply(this, arguments);\n  };\n  function n2(e3, t2) {\n    if (!t2)\n      return \"\";\n    var i3 = \"; \" + e3;\n    return true === t2 ? i3 : i3 + \"=\" + t2;\n  }\n  function a2(e3, t2, i3) {\n    return encodeURIComponent(e3).replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent).replace(/\\(/g, \"%28\").replace(/\\)/g, \"%29\") + \"=\" + encodeURIComponent(t2).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent) + function(e4) {\n      if (\"number\" == typeof e4.expires) {\n        var t3 = /* @__PURE__ */ new Date();\n        t3.setMilliseconds(t3.getMilliseconds() + 864e5 * e4.expires), e4.expires = t3;\n      }\n      return n2(\"Expires\", e4.expires ? e4.expires.toUTCString() : \"\") + n2(\"Domain\", e4.domain) + n2(\"Path\", e4.path) + n2(\"Secure\", e4.secure) + n2(\"SameSite\", e4.sameSite);\n    }(i3);\n  }\n  function r2(e3) {\n    for (var t2 = {}, i3 = e3 ? e3.split(\"; \") : [], o3 = /(%[\\dA-F]{2})+/gi, n3 = 0; n3 < i3.length; n3++) {\n      var a3 = i3[n3].split(\"=\"), r3 = a3.slice(1).join(\"=\");\n      '\"' === r3.charAt(0) && (r3 = r3.slice(1, -1));\n      try {\n        t2[a3[0].replace(o3, decodeURIComponent)] = r3.replace(o3, decodeURIComponent);\n      } catch (e4) {\n      }\n    }\n    return t2;\n  }\n  function s2() {\n    return r2(document.cookie);\n  }\n  function c2(e3, t2, i3) {\n    document.cookie = a2(e3, t2, o2({ path: \"/\" }, i3));\n  }\n  i2.__esModule = true, i2.encode = a2, i2.parse = r2, i2.getAll = s2, i2.get = function(e3) {\n    return s2()[e3];\n  }, i2.set = c2, i2.remove = function(e3, t2) {\n    c2(e3, \"\", o2(o2({}, t2), { expires: -1 }));\n  };\n});\ni(R), R.encode, R.parse, R.getAll;\nvar U = R.get;\nvar L = R.set;\nvar D = R.remove;\nvar X = { get(e2) {\n  const t2 = U(e2);\n  if (void 0 !== t2)\n    return JSON.parse(t2);\n}, save(e2, t2, i2) {\n  let o2 = {};\n  \"https:\" === window.location.protocol && (o2 = { secure: true, sameSite: \"none\" }), (null == i2 ? void 0 : i2.daysUntilExpire) && (o2.expires = i2.daysUntilExpire), (null == i2 ? void 0 : i2.cookieDomain) && (o2.domain = i2.cookieDomain), L(e2, JSON.stringify(t2), o2);\n}, remove(e2, t2) {\n  let i2 = {};\n  (null == t2 ? void 0 : t2.cookieDomain) && (i2.domain = t2.cookieDomain), D(e2, i2);\n} };\nvar N = { get(e2) {\n  const t2 = X.get(e2);\n  return t2 || X.get(`_legacy_${e2}`);\n}, save(e2, t2, i2) {\n  let o2 = {};\n  \"https:\" === window.location.protocol && (o2 = { secure: true }), (null == i2 ? void 0 : i2.daysUntilExpire) && (o2.expires = i2.daysUntilExpire), (null == i2 ? void 0 : i2.cookieDomain) && (o2.domain = i2.cookieDomain), L(`_legacy_${e2}`, JSON.stringify(t2), o2), X.save(e2, t2, i2);\n}, remove(e2, t2) {\n  let i2 = {};\n  (null == t2 ? void 0 : t2.cookieDomain) && (i2.domain = t2.cookieDomain), D(e2, i2), X.remove(e2, t2), X.remove(`_legacy_${e2}`, t2);\n} };\nvar J = { get(e2) {\n  if (\"undefined\" == typeof sessionStorage)\n    return;\n  const t2 = sessionStorage.getItem(e2);\n  return null != t2 ? JSON.parse(t2) : void 0;\n}, save(e2, t2) {\n  sessionStorage.setItem(e2, JSON.stringify(t2));\n}, remove(e2) {\n  sessionStorage.removeItem(e2);\n} };\nfunction F(e2, t2, i2) {\n  var o2 = void 0 === t2 ? null : t2, n2 = function(e3, t3) {\n    var i3 = atob(e3);\n    if (t3) {\n      for (var o3 = new Uint8Array(i3.length), n3 = 0, a3 = i3.length; n3 < a3; ++n3)\n        o3[n3] = i3.charCodeAt(n3);\n      return String.fromCharCode.apply(null, new Uint16Array(o3.buffer));\n    }\n    return i3;\n  }(e2, void 0 !== i2 && i2), a2 = n2.indexOf(\"\\n\", 10) + 1, r2 = n2.substring(a2) + (o2 ? \"//# sourceMappingURL=\" + o2 : \"\"), s2 = new Blob([r2], { type: \"application/javascript\" });\n  return URL.createObjectURL(s2);\n}\nvar H;\nvar Y;\nvar G;\nvar V;\nvar M = (H = \"Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwohZnVuY3Rpb24oKXsidXNlIHN0cmljdCI7Y2xhc3MgZSBleHRlbmRzIEVycm9ye2NvbnN0cnVjdG9yKHQscil7c3VwZXIociksdGhpcy5lcnJvcj10LHRoaXMuZXJyb3JfZGVzY3JpcHRpb249cixPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcyxlLnByb3RvdHlwZSl9c3RhdGljIGZyb21QYXlsb2FkKHtlcnJvcjp0LGVycm9yX2Rlc2NyaXB0aW9uOnJ9KXtyZXR1cm4gbmV3IGUodCxyKX19Y2xhc3MgdCBleHRlbmRzIGV7Y29uc3RydWN0b3IoZSxzKXtzdXBlcigibWlzc2luZ19yZWZyZXNoX3Rva2VuIixgTWlzc2luZyBSZWZyZXNoIFRva2VuIChhdWRpZW5jZTogJyR7cihlLFsiZGVmYXVsdCJdKX0nLCBzY29wZTogJyR7cihzKX0nKWApLHRoaXMuYXVkaWVuY2U9ZSx0aGlzLnNjb3BlPXMsT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsdC5wcm90b3R5cGUpfX1mdW5jdGlvbiByKGUsdD1bXSl7cmV0dXJuIGUmJiF0LmluY2x1ZGVzKGUpP2U6IiJ9ImZ1bmN0aW9uIj09dHlwZW9mIFN1cHByZXNzZWRFcnJvciYmU3VwcHJlc3NlZEVycm9yO2NvbnN0IHM9ZT0+e3ZhcntjbGllbnRJZDp0fT1lLHI9ZnVuY3Rpb24oZSx0KXt2YXIgcj17fTtmb3IodmFyIHMgaW4gZSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxzKSYmdC5pbmRleE9mKHMpPDAmJihyW3NdPWVbc10pO2lmKG51bGwhPWUmJiJmdW5jdGlvbiI9PXR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgbz0wO2ZvcihzPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7bzxzLmxlbmd0aDtvKyspdC5pbmRleE9mKHNbb10pPDAmJk9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChlLHNbb10pJiYocltzW29dXT1lW3Nbb11dKX1yZXR1cm4gcn0oZSxbImNsaWVudElkIl0pO3JldHVybiBuZXcgVVJMU2VhcmNoUGFyYW1zKChlPT5PYmplY3Qua2V5cyhlKS5maWx0ZXIoKHQ9PnZvaWQgMCE9PWVbdF0pKS5yZWR1Y2UoKCh0LHIpPT5PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdCkse1tyXTplW3JdfSkpLHt9KSkoT2JqZWN0LmFzc2lnbih7Y2xpZW50X2lkOnR9LHIpKSkudG9TdHJpbmcoKX07bGV0IG89e307Y29uc3Qgbj0oZSx0KT0+YCR7ZX18JHt0fWA7YWRkRXZlbnRMaXN0ZW5lcigibWVzc2FnZSIsKGFzeW5jKHtkYXRhOnt0aW1lb3V0OmUsYXV0aDpyLGZldGNoVXJsOmksZmV0Y2hPcHRpb25zOmMsdXNlRm9ybURhdGE6YX0scG9ydHM6W3BdfSk9PntsZXQgZjtjb25zdHthdWRpZW5jZTp1LHNjb3BlOmx9PXJ8fHt9O3RyeXtjb25zdCByPWE/KGU9Pntjb25zdCB0PW5ldyBVUkxTZWFyY2hQYXJhbXMoZSkscj17fTtyZXR1cm4gdC5mb3JFYWNoKCgoZSx0KT0+e3JbdF09ZX0pKSxyfSkoYy5ib2R5KTpKU09OLnBhcnNlKGMuYm9keSk7aWYoIXIucmVmcmVzaF90b2tlbiYmInJlZnJlc2hfdG9rZW4iPT09ci5ncmFudF90eXBlKXtjb25zdCBlPSgoZSx0KT0+b1tuKGUsdCldKSh1LGwpO2lmKCFlKXRocm93IG5ldyB0KHUsbCk7Yy5ib2R5PWE/cyhPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scikse3JlZnJlc2hfdG9rZW46ZX0pKTpKU09OLnN0cmluZ2lmeShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scikse3JlZnJlc2hfdG9rZW46ZX0pKX1sZXQgaCxnOyJmdW5jdGlvbiI9PXR5cGVvZiBBYm9ydENvbnRyb2xsZXImJihoPW5ldyBBYm9ydENvbnRyb2xsZXIsYy5zaWduYWw9aC5zaWduYWwpO3RyeXtnPWF3YWl0IFByb21pc2UucmFjZShbKGQ9ZSxuZXcgUHJvbWlzZSgoZT0+c2V0VGltZW91dChlLGQpKSkpLGZldGNoKGksT2JqZWN0LmFzc2lnbih7fSxjKSldKX1jYXRjaChlKXtyZXR1cm4gdm9pZCBwLnBvc3RNZXNzYWdlKHtlcnJvcjplLm1lc3NhZ2V9KX1pZighZylyZXR1cm4gaCYmaC5hYm9ydCgpLHZvaWQgcC5wb3N0TWVzc2FnZSh7ZXJyb3I6IlRpbWVvdXQgd2hlbiBleGVjdXRpbmcgJ2ZldGNoJyJ9KTtmPWF3YWl0IGcuanNvbigpLGYucmVmcmVzaF90b2tlbj8oKChlLHQscik9PntvW24odCxyKV09ZX0pKGYucmVmcmVzaF90b2tlbix1LGwpLGRlbGV0ZSBmLnJlZnJlc2hfdG9rZW4pOigoZSx0KT0+e2RlbGV0ZSBvW24oZSx0KV19KSh1LGwpLHAucG9zdE1lc3NhZ2Uoe29rOmcub2ssanNvbjpmfSl9Y2F0Y2goZSl7cC5wb3N0TWVzc2FnZSh7b2s6ITEsanNvbjp7ZXJyb3I6ZS5lcnJvcixlcnJvcl9kZXNjcmlwdGlvbjplLm1lc3NhZ2V9fSl9dmFyIGR9KSl9KCk7Cgo=\", Y = null, G = false, function(e2) {\n  return V = V || F(H, Y, G), new Worker(V, e2);\n});\nvar A = {};\nvar B = class {\n  constructor(e2, t2) {\n    this.cache = e2, this.clientId = t2, this.manifestKey = this.createManifestKeyFrom(this.clientId);\n  }\n  async add(e2) {\n    var t2;\n    const i2 = new Set((null === (t2 = await this.cache.get(this.manifestKey)) || void 0 === t2 ? void 0 : t2.keys) || []);\n    i2.add(e2), await this.cache.set(this.manifestKey, { keys: [...i2] });\n  }\n  async remove(e2) {\n    const t2 = await this.cache.get(this.manifestKey);\n    if (t2) {\n      const i2 = new Set(t2.keys);\n      return i2.delete(e2), i2.size > 0 ? await this.cache.set(this.manifestKey, { keys: [...i2] }) : await this.cache.remove(this.manifestKey);\n    }\n  }\n  get() {\n    return this.cache.get(this.manifestKey);\n  }\n  clear() {\n    return this.cache.remove(this.manifestKey);\n  }\n  createManifestKeyFrom(e2) {\n    return `@@auth0spajs@@::${e2}`;\n  }\n};\nvar $ = { memory: () => new P().enclosedCache, localstorage: () => new z() };\nvar q = (e2) => $[e2];\nvar Q = (t2) => {\n  const { openUrl: i2, onRedirect: o2 } = t2, n2 = e(t2, [\"openUrl\", \"onRedirect\"]);\n  return Object.assign(Object.assign({}, n2), { openUrl: false === i2 || i2 ? i2 : o2 });\n};\nvar ee = new a();\nvar te = class {\n  constructor(e2) {\n    let t2, i2;\n    if (this.userCache = new P().enclosedCache, this.defaultOptions = { authorizationParams: { scope: \"openid profile email\" }, useRefreshTokensFallback: false, useFormData: true }, this._releaseLockOnPageHide = async () => {\n      await ee.releaseLock(\"auth0.lock.getTokenSilently\"), window.removeEventListener(\"pagehide\", this._releaseLockOnPageHide);\n    }, this.options = Object.assign(Object.assign(Object.assign({}, this.defaultOptions), e2), { authorizationParams: Object.assign(Object.assign({}, this.defaultOptions.authorizationParams), e2.authorizationParams) }), \"undefined\" != typeof window && (() => {\n      if (!w())\n        throw new Error(\"For security reasons, `window.crypto` is required to run `auth0-spa-js`.\");\n      if (void 0 === w().subtle)\n        throw new Error(\"\\n      auth0-spa-js must run on a secure origin. See https://github.com/auth0/auth0-spa-js/blob/main/FAQ.md#why-do-i-get-auth0-spa-js-must-run-on-a-secure-origin for more information.\\n    \");\n    })(), e2.cache && e2.cacheLocation && console.warn(\"Both `cache` and `cacheLocation` options have been specified in the Auth0Client configuration; ignoring `cacheLocation` and using `cache`.\"), e2.cache)\n      i2 = e2.cache;\n    else {\n      if (t2 = e2.cacheLocation || \"memory\", !q(t2))\n        throw new Error(`Invalid cache location \"${t2}\"`);\n      i2 = q(t2)();\n    }\n    this.httpTimeoutMs = e2.httpTimeoutInSeconds ? 1e3 * e2.httpTimeoutInSeconds : 1e4, this.cookieStorage = false === e2.legacySameSiteCookie ? X : N, this.orgHintCookieName = `auth0.${this.options.clientId}.organization_hint`, this.isAuthenticatedCookieName = ((e3) => `auth0.${e3}.is.authenticated`)(this.options.clientId), this.sessionCheckExpiryDays = e2.sessionCheckExpiryDays || 1;\n    const o2 = e2.useCookiesForTransactions ? this.cookieStorage : J;\n    var n2;\n    this.scope = j(\"openid\", this.options.authorizationParams.scope, this.options.useRefreshTokens ? \"offline_access\" : \"\"), this.transactionManager = new Z(o2, this.options.clientId, this.options.cookieDomain), this.nowProvider = this.options.nowProvider || c, this.cacheManager = new x(i2, i2.allKeys ? void 0 : new B(i2, this.options.clientId), this.nowProvider), this.domainUrl = (n2 = this.options.domain, /^https?:\\/\\//.test(n2) ? n2 : `https://${n2}`), this.tokenIssuer = ((e3, t3) => e3 ? e3.startsWith(\"https://\") ? e3 : `https://${e3}/` : `${t3}/`)(this.options.issuer, this.domainUrl), \"undefined\" != typeof window && window.Worker && this.options.useRefreshTokens && \"memory\" === t2 && (this.options.workerUrl ? this.worker = new Worker(this.options.workerUrl) : this.worker = new M());\n  }\n  _url(e2) {\n    const t2 = encodeURIComponent(btoa(JSON.stringify(this.options.auth0Client || s)));\n    return `${this.domainUrl}${e2}&auth0Client=${t2}`;\n  }\n  _authorizeUrl(e2) {\n    return this._url(`/authorize?${v(e2)}`);\n  }\n  async _verifyIdToken(e2, t2, i2) {\n    const o2 = await this.nowProvider();\n    return E({ iss: this.tokenIssuer, aud: this.options.clientId, id_token: e2, nonce: t2, organization: i2, leeway: this.options.leeway, max_age: (n2 = this.options.authorizationParams.max_age, \"string\" != typeof n2 ? n2 : parseInt(n2, 10) || void 0), now: o2 });\n    var n2;\n  }\n  _processOrgHint(e2) {\n    e2 ? this.cookieStorage.save(this.orgHintCookieName, e2, { daysUntilExpire: this.sessionCheckExpiryDays, cookieDomain: this.options.cookieDomain }) : this.cookieStorage.remove(this.orgHintCookieName, { cookieDomain: this.options.cookieDomain });\n  }\n  async _prepareAuthorizeUrl(e2, t2, i2) {\n    const o2 = k(y()), n2 = k(y()), a2 = y(), r2 = ((e3) => {\n      const t3 = new Uint8Array(e3);\n      return ((e4) => {\n        const t4 = { \"+\": \"-\", \"/\": \"_\", \"=\": \"\" };\n        return e4.replace(/[+/=]/g, (e5) => t4[e5]);\n      })(window.btoa(String.fromCharCode(...Array.from(t3))));\n    })(await (async (e3) => {\n      const t3 = w().subtle.digest({ name: \"SHA-256\" }, new TextEncoder().encode(e3));\n      return await t3;\n    })(a2)), s2 = ((e3, t3, i3, o3, n3, a3, r3, s3) => Object.assign(Object.assign(Object.assign({ client_id: e3.clientId }, e3.authorizationParams), i3), { scope: j(t3, i3.scope), response_type: \"code\", response_mode: s3 || \"query\", state: o3, nonce: n3, redirect_uri: r3 || e3.authorizationParams.redirect_uri, code_challenge: a3, code_challenge_method: \"S256\" }))(this.options, this.scope, e2, o2, n2, r2, e2.redirect_uri || this.options.authorizationParams.redirect_uri || i2, null == t2 ? void 0 : t2.response_mode), c2 = this._authorizeUrl(s2);\n    return { nonce: n2, code_verifier: a2, scope: s2.scope, audience: s2.audience || \"default\", redirect_uri: s2.redirect_uri, state: o2, url: c2 };\n  }\n  async loginWithPopup(e2, t2) {\n    var i2;\n    if (e2 = e2 || {}, !(t2 = t2 || {}).popup && (t2.popup = ((e3) => {\n      const t3 = window.screenX + (window.innerWidth - 400) / 2, i3 = window.screenY + (window.innerHeight - 600) / 2;\n      return window.open(e3, \"auth0:authorize:popup\", `left=${t3},top=${i3},width=400,height=600,resizable,scrollbars=yes,status=1`);\n    })(\"\"), !t2.popup))\n      throw new Error(\"Unable to open a popup for loginWithPopup - window.open returned `null`\");\n    const o2 = await this._prepareAuthorizeUrl(e2.authorizationParams || {}, { response_mode: \"web_message\" }, window.location.origin);\n    t2.popup.location.href = o2.url;\n    const n2 = await ((e3) => new Promise((t3, i3) => {\n      let o3;\n      const n3 = setInterval(() => {\n        e3.popup && e3.popup.closed && (clearInterval(n3), clearTimeout(a3), window.removeEventListener(\"message\", o3, false), i3(new p(e3.popup)));\n      }, 1e3), a3 = setTimeout(() => {\n        clearInterval(n3), i3(new h(e3.popup)), window.removeEventListener(\"message\", o3, false);\n      }, 1e3 * (e3.timeoutInSeconds || 60));\n      o3 = function(r2) {\n        if (r2.data && \"authorization_response\" === r2.data.type) {\n          if (clearTimeout(a3), clearInterval(n3), window.removeEventListener(\"message\", o3, false), e3.popup.close(), r2.data.response.error)\n            return i3(d.fromPayload(r2.data.response));\n          t3(r2.data.response);\n        }\n      }, window.addEventListener(\"message\", o3);\n    }))(Object.assign(Object.assign({}, t2), { timeoutInSeconds: t2.timeoutInSeconds || this.options.authorizeTimeoutInSeconds || 60 }));\n    if (o2.state !== n2.state)\n      throw new d(\"state_mismatch\", \"Invalid state\");\n    const a2 = (null === (i2 = e2.authorizationParams) || void 0 === i2 ? void 0 : i2.organization) || this.options.authorizationParams.organization;\n    await this._requestToken({ audience: o2.audience, scope: o2.scope, code_verifier: o2.code_verifier, grant_type: \"authorization_code\", code: n2.code, redirect_uri: o2.redirect_uri }, { nonceIn: o2.nonce, organization: a2 });\n  }\n  async getUser() {\n    var e2;\n    const t2 = await this._getIdTokenFromCache();\n    return null === (e2 = null == t2 ? void 0 : t2.decodedToken) || void 0 === e2 ? void 0 : e2.user;\n  }\n  async getIdTokenClaims() {\n    var e2;\n    const t2 = await this._getIdTokenFromCache();\n    return null === (e2 = null == t2 ? void 0 : t2.decodedToken) || void 0 === e2 ? void 0 : e2.claims;\n  }\n  async loginWithRedirect(t2 = {}) {\n    var i2;\n    const o2 = Q(t2), { openUrl: n2, fragment: a2, appState: r2 } = o2, s2 = e(o2, [\"openUrl\", \"fragment\", \"appState\"]), c2 = (null === (i2 = s2.authorizationParams) || void 0 === i2 ? void 0 : i2.organization) || this.options.authorizationParams.organization, d2 = await this._prepareAuthorizeUrl(s2.authorizationParams || {}), { url: u2 } = d2, l2 = e(d2, [\"url\"]);\n    this.transactionManager.create(Object.assign(Object.assign(Object.assign({}, l2), { appState: r2 }), c2 && { organization: c2 }));\n    const h2 = a2 ? `${u2}#${a2}` : u2;\n    n2 ? await n2(h2) : window.location.assign(h2);\n  }\n  async handleRedirectCallback(e2 = window.location.href) {\n    const t2 = e2.split(\"?\").slice(1);\n    if (0 === t2.length)\n      throw new Error(\"There are no query params available for parsing.\");\n    const { state: i2, code: o2, error: n2, error_description: a2 } = ((e3) => {\n      e3.indexOf(\"#\") > -1 && (e3 = e3.substring(0, e3.indexOf(\"#\")));\n      const t3 = new URLSearchParams(e3);\n      return { state: t3.get(\"state\"), code: t3.get(\"code\") || void 0, error: t3.get(\"error\") || void 0, error_description: t3.get(\"error_description\") || void 0 };\n    })(t2.join(\"\")), r2 = this.transactionManager.get();\n    if (!r2)\n      throw new d(\"missing_transaction\", \"Invalid state\");\n    if (this.transactionManager.remove(), n2)\n      throw new u(n2, a2 || n2, i2, r2.appState);\n    if (!r2.code_verifier || r2.state && r2.state !== i2)\n      throw new d(\"state_mismatch\", \"Invalid state\");\n    const s2 = r2.organization, c2 = r2.nonce, l2 = r2.redirect_uri;\n    return await this._requestToken(Object.assign({ audience: r2.audience, scope: r2.scope, code_verifier: r2.code_verifier, grant_type: \"authorization_code\", code: o2 }, l2 ? { redirect_uri: l2 } : {}), { nonceIn: c2, organization: s2 }), { appState: r2.appState };\n  }\n  async checkSession(e2) {\n    if (!this.cookieStorage.get(this.isAuthenticatedCookieName)) {\n      if (!this.cookieStorage.get(\"auth0.is.authenticated\"))\n        return;\n      this.cookieStorage.save(this.isAuthenticatedCookieName, true, { daysUntilExpire: this.sessionCheckExpiryDays, cookieDomain: this.options.cookieDomain }), this.cookieStorage.remove(\"auth0.is.authenticated\");\n    }\n    try {\n      await this.getTokenSilently(e2);\n    } catch (e3) {\n    }\n  }\n  async getTokenSilently(e2 = {}) {\n    var t2;\n    const i2 = Object.assign(Object.assign({ cacheMode: \"on\" }, e2), { authorizationParams: Object.assign(Object.assign(Object.assign({}, this.options.authorizationParams), e2.authorizationParams), { scope: j(this.scope, null === (t2 = e2.authorizationParams) || void 0 === t2 ? void 0 : t2.scope) }) }), o2 = await ((e3, t3) => {\n      let i3 = A[t3];\n      return i3 || (i3 = e3().finally(() => {\n        delete A[t3], i3 = null;\n      }), A[t3] = i3), i3;\n    })(() => this._getTokenSilently(i2), `${this.options.clientId}::${i2.authorizationParams.audience}::${i2.authorizationParams.scope}`);\n    return e2.detailedResponse ? o2 : null == o2 ? void 0 : o2.access_token;\n  }\n  async _getTokenSilently(t2) {\n    const { cacheMode: i2 } = t2, o2 = e(t2, [\"cacheMode\"]);\n    if (\"off\" !== i2) {\n      const e2 = await this._getEntryFromCache({ scope: o2.authorizationParams.scope, audience: o2.authorizationParams.audience || \"default\", clientId: this.options.clientId });\n      if (e2)\n        return e2;\n    }\n    if (\"cache-only\" !== i2) {\n      if (!await (async (e2, t3 = 3) => {\n        for (let i3 = 0; i3 < t3; i3++)\n          if (await e2())\n            return true;\n        return false;\n      })(() => ee.acquireLock(\"auth0.lock.getTokenSilently\", 5e3), 10))\n        throw new l();\n      try {\n        if (window.addEventListener(\"pagehide\", this._releaseLockOnPageHide), \"off\" !== i2) {\n          const e3 = await this._getEntryFromCache({ scope: o2.authorizationParams.scope, audience: o2.authorizationParams.audience || \"default\", clientId: this.options.clientId });\n          if (e3)\n            return e3;\n        }\n        const e2 = this.options.useRefreshTokens ? await this._getTokenUsingRefreshToken(o2) : await this._getTokenFromIFrame(o2), { id_token: t3, access_token: n2, oauthTokenScope: a2, expires_in: r2 } = e2;\n        return Object.assign(Object.assign({ id_token: t3, access_token: n2 }, a2 ? { scope: a2 } : null), { expires_in: r2 });\n      } finally {\n        await ee.releaseLock(\"auth0.lock.getTokenSilently\"), window.removeEventListener(\"pagehide\", this._releaseLockOnPageHide);\n      }\n    }\n  }\n  async getTokenWithPopup(e2 = {}, t2 = {}) {\n    var i2;\n    const o2 = Object.assign(Object.assign({}, e2), { authorizationParams: Object.assign(Object.assign(Object.assign({}, this.options.authorizationParams), e2.authorizationParams), { scope: j(this.scope, null === (i2 = e2.authorizationParams) || void 0 === i2 ? void 0 : i2.scope) }) });\n    t2 = Object.assign(Object.assign({}, r), t2), await this.loginWithPopup(o2, t2);\n    return (await this.cacheManager.get(new C({ scope: o2.authorizationParams.scope, audience: o2.authorizationParams.audience || \"default\", clientId: this.options.clientId }))).access_token;\n  }\n  async isAuthenticated() {\n    return !!await this.getUser();\n  }\n  _buildLogoutUrl(t2) {\n    null !== t2.clientId ? t2.clientId = t2.clientId || this.options.clientId : delete t2.clientId;\n    const i2 = t2.logoutParams || {}, { federated: o2 } = i2, n2 = e(i2, [\"federated\"]), a2 = o2 ? \"&federated\" : \"\";\n    return this._url(`/v2/logout?${v(Object.assign({ clientId: t2.clientId }, n2))}`) + a2;\n  }\n  async logout(t2 = {}) {\n    const i2 = Q(t2), { openUrl: o2 } = i2, n2 = e(i2, [\"openUrl\"]);\n    null === t2.clientId ? await this.cacheManager.clear() : await this.cacheManager.clear(t2.clientId || this.options.clientId), this.cookieStorage.remove(this.orgHintCookieName, { cookieDomain: this.options.cookieDomain }), this.cookieStorage.remove(this.isAuthenticatedCookieName, { cookieDomain: this.options.cookieDomain }), this.userCache.remove(\"@@user@@\");\n    const a2 = this._buildLogoutUrl(n2);\n    o2 ? await o2(a2) : false !== o2 && window.location.assign(a2);\n  }\n  async _getTokenFromIFrame(e2) {\n    const t2 = Object.assign(Object.assign({}, e2.authorizationParams), { prompt: \"none\" }), i2 = this.cookieStorage.get(this.orgHintCookieName);\n    i2 && !t2.organization && (t2.organization = i2);\n    const { url: o2, state: n2, nonce: a2, code_verifier: r2, redirect_uri: s2, scope: c2, audience: u2 } = await this._prepareAuthorizeUrl(t2, { response_mode: \"web_message\" }, window.location.origin);\n    try {\n      if (window.crossOriginIsolated)\n        throw new d(\"login_required\", \"The application is running in a Cross-Origin Isolated context, silently retrieving a token without refresh token is not possible.\");\n      const i3 = e2.timeoutInSeconds || this.options.authorizeTimeoutInSeconds, h2 = await ((e3, t3, i4 = 60) => new Promise((o3, n3) => {\n        const a3 = window.document.createElement(\"iframe\");\n        a3.setAttribute(\"width\", \"0\"), a3.setAttribute(\"height\", \"0\"), a3.style.display = \"none\";\n        const r3 = () => {\n          window.document.body.contains(a3) && (window.document.body.removeChild(a3), window.removeEventListener(\"message\", s3, false));\n        };\n        let s3;\n        const c3 = setTimeout(() => {\n          n3(new l()), r3();\n        }, 1e3 * i4);\n        s3 = function(e4) {\n          if (e4.origin != t3)\n            return;\n          if (!e4.data || \"authorization_response\" !== e4.data.type)\n            return;\n          const i5 = e4.source;\n          i5 && i5.close(), e4.data.response.error ? n3(d.fromPayload(e4.data.response)) : o3(e4.data.response), clearTimeout(c3), window.removeEventListener(\"message\", s3, false), setTimeout(r3, 2e3);\n        }, window.addEventListener(\"message\", s3, false), window.document.body.appendChild(a3), a3.setAttribute(\"src\", e3);\n      }))(o2, this.domainUrl, i3);\n      if (n2 !== h2.state)\n        throw new d(\"state_mismatch\", \"Invalid state\");\n      const p2 = await this._requestToken(Object.assign(Object.assign({}, e2.authorizationParams), { code_verifier: r2, code: h2.code, grant_type: \"authorization_code\", redirect_uri: s2, timeout: e2.authorizationParams.timeout || this.httpTimeoutMs }), { nonceIn: a2, organization: t2.organization });\n      return Object.assign(Object.assign({}, p2), { scope: c2, oauthTokenScope: p2.scope, audience: u2 });\n    } catch (e3) {\n      throw \"login_required\" === e3.error && this.logout({ openUrl: false }), e3;\n    }\n  }\n  async _getTokenUsingRefreshToken(e2) {\n    const t2 = await this.cacheManager.get(new C({ scope: e2.authorizationParams.scope, audience: e2.authorizationParams.audience || \"default\", clientId: this.options.clientId }));\n    if (!(t2 && t2.refresh_token || this.worker)) {\n      if (this.options.useRefreshTokensFallback)\n        return await this._getTokenFromIFrame(e2);\n      throw new f(e2.authorizationParams.audience || \"default\", e2.authorizationParams.scope);\n    }\n    const i2 = e2.authorizationParams.redirect_uri || this.options.authorizationParams.redirect_uri || window.location.origin, o2 = \"number\" == typeof e2.timeoutInSeconds ? 1e3 * e2.timeoutInSeconds : null;\n    try {\n      const n2 = await this._requestToken(Object.assign(Object.assign(Object.assign({}, e2.authorizationParams), { grant_type: \"refresh_token\", refresh_token: t2 && t2.refresh_token, redirect_uri: i2 }), o2 && { timeout: o2 }));\n      return Object.assign(Object.assign({}, n2), { scope: e2.authorizationParams.scope, oauthTokenScope: n2.scope, audience: e2.authorizationParams.audience || \"default\" });\n    } catch (t3) {\n      if ((t3.message.indexOf(\"Missing Refresh Token\") > -1 || t3.message && t3.message.indexOf(\"invalid refresh token\") > -1) && this.options.useRefreshTokensFallback)\n        return await this._getTokenFromIFrame(e2);\n      throw t3;\n    }\n  }\n  async _saveEntryInCache(t2) {\n    const { id_token: i2, decodedToken: o2 } = t2, n2 = e(t2, [\"id_token\", \"decodedToken\"]);\n    this.userCache.set(\"@@user@@\", { id_token: i2, decodedToken: o2 }), await this.cacheManager.setIdToken(this.options.clientId, t2.id_token, t2.decodedToken), await this.cacheManager.set(n2);\n  }\n  async _getIdTokenFromCache() {\n    const e2 = this.options.authorizationParams.audience || \"default\", t2 = await this.cacheManager.getIdToken(new C({ clientId: this.options.clientId, audience: e2, scope: this.scope })), i2 = this.userCache.get(\"@@user@@\");\n    return t2 && t2.id_token === (null == i2 ? void 0 : i2.id_token) ? i2 : (this.userCache.set(\"@@user@@\", t2), t2);\n  }\n  async _getEntryFromCache({ scope: e2, audience: t2, clientId: i2 }) {\n    const o2 = await this.cacheManager.get(new C({ scope: e2, audience: t2, clientId: i2 }), 60);\n    if (o2 && o2.access_token) {\n      const { access_token: e3, oauthTokenScope: t3, expires_in: i3 } = o2, n2 = await this._getIdTokenFromCache();\n      return n2 && Object.assign(Object.assign({ id_token: n2.id_token, access_token: e3 }, t3 ? { scope: t3 } : null), { expires_in: i3 });\n    }\n  }\n  async _requestToken(e2, t2) {\n    const { nonceIn: i2, organization: o2 } = t2 || {}, n2 = await T(Object.assign({ baseUrl: this.domainUrl, client_id: this.options.clientId, auth0Client: this.options.auth0Client, useFormData: this.options.useFormData, timeout: this.httpTimeoutMs }, e2), this.worker), a2 = await this._verifyIdToken(n2.id_token, i2, o2);\n    return await this._saveEntryInCache(Object.assign(Object.assign(Object.assign(Object.assign({}, n2), { decodedToken: a2, scope: e2.scope, audience: e2.audience || \"default\" }), n2.scope ? { oauthTokenScope: n2.scope } : null), { client_id: this.options.clientId })), this.cookieStorage.save(this.isAuthenticatedCookieName, true, { daysUntilExpire: this.sessionCheckExpiryDays, cookieDomain: this.options.cookieDomain }), this._processOrgHint(o2 || a2.claims.org_id), Object.assign(Object.assign({}, n2), { decodedToken: a2 });\n  }\n};\nvar ie = class {\n};\nvar initialAuthState = {\n  isAuthenticated: false,\n  isLoading: true\n};\nvar stub = function() {\n  throw new Error(\"You forgot to wrap your component in <Auth0Provider>.\");\n};\nvar initialContext = __assign(__assign({}, initialAuthState), { buildAuthorizeUrl: stub, buildLogoutUrl: stub, getAccessTokenSilently: stub, getAccessTokenWithPopup: stub, getIdTokenClaims: stub, loginWithRedirect: stub, loginWithPopup: stub, logout: stub, handleRedirectCallback: stub });\nvar Auth0Context = (0, import_react.createContext)(initialContext);\nvar OAuthError = (\n  /** @class */\n  function(_super) {\n    __extends(OAuthError2, _super);\n    function OAuthError2(error, error_description) {\n      var _this = _super.call(this, error_description || error) || this;\n      _this.error = error;\n      _this.error_description = error_description;\n      Object.setPrototypeOf(_this, OAuthError2.prototype);\n      return _this;\n    }\n    return OAuthError2;\n  }(Error)\n);\nvar CODE_RE = /[?&]code=[^&]+/;\nvar STATE_RE = /[?&]state=[^&]+/;\nvar ERROR_RE = /[?&]error=[^&]+/;\nvar hasAuthParams = function(searchParams) {\n  if (searchParams === void 0) {\n    searchParams = window.location.search;\n  }\n  return (CODE_RE.test(searchParams) || ERROR_RE.test(searchParams)) && STATE_RE.test(searchParams);\n};\nvar normalizeErrorFn = function(fallbackMessage) {\n  return function(error) {\n    if (error instanceof Error) {\n      return error;\n    }\n    if (error !== null && typeof error === \"object\" && \"error\" in error && typeof error.error === \"string\") {\n      if (\"error_description\" in error && typeof error.error_description === \"string\") {\n        return new OAuthError(error.error, error.error_description);\n      }\n      return new OAuthError(error.error);\n    }\n    return new Error(fallbackMessage);\n  };\n};\nvar loginError = normalizeErrorFn(\"Login failed\");\nvar tokenError = normalizeErrorFn(\"Get access token failed\");\nvar deprecateRedirectUri = function(options) {\n  var _a;\n  if (options === null || options === void 0 ? void 0 : options.redirectUri) {\n    console.warn(\"Using `redirectUri` has been deprecated, please use `authorizationParams.redirect_uri` instead as `redirectUri` will be no longer supported in a future version\");\n    options.authorizationParams = options.authorizationParams || {};\n    options.authorizationParams.redirect_uri = options.redirectUri;\n    delete options.redirectUri;\n  }\n  if ((_a = options === null || options === void 0 ? void 0 : options.authorizationParams) === null || _a === void 0 ? void 0 : _a.redirectUri) {\n    console.warn(\"Using `authorizationParams.redirectUri` has been deprecated, please use `authorizationParams.redirect_uri` instead as `authorizationParams.redirectUri` will be removed in a future version\");\n    options.authorizationParams.redirect_uri = options.authorizationParams.redirectUri;\n    delete options.authorizationParams.redirectUri;\n  }\n};\nvar reducer = function(state, action) {\n  switch (action.type) {\n    case \"LOGIN_POPUP_STARTED\":\n      return __assign(__assign({}, state), { isLoading: true });\n    case \"LOGIN_POPUP_COMPLETE\":\n    case \"INITIALISED\":\n      return __assign(__assign({}, state), { isAuthenticated: !!action.user, user: action.user, isLoading: false, error: void 0 });\n    case \"HANDLE_REDIRECT_COMPLETE\":\n    case \"GET_ACCESS_TOKEN_COMPLETE\":\n      if (state.user === action.user) {\n        return state;\n      }\n      return __assign(__assign({}, state), { isAuthenticated: !!action.user, user: action.user });\n    case \"LOGOUT\":\n      return __assign(__assign({}, state), { isAuthenticated: false, user: void 0 });\n    case \"ERROR\":\n      return __assign(__assign({}, state), { isLoading: false, error: action.error });\n  }\n};\nvar toAuth0ClientOptions = function(opts) {\n  deprecateRedirectUri(opts);\n  return __assign(__assign({}, opts), { auth0Client: {\n    name: \"auth0-react\",\n    version: \"2.2.4\"\n  } });\n};\nvar defaultOnRedirectCallback = function(appState) {\n  window.history.replaceState({}, document.title, (appState === null || appState === void 0 ? void 0 : appState.returnTo) || window.location.pathname);\n};\nvar Auth0Provider = function(opts) {\n  var children = opts.children, skipRedirectCallback = opts.skipRedirectCallback, _a = opts.onRedirectCallback, onRedirectCallback = _a === void 0 ? defaultOnRedirectCallback : _a, _b = opts.context, context = _b === void 0 ? Auth0Context : _b, clientOpts = __rest(opts, [\"children\", \"skipRedirectCallback\", \"onRedirectCallback\", \"context\"]);\n  var client = (0, import_react.useState)(function() {\n    return new te(toAuth0ClientOptions(clientOpts));\n  })[0];\n  var _c = (0, import_react.useReducer)(reducer, initialAuthState), state = _c[0], dispatch = _c[1];\n  var didInitialise = (0, import_react.useRef)(false);\n  (0, import_react.useEffect)(function() {\n    if (didInitialise.current) {\n      return;\n    }\n    didInitialise.current = true;\n    (function() {\n      return __awaiter(void 0, void 0, void 0, function() {\n        var user, appState, error_1;\n        return __generator(this, function(_a2) {\n          switch (_a2.label) {\n            case 0:\n              _a2.trys.push([0, 7, , 8]);\n              user = void 0;\n              if (!(hasAuthParams() && !skipRedirectCallback))\n                return [3, 3];\n              return [4, client.handleRedirectCallback()];\n            case 1:\n              appState = _a2.sent().appState;\n              return [4, client.getUser()];\n            case 2:\n              user = _a2.sent();\n              onRedirectCallback(appState, user);\n              return [3, 6];\n            case 3:\n              return [4, client.checkSession()];\n            case 4:\n              _a2.sent();\n              return [4, client.getUser()];\n            case 5:\n              user = _a2.sent();\n              _a2.label = 6;\n            case 6:\n              dispatch({ type: \"INITIALISED\", user });\n              return [3, 8];\n            case 7:\n              error_1 = _a2.sent();\n              dispatch({ type: \"ERROR\", error: loginError(error_1) });\n              return [3, 8];\n            case 8:\n              return [\n                2\n                /*return*/\n              ];\n          }\n        });\n      });\n    })();\n  }, [client, onRedirectCallback, skipRedirectCallback]);\n  var loginWithRedirect = (0, import_react.useCallback)(function(opts2) {\n    deprecateRedirectUri(opts2);\n    return client.loginWithRedirect(opts2);\n  }, [client]);\n  var loginWithPopup = (0, import_react.useCallback)(function(options, config) {\n    return __awaiter(void 0, void 0, void 0, function() {\n      var error_2, user;\n      return __generator(this, function(_a2) {\n        switch (_a2.label) {\n          case 0:\n            dispatch({ type: \"LOGIN_POPUP_STARTED\" });\n            _a2.label = 1;\n          case 1:\n            _a2.trys.push([1, 3, , 4]);\n            return [4, client.loginWithPopup(options, config)];\n          case 2:\n            _a2.sent();\n            return [3, 4];\n          case 3:\n            error_2 = _a2.sent();\n            dispatch({ type: \"ERROR\", error: loginError(error_2) });\n            return [\n              2\n              /*return*/\n            ];\n          case 4:\n            return [4, client.getUser()];\n          case 5:\n            user = _a2.sent();\n            dispatch({ type: \"LOGIN_POPUP_COMPLETE\", user });\n            return [\n              2\n              /*return*/\n            ];\n        }\n      });\n    });\n  }, [client]);\n  var logout = (0, import_react.useCallback)(function(opts2) {\n    if (opts2 === void 0) {\n      opts2 = {};\n    }\n    return __awaiter(void 0, void 0, void 0, function() {\n      return __generator(this, function(_a2) {\n        switch (_a2.label) {\n          case 0:\n            return [4, client.logout(opts2)];\n          case 1:\n            _a2.sent();\n            if (opts2.openUrl || opts2.openUrl === false) {\n              dispatch({ type: \"LOGOUT\" });\n            }\n            return [\n              2\n              /*return*/\n            ];\n        }\n      });\n    });\n  }, [client]);\n  var getAccessTokenSilently = (0, import_react.useCallback)(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    function(opts2) {\n      return __awaiter(void 0, void 0, void 0, function() {\n        var token, error_3, _a2;\n        var _b2;\n        return __generator(this, function(_c2) {\n          switch (_c2.label) {\n            case 0:\n              _c2.trys.push([0, 2, 3, 5]);\n              return [4, client.getTokenSilently(opts2)];\n            case 1:\n              token = _c2.sent();\n              return [3, 5];\n            case 2:\n              error_3 = _c2.sent();\n              throw tokenError(error_3);\n            case 3:\n              _a2 = dispatch;\n              _b2 = {\n                type: \"GET_ACCESS_TOKEN_COMPLETE\"\n              };\n              return [4, client.getUser()];\n            case 4:\n              _a2.apply(void 0, [(_b2.user = _c2.sent(), _b2)]);\n              return [\n                7\n                /*endfinally*/\n              ];\n            case 5:\n              return [2, token];\n          }\n        });\n      });\n    },\n    [client]\n  );\n  var getAccessTokenWithPopup = (0, import_react.useCallback)(function(opts2, config) {\n    return __awaiter(void 0, void 0, void 0, function() {\n      var token, error_4, _a2;\n      var _b2;\n      return __generator(this, function(_c2) {\n        switch (_c2.label) {\n          case 0:\n            _c2.trys.push([0, 2, 3, 5]);\n            return [4, client.getTokenWithPopup(opts2, config)];\n          case 1:\n            token = _c2.sent();\n            return [3, 5];\n          case 2:\n            error_4 = _c2.sent();\n            throw tokenError(error_4);\n          case 3:\n            _a2 = dispatch;\n            _b2 = {\n              type: \"GET_ACCESS_TOKEN_COMPLETE\"\n            };\n            return [4, client.getUser()];\n          case 4:\n            _a2.apply(void 0, [(_b2.user = _c2.sent(), _b2)]);\n            return [\n              7\n              /*endfinally*/\n            ];\n          case 5:\n            return [2, token];\n        }\n      });\n    });\n  }, [client]);\n  var getIdTokenClaims = (0, import_react.useCallback)(function() {\n    return client.getIdTokenClaims();\n  }, [client]);\n  var handleRedirectCallback = (0, import_react.useCallback)(function(url) {\n    return __awaiter(void 0, void 0, void 0, function() {\n      var error_5, _a2;\n      var _b2;\n      return __generator(this, function(_c2) {\n        switch (_c2.label) {\n          case 0:\n            _c2.trys.push([0, 2, 3, 5]);\n            return [4, client.handleRedirectCallback(url)];\n          case 1:\n            return [2, _c2.sent()];\n          case 2:\n            error_5 = _c2.sent();\n            throw tokenError(error_5);\n          case 3:\n            _a2 = dispatch;\n            _b2 = {\n              type: \"HANDLE_REDIRECT_COMPLETE\"\n            };\n            return [4, client.getUser()];\n          case 4:\n            _a2.apply(void 0, [(_b2.user = _c2.sent(), _b2)]);\n            return [\n              7\n              /*endfinally*/\n            ];\n          case 5:\n            return [\n              2\n              /*return*/\n            ];\n        }\n      });\n    });\n  }, [client]);\n  var contextValue = (0, import_react.useMemo)(function() {\n    return __assign(__assign({}, state), { getAccessTokenSilently, getAccessTokenWithPopup, getIdTokenClaims, loginWithRedirect, loginWithPopup, logout, handleRedirectCallback });\n  }, [\n    state,\n    getAccessTokenSilently,\n    getAccessTokenWithPopup,\n    getIdTokenClaims,\n    loginWithRedirect,\n    loginWithPopup,\n    logout,\n    handleRedirectCallback\n  ]);\n  return import_react.default.createElement(context.Provider, { value: contextValue }, children);\n};\nvar useAuth0 = function(context) {\n  if (context === void 0) {\n    context = Auth0Context;\n  }\n  return (0, import_react.useContext)(context);\n};\nvar withAuth0 = function(Component, context) {\n  if (context === void 0) {\n    context = Auth0Context;\n  }\n  return function WithAuth(props) {\n    return import_react.default.createElement(context.Consumer, null, function(auth) {\n      return import_react.default.createElement(Component, __assign({}, props, { auth0: auth }));\n    });\n  };\n};\nvar defaultOnRedirecting = function() {\n  return import_react.default.createElement(import_react.default.Fragment, null);\n};\nvar defaultOnBeforeAuthentication = function() {\n  return __awaiter(void 0, void 0, void 0, function() {\n    return __generator(this, function(_a) {\n      return [\n        2\n        /*return*/\n      ];\n    });\n  });\n};\nvar defaultReturnTo = function() {\n  return \"\".concat(window.location.pathname).concat(window.location.search);\n};\nvar withAuthenticationRequired = function(Component, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return function WithAuthenticationRequired(props) {\n    var _this = this;\n    var _a = options.returnTo, returnTo = _a === void 0 ? defaultReturnTo : _a, _b = options.onRedirecting, onRedirecting = _b === void 0 ? defaultOnRedirecting : _b, _c = options.onBeforeAuthentication, onBeforeAuthentication = _c === void 0 ? defaultOnBeforeAuthentication : _c, loginOptions = options.loginOptions, _d = options.context, context = _d === void 0 ? Auth0Context : _d;\n    var _e = useAuth0(context), isAuthenticated = _e.isAuthenticated, isLoading = _e.isLoading, loginWithRedirect = _e.loginWithRedirect;\n    (0, import_react.useEffect)(function() {\n      if (isLoading || isAuthenticated) {\n        return;\n      }\n      var opts = __assign(__assign({}, loginOptions), { appState: __assign(__assign({}, loginOptions && loginOptions.appState), { returnTo: typeof returnTo === \"function\" ? returnTo() : returnTo }) });\n      (function() {\n        return __awaiter(_this, void 0, void 0, function() {\n          return __generator(this, function(_a2) {\n            switch (_a2.label) {\n              case 0:\n                return [4, onBeforeAuthentication()];\n              case 1:\n                _a2.sent();\n                return [4, loginWithRedirect(opts)];\n              case 2:\n                _a2.sent();\n                return [\n                  2\n                  /*return*/\n                ];\n            }\n          });\n        });\n      })();\n    }, [\n      isLoading,\n      isAuthenticated,\n      loginWithRedirect,\n      onBeforeAuthentication,\n      loginOptions,\n      returnTo\n    ]);\n    return isAuthenticated ? import_react.default.createElement(Component, __assign({}, props)) : onRedirecting();\n  };\n};\nexport {\n  Auth0Context,\n  Auth0Provider,\n  u as AuthenticationError,\n  d as GenericError,\n  P as InMemoryCache,\n  z as LocalStorageCache,\n  m as MfaRequiredError,\n  f as MissingRefreshTokenError,\n  OAuthError,\n  p as PopupCancelledError,\n  h as PopupTimeoutError,\n  l as TimeoutError,\n  ie as User,\n  initialContext,\n  useAuth0,\n  withAuth0,\n  withAuthenticationRequired\n};\n//# sourceMappingURL=@auth0_auth0-react.js.map\n",
      "start": 1703474738440,
      "end": 1703474742329,
      "sourcemaps": null
    },
    {
      "name": "vite:react-babel",
      "start": 1703474742329,
      "end": 1703474742329,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1703474742329,
      "end": 1703474742329,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1703474742329,
      "end": 1703474742329,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1703474742329,
      "end": 1703474742329,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1703474742329,
      "end": 1703474742329,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1703474742329,
      "end": 1703474742329,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1703474742329,
      "end": 1703474742329,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1703474742329,
      "end": 1703474742330,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1703474742330,
      "end": 1703474742330,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1703474742330,
      "end": 1703474742330,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1703474742330,
      "end": 1703474742330,
      "order": "normal"
    },
    {
      "name": "vite:client-inject",
      "start": 1703474742330,
      "end": 1703474742330,
      "order": "normal"
    },
    {
      "name": "vite:import-analysis",
      "result": "\"use strict\";\n(() => {\n  var __create = Object.create;\n  var __defProp = Object.defineProperty;\n  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n  var __getOwnPropNames = Object.getOwnPropertyNames;\n  var __getProtoOf = Object.getPrototypeOf;\n  var __hasOwnProp = Object.prototype.hasOwnProperty;\n  var __esm = (fn, res) => function __init() {\n    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;\n  };\n  var __commonJS = (cb, mod) => function __require() {\n    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n  };\n  var __copyProps = (to, from, except, desc) => {\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n      for (let key of __getOwnPropNames(from))\n        if (!__hasOwnProp.call(to, key) && key !== except)\n          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n    }\n    return to;\n  };\n  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n    // If the importer is in node compatibility mode or this is not an ESM\n    // file that has been converted to a CommonJS file using a Babel-\n    // compatible transform (i.e. \"__esModule\" has not been set), then set\n    // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n    isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n    mod\n  ));\n\n  // node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js\n  var require_base64_js = __commonJS({\n    \"node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js\"(exports) {\n      \"use strict\";\n      init_dist();\n      exports.byteLength = byteLength;\n      exports.toByteArray = toByteArray;\n      exports.fromByteArray = fromByteArray;\n      var lookup = [];\n      var revLookup = [];\n      var Arr = typeof Uint8Array !== \"undefined\" ? Uint8Array : Array;\n      var code = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n      for (i = 0, len = code.length; i < len; ++i) {\n        lookup[i] = code[i];\n        revLookup[code.charCodeAt(i)] = i;\n      }\n      var i;\n      var len;\n      revLookup[\"-\".charCodeAt(0)] = 62;\n      revLookup[\"_\".charCodeAt(0)] = 63;\n      function getLens(b64) {\n        var len2 = b64.length;\n        if (len2 % 4 > 0) {\n          throw new Error(\"Invalid string. Length must be a multiple of 4\");\n        }\n        var validLen = b64.indexOf(\"=\");\n        if (validLen === -1)\n          validLen = len2;\n        var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;\n        return [validLen, placeHoldersLen];\n      }\n      function byteLength(b64) {\n        var lens = getLens(b64);\n        var validLen = lens[0];\n        var placeHoldersLen = lens[1];\n        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n      }\n      function _byteLength(b64, validLen, placeHoldersLen) {\n        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n      }\n      function toByteArray(b64) {\n        var tmp;\n        var lens = getLens(b64);\n        var validLen = lens[0];\n        var placeHoldersLen = lens[1];\n        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n        var curByte = 0;\n        var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;\n        var i2;\n        for (i2 = 0; i2 < len2; i2 += 4) {\n          tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];\n          arr[curByte++] = tmp >> 16 & 255;\n          arr[curByte++] = tmp >> 8 & 255;\n          arr[curByte++] = tmp & 255;\n        }\n        if (placeHoldersLen === 2) {\n          tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;\n          arr[curByte++] = tmp & 255;\n        }\n        if (placeHoldersLen === 1) {\n          tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;\n          arr[curByte++] = tmp >> 8 & 255;\n          arr[curByte++] = tmp & 255;\n        }\n        return arr;\n      }\n      function tripletToBase64(num) {\n        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];\n      }\n      function encodeChunk(uint8, start, end) {\n        var tmp;\n        var output = [];\n        for (var i2 = start; i2 < end; i2 += 3) {\n          tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);\n          output.push(tripletToBase64(tmp));\n        }\n        return output.join(\"\");\n      }\n      function fromByteArray(uint8) {\n        var tmp;\n        var len2 = uint8.length;\n        var extraBytes = len2 % 3;\n        var parts = [];\n        var maxChunkLength = 16383;\n        for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {\n          parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));\n        }\n        if (extraBytes === 1) {\n          tmp = uint8[len2 - 1];\n          parts.push(\n            lookup[tmp >> 2] + lookup[tmp << 4 & 63] + \"==\"\n          );\n        } else if (extraBytes === 2) {\n          tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];\n          parts.push(\n            lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + \"=\"\n          );\n        }\n        return parts.join(\"\");\n      }\n    }\n  });\n\n  // node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js\n  var require_ieee754 = __commonJS({\n    \"node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js\"(exports) {\n      init_dist();\n      exports.read = function(buffer, offset, isLE, mLen, nBytes) {\n        var e, m;\n        var eLen = nBytes * 8 - mLen - 1;\n        var eMax = (1 << eLen) - 1;\n        var eBias = eMax >> 1;\n        var nBits = -7;\n        var i = isLE ? nBytes - 1 : 0;\n        var d = isLE ? -1 : 1;\n        var s2 = buffer[offset + i];\n        i += d;\n        e = s2 & (1 << -nBits) - 1;\n        s2 >>= -nBits;\n        nBits += eLen;\n        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {\n        }\n        m = e & (1 << -nBits) - 1;\n        e >>= -nBits;\n        nBits += mLen;\n        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {\n        }\n        if (e === 0) {\n          e = 1 - eBias;\n        } else if (e === eMax) {\n          return m ? NaN : (s2 ? -1 : 1) * Infinity;\n        } else {\n          m = m + Math.pow(2, mLen);\n          e = e - eBias;\n        }\n        return (s2 ? -1 : 1) * m * Math.pow(2, e - mLen);\n      };\n      exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {\n        var e, m, c;\n        var eLen = nBytes * 8 - mLen - 1;\n        var eMax = (1 << eLen) - 1;\n        var eBias = eMax >> 1;\n        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n        var i = isLE ? 0 : nBytes - 1;\n        var d = isLE ? 1 : -1;\n        var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n        value = Math.abs(value);\n        if (isNaN(value) || value === Infinity) {\n          m = isNaN(value) ? 1 : 0;\n          e = eMax;\n        } else {\n          e = Math.floor(Math.log(value) / Math.LN2);\n          if (value * (c = Math.pow(2, -e)) < 1) {\n            e--;\n            c *= 2;\n          }\n          if (e + eBias >= 1) {\n            value += rt / c;\n          } else {\n            value += rt * Math.pow(2, 1 - eBias);\n          }\n          if (value * c >= 2) {\n            e++;\n            c /= 2;\n          }\n          if (e + eBias >= eMax) {\n            m = 0;\n            e = eMax;\n          } else if (e + eBias >= 1) {\n            m = (value * c - 1) * Math.pow(2, mLen);\n            e = e + eBias;\n          } else {\n            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n            e = 0;\n          }\n        }\n        for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {\n        }\n        e = e << mLen | m;\n        eLen += mLen;\n        for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {\n        }\n        buffer[offset + i - d] |= s2 * 128;\n      };\n    }\n  });\n\n  // node_modules/.pnpm/buffer@6.0.3_patch_hash=zkkuxompt5d553skpnegwi5wuy/node_modules/buffer/index.js\n  var require_buffer = __commonJS({\n    \"node_modules/.pnpm/buffer@6.0.3_patch_hash=zkkuxompt5d553skpnegwi5wuy/node_modules/buffer/index.js\"(exports) {\n      \"use strict\";\n      init_dist();\n      var base64 = require_base64_js();\n      var ieee754 = require_ieee754();\n      var customInspectSymbol = typeof Symbol === \"function\" && typeof Symbol[\"for\"] === \"function\" ? Symbol[\"for\"](\"nodejs.util.inspect.custom\") : null;\n      exports.Buffer = Buffer2;\n      exports.SlowBuffer = SlowBuffer;\n      exports.INSPECT_MAX_BYTES = 50;\n      var K_MAX_LENGTH = 2147483647;\n      exports.kMaxLength = K_MAX_LENGTH;\n      var { Uint8Array: GlobalUint8Array, ArrayBuffer: GlobalArrayBuffer, SharedArrayBuffer: GlobalSharedArrayBuffer } = globalThis;\n      Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();\n      if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== \"undefined\" && typeof console.error === \"function\") {\n        console.error(\n          \"This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.\"\n        );\n      }\n      function typedArraySupport() {\n        try {\n          const arr = new GlobalUint8Array(1);\n          const proto = { foo: function() {\n            return 42;\n          } };\n          Object.setPrototypeOf(proto, GlobalUint8Array.prototype);\n          Object.setPrototypeOf(arr, proto);\n          return arr.foo() === 42;\n        } catch (e) {\n          return false;\n        }\n      }\n      Object.defineProperty(Buffer2.prototype, \"parent\", {\n        enumerable: true,\n        get: function() {\n          if (!Buffer2.isBuffer(this))\n            return void 0;\n          return this.buffer;\n        }\n      });\n      Object.defineProperty(Buffer2.prototype, \"offset\", {\n        enumerable: true,\n        get: function() {\n          if (!Buffer2.isBuffer(this))\n            return void 0;\n          return this.byteOffset;\n        }\n      });\n      function createBuffer(length) {\n        if (length > K_MAX_LENGTH) {\n          throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"');\n        }\n        const buf = new GlobalUint8Array(length);\n        Object.setPrototypeOf(buf, Buffer2.prototype);\n        return buf;\n      }\n      function Buffer2(arg, encodingOrOffset, length) {\n        if (typeof arg === \"number\") {\n          if (typeof encodingOrOffset === \"string\") {\n            throw new TypeError(\n              'The \"string\" argument must be of type string. Received type number'\n            );\n          }\n          return allocUnsafe(arg);\n        }\n        return from(arg, encodingOrOffset, length);\n      }\n      Buffer2.poolSize = 8192;\n      function from(value, encodingOrOffset, length) {\n        if (typeof value === \"string\") {\n          return fromString(value, encodingOrOffset);\n        }\n        if (GlobalArrayBuffer.isView(value)) {\n          return fromArrayView(value);\n        }\n        if (value == null) {\n          throw new TypeError(\n            \"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value\n          );\n        }\n        if (isInstance(value, GlobalArrayBuffer) || value && isInstance(value.buffer, GlobalArrayBuffer)) {\n          return fromArrayBuffer(value, encodingOrOffset, length);\n        }\n        if (typeof GlobalSharedArrayBuffer !== \"undefined\" && (isInstance(value, GlobalSharedArrayBuffer) || value && isInstance(value.buffer, GlobalSharedArrayBuffer))) {\n          return fromArrayBuffer(value, encodingOrOffset, length);\n        }\n        if (typeof value === \"number\") {\n          throw new TypeError(\n            'The \"value\" argument must not be of type number. Received type number'\n          );\n        }\n        const valueOf = value.valueOf && value.valueOf();\n        if (valueOf != null && valueOf !== value) {\n          return Buffer2.from(valueOf, encodingOrOffset, length);\n        }\n        const b = fromObject(value);\n        if (b)\n          return b;\n        if (typeof Symbol !== \"undefined\" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === \"function\") {\n          return Buffer2.from(value[Symbol.toPrimitive](\"string\"), encodingOrOffset, length);\n        }\n        throw new TypeError(\n          \"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value\n        );\n      }\n      Buffer2.from = function(value, encodingOrOffset, length) {\n        return from(value, encodingOrOffset, length);\n      };\n      Object.setPrototypeOf(Buffer2.prototype, GlobalUint8Array.prototype);\n      Object.setPrototypeOf(Buffer2, GlobalUint8Array);\n      function assertSize(size) {\n        if (typeof size !== \"number\") {\n          throw new TypeError('\"size\" argument must be of type number');\n        } else if (size < 0) {\n          throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"');\n        }\n      }\n      function alloc(size, fill, encoding) {\n        assertSize(size);\n        if (size <= 0) {\n          return createBuffer(size);\n        }\n        if (fill !== void 0) {\n          return typeof encoding === \"string\" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);\n        }\n        return createBuffer(size);\n      }\n      Buffer2.alloc = function(size, fill, encoding) {\n        return alloc(size, fill, encoding);\n      };\n      function allocUnsafe(size) {\n        assertSize(size);\n        return createBuffer(size < 0 ? 0 : checked(size) | 0);\n      }\n      Buffer2.allocUnsafe = function(size) {\n        return allocUnsafe(size);\n      };\n      Buffer2.allocUnsafeSlow = function(size) {\n        return allocUnsafe(size);\n      };\n      function fromString(string, encoding) {\n        if (typeof encoding !== \"string\" || encoding === \"\") {\n          encoding = \"utf8\";\n        }\n        if (!Buffer2.isEncoding(encoding)) {\n          throw new TypeError(\"Unknown encoding: \" + encoding);\n        }\n        const length = byteLength(string, encoding) | 0;\n        let buf = createBuffer(length);\n        const actual = buf.write(string, encoding);\n        if (actual !== length) {\n          buf = buf.slice(0, actual);\n        }\n        return buf;\n      }\n      function fromArrayLike(array) {\n        const length = array.length < 0 ? 0 : checked(array.length) | 0;\n        const buf = createBuffer(length);\n        for (let i = 0; i < length; i += 1) {\n          buf[i] = array[i] & 255;\n        }\n        return buf;\n      }\n      function fromArrayView(arrayView) {\n        if (isInstance(arrayView, GlobalUint8Array)) {\n          const copy = new GlobalUint8Array(arrayView);\n          return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);\n        }\n        return fromArrayLike(arrayView);\n      }\n      function fromArrayBuffer(array, byteOffset, length) {\n        if (byteOffset < 0 || array.byteLength < byteOffset) {\n          throw new RangeError('\"offset\" is outside of buffer bounds');\n        }\n        if (array.byteLength < byteOffset + (length || 0)) {\n          throw new RangeError('\"length\" is outside of buffer bounds');\n        }\n        let buf;\n        if (byteOffset === void 0 && length === void 0) {\n          buf = new GlobalUint8Array(array);\n        } else if (length === void 0) {\n          buf = new GlobalUint8Array(array, byteOffset);\n        } else {\n          buf = new GlobalUint8Array(array, byteOffset, length);\n        }\n        Object.setPrototypeOf(buf, Buffer2.prototype);\n        return buf;\n      }\n      function fromObject(obj) {\n        if (Buffer2.isBuffer(obj)) {\n          const len = checked(obj.length) | 0;\n          const buf = createBuffer(len);\n          if (buf.length === 0) {\n            return buf;\n          }\n          obj.copy(buf, 0, 0, len);\n          return buf;\n        }\n        if (obj.length !== void 0) {\n          if (typeof obj.length !== \"number\" || numberIsNaN(obj.length)) {\n            return createBuffer(0);\n          }\n          return fromArrayLike(obj);\n        }\n        if (obj.type === \"Buffer\" && Array.isArray(obj.data)) {\n          return fromArrayLike(obj.data);\n        }\n      }\n      function checked(length) {\n        if (length >= K_MAX_LENGTH) {\n          throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\" + K_MAX_LENGTH.toString(16) + \" bytes\");\n        }\n        return length | 0;\n      }\n      function SlowBuffer(length) {\n        if (+length != length) {\n          length = 0;\n        }\n        return Buffer2.alloc(+length);\n      }\n      Buffer2.isBuffer = function isBuffer(b) {\n        return b != null && b._isBuffer === true && b !== Buffer2.prototype;\n      };\n      Buffer2.compare = function compare(a, b) {\n        if (isInstance(a, GlobalUint8Array))\n          a = Buffer2.from(a, a.offset, a.byteLength);\n        if (isInstance(b, GlobalUint8Array))\n          b = Buffer2.from(b, b.offset, b.byteLength);\n        if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {\n          throw new TypeError(\n            'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n          );\n        }\n        if (a === b)\n          return 0;\n        let x = a.length;\n        let y = b.length;\n        for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n          if (a[i] !== b[i]) {\n            x = a[i];\n            y = b[i];\n            break;\n          }\n        }\n        if (x < y)\n          return -1;\n        if (y < x)\n          return 1;\n        return 0;\n      };\n      Buffer2.isEncoding = function isEncoding(encoding) {\n        switch (String(encoding).toLowerCase()) {\n          case \"hex\":\n          case \"utf8\":\n          case \"utf-8\":\n          case \"ascii\":\n          case \"latin1\":\n          case \"binary\":\n          case \"base64\":\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return true;\n          default:\n            return false;\n        }\n      };\n      Buffer2.concat = function concat(list, length) {\n        if (!Array.isArray(list)) {\n          throw new TypeError('\"list\" argument must be an Array of Buffers');\n        }\n        if (list.length === 0) {\n          return Buffer2.alloc(0);\n        }\n        let i;\n        if (length === void 0) {\n          length = 0;\n          for (i = 0; i < list.length; ++i) {\n            length += list[i].length;\n          }\n        }\n        const buffer = Buffer2.allocUnsafe(length);\n        let pos = 0;\n        for (i = 0; i < list.length; ++i) {\n          let buf = list[i];\n          if (isInstance(buf, GlobalUint8Array)) {\n            if (pos + buf.length > buffer.length) {\n              if (!Buffer2.isBuffer(buf))\n                buf = Buffer2.from(buf);\n              buf.copy(buffer, pos);\n            } else {\n              GlobalUint8Array.prototype.set.call(\n                buffer,\n                buf,\n                pos\n              );\n            }\n          } else if (!Buffer2.isBuffer(buf)) {\n            throw new TypeError('\"list\" argument must be an Array of Buffers');\n          } else {\n            buf.copy(buffer, pos);\n          }\n          pos += buf.length;\n        }\n        return buffer;\n      };\n      function byteLength(string, encoding) {\n        if (Buffer2.isBuffer(string)) {\n          return string.length;\n        }\n        if (GlobalArrayBuffer.isView(string) || isInstance(string, GlobalArrayBuffer)) {\n          return string.byteLength;\n        }\n        if (typeof string !== \"string\") {\n          throw new TypeError(\n            'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string\n          );\n        }\n        const len = string.length;\n        const mustMatch = arguments.length > 2 && arguments[2] === true;\n        if (!mustMatch && len === 0)\n          return 0;\n        let loweredCase = false;\n        for (; ; ) {\n          switch (encoding) {\n            case \"ascii\":\n            case \"latin1\":\n            case \"binary\":\n              return len;\n            case \"utf8\":\n            case \"utf-8\":\n              return utf8ToBytes(string).length;\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n              return len * 2;\n            case \"hex\":\n              return len >>> 1;\n            case \"base64\":\n              return base64ToBytes(string).length;\n            default:\n              if (loweredCase) {\n                return mustMatch ? -1 : utf8ToBytes(string).length;\n              }\n              encoding = (\"\" + encoding).toLowerCase();\n              loweredCase = true;\n          }\n        }\n      }\n      Buffer2.byteLength = byteLength;\n      function slowToString(encoding, start, end) {\n        let loweredCase = false;\n        if (start === void 0 || start < 0) {\n          start = 0;\n        }\n        if (start > this.length) {\n          return \"\";\n        }\n        if (end === void 0 || end > this.length) {\n          end = this.length;\n        }\n        if (end <= 0) {\n          return \"\";\n        }\n        end >>>= 0;\n        start >>>= 0;\n        if (end <= start) {\n          return \"\";\n        }\n        if (!encoding)\n          encoding = \"utf8\";\n        while (true) {\n          switch (encoding) {\n            case \"hex\":\n              return hexSlice(this, start, end);\n            case \"utf8\":\n            case \"utf-8\":\n              return utf8Slice(this, start, end);\n            case \"ascii\":\n              return asciiSlice(this, start, end);\n            case \"latin1\":\n            case \"binary\":\n              return latin1Slice(this, start, end);\n            case \"base64\":\n              return base64Slice(this, start, end);\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n              return utf16leSlice(this, start, end);\n            default:\n              if (loweredCase)\n                throw new TypeError(\"Unknown encoding: \" + encoding);\n              encoding = (encoding + \"\").toLowerCase();\n              loweredCase = true;\n          }\n        }\n      }\n      Buffer2.prototype._isBuffer = true;\n      function swap(b, n, m) {\n        const i = b[n];\n        b[n] = b[m];\n        b[m] = i;\n      }\n      Buffer2.prototype.swap16 = function swap16() {\n        const len = this.length;\n        if (len % 2 !== 0) {\n          throw new RangeError(\"Buffer size must be a multiple of 16-bits\");\n        }\n        for (let i = 0; i < len; i += 2) {\n          swap(this, i, i + 1);\n        }\n        return this;\n      };\n      Buffer2.prototype.swap32 = function swap32() {\n        const len = this.length;\n        if (len % 4 !== 0) {\n          throw new RangeError(\"Buffer size must be a multiple of 32-bits\");\n        }\n        for (let i = 0; i < len; i += 4) {\n          swap(this, i, i + 3);\n          swap(this, i + 1, i + 2);\n        }\n        return this;\n      };\n      Buffer2.prototype.swap64 = function swap64() {\n        const len = this.length;\n        if (len % 8 !== 0) {\n          throw new RangeError(\"Buffer size must be a multiple of 64-bits\");\n        }\n        for (let i = 0; i < len; i += 8) {\n          swap(this, i, i + 7);\n          swap(this, i + 1, i + 6);\n          swap(this, i + 2, i + 5);\n          swap(this, i + 3, i + 4);\n        }\n        return this;\n      };\n      Buffer2.prototype.toString = function toString() {\n        const length = this.length;\n        if (length === 0)\n          return \"\";\n        if (arguments.length === 0)\n          return utf8Slice(this, 0, length);\n        return slowToString.apply(this, arguments);\n      };\n      Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;\n      Buffer2.prototype.equals = function equals(b) {\n        if (!Buffer2.isBuffer(b))\n          throw new TypeError(\"Argument must be a Buffer\");\n        if (this === b)\n          return true;\n        return Buffer2.compare(this, b) === 0;\n      };\n      Buffer2.prototype.inspect = function inspect() {\n        let str = \"\";\n        const max = exports.INSPECT_MAX_BYTES;\n        str = this.toString(\"hex\", 0, max).replace(/(.{2})/g, \"$1 \").trim();\n        if (this.length > max)\n          str += \" ... \";\n        return \"<Buffer \" + str + \">\";\n      };\n      if (customInspectSymbol) {\n        Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;\n      }\n      Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n        if (isInstance(target, GlobalUint8Array)) {\n          target = Buffer2.from(target, target.offset, target.byteLength);\n        }\n        if (!Buffer2.isBuffer(target)) {\n          throw new TypeError(\n            'The \"target\" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target\n          );\n        }\n        if (start === void 0) {\n          start = 0;\n        }\n        if (end === void 0) {\n          end = target ? target.length : 0;\n        }\n        if (thisStart === void 0) {\n          thisStart = 0;\n        }\n        if (thisEnd === void 0) {\n          thisEnd = this.length;\n        }\n        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n          throw new RangeError(\"out of range index\");\n        }\n        if (thisStart >= thisEnd && start >= end) {\n          return 0;\n        }\n        if (thisStart >= thisEnd) {\n          return -1;\n        }\n        if (start >= end) {\n          return 1;\n        }\n        start >>>= 0;\n        end >>>= 0;\n        thisStart >>>= 0;\n        thisEnd >>>= 0;\n        if (this === target)\n          return 0;\n        let x = thisEnd - thisStart;\n        let y = end - start;\n        const len = Math.min(x, y);\n        const thisCopy = this.slice(thisStart, thisEnd);\n        const targetCopy = target.slice(start, end);\n        for (let i = 0; i < len; ++i) {\n          if (thisCopy[i] !== targetCopy[i]) {\n            x = thisCopy[i];\n            y = targetCopy[i];\n            break;\n          }\n        }\n        if (x < y)\n          return -1;\n        if (y < x)\n          return 1;\n        return 0;\n      };\n      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n        if (buffer.length === 0)\n          return -1;\n        if (typeof byteOffset === \"string\") {\n          encoding = byteOffset;\n          byteOffset = 0;\n        } else if (byteOffset > 2147483647) {\n          byteOffset = 2147483647;\n        } else if (byteOffset < -2147483648) {\n          byteOffset = -2147483648;\n        }\n        byteOffset = +byteOffset;\n        if (numberIsNaN(byteOffset)) {\n          byteOffset = dir ? 0 : buffer.length - 1;\n        }\n        if (byteOffset < 0)\n          byteOffset = buffer.length + byteOffset;\n        if (byteOffset >= buffer.length) {\n          if (dir)\n            return -1;\n          else\n            byteOffset = buffer.length - 1;\n        } else if (byteOffset < 0) {\n          if (dir)\n            byteOffset = 0;\n          else\n            return -1;\n        }\n        if (typeof val === \"string\") {\n          val = Buffer2.from(val, encoding);\n        }\n        if (Buffer2.isBuffer(val)) {\n          if (val.length === 0) {\n            return -1;\n          }\n          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n        } else if (typeof val === \"number\") {\n          val = val & 255;\n          if (typeof GlobalUint8Array.prototype.indexOf === \"function\") {\n            if (dir) {\n              return GlobalUint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n            } else {\n              return GlobalUint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n            }\n          }\n          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);\n        }\n        throw new TypeError(\"val must be string, number or Buffer\");\n      }\n      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n        let indexSize = 1;\n        let arrLength = arr.length;\n        let valLength = val.length;\n        if (encoding !== void 0) {\n          encoding = String(encoding).toLowerCase();\n          if (encoding === \"ucs2\" || encoding === \"ucs-2\" || encoding === \"utf16le\" || encoding === \"utf-16le\") {\n            if (arr.length < 2 || val.length < 2) {\n              return -1;\n            }\n            indexSize = 2;\n            arrLength /= 2;\n            valLength /= 2;\n            byteOffset /= 2;\n          }\n        }\n        function read(buf, i2) {\n          if (indexSize === 1) {\n            return buf[i2];\n          } else {\n            return buf.readUInt16BE(i2 * indexSize);\n          }\n        }\n        let i;\n        if (dir) {\n          let foundIndex = -1;\n          for (i = byteOffset; i < arrLength; i++) {\n            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n              if (foundIndex === -1)\n                foundIndex = i;\n              if (i - foundIndex + 1 === valLength)\n                return foundIndex * indexSize;\n            } else {\n              if (foundIndex !== -1)\n                i -= i - foundIndex;\n              foundIndex = -1;\n            }\n          }\n        } else {\n          if (byteOffset + valLength > arrLength)\n            byteOffset = arrLength - valLength;\n          for (i = byteOffset; i >= 0; i--) {\n            let found = true;\n            for (let j = 0; j < valLength; j++) {\n              if (read(arr, i + j) !== read(val, j)) {\n                found = false;\n                break;\n              }\n            }\n            if (found)\n              return i;\n          }\n        }\n        return -1;\n      }\n      Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {\n        return this.indexOf(val, byteOffset, encoding) !== -1;\n      };\n      Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n      };\n      Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n      };\n      function hexWrite(buf, string, offset, length) {\n        offset = Number(offset) || 0;\n        const remaining = buf.length - offset;\n        if (!length) {\n          length = remaining;\n        } else {\n          length = Number(length);\n          if (length > remaining) {\n            length = remaining;\n          }\n        }\n        const strLen = string.length;\n        if (length > strLen / 2) {\n          length = strLen / 2;\n        }\n        let i;\n        for (i = 0; i < length; ++i) {\n          const parsed = parseInt(string.substr(i * 2, 2), 16);\n          if (numberIsNaN(parsed))\n            return i;\n          buf[offset + i] = parsed;\n        }\n        return i;\n      }\n      function utf8Write(buf, string, offset, length) {\n        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n      }\n      function asciiWrite(buf, string, offset, length) {\n        return blitBuffer(asciiToBytes(string), buf, offset, length);\n      }\n      function base64Write(buf, string, offset, length) {\n        return blitBuffer(base64ToBytes(string), buf, offset, length);\n      }\n      function ucs2Write(buf, string, offset, length) {\n        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n      }\n      Buffer2.prototype.write = function write(string, offset, length, encoding) {\n        if (offset === void 0) {\n          encoding = \"utf8\";\n          length = this.length;\n          offset = 0;\n        } else if (length === void 0 && typeof offset === \"string\") {\n          encoding = offset;\n          length = this.length;\n          offset = 0;\n        } else if (isFinite(offset)) {\n          offset = offset >>> 0;\n          if (isFinite(length)) {\n            length = length >>> 0;\n            if (encoding === void 0)\n              encoding = \"utf8\";\n          } else {\n            encoding = length;\n            length = void 0;\n          }\n        } else {\n          throw new Error(\n            \"Buffer.write(string, encoding, offset[, length]) is no longer supported\"\n          );\n        }\n        const remaining = this.length - offset;\n        if (length === void 0 || length > remaining)\n          length = remaining;\n        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n          throw new RangeError(\"Attempt to write outside buffer bounds\");\n        }\n        if (!encoding)\n          encoding = \"utf8\";\n        let loweredCase = false;\n        for (; ; ) {\n          switch (encoding) {\n            case \"hex\":\n              return hexWrite(this, string, offset, length);\n            case \"utf8\":\n            case \"utf-8\":\n              return utf8Write(this, string, offset, length);\n            case \"ascii\":\n            case \"latin1\":\n            case \"binary\":\n              return asciiWrite(this, string, offset, length);\n            case \"base64\":\n              return base64Write(this, string, offset, length);\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n              return ucs2Write(this, string, offset, length);\n            default:\n              if (loweredCase)\n                throw new TypeError(\"Unknown encoding: \" + encoding);\n              encoding = (\"\" + encoding).toLowerCase();\n              loweredCase = true;\n          }\n        }\n      };\n      Buffer2.prototype.toJSON = function toJSON() {\n        return {\n          type: \"Buffer\",\n          data: Array.prototype.slice.call(this._arr || this, 0)\n        };\n      };\n      function base64Slice(buf, start, end) {\n        if (start === 0 && end === buf.length) {\n          return base64.fromByteArray(buf);\n        } else {\n          return base64.fromByteArray(buf.slice(start, end));\n        }\n      }\n      function utf8Slice(buf, start, end) {\n        end = Math.min(buf.length, end);\n        const res = [];\n        let i = start;\n        while (i < end) {\n          const firstByte = buf[i];\n          let codePoint = null;\n          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;\n          if (i + bytesPerSequence <= end) {\n            let secondByte, thirdByte, fourthByte, tempCodePoint;\n            switch (bytesPerSequence) {\n              case 1:\n                if (firstByte < 128) {\n                  codePoint = firstByte;\n                }\n                break;\n              case 2:\n                secondByte = buf[i + 1];\n                if ((secondByte & 192) === 128) {\n                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;\n                  if (tempCodePoint > 127) {\n                    codePoint = tempCodePoint;\n                  }\n                }\n                break;\n              case 3:\n                secondByte = buf[i + 1];\n                thirdByte = buf[i + 2];\n                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {\n                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;\n                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {\n                    codePoint = tempCodePoint;\n                  }\n                }\n                break;\n              case 4:\n                secondByte = buf[i + 1];\n                thirdByte = buf[i + 2];\n                fourthByte = buf[i + 3];\n                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {\n                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;\n                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {\n                    codePoint = tempCodePoint;\n                  }\n                }\n            }\n          }\n          if (codePoint === null) {\n            codePoint = 65533;\n            bytesPerSequence = 1;\n          } else if (codePoint > 65535) {\n            codePoint -= 65536;\n            res.push(codePoint >>> 10 & 1023 | 55296);\n            codePoint = 56320 | codePoint & 1023;\n          }\n          res.push(codePoint);\n          i += bytesPerSequence;\n        }\n        return decodeCodePointsArray(res);\n      }\n      var MAX_ARGUMENTS_LENGTH = 4096;\n      function decodeCodePointsArray(codePoints) {\n        const len = codePoints.length;\n        if (len <= MAX_ARGUMENTS_LENGTH) {\n          return String.fromCharCode.apply(String, codePoints);\n        }\n        let res = \"\";\n        let i = 0;\n        while (i < len) {\n          res += String.fromCharCode.apply(\n            String,\n            codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n          );\n        }\n        return res;\n      }\n      function asciiSlice(buf, start, end) {\n        let ret = \"\";\n        end = Math.min(buf.length, end);\n        for (let i = start; i < end; ++i) {\n          ret += String.fromCharCode(buf[i] & 127);\n        }\n        return ret;\n      }\n      function latin1Slice(buf, start, end) {\n        let ret = \"\";\n        end = Math.min(buf.length, end);\n        for (let i = start; i < end; ++i) {\n          ret += String.fromCharCode(buf[i]);\n        }\n        return ret;\n      }\n      function hexSlice(buf, start, end) {\n        const len = buf.length;\n        if (!start || start < 0)\n          start = 0;\n        if (!end || end < 0 || end > len)\n          end = len;\n        let out = \"\";\n        for (let i = start; i < end; ++i) {\n          out += hexSliceLookupTable[buf[i]];\n        }\n        return out;\n      }\n      function utf16leSlice(buf, start, end) {\n        const bytes = buf.slice(start, end);\n        let res = \"\";\n        for (let i = 0; i < bytes.length - 1; i += 2) {\n          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n        }\n        return res;\n      }\n      Buffer2.prototype.slice = function slice(start, end) {\n        const len = this.length;\n        start = ~~start;\n        end = end === void 0 ? len : ~~end;\n        if (start < 0) {\n          start += len;\n          if (start < 0)\n            start = 0;\n        } else if (start > len) {\n          start = len;\n        }\n        if (end < 0) {\n          end += len;\n          if (end < 0)\n            end = 0;\n        } else if (end > len) {\n          end = len;\n        }\n        if (end < start)\n          end = start;\n        const newBuf = this.subarray(start, end);\n        Object.setPrototypeOf(newBuf, Buffer2.prototype);\n        return newBuf;\n      };\n      function checkOffset(offset, ext, length) {\n        if (offset % 1 !== 0 || offset < 0)\n          throw new RangeError(\"offset is not uint\");\n        if (offset + ext > length)\n          throw new RangeError(\"Trying to access beyond buffer length\");\n      }\n      Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert)\n          checkOffset(offset, byteLength2, this.length);\n        let val = this[offset];\n        let mul = 1;\n        let i = 0;\n        while (++i < byteLength2 && (mul *= 256)) {\n          val += this[offset + i] * mul;\n        }\n        return val;\n      };\n      Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert) {\n          checkOffset(offset, byteLength2, this.length);\n        }\n        let val = this[offset + --byteLength2];\n        let mul = 1;\n        while (byteLength2 > 0 && (mul *= 256)) {\n          val += this[offset + --byteLength2] * mul;\n        }\n        return val;\n      };\n      Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 1, this.length);\n        return this[offset];\n      };\n      Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 2, this.length);\n        return this[offset] | this[offset + 1] << 8;\n      };\n      Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 2, this.length);\n        return this[offset] << 8 | this[offset + 1];\n      };\n      Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;\n      };\n      Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n      };\n      Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {\n        offset = offset >>> 0;\n        validateNumber(offset, \"offset\");\n        const first = this[offset];\n        const last = this[offset + 7];\n        if (first === void 0 || last === void 0) {\n          boundsError(offset, this.length - 8);\n        }\n        const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;\n        const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;\n        return BigInt(lo) + (BigInt(hi) << BigInt(32));\n      });\n      Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {\n        offset = offset >>> 0;\n        validateNumber(offset, \"offset\");\n        const first = this[offset];\n        const last = this[offset + 7];\n        if (first === void 0 || last === void 0) {\n          boundsError(offset, this.length - 8);\n        }\n        const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];\n        const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;\n        return (BigInt(hi) << BigInt(32)) + BigInt(lo);\n      });\n      Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert)\n          checkOffset(offset, byteLength2, this.length);\n        let val = this[offset];\n        let mul = 1;\n        let i = 0;\n        while (++i < byteLength2 && (mul *= 256)) {\n          val += this[offset + i] * mul;\n        }\n        mul *= 128;\n        if (val >= mul)\n          val -= Math.pow(2, 8 * byteLength2);\n        return val;\n      };\n      Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert)\n          checkOffset(offset, byteLength2, this.length);\n        let i = byteLength2;\n        let mul = 1;\n        let val = this[offset + --i];\n        while (i > 0 && (mul *= 256)) {\n          val += this[offset + --i] * mul;\n        }\n        mul *= 128;\n        if (val >= mul)\n          val -= Math.pow(2, 8 * byteLength2);\n        return val;\n      };\n      Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 1, this.length);\n        if (!(this[offset] & 128))\n          return this[offset];\n        return (255 - this[offset] + 1) * -1;\n      };\n      Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 2, this.length);\n        const val = this[offset] | this[offset + 1] << 8;\n        return val & 32768 ? val | 4294901760 : val;\n      };\n      Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 2, this.length);\n        const val = this[offset + 1] | this[offset] << 8;\n        return val & 32768 ? val | 4294901760 : val;\n      };\n      Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n      };\n      Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n      };\n      Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {\n        offset = offset >>> 0;\n        validateNumber(offset, \"offset\");\n        const first = this[offset];\n        const last = this[offset + 7];\n        if (first === void 0 || last === void 0) {\n          boundsError(offset, this.length - 8);\n        }\n        const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);\n        return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);\n      });\n      Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {\n        offset = offset >>> 0;\n        validateNumber(offset, \"offset\");\n        const first = this[offset];\n        const last = this[offset + 7];\n        if (first === void 0 || last === void 0) {\n          boundsError(offset, this.length - 8);\n        }\n        const val = (first << 24) + // Overflow\n        this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];\n        return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);\n      });\n      Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return ieee754.read(this, offset, true, 23, 4);\n      };\n      Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return ieee754.read(this, offset, false, 23, 4);\n      };\n      Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 8, this.length);\n        return ieee754.read(this, offset, true, 52, 8);\n      };\n      Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 8, this.length);\n        return ieee754.read(this, offset, false, 52, 8);\n      };\n      function checkInt(buf, value, offset, ext, max, min) {\n        if (!Buffer2.isBuffer(buf))\n          throw new TypeError('\"buffer\" argument must be a Buffer instance');\n        if (value > max || value < min)\n          throw new RangeError('\"value\" argument is out of bounds');\n        if (offset + ext > buf.length)\n          throw new RangeError(\"Index out of range\");\n      }\n      Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert) {\n          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;\n          checkInt(this, value, offset, byteLength2, maxBytes, 0);\n        }\n        let mul = 1;\n        let i = 0;\n        this[offset] = value & 255;\n        while (++i < byteLength2 && (mul *= 256)) {\n          this[offset + i] = value / mul & 255;\n        }\n        return offset + byteLength2;\n      };\n      Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert) {\n          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;\n          checkInt(this, value, offset, byteLength2, maxBytes, 0);\n        }\n        let i = byteLength2 - 1;\n        let mul = 1;\n        this[offset + i] = value & 255;\n        while (--i >= 0 && (mul *= 256)) {\n          this[offset + i] = value / mul & 255;\n        }\n        return offset + byteLength2;\n      };\n      Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 1, 255, 0);\n        this[offset] = value & 255;\n        return offset + 1;\n      };\n      Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 2, 65535, 0);\n        this[offset] = value & 255;\n        this[offset + 1] = value >>> 8;\n        return offset + 2;\n      };\n      Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 2, 65535, 0);\n        this[offset] = value >>> 8;\n        this[offset + 1] = value & 255;\n        return offset + 2;\n      };\n      Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 4, 4294967295, 0);\n        this[offset + 3] = value >>> 24;\n        this[offset + 2] = value >>> 16;\n        this[offset + 1] = value >>> 8;\n        this[offset] = value & 255;\n        return offset + 4;\n      };\n      Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 4, 4294967295, 0);\n        this[offset] = value >>> 24;\n        this[offset + 1] = value >>> 16;\n        this[offset + 2] = value >>> 8;\n        this[offset + 3] = value & 255;\n        return offset + 4;\n      };\n      function wrtBigUInt64LE(buf, value, offset, min, max) {\n        checkIntBI(value, min, max, buf, offset, 7);\n        let lo = Number(value & BigInt(4294967295));\n        buf[offset++] = lo;\n        lo = lo >> 8;\n        buf[offset++] = lo;\n        lo = lo >> 8;\n        buf[offset++] = lo;\n        lo = lo >> 8;\n        buf[offset++] = lo;\n        let hi = Number(value >> BigInt(32) & BigInt(4294967295));\n        buf[offset++] = hi;\n        hi = hi >> 8;\n        buf[offset++] = hi;\n        hi = hi >> 8;\n        buf[offset++] = hi;\n        hi = hi >> 8;\n        buf[offset++] = hi;\n        return offset;\n      }\n      function wrtBigUInt64BE(buf, value, offset, min, max) {\n        checkIntBI(value, min, max, buf, offset, 7);\n        let lo = Number(value & BigInt(4294967295));\n        buf[offset + 7] = lo;\n        lo = lo >> 8;\n        buf[offset + 6] = lo;\n        lo = lo >> 8;\n        buf[offset + 5] = lo;\n        lo = lo >> 8;\n        buf[offset + 4] = lo;\n        let hi = Number(value >> BigInt(32) & BigInt(4294967295));\n        buf[offset + 3] = hi;\n        hi = hi >> 8;\n        buf[offset + 2] = hi;\n        hi = hi >> 8;\n        buf[offset + 1] = hi;\n        hi = hi >> 8;\n        buf[offset] = hi;\n        return offset + 8;\n      }\n      Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {\n        return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n      });\n      Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {\n        return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n      });\n      Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          const limit = Math.pow(2, 8 * byteLength2 - 1);\n          checkInt(this, value, offset, byteLength2, limit - 1, -limit);\n        }\n        let i = 0;\n        let mul = 1;\n        let sub = 0;\n        this[offset] = value & 255;\n        while (++i < byteLength2 && (mul *= 256)) {\n          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n            sub = 1;\n          }\n          this[offset + i] = (value / mul >> 0) - sub & 255;\n        }\n        return offset + byteLength2;\n      };\n      Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          const limit = Math.pow(2, 8 * byteLength2 - 1);\n          checkInt(this, value, offset, byteLength2, limit - 1, -limit);\n        }\n        let i = byteLength2 - 1;\n        let mul = 1;\n        let sub = 0;\n        this[offset + i] = value & 255;\n        while (--i >= 0 && (mul *= 256)) {\n          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n            sub = 1;\n          }\n          this[offset + i] = (value / mul >> 0) - sub & 255;\n        }\n        return offset + byteLength2;\n      };\n      Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 1, 127, -128);\n        if (value < 0)\n          value = 255 + value + 1;\n        this[offset] = value & 255;\n        return offset + 1;\n      };\n      Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 2, 32767, -32768);\n        this[offset] = value & 255;\n        this[offset + 1] = value >>> 8;\n        return offset + 2;\n      };\n      Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 2, 32767, -32768);\n        this[offset] = value >>> 8;\n        this[offset + 1] = value & 255;\n        return offset + 2;\n      };\n      Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 4, 2147483647, -2147483648);\n        this[offset] = value & 255;\n        this[offset + 1] = value >>> 8;\n        this[offset + 2] = value >>> 16;\n        this[offset + 3] = value >>> 24;\n        return offset + 4;\n      };\n      Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 4, 2147483647, -2147483648);\n        if (value < 0)\n          value = 4294967295 + value + 1;\n        this[offset] = value >>> 24;\n        this[offset + 1] = value >>> 16;\n        this[offset + 2] = value >>> 8;\n        this[offset + 3] = value & 255;\n        return offset + 4;\n      };\n      Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {\n        return wrtBigUInt64LE(this, value, offset, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n      });\n      Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {\n        return wrtBigUInt64BE(this, value, offset, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n      });\n      function checkIEEE754(buf, value, offset, ext, max, min) {\n        if (offset + ext > buf.length)\n          throw new RangeError(\"Index out of range\");\n        if (offset < 0)\n          throw new RangeError(\"Index out of range\");\n      }\n      function writeFloat(buf, value, offset, littleEndian, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);\n        }\n        ieee754.write(buf, value, offset, littleEndian, 23, 4);\n        return offset + 4;\n      }\n      Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n        return writeFloat(this, value, offset, true, noAssert);\n      };\n      Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n        return writeFloat(this, value, offset, false, noAssert);\n      };\n      function writeDouble(buf, value, offset, littleEndian, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);\n        }\n        ieee754.write(buf, value, offset, littleEndian, 52, 8);\n        return offset + 8;\n      }\n      Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n        return writeDouble(this, value, offset, true, noAssert);\n      };\n      Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n        return writeDouble(this, value, offset, false, noAssert);\n      };\n      Buffer2.prototype.copy = function copy(target, targetStart, start, end) {\n        if (!Buffer2.isBuffer(target))\n          throw new TypeError(\"argument should be a Buffer\");\n        if (!start)\n          start = 0;\n        if (!end && end !== 0)\n          end = this.length;\n        if (targetStart >= target.length)\n          targetStart = target.length;\n        if (!targetStart)\n          targetStart = 0;\n        if (end > 0 && end < start)\n          end = start;\n        if (end === start)\n          return 0;\n        if (target.length === 0 || this.length === 0)\n          return 0;\n        if (targetStart < 0) {\n          throw new RangeError(\"targetStart out of bounds\");\n        }\n        if (start < 0 || start >= this.length)\n          throw new RangeError(\"Index out of range\");\n        if (end < 0)\n          throw new RangeError(\"sourceEnd out of bounds\");\n        if (end > this.length)\n          end = this.length;\n        if (target.length - targetStart < end - start) {\n          end = target.length - targetStart + start;\n        }\n        const len = end - start;\n        if (this === target && typeof GlobalUint8Array.prototype.copyWithin === \"function\") {\n          this.copyWithin(targetStart, start, end);\n        } else {\n          GlobalUint8Array.prototype.set.call(\n            target,\n            this.subarray(start, end),\n            targetStart\n          );\n        }\n        return len;\n      };\n      Buffer2.prototype.fill = function fill(val, start, end, encoding) {\n        if (typeof val === \"string\") {\n          if (typeof start === \"string\") {\n            encoding = start;\n            start = 0;\n            end = this.length;\n          } else if (typeof end === \"string\") {\n            encoding = end;\n            end = this.length;\n          }\n          if (encoding !== void 0 && typeof encoding !== \"string\") {\n            throw new TypeError(\"encoding must be a string\");\n          }\n          if (typeof encoding === \"string\" && !Buffer2.isEncoding(encoding)) {\n            throw new TypeError(\"Unknown encoding: \" + encoding);\n          }\n          if (val.length === 1) {\n            const code = val.charCodeAt(0);\n            if (encoding === \"utf8\" && code < 128 || encoding === \"latin1\") {\n              val = code;\n            }\n          }\n        } else if (typeof val === \"number\") {\n          val = val & 255;\n        } else if (typeof val === \"boolean\") {\n          val = Number(val);\n        }\n        if (start < 0 || this.length < start || this.length < end) {\n          throw new RangeError(\"Out of range index\");\n        }\n        if (end <= start) {\n          return this;\n        }\n        start = start >>> 0;\n        end = end === void 0 ? this.length : end >>> 0;\n        if (!val)\n          val = 0;\n        let i;\n        if (typeof val === \"number\") {\n          for (i = start; i < end; ++i) {\n            this[i] = val;\n          }\n        } else {\n          const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);\n          const len = bytes.length;\n          if (len === 0) {\n            throw new TypeError('The value \"' + val + '\" is invalid for argument \"value\"');\n          }\n          for (i = 0; i < end - start; ++i) {\n            this[i + start] = bytes[i % len];\n          }\n        }\n        return this;\n      };\n      var errors = {};\n      function E(sym, getMessage, Base) {\n        errors[sym] = class NodeError extends Base {\n          constructor() {\n            super();\n            Object.defineProperty(this, \"message\", {\n              value: getMessage.apply(this, arguments),\n              writable: true,\n              configurable: true\n            });\n            this.name = `${this.name} [${sym}]`;\n            this.stack;\n            delete this.name;\n          }\n          get code() {\n            return sym;\n          }\n          set code(value) {\n            Object.defineProperty(this, \"code\", {\n              configurable: true,\n              enumerable: true,\n              value,\n              writable: true\n            });\n          }\n          toString() {\n            return `${this.name} [${sym}]: ${this.message}`;\n          }\n        };\n      }\n      E(\n        \"ERR_BUFFER_OUT_OF_BOUNDS\",\n        function(name) {\n          if (name) {\n            return `${name} is outside of buffer bounds`;\n          }\n          return \"Attempt to access memory outside buffer bounds\";\n        },\n        RangeError\n      );\n      E(\n        \"ERR_INVALID_ARG_TYPE\",\n        function(name, actual) {\n          return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`;\n        },\n        TypeError\n      );\n      E(\n        \"ERR_OUT_OF_RANGE\",\n        function(str, range, input) {\n          let msg = `The value of \"${str}\" is out of range.`;\n          let received = input;\n          if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n            received = addNumericalSeparator(String(input));\n          } else if (typeof input === \"bigint\") {\n            received = String(input);\n            if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n              received = addNumericalSeparator(received);\n            }\n            received += \"n\";\n          }\n          msg += ` It must be ${range}. Received ${received}`;\n          return msg;\n        },\n        RangeError\n      );\n      function addNumericalSeparator(val) {\n        let res = \"\";\n        let i = val.length;\n        const start = val[0] === \"-\" ? 1 : 0;\n        for (; i >= start + 4; i -= 3) {\n          res = `_${val.slice(i - 3, i)}${res}`;\n        }\n        return `${val.slice(0, i)}${res}`;\n      }\n      function checkBounds(buf, offset, byteLength2) {\n        validateNumber(offset, \"offset\");\n        if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {\n          boundsError(offset, buf.length - (byteLength2 + 1));\n        }\n      }\n      function checkIntBI(value, min, max, buf, offset, byteLength2) {\n        if (value > max || value < min) {\n          const n = typeof min === \"bigint\" ? \"n\" : \"\";\n          let range;\n          if (byteLength2 > 3) {\n            if (min === 0 || min === BigInt(0)) {\n              range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;\n            } else {\n              range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;\n            }\n          } else {\n            range = `>= ${min}${n} and <= ${max}${n}`;\n          }\n          throw new errors.ERR_OUT_OF_RANGE(\"value\", range, value);\n        }\n        checkBounds(buf, offset, byteLength2);\n      }\n      function validateNumber(value, name) {\n        if (typeof value !== \"number\") {\n          throw new errors.ERR_INVALID_ARG_TYPE(name, \"number\", value);\n        }\n      }\n      function boundsError(value, length, type) {\n        if (Math.floor(value) !== value) {\n          validateNumber(value, type);\n          throw new errors.ERR_OUT_OF_RANGE(type || \"offset\", \"an integer\", value);\n        }\n        if (length < 0) {\n          throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();\n        }\n        throw new errors.ERR_OUT_OF_RANGE(\n          type || \"offset\",\n          `>= ${type ? 1 : 0} and <= ${length}`,\n          value\n        );\n      }\n      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;\n      function base64clean(str) {\n        str = str.split(\"=\")[0];\n        str = str.trim().replace(INVALID_BASE64_RE, \"\");\n        if (str.length < 2)\n          return \"\";\n        while (str.length % 4 !== 0) {\n          str = str + \"=\";\n        }\n        return str;\n      }\n      function utf8ToBytes(string, units) {\n        units = units || Infinity;\n        let codePoint;\n        const length = string.length;\n        let leadSurrogate = null;\n        const bytes = [];\n        for (let i = 0; i < length; ++i) {\n          codePoint = string.charCodeAt(i);\n          if (codePoint > 55295 && codePoint < 57344) {\n            if (!leadSurrogate) {\n              if (codePoint > 56319) {\n                if ((units -= 3) > -1)\n                  bytes.push(239, 191, 189);\n                continue;\n              } else if (i + 1 === length) {\n                if ((units -= 3) > -1)\n                  bytes.push(239, 191, 189);\n                continue;\n              }\n              leadSurrogate = codePoint;\n              continue;\n            }\n            if (codePoint < 56320) {\n              if ((units -= 3) > -1)\n                bytes.push(239, 191, 189);\n              leadSurrogate = codePoint;\n              continue;\n            }\n            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;\n          } else if (leadSurrogate) {\n            if ((units -= 3) > -1)\n              bytes.push(239, 191, 189);\n          }\n          leadSurrogate = null;\n          if (codePoint < 128) {\n            if ((units -= 1) < 0)\n              break;\n            bytes.push(codePoint);\n          } else if (codePoint < 2048) {\n            if ((units -= 2) < 0)\n              break;\n            bytes.push(\n              codePoint >> 6 | 192,\n              codePoint & 63 | 128\n            );\n          } else if (codePoint < 65536) {\n            if ((units -= 3) < 0)\n              break;\n            bytes.push(\n              codePoint >> 12 | 224,\n              codePoint >> 6 & 63 | 128,\n              codePoint & 63 | 128\n            );\n          } else if (codePoint < 1114112) {\n            if ((units -= 4) < 0)\n              break;\n            bytes.push(\n              codePoint >> 18 | 240,\n              codePoint >> 12 & 63 | 128,\n              codePoint >> 6 & 63 | 128,\n              codePoint & 63 | 128\n            );\n          } else {\n            throw new Error(\"Invalid code point\");\n          }\n        }\n        return bytes;\n      }\n      function asciiToBytes(str) {\n        const byteArray = [];\n        for (let i = 0; i < str.length; ++i) {\n          byteArray.push(str.charCodeAt(i) & 255);\n        }\n        return byteArray;\n      }\n      function utf16leToBytes(str, units) {\n        let c, hi, lo;\n        const byteArray = [];\n        for (let i = 0; i < str.length; ++i) {\n          if ((units -= 2) < 0)\n            break;\n          c = str.charCodeAt(i);\n          hi = c >> 8;\n          lo = c % 256;\n          byteArray.push(lo);\n          byteArray.push(hi);\n        }\n        return byteArray;\n      }\n      function base64ToBytes(str) {\n        return base64.toByteArray(base64clean(str));\n      }\n      function blitBuffer(src, dst, offset, length) {\n        let i;\n        for (i = 0; i < length; ++i) {\n          if (i + offset >= dst.length || i >= src.length)\n            break;\n          dst[i + offset] = src[i];\n        }\n        return i;\n      }\n      function isInstance(obj, type) {\n        return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;\n      }\n      function numberIsNaN(obj) {\n        return obj !== obj;\n      }\n      var hexSliceLookupTable = function() {\n        const alphabet = \"0123456789abcdef\";\n        const table = new Array(256);\n        for (let i = 0; i < 16; ++i) {\n          const i16 = i * 16;\n          for (let j = 0; j < 16; ++j) {\n            table[i16 + j] = alphabet[i] + alphabet[j];\n          }\n        }\n        return table;\n      }();\n      function defineBigIntMethod(fn) {\n        return typeof BigInt === \"undefined\" ? BufferBigIntNotDefined : fn;\n      }\n      function BufferBigIntNotDefined() {\n        throw new Error(\"BigInt not supported\");\n      }\n    }\n  });\n\n  // node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js\n  var require_browser = __commonJS({\n    \"node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js\"(exports, module) {\n      init_dist();\n      var process = module.exports = {};\n      var cachedSetTimeout;\n      var cachedClearTimeout;\n      function defaultSetTimout() {\n        throw new Error(\"setTimeout has not been defined\");\n      }\n      function defaultClearTimeout() {\n        throw new Error(\"clearTimeout has not been defined\");\n      }\n      (function() {\n        try {\n          if (typeof setTimeout === \"function\") {\n            cachedSetTimeout = setTimeout;\n          } else {\n            cachedSetTimeout = defaultSetTimout;\n          }\n        } catch (e) {\n          cachedSetTimeout = defaultSetTimout;\n        }\n        try {\n          if (typeof clearTimeout === \"function\") {\n            cachedClearTimeout = clearTimeout;\n          } else {\n            cachedClearTimeout = defaultClearTimeout;\n          }\n        } catch (e) {\n          cachedClearTimeout = defaultClearTimeout;\n        }\n      })();\n      function runTimeout(fun) {\n        if (cachedSetTimeout === setTimeout) {\n          return setTimeout(fun, 0);\n        }\n        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n          cachedSetTimeout = setTimeout;\n          return setTimeout(fun, 0);\n        }\n        try {\n          return cachedSetTimeout(fun, 0);\n        } catch (e) {\n          try {\n            return cachedSetTimeout.call(null, fun, 0);\n          } catch (e2) {\n            return cachedSetTimeout.call(this, fun, 0);\n          }\n        }\n      }\n      function runClearTimeout(marker) {\n        if (cachedClearTimeout === clearTimeout) {\n          return clearTimeout(marker);\n        }\n        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n          cachedClearTimeout = clearTimeout;\n          return clearTimeout(marker);\n        }\n        try {\n          return cachedClearTimeout(marker);\n        } catch (e) {\n          try {\n            return cachedClearTimeout.call(null, marker);\n          } catch (e2) {\n            return cachedClearTimeout.call(this, marker);\n          }\n        }\n      }\n      var queue = [];\n      var draining = false;\n      var currentQueue;\n      var queueIndex = -1;\n      function cleanUpNextTick() {\n        if (!draining || !currentQueue) {\n          return;\n        }\n        draining = false;\n        if (currentQueue.length) {\n          queue = currentQueue.concat(queue);\n        } else {\n          queueIndex = -1;\n        }\n        if (queue.length) {\n          drainQueue();\n        }\n      }\n      function drainQueue() {\n        if (draining) {\n          return;\n        }\n        var timeout = runTimeout(cleanUpNextTick);\n        draining = true;\n        var len = queue.length;\n        while (len) {\n          currentQueue = queue;\n          queue = [];\n          while (++queueIndex < len) {\n            if (currentQueue) {\n              currentQueue[queueIndex].run();\n            }\n          }\n          queueIndex = -1;\n          len = queue.length;\n        }\n        currentQueue = null;\n        draining = false;\n        runClearTimeout(timeout);\n      }\n      process.nextTick = function(fun) {\n        var args = new Array(arguments.length - 1);\n        if (arguments.length > 1) {\n          for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n          }\n        }\n        queue.push(new Item(fun, args));\n        if (queue.length === 1 && !draining) {\n          runTimeout(drainQueue);\n        }\n      };\n      function Item(fun, array) {\n        this.fun = fun;\n        this.array = array;\n      }\n      Item.prototype.run = function() {\n        this.fun.apply(null, this.array);\n      };\n      process.title = \"browser\";\n      process.browser = true;\n      process.env = {};\n      process.argv = [];\n      process.version = \"\";\n      process.versions = {};\n      function noop() {\n      }\n      process.on = noop;\n      process.addListener = noop;\n      process.once = noop;\n      process.off = noop;\n      process.removeListener = noop;\n      process.removeAllListeners = noop;\n      process.emit = noop;\n      process.prependListener = noop;\n      process.prependOnceListener = noop;\n      process.listeners = function(name) {\n        return [];\n      };\n      process.binding = function(name) {\n        throw new Error(\"process.binding is not supported\");\n      };\n      process.cwd = function() {\n        return \"/\";\n      };\n      process.chdir = function(dir) {\n        throw new Error(\"process.chdir is not supported\");\n      };\n      process.umask = function() {\n        return 0;\n      };\n    }\n  });\n\n  // shims/dist/index.js\n  var import_buffer_polyfill, import_process, o;\n  var init_dist = __esm({\n    \"shims/dist/index.js\"() {\n      \"use strict\";\n      import_buffer_polyfill = __toESM(require_buffer(), 1);\n      import_process = __toESM(require_browser(), 1);\n      o = globalThis || void 0 || self;\n    }\n  });\n\n  // shims/banner/index.cjs\n  var require_banner = __commonJS({\n    \"shims/banner/index.cjs\"() {\n      init_dist();\n      globalThis.Buffer = globalThis.Buffer || import_buffer_polyfill.Buffer;\n      globalThis.global = globalThis.global || o;\n      globalThis.process = globalThis.process || import_process.default;\n    }\n  });\n  require_banner();\n})();\n/*! Bundled license information:\n\nieee754/index.js:\n  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)\n\nbuffer/index.js:\n  (*!\n   * The buffer module from node.js, for the browser.\n   *\n   * @author   Feross Aboukhadijeh <https://feross.org>\n   * @license  MIT\n   *)\n*/\n\nimport {\n  require_react\n} from \"/node_modules/.vite/deps/chunk-DMLNAHRU.js?v=988c63e5\";\nimport {\n  __toESM,\n  require_dist\n} from \"/node_modules/.vite/deps/chunk-4KAQPM64.js?v=988c63e5\";\n\n// node_modules/@auth0/auth0-react/dist/auth0-react.esm.js\nvar import_dist = __toESM(require_dist());\nvar import_react = __toESM(require_react());\nvar extendStatics = function(d2, b2) {\n  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n    d3.__proto__ = b3;\n  } || function(d3, b3) {\n    for (var p2 in b3)\n      if (Object.prototype.hasOwnProperty.call(b3, p2))\n        d3[p2] = b3[p2];\n  };\n  return extendStatics(d2, b2);\n};\nfunction __extends(d2, b2) {\n  if (typeof b2 !== \"function\" && b2 !== null)\n    throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n  extendStatics(d2, b2);\n  function __() {\n    this.constructor = d2;\n  }\n  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n}\nvar __assign = function() {\n  __assign = Object.assign || function __assign2(t2) {\n    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {\n      s2 = arguments[i2];\n      for (var p2 in s2)\n        if (Object.prototype.hasOwnProperty.call(s2, p2))\n          t2[p2] = s2[p2];\n    }\n    return t2;\n  };\n  return __assign.apply(this, arguments);\n};\nfunction __rest(s2, e2) {\n  var t2 = {};\n  for (var p2 in s2)\n    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)\n      t2[p2] = s2[p2];\n  if (s2 != null && typeof Object.getOwnPropertySymbols === \"function\")\n    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {\n      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))\n        t2[p2[i2]] = s2[p2[i2]];\n    }\n  return t2;\n}\nfunction __awaiter(thisArg, _arguments, P2, generator) {\n  function adopt(value) {\n    return value instanceof P2 ? value : new P2(function(resolve) {\n      resolve(value);\n    });\n  }\n  return new (P2 || (P2 = Promise))(function(resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e2) {\n        reject(e2);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e2) {\n        reject(e2);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\nfunction __generator(thisArg, body) {\n  var _2 = { label: 0, sent: function() {\n    if (t2[0] & 1)\n      throw t2[1];\n    return t2[1];\n  }, trys: [], ops: [] }, f2, y2, t2, g2;\n  return g2 = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g2[Symbol.iterator] = function() {\n    return this;\n  }), g2;\n  function verb(n2) {\n    return function(v2) {\n      return step([n2, v2]);\n    };\n  }\n  function step(op) {\n    if (f2)\n      throw new TypeError(\"Generator is already executing.\");\n    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)\n      try {\n        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2[\"return\"] : op[0] ? y2[\"throw\"] || ((t2 = y2[\"return\"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)\n          return t2;\n        if (y2 = 0, t2)\n          op = [op[0] & 2, t2.value];\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t2 = op;\n            break;\n          case 4:\n            _2.label++;\n            return { value: op[1], done: false };\n          case 5:\n            _2.label++;\n            y2 = op[1];\n            op = [0];\n            continue;\n          case 7:\n            op = _2.ops.pop();\n            _2.trys.pop();\n            continue;\n          default:\n            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _2 = 0;\n              continue;\n            }\n            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {\n              _2.label = op[1];\n              break;\n            }\n            if (op[0] === 6 && _2.label < t2[1]) {\n              _2.label = t2[1];\n              t2 = op;\n              break;\n            }\n            if (t2 && _2.label < t2[2]) {\n              _2.label = t2[2];\n              _2.ops.push(op);\n              break;\n            }\n            if (t2[2])\n              _2.ops.pop();\n            _2.trys.pop();\n            continue;\n        }\n        op = body.call(thisArg, _2);\n      } catch (e2) {\n        op = [6, e2];\n        y2 = 0;\n      } finally {\n        f2 = t2 = 0;\n      }\n    if (op[0] & 5)\n      throw op[1];\n    return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\nfunction e(e2, t2) {\n  var i2 = {};\n  for (var o2 in e2)\n    Object.prototype.hasOwnProperty.call(e2, o2) && t2.indexOf(o2) < 0 && (i2[o2] = e2[o2]);\n  if (null != e2 && \"function\" == typeof Object.getOwnPropertySymbols) {\n    var n2 = 0;\n    for (o2 = Object.getOwnPropertySymbols(e2); n2 < o2.length; n2++)\n      t2.indexOf(o2[n2]) < 0 && Object.prototype.propertyIsEnumerable.call(e2, o2[n2]) && (i2[o2[n2]] = e2[o2[n2]]);\n  }\n  return i2;\n}\nvar t = \"undefined\" != typeof globalThis ? globalThis : \"undefined\" != typeof window ? window : \"undefined\" != typeof global ? global : \"undefined\" != typeof self ? self : {};\nfunction i(e2) {\n  return e2 && e2.__esModule && Object.prototype.hasOwnProperty.call(e2, \"default\") ? e2.default : e2;\n}\nfunction o(e2, t2) {\n  return e2(t2 = { exports: {} }, t2.exports), t2.exports;\n}\nvar n = o(function(e2, t2) {\n  Object.defineProperty(t2, \"__esModule\", { value: true });\n  var i2 = function() {\n    function e3() {\n      var e4 = this;\n      this.locked = /* @__PURE__ */ new Map(), this.addToLocked = function(t3, i3) {\n        var o2 = e4.locked.get(t3);\n        void 0 === o2 ? void 0 === i3 ? e4.locked.set(t3, []) : e4.locked.set(t3, [i3]) : void 0 !== i3 && (o2.unshift(i3), e4.locked.set(t3, o2));\n      }, this.isLocked = function(t3) {\n        return e4.locked.has(t3);\n      }, this.lock = function(t3) {\n        return new Promise(function(i3, o2) {\n          e4.isLocked(t3) ? e4.addToLocked(t3, i3) : (e4.addToLocked(t3), i3());\n        });\n      }, this.unlock = function(t3) {\n        var i3 = e4.locked.get(t3);\n        if (void 0 !== i3 && 0 !== i3.length) {\n          var o2 = i3.pop();\n          e4.locked.set(t3, i3), void 0 !== o2 && setTimeout(o2, 0);\n        } else\n          e4.locked.delete(t3);\n      };\n    }\n    return e3.getInstance = function() {\n      return void 0 === e3.instance && (e3.instance = new e3()), e3.instance;\n    }, e3;\n  }();\n  t2.default = function() {\n    return i2.getInstance();\n  };\n});\ni(n);\nvar a = i(o(function(e2, i2) {\n  var o2 = t && t.__awaiter || function(e3, t2, i3, o3) {\n    return new (i3 || (i3 = Promise))(function(n2, a3) {\n      function r3(e4) {\n        try {\n          c3(o3.next(e4));\n        } catch (e5) {\n          a3(e5);\n        }\n      }\n      function s3(e4) {\n        try {\n          c3(o3.throw(e4));\n        } catch (e5) {\n          a3(e5);\n        }\n      }\n      function c3(e4) {\n        e4.done ? n2(e4.value) : new i3(function(t3) {\n          t3(e4.value);\n        }).then(r3, s3);\n      }\n      c3((o3 = o3.apply(e3, t2 || [])).next());\n    });\n  }, a2 = t && t.__generator || function(e3, t2) {\n    var i3, o3, n2, a3, r3 = { label: 0, sent: function() {\n      if (1 & n2[0])\n        throw n2[1];\n      return n2[1];\n    }, trys: [], ops: [] };\n    return a3 = { next: s3(0), throw: s3(1), return: s3(2) }, \"function\" == typeof Symbol && (a3[Symbol.iterator] = function() {\n      return this;\n    }), a3;\n    function s3(a4) {\n      return function(s4) {\n        return function(a5) {\n          if (i3)\n            throw new TypeError(\"Generator is already executing.\");\n          for (; r3; )\n            try {\n              if (i3 = 1, o3 && (n2 = 2 & a5[0] ? o3.return : a5[0] ? o3.throw || ((n2 = o3.return) && n2.call(o3), 0) : o3.next) && !(n2 = n2.call(o3, a5[1])).done)\n                return n2;\n              switch (o3 = 0, n2 && (a5 = [2 & a5[0], n2.value]), a5[0]) {\n                case 0:\n                case 1:\n                  n2 = a5;\n                  break;\n                case 4:\n                  return r3.label++, { value: a5[1], done: false };\n                case 5:\n                  r3.label++, o3 = a5[1], a5 = [0];\n                  continue;\n                case 7:\n                  a5 = r3.ops.pop(), r3.trys.pop();\n                  continue;\n                default:\n                  if (!(n2 = r3.trys, (n2 = n2.length > 0 && n2[n2.length - 1]) || 6 !== a5[0] && 2 !== a5[0])) {\n                    r3 = 0;\n                    continue;\n                  }\n                  if (3 === a5[0] && (!n2 || a5[1] > n2[0] && a5[1] < n2[3])) {\n                    r3.label = a5[1];\n                    break;\n                  }\n                  if (6 === a5[0] && r3.label < n2[1]) {\n                    r3.label = n2[1], n2 = a5;\n                    break;\n                  }\n                  if (n2 && r3.label < n2[2]) {\n                    r3.label = n2[2], r3.ops.push(a5);\n                    break;\n                  }\n                  n2[2] && r3.ops.pop(), r3.trys.pop();\n                  continue;\n              }\n              a5 = t2.call(e3, r3);\n            } catch (e4) {\n              a5 = [6, e4], o3 = 0;\n            } finally {\n              i3 = n2 = 0;\n            }\n          if (5 & a5[0])\n            throw a5[1];\n          return { value: a5[0] ? a5[1] : void 0, done: true };\n        }([a4, s4]);\n      };\n    }\n  }, r2 = t;\n  Object.defineProperty(i2, \"__esModule\", { value: true });\n  var s2 = \"browser-tabs-lock-key\", c2 = { key: function(e3) {\n    return o2(r2, void 0, void 0, function() {\n      return a2(this, function(e4) {\n        throw new Error(\"Unsupported\");\n      });\n    });\n  }, getItem: function(e3) {\n    return o2(r2, void 0, void 0, function() {\n      return a2(this, function(e4) {\n        throw new Error(\"Unsupported\");\n      });\n    });\n  }, clear: function() {\n    return o2(r2, void 0, void 0, function() {\n      return a2(this, function(e3) {\n        return [2, window.localStorage.clear()];\n      });\n    });\n  }, removeItem: function(e3) {\n    return o2(r2, void 0, void 0, function() {\n      return a2(this, function(e4) {\n        throw new Error(\"Unsupported\");\n      });\n    });\n  }, setItem: function(e3, t2) {\n    return o2(r2, void 0, void 0, function() {\n      return a2(this, function(e4) {\n        throw new Error(\"Unsupported\");\n      });\n    });\n  }, keySync: function(e3) {\n    return window.localStorage.key(e3);\n  }, getItemSync: function(e3) {\n    return window.localStorage.getItem(e3);\n  }, clearSync: function() {\n    return window.localStorage.clear();\n  }, removeItemSync: function(e3) {\n    return window.localStorage.removeItem(e3);\n  }, setItemSync: function(e3, t2) {\n    return window.localStorage.setItem(e3, t2);\n  } };\n  function d2(e3) {\n    return new Promise(function(t2) {\n      return setTimeout(t2, e3);\n    });\n  }\n  function u2(e3) {\n    for (var t2 = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz\", i3 = \"\", o3 = 0; o3 < e3; o3++) {\n      i3 += t2[Math.floor(Math.random() * t2.length)];\n    }\n    return i3;\n  }\n  var l2 = function() {\n    function e3(t2) {\n      this.acquiredIatSet = /* @__PURE__ */ new Set(), this.storageHandler = void 0, this.id = Date.now().toString() + u2(15), this.acquireLock = this.acquireLock.bind(this), this.releaseLock = this.releaseLock.bind(this), this.releaseLock__private__ = this.releaseLock__private__.bind(this), this.waitForSomethingToChange = this.waitForSomethingToChange.bind(this), this.refreshLockWhileAcquired = this.refreshLockWhileAcquired.bind(this), this.storageHandler = t2, void 0 === e3.waiters && (e3.waiters = []);\n    }\n    return e3.prototype.acquireLock = function(t2, i3) {\n      return void 0 === i3 && (i3 = 5e3), o2(this, void 0, void 0, function() {\n        var o3, n2, r3, l3, h2, p2, m2;\n        return a2(this, function(a3) {\n          switch (a3.label) {\n            case 0:\n              o3 = Date.now() + u2(4), n2 = Date.now() + i3, r3 = s2 + \"-\" + t2, l3 = void 0 === this.storageHandler ? c2 : this.storageHandler, a3.label = 1;\n            case 1:\n              return Date.now() < n2 ? [4, d2(30)] : [3, 8];\n            case 2:\n              return a3.sent(), null !== l3.getItemSync(r3) ? [3, 5] : (h2 = this.id + \"-\" + t2 + \"-\" + o3, [4, d2(Math.floor(25 * Math.random()))]);\n            case 3:\n              return a3.sent(), l3.setItemSync(r3, JSON.stringify({ id: this.id, iat: o3, timeoutKey: h2, timeAcquired: Date.now(), timeRefreshed: Date.now() })), [4, d2(30)];\n            case 4:\n              return a3.sent(), null !== (p2 = l3.getItemSync(r3)) && (m2 = JSON.parse(p2)).id === this.id && m2.iat === o3 ? (this.acquiredIatSet.add(o3), this.refreshLockWhileAcquired(r3, o3), [2, true]) : [3, 7];\n            case 5:\n              return e3.lockCorrector(void 0 === this.storageHandler ? c2 : this.storageHandler), [4, this.waitForSomethingToChange(n2)];\n            case 6:\n              a3.sent(), a3.label = 7;\n            case 7:\n              return o3 = Date.now() + u2(4), [3, 1];\n            case 8:\n              return [2, false];\n          }\n        });\n      });\n    }, e3.prototype.refreshLockWhileAcquired = function(e4, t2) {\n      return o2(this, void 0, void 0, function() {\n        var i3 = this;\n        return a2(this, function(r3) {\n          return setTimeout(function() {\n            return o2(i3, void 0, void 0, function() {\n              var i4, o3, r4;\n              return a2(this, function(a3) {\n                switch (a3.label) {\n                  case 0:\n                    return [4, n.default().lock(t2)];\n                  case 1:\n                    return a3.sent(), this.acquiredIatSet.has(t2) ? (i4 = void 0 === this.storageHandler ? c2 : this.storageHandler, null === (o3 = i4.getItemSync(e4)) ? (n.default().unlock(t2), [2]) : ((r4 = JSON.parse(o3)).timeRefreshed = Date.now(), i4.setItemSync(e4, JSON.stringify(r4)), n.default().unlock(t2), this.refreshLockWhileAcquired(e4, t2), [2])) : (n.default().unlock(t2), [2]);\n                }\n              });\n            });\n          }, 1e3), [2];\n        });\n      });\n    }, e3.prototype.waitForSomethingToChange = function(t2) {\n      return o2(this, void 0, void 0, function() {\n        return a2(this, function(i3) {\n          switch (i3.label) {\n            case 0:\n              return [4, new Promise(function(i4) {\n                var o3 = false, n2 = Date.now(), a3 = false;\n                function r3() {\n                  if (a3 || (window.removeEventListener(\"storage\", r3), e3.removeFromWaiting(r3), clearTimeout(s3), a3 = true), !o3) {\n                    o3 = true;\n                    var t3 = 50 - (Date.now() - n2);\n                    t3 > 0 ? setTimeout(i4, t3) : i4(null);\n                  }\n                }\n                window.addEventListener(\"storage\", r3), e3.addToWaiting(r3);\n                var s3 = setTimeout(r3, Math.max(0, t2 - Date.now()));\n              })];\n            case 1:\n              return i3.sent(), [2];\n          }\n        });\n      });\n    }, e3.addToWaiting = function(t2) {\n      this.removeFromWaiting(t2), void 0 !== e3.waiters && e3.waiters.push(t2);\n    }, e3.removeFromWaiting = function(t2) {\n      void 0 !== e3.waiters && (e3.waiters = e3.waiters.filter(function(e4) {\n        return e4 !== t2;\n      }));\n    }, e3.notifyWaiters = function() {\n      void 0 !== e3.waiters && e3.waiters.slice().forEach(function(e4) {\n        return e4();\n      });\n    }, e3.prototype.releaseLock = function(e4) {\n      return o2(this, void 0, void 0, function() {\n        return a2(this, function(t2) {\n          switch (t2.label) {\n            case 0:\n              return [4, this.releaseLock__private__(e4)];\n            case 1:\n              return [2, t2.sent()];\n          }\n        });\n      });\n    }, e3.prototype.releaseLock__private__ = function(t2) {\n      return o2(this, void 0, void 0, function() {\n        var i3, o3, r3, d3;\n        return a2(this, function(a3) {\n          switch (a3.label) {\n            case 0:\n              return i3 = void 0 === this.storageHandler ? c2 : this.storageHandler, o3 = s2 + \"-\" + t2, null === (r3 = i3.getItemSync(o3)) ? [2] : (d3 = JSON.parse(r3)).id !== this.id ? [3, 2] : [4, n.default().lock(d3.iat)];\n            case 1:\n              a3.sent(), this.acquiredIatSet.delete(d3.iat), i3.removeItemSync(o3), n.default().unlock(d3.iat), e3.notifyWaiters(), a3.label = 2;\n            case 2:\n              return [2];\n          }\n        });\n      });\n    }, e3.lockCorrector = function(t2) {\n      for (var i3 = Date.now() - 5e3, o3 = t2, n2 = [], a3 = 0; ; ) {\n        var r3 = o3.keySync(a3);\n        if (null === r3)\n          break;\n        n2.push(r3), a3++;\n      }\n      for (var c3 = false, d3 = 0; d3 < n2.length; d3++) {\n        var u3 = n2[d3];\n        if (u3.includes(s2)) {\n          var l3 = o3.getItemSync(u3);\n          if (null !== l3) {\n            var h2 = JSON.parse(l3);\n            (void 0 === h2.timeRefreshed && h2.timeAcquired < i3 || void 0 !== h2.timeRefreshed && h2.timeRefreshed < i3) && (o3.removeItemSync(u3), c3 = true);\n          }\n        }\n      }\n      c3 && e3.notifyWaiters();\n    }, e3.waiters = void 0, e3;\n  }();\n  i2.default = l2;\n}));\nvar r = { timeoutInSeconds: 60 };\nvar s = { name: \"auth0-spa-js\", version: \"2.1.3\" };\nvar c = () => Date.now();\nvar d = class _d extends Error {\n  constructor(e2, t2) {\n    super(t2), this.error = e2, this.error_description = t2, Object.setPrototypeOf(this, _d.prototype);\n  }\n  static fromPayload({ error: e2, error_description: t2 }) {\n    return new _d(e2, t2);\n  }\n};\nvar u = class _u extends d {\n  constructor(e2, t2, i2, o2 = null) {\n    super(e2, t2), this.state = i2, this.appState = o2, Object.setPrototypeOf(this, _u.prototype);\n  }\n};\nvar l = class _l extends d {\n  constructor() {\n    super(\"timeout\", \"Timeout\"), Object.setPrototypeOf(this, _l.prototype);\n  }\n};\nvar h = class _h extends l {\n  constructor(e2) {\n    super(), this.popup = e2, Object.setPrototypeOf(this, _h.prototype);\n  }\n};\nvar p = class _p extends d {\n  constructor(e2) {\n    super(\"cancelled\", \"Popup closed\"), this.popup = e2, Object.setPrototypeOf(this, _p.prototype);\n  }\n};\nvar m = class _m extends d {\n  constructor(e2, t2, i2) {\n    super(e2, t2), this.mfa_token = i2, Object.setPrototypeOf(this, _m.prototype);\n  }\n};\nvar f = class _f extends d {\n  constructor(e2, t2) {\n    super(\"missing_refresh_token\", `Missing Refresh Token (audience: '${g(e2, [\"default\"])}', scope: '${g(t2)}')`), this.audience = e2, this.scope = t2, Object.setPrototypeOf(this, _f.prototype);\n  }\n};\nfunction g(e2, t2 = []) {\n  return e2 && !t2.includes(e2) ? e2 : \"\";\n}\nvar w = () => window.crypto;\nvar y = () => {\n  const e2 = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_~.\";\n  let t2 = \"\";\n  return Array.from(w().getRandomValues(new Uint8Array(43))).forEach((i2) => t2 += e2[i2 % e2.length]), t2;\n};\nvar k = (e2) => btoa(e2);\nvar v = (t2) => {\n  var { clientId: i2 } = t2, o2 = e(t2, [\"clientId\"]);\n  return new URLSearchParams(((e2) => Object.keys(e2).filter((t3) => void 0 !== e2[t3]).reduce((t3, i3) => Object.assign(Object.assign({}, t3), { [i3]: e2[i3] }), {}))(Object.assign({ client_id: i2 }, o2))).toString();\n};\nvar b = (e2) => ((e3) => decodeURIComponent(atob(e3).split(\"\").map((e4) => \"%\" + (\"00\" + e4.charCodeAt(0).toString(16)).slice(-2)).join(\"\")))(e2.replace(/_/g, \"/\").replace(/-/g, \"+\"));\nvar _ = async (e2, t2) => {\n  const i2 = await fetch(e2, t2);\n  return { ok: i2.ok, json: await i2.json() };\n};\nvar I = async (e2, t2, i2) => {\n  const o2 = new AbortController();\n  let n2;\n  return t2.signal = o2.signal, Promise.race([_(e2, t2), new Promise((e3, t3) => {\n    n2 = setTimeout(() => {\n      o2.abort(), t3(new Error(\"Timeout when executing 'fetch'\"));\n    }, i2);\n  })]).finally(() => {\n    clearTimeout(n2);\n  });\n};\nvar S = async (e2, t2, i2, o2, n2, a2, r2) => {\n  return s2 = { auth: { audience: t2, scope: i2 }, timeout: n2, fetchUrl: e2, fetchOptions: o2, useFormData: r2 }, c2 = a2, new Promise(function(e3, t3) {\n    const i3 = new MessageChannel();\n    i3.port1.onmessage = function(o3) {\n      o3.data.error ? t3(new Error(o3.data.error)) : e3(o3.data), i3.port1.close();\n    }, c2.postMessage(s2, [i3.port2]);\n  });\n  var s2, c2;\n};\nvar O = async (e2, t2, i2, o2, n2, a2, r2 = 1e4) => n2 ? S(e2, t2, i2, o2, r2, n2, a2) : I(e2, o2, r2);\nasync function T(t2, i2) {\n  var { baseUrl: o2, timeout: n2, audience: a2, scope: r2, auth0Client: c2, useFormData: u2 } = t2, l2 = e(t2, [\"baseUrl\", \"timeout\", \"audience\", \"scope\", \"auth0Client\", \"useFormData\"]);\n  const h2 = u2 ? v(l2) : JSON.stringify(l2);\n  return await async function(t3, i3, o3, n3, a3, r3, s2) {\n    let c3, u3 = null;\n    for (let e2 = 0; e2 < 3; e2++)\n      try {\n        c3 = await O(t3, o3, n3, a3, r3, s2, i3), u3 = null;\n        break;\n      } catch (e3) {\n        u3 = e3;\n      }\n    if (u3)\n      throw u3;\n    const l3 = c3.json, { error: h3, error_description: p2 } = l3, g2 = e(l3, [\"error\", \"error_description\"]), { ok: w2 } = c3;\n    if (!w2) {\n      const e2 = p2 || `HTTP error. Unable to fetch ${t3}`;\n      if (\"mfa_required\" === h3)\n        throw new m(h3, e2, g2.mfa_token);\n      if (\"missing_refresh_token\" === h3)\n        throw new f(o3, n3);\n      throw new d(h3 || \"request_error\", e2);\n    }\n    return g2;\n  }(`${o2}/oauth/token`, n2, a2 || \"default\", r2, { method: \"POST\", body: h2, headers: { \"Content-Type\": u2 ? \"application/x-www-form-urlencoded\" : \"application/json\", \"Auth0-Client\": btoa(JSON.stringify(c2 || s)) } }, i2, u2);\n}\nvar j = (...e2) => {\n  return (t2 = e2.filter(Boolean).join(\" \").trim().split(/\\s+/), Array.from(new Set(t2))).join(\" \");\n  var t2;\n};\nvar C = class _C {\n  constructor(e2, t2 = \"@@auth0spajs@@\", i2) {\n    this.prefix = t2, this.suffix = i2, this.clientId = e2.clientId, this.scope = e2.scope, this.audience = e2.audience;\n  }\n  toKey() {\n    return [this.prefix, this.clientId, this.audience, this.scope, this.suffix].filter(Boolean).join(\"::\");\n  }\n  static fromKey(e2) {\n    const [t2, i2, o2, n2] = e2.split(\"::\");\n    return new _C({ clientId: i2, scope: n2, audience: o2 }, t2);\n  }\n  static fromCacheEntry(e2) {\n    const { scope: t2, audience: i2, client_id: o2 } = e2;\n    return new _C({ scope: t2, audience: i2, clientId: o2 });\n  }\n};\nvar z = class {\n  set(e2, t2) {\n    localStorage.setItem(e2, JSON.stringify(t2));\n  }\n  get(e2) {\n    const t2 = window.localStorage.getItem(e2);\n    if (t2)\n      try {\n        return JSON.parse(t2);\n      } catch (e3) {\n        return;\n      }\n  }\n  remove(e2) {\n    localStorage.removeItem(e2);\n  }\n  allKeys() {\n    return Object.keys(window.localStorage).filter((e2) => e2.startsWith(\"@@auth0spajs@@\"));\n  }\n};\nvar P = class {\n  constructor() {\n    this.enclosedCache = /* @__PURE__ */ function() {\n      let e2 = {};\n      return { set(t2, i2) {\n        e2[t2] = i2;\n      }, get(t2) {\n        const i2 = e2[t2];\n        if (i2)\n          return i2;\n      }, remove(t2) {\n        delete e2[t2];\n      }, allKeys: () => Object.keys(e2) };\n    }();\n  }\n};\nvar x = class {\n  constructor(e2, t2, i2) {\n    this.cache = e2, this.keyManifest = t2, this.nowProvider = i2 || c;\n  }\n  async setIdToken(e2, t2, i2) {\n    var o2;\n    const n2 = this.getIdTokenCacheKey(e2);\n    await this.cache.set(n2, { id_token: t2, decodedToken: i2 }), await (null === (o2 = this.keyManifest) || void 0 === o2 ? void 0 : o2.add(n2));\n  }\n  async getIdToken(e2) {\n    const t2 = await this.cache.get(this.getIdTokenCacheKey(e2.clientId));\n    if (!t2 && e2.scope && e2.audience) {\n      const t3 = await this.get(e2);\n      if (!t3)\n        return;\n      if (!t3.id_token || !t3.decodedToken)\n        return;\n      return { id_token: t3.id_token, decodedToken: t3.decodedToken };\n    }\n    if (t2)\n      return { id_token: t2.id_token, decodedToken: t2.decodedToken };\n  }\n  async get(e2, t2 = 0) {\n    var i2;\n    let o2 = await this.cache.get(e2.toKey());\n    if (!o2) {\n      const t3 = await this.getCacheKeys();\n      if (!t3)\n        return;\n      const i3 = this.matchExistingCacheKey(e2, t3);\n      i3 && (o2 = await this.cache.get(i3));\n    }\n    if (!o2)\n      return;\n    const n2 = await this.nowProvider(), a2 = Math.floor(n2 / 1e3);\n    return o2.expiresAt - t2 < a2 ? o2.body.refresh_token ? (o2.body = { refresh_token: o2.body.refresh_token }, await this.cache.set(e2.toKey(), o2), o2.body) : (await this.cache.remove(e2.toKey()), void await (null === (i2 = this.keyManifest) || void 0 === i2 ? void 0 : i2.remove(e2.toKey()))) : o2.body;\n  }\n  async set(e2) {\n    var t2;\n    const i2 = new C({ clientId: e2.client_id, scope: e2.scope, audience: e2.audience }), o2 = await this.wrapCacheEntry(e2);\n    await this.cache.set(i2.toKey(), o2), await (null === (t2 = this.keyManifest) || void 0 === t2 ? void 0 : t2.add(i2.toKey()));\n  }\n  async clear(e2) {\n    var t2;\n    const i2 = await this.getCacheKeys();\n    i2 && (await i2.filter((t3) => !e2 || t3.includes(e2)).reduce(async (e3, t3) => {\n      await e3, await this.cache.remove(t3);\n    }, Promise.resolve()), await (null === (t2 = this.keyManifest) || void 0 === t2 ? void 0 : t2.clear()));\n  }\n  async wrapCacheEntry(e2) {\n    const t2 = await this.nowProvider();\n    return { body: e2, expiresAt: Math.floor(t2 / 1e3) + e2.expires_in };\n  }\n  async getCacheKeys() {\n    var e2;\n    return this.keyManifest ? null === (e2 = await this.keyManifest.get()) || void 0 === e2 ? void 0 : e2.keys : this.cache.allKeys ? this.cache.allKeys() : void 0;\n  }\n  getIdTokenCacheKey(e2) {\n    return new C({ clientId: e2 }, \"@@auth0spajs@@\", \"@@user@@\").toKey();\n  }\n  matchExistingCacheKey(e2, t2) {\n    return t2.filter((t3) => {\n      var i2;\n      const o2 = C.fromKey(t3), n2 = new Set(o2.scope && o2.scope.split(\" \")), a2 = (null === (i2 = e2.scope) || void 0 === i2 ? void 0 : i2.split(\" \")) || [], r2 = o2.scope && a2.reduce((e3, t4) => e3 && n2.has(t4), true);\n      return \"@@auth0spajs@@\" === o2.prefix && o2.clientId === e2.clientId && o2.audience === e2.audience && r2;\n    })[0];\n  }\n};\nvar Z = class {\n  constructor(e2, t2, i2) {\n    this.storage = e2, this.clientId = t2, this.cookieDomain = i2, this.storageKey = `a0.spajs.txs.${this.clientId}`;\n  }\n  create(e2) {\n    this.storage.save(this.storageKey, e2, { daysUntilExpire: 1, cookieDomain: this.cookieDomain });\n  }\n  get() {\n    return this.storage.get(this.storageKey);\n  }\n  remove() {\n    this.storage.remove(this.storageKey, { cookieDomain: this.cookieDomain });\n  }\n};\nvar K = (e2) => \"number\" == typeof e2;\nvar W = [\"iss\", \"aud\", \"exp\", \"nbf\", \"iat\", \"jti\", \"azp\", \"nonce\", \"auth_time\", \"at_hash\", \"c_hash\", \"acr\", \"amr\", \"sub_jwk\", \"cnf\", \"sip_from_tag\", \"sip_date\", \"sip_callid\", \"sip_cseq_num\", \"sip_via_branch\", \"orig\", \"dest\", \"mky\", \"events\", \"toe\", \"txn\", \"rph\", \"sid\", \"vot\", \"vtm\"];\nvar E = (e2) => {\n  if (!e2.id_token)\n    throw new Error(\"ID token is required but missing\");\n  const t2 = ((e3) => {\n    const t3 = e3.split(\".\"), [i3, o3, n3] = t3;\n    if (3 !== t3.length || !i3 || !o3 || !n3)\n      throw new Error(\"ID token could not be decoded\");\n    const a2 = JSON.parse(b(o3)), r2 = { __raw: e3 }, s2 = {};\n    return Object.keys(a2).forEach((e4) => {\n      r2[e4] = a2[e4], W.includes(e4) || (s2[e4] = a2[e4]);\n    }), { encoded: { header: i3, payload: o3, signature: n3 }, header: JSON.parse(b(i3)), claims: r2, user: s2 };\n  })(e2.id_token);\n  if (!t2.claims.iss)\n    throw new Error(\"Issuer (iss) claim must be a string present in the ID token\");\n  if (t2.claims.iss !== e2.iss)\n    throw new Error(`Issuer (iss) claim mismatch in the ID token; expected \"${e2.iss}\", found \"${t2.claims.iss}\"`);\n  if (!t2.user.sub)\n    throw new Error(\"Subject (sub) claim must be a string present in the ID token\");\n  if (\"RS256\" !== t2.header.alg)\n    throw new Error(`Signature algorithm of \"${t2.header.alg}\" is not supported. Expected the ID token to be signed with \"RS256\".`);\n  if (!t2.claims.aud || \"string\" != typeof t2.claims.aud && !Array.isArray(t2.claims.aud))\n    throw new Error(\"Audience (aud) claim must be a string or array of strings present in the ID token\");\n  if (Array.isArray(t2.claims.aud)) {\n    if (!t2.claims.aud.includes(e2.aud))\n      throw new Error(`Audience (aud) claim mismatch in the ID token; expected \"${e2.aud}\" but was not one of \"${t2.claims.aud.join(\", \")}\"`);\n    if (t2.claims.aud.length > 1) {\n      if (!t2.claims.azp)\n        throw new Error(\"Authorized Party (azp) claim must be a string present in the ID token when Audience (aud) claim has multiple values\");\n      if (t2.claims.azp !== e2.aud)\n        throw new Error(`Authorized Party (azp) claim mismatch in the ID token; expected \"${e2.aud}\", found \"${t2.claims.azp}\"`);\n    }\n  } else if (t2.claims.aud !== e2.aud)\n    throw new Error(`Audience (aud) claim mismatch in the ID token; expected \"${e2.aud}\" but found \"${t2.claims.aud}\"`);\n  if (e2.nonce) {\n    if (!t2.claims.nonce)\n      throw new Error(\"Nonce (nonce) claim must be a string present in the ID token\");\n    if (t2.claims.nonce !== e2.nonce)\n      throw new Error(`Nonce (nonce) claim mismatch in the ID token; expected \"${e2.nonce}\", found \"${t2.claims.nonce}\"`);\n  }\n  if (e2.max_age && !K(t2.claims.auth_time))\n    throw new Error(\"Authentication Time (auth_time) claim must be a number present in the ID token when Max Age (max_age) is specified\");\n  if (null == t2.claims.exp || !K(t2.claims.exp))\n    throw new Error(\"Expiration Time (exp) claim must be a number present in the ID token\");\n  if (!K(t2.claims.iat))\n    throw new Error(\"Issued At (iat) claim must be a number present in the ID token\");\n  const i2 = e2.leeway || 60, o2 = new Date(e2.now || Date.now()), n2 = /* @__PURE__ */ new Date(0);\n  if (n2.setUTCSeconds(t2.claims.exp + i2), o2 > n2)\n    throw new Error(`Expiration Time (exp) claim error in the ID token; current time (${o2}) is after expiration time (${n2})`);\n  if (null != t2.claims.nbf && K(t2.claims.nbf)) {\n    const e3 = /* @__PURE__ */ new Date(0);\n    if (e3.setUTCSeconds(t2.claims.nbf - i2), o2 < e3)\n      throw new Error(`Not Before time (nbf) claim in the ID token indicates that this token can't be used just yet. Current time (${o2}) is before ${e3}`);\n  }\n  if (null != t2.claims.auth_time && K(t2.claims.auth_time)) {\n    const n3 = /* @__PURE__ */ new Date(0);\n    if (n3.setUTCSeconds(parseInt(t2.claims.auth_time) + e2.max_age + i2), o2 > n3)\n      throw new Error(`Authentication Time (auth_time) claim in the ID token indicates that too much time has passed since the last end-user authentication. Current time (${o2}) is after last auth at ${n3}`);\n  }\n  if (e2.organization) {\n    const i3 = e2.organization.trim();\n    if (i3.startsWith(\"org_\")) {\n      const e3 = i3;\n      if (!t2.claims.org_id)\n        throw new Error(\"Organization ID (org_id) claim must be a string present in the ID token\");\n      if (e3 !== t2.claims.org_id)\n        throw new Error(`Organization ID (org_id) claim mismatch in the ID token; expected \"${e3}\", found \"${t2.claims.org_id}\"`);\n    } else {\n      const e3 = i3.toLowerCase();\n      if (!t2.claims.org_name)\n        throw new Error(\"Organization Name (org_name) claim must be a string present in the ID token\");\n      if (e3 !== t2.claims.org_name)\n        throw new Error(`Organization Name (org_name) claim mismatch in the ID token; expected \"${e3}\", found \"${t2.claims.org_name}\"`);\n    }\n  }\n  return t2;\n};\nvar R = o(function(e2, i2) {\n  var o2 = t && t.__assign || function() {\n    return o2 = Object.assign || function(e3) {\n      for (var t2, i3 = 1, o3 = arguments.length; i3 < o3; i3++)\n        for (var n3 in t2 = arguments[i3])\n          Object.prototype.hasOwnProperty.call(t2, n3) && (e3[n3] = t2[n3]);\n      return e3;\n    }, o2.apply(this, arguments);\n  };\n  function n2(e3, t2) {\n    if (!t2)\n      return \"\";\n    var i3 = \"; \" + e3;\n    return true === t2 ? i3 : i3 + \"=\" + t2;\n  }\n  function a2(e3, t2, i3) {\n    return encodeURIComponent(e3).replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent).replace(/\\(/g, \"%28\").replace(/\\)/g, \"%29\") + \"=\" + encodeURIComponent(t2).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent) + function(e4) {\n      if (\"number\" == typeof e4.expires) {\n        var t3 = /* @__PURE__ */ new Date();\n        t3.setMilliseconds(t3.getMilliseconds() + 864e5 * e4.expires), e4.expires = t3;\n      }\n      return n2(\"Expires\", e4.expires ? e4.expires.toUTCString() : \"\") + n2(\"Domain\", e4.domain) + n2(\"Path\", e4.path) + n2(\"Secure\", e4.secure) + n2(\"SameSite\", e4.sameSite);\n    }(i3);\n  }\n  function r2(e3) {\n    for (var t2 = {}, i3 = e3 ? e3.split(\"; \") : [], o3 = /(%[\\dA-F]{2})+/gi, n3 = 0; n3 < i3.length; n3++) {\n      var a3 = i3[n3].split(\"=\"), r3 = a3.slice(1).join(\"=\");\n      '\"' === r3.charAt(0) && (r3 = r3.slice(1, -1));\n      try {\n        t2[a3[0].replace(o3, decodeURIComponent)] = r3.replace(o3, decodeURIComponent);\n      } catch (e4) {\n      }\n    }\n    return t2;\n  }\n  function s2() {\n    return r2(document.cookie);\n  }\n  function c2(e3, t2, i3) {\n    document.cookie = a2(e3, t2, o2({ path: \"/\" }, i3));\n  }\n  i2.__esModule = true, i2.encode = a2, i2.parse = r2, i2.getAll = s2, i2.get = function(e3) {\n    return s2()[e3];\n  }, i2.set = c2, i2.remove = function(e3, t2) {\n    c2(e3, \"\", o2(o2({}, t2), { expires: -1 }));\n  };\n});\ni(R), R.encode, R.parse, R.getAll;\nvar U = R.get;\nvar L = R.set;\nvar D = R.remove;\nvar X = { get(e2) {\n  const t2 = U(e2);\n  if (void 0 !== t2)\n    return JSON.parse(t2);\n}, save(e2, t2, i2) {\n  let o2 = {};\n  \"https:\" === window.location.protocol && (o2 = { secure: true, sameSite: \"none\" }), (null == i2 ? void 0 : i2.daysUntilExpire) && (o2.expires = i2.daysUntilExpire), (null == i2 ? void 0 : i2.cookieDomain) && (o2.domain = i2.cookieDomain), L(e2, JSON.stringify(t2), o2);\n}, remove(e2, t2) {\n  let i2 = {};\n  (null == t2 ? void 0 : t2.cookieDomain) && (i2.domain = t2.cookieDomain), D(e2, i2);\n} };\nvar N = { get(e2) {\n  const t2 = X.get(e2);\n  return t2 || X.get(`_legacy_${e2}`);\n}, save(e2, t2, i2) {\n  let o2 = {};\n  \"https:\" === window.location.protocol && (o2 = { secure: true }), (null == i2 ? void 0 : i2.daysUntilExpire) && (o2.expires = i2.daysUntilExpire), (null == i2 ? void 0 : i2.cookieDomain) && (o2.domain = i2.cookieDomain), L(`_legacy_${e2}`, JSON.stringify(t2), o2), X.save(e2, t2, i2);\n}, remove(e2, t2) {\n  let i2 = {};\n  (null == t2 ? void 0 : t2.cookieDomain) && (i2.domain = t2.cookieDomain), D(e2, i2), X.remove(e2, t2), X.remove(`_legacy_${e2}`, t2);\n} };\nvar J = { get(e2) {\n  if (\"undefined\" == typeof sessionStorage)\n    return;\n  const t2 = sessionStorage.getItem(e2);\n  return null != t2 ? JSON.parse(t2) : void 0;\n}, save(e2, t2) {\n  sessionStorage.setItem(e2, JSON.stringify(t2));\n}, remove(e2) {\n  sessionStorage.removeItem(e2);\n} };\nfunction F(e2, t2, i2) {\n  var o2 = void 0 === t2 ? null : t2, n2 = function(e3, t3) {\n    var i3 = atob(e3);\n    if (t3) {\n      for (var o3 = new Uint8Array(i3.length), n3 = 0, a3 = i3.length; n3 < a3; ++n3)\n        o3[n3] = i3.charCodeAt(n3);\n      return String.fromCharCode.apply(null, new Uint16Array(o3.buffer));\n    }\n    return i3;\n  }(e2, void 0 !== i2 && i2), a2 = n2.indexOf(\"\\n\", 10) + 1, r2 = n2.substring(a2) + (o2 ? \"//# sourceMappingURL=\" + o2 : \"\"), s2 = new Blob([r2], { type: \"application/javascript\" });\n  return URL.createObjectURL(s2);\n}\nvar H;\nvar Y;\nvar G;\nvar V;\nvar M = (H = \"Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwohZnVuY3Rpb24oKXsidXNlIHN0cmljdCI7Y2xhc3MgZSBleHRlbmRzIEVycm9ye2NvbnN0cnVjdG9yKHQscil7c3VwZXIociksdGhpcy5lcnJvcj10LHRoaXMuZXJyb3JfZGVzY3JpcHRpb249cixPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcyxlLnByb3RvdHlwZSl9c3RhdGljIGZyb21QYXlsb2FkKHtlcnJvcjp0LGVycm9yX2Rlc2NyaXB0aW9uOnJ9KXtyZXR1cm4gbmV3IGUodCxyKX19Y2xhc3MgdCBleHRlbmRzIGV7Y29uc3RydWN0b3IoZSxzKXtzdXBlcigibWlzc2luZ19yZWZyZXNoX3Rva2VuIixgTWlzc2luZyBSZWZyZXNoIFRva2VuIChhdWRpZW5jZTogJyR7cihlLFsiZGVmYXVsdCJdKX0nLCBzY29wZTogJyR7cihzKX0nKWApLHRoaXMuYXVkaWVuY2U9ZSx0aGlzLnNjb3BlPXMsT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsdC5wcm90b3R5cGUpfX1mdW5jdGlvbiByKGUsdD1bXSl7cmV0dXJuIGUmJiF0LmluY2x1ZGVzKGUpP2U6IiJ9ImZ1bmN0aW9uIj09dHlwZW9mIFN1cHByZXNzZWRFcnJvciYmU3VwcHJlc3NlZEVycm9yO2NvbnN0IHM9ZT0+e3ZhcntjbGllbnRJZDp0fT1lLHI9ZnVuY3Rpb24oZSx0KXt2YXIgcj17fTtmb3IodmFyIHMgaW4gZSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxzKSYmdC5pbmRleE9mKHMpPDAmJihyW3NdPWVbc10pO2lmKG51bGwhPWUmJiJmdW5jdGlvbiI9PXR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgbz0wO2ZvcihzPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7bzxzLmxlbmd0aDtvKyspdC5pbmRleE9mKHNbb10pPDAmJk9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChlLHNbb10pJiYocltzW29dXT1lW3Nbb11dKX1yZXR1cm4gcn0oZSxbImNsaWVudElkIl0pO3JldHVybiBuZXcgVVJMU2VhcmNoUGFyYW1zKChlPT5PYmplY3Qua2V5cyhlKS5maWx0ZXIoKHQ9PnZvaWQgMCE9PWVbdF0pKS5yZWR1Y2UoKCh0LHIpPT5PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdCkse1tyXTplW3JdfSkpLHt9KSkoT2JqZWN0LmFzc2lnbih7Y2xpZW50X2lkOnR9LHIpKSkudG9TdHJpbmcoKX07bGV0IG89e307Y29uc3Qgbj0oZSx0KT0+YCR7ZX18JHt0fWA7YWRkRXZlbnRMaXN0ZW5lcigibWVzc2FnZSIsKGFzeW5jKHtkYXRhOnt0aW1lb3V0OmUsYXV0aDpyLGZldGNoVXJsOmksZmV0Y2hPcHRpb25zOmMsdXNlRm9ybURhdGE6YX0scG9ydHM6W3BdfSk9PntsZXQgZjtjb25zdHthdWRpZW5jZTp1LHNjb3BlOmx9PXJ8fHt9O3RyeXtjb25zdCByPWE/KGU9Pntjb25zdCB0PW5ldyBVUkxTZWFyY2hQYXJhbXMoZSkscj17fTtyZXR1cm4gdC5mb3JFYWNoKCgoZSx0KT0+e3JbdF09ZX0pKSxyfSkoYy5ib2R5KTpKU09OLnBhcnNlKGMuYm9keSk7aWYoIXIucmVmcmVzaF90b2tlbiYmInJlZnJlc2hfdG9rZW4iPT09ci5ncmFudF90eXBlKXtjb25zdCBlPSgoZSx0KT0+b1tuKGUsdCldKSh1LGwpO2lmKCFlKXRocm93IG5ldyB0KHUsbCk7Yy5ib2R5PWE/cyhPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scikse3JlZnJlc2hfdG9rZW46ZX0pKTpKU09OLnN0cmluZ2lmeShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scikse3JlZnJlc2hfdG9rZW46ZX0pKX1sZXQgaCxnOyJmdW5jdGlvbiI9PXR5cGVvZiBBYm9ydENvbnRyb2xsZXImJihoPW5ldyBBYm9ydENvbnRyb2xsZXIsYy5zaWduYWw9aC5zaWduYWwpO3RyeXtnPWF3YWl0IFByb21pc2UucmFjZShbKGQ9ZSxuZXcgUHJvbWlzZSgoZT0+c2V0VGltZW91dChlLGQpKSkpLGZldGNoKGksT2JqZWN0LmFzc2lnbih7fSxjKSldKX1jYXRjaChlKXtyZXR1cm4gdm9pZCBwLnBvc3RNZXNzYWdlKHtlcnJvcjplLm1lc3NhZ2V9KX1pZighZylyZXR1cm4gaCYmaC5hYm9ydCgpLHZvaWQgcC5wb3N0TWVzc2FnZSh7ZXJyb3I6IlRpbWVvdXQgd2hlbiBleGVjdXRpbmcgJ2ZldGNoJyJ9KTtmPWF3YWl0IGcuanNvbigpLGYucmVmcmVzaF90b2tlbj8oKChlLHQscik9PntvW24odCxyKV09ZX0pKGYucmVmcmVzaF90b2tlbix1LGwpLGRlbGV0ZSBmLnJlZnJlc2hfdG9rZW4pOigoZSx0KT0+e2RlbGV0ZSBvW24oZSx0KV19KSh1LGwpLHAucG9zdE1lc3NhZ2Uoe29rOmcub2ssanNvbjpmfSl9Y2F0Y2goZSl7cC5wb3N0TWVzc2FnZSh7b2s6ITEsanNvbjp7ZXJyb3I6ZS5lcnJvcixlcnJvcl9kZXNjcmlwdGlvbjplLm1lc3NhZ2V9fSl9dmFyIGR9KSl9KCk7Cgo=\", Y = null, G = false, function(e2) {\n  return V = V || F(H, Y, G), new Worker(V, e2);\n});\nvar A = {};\nvar B = class {\n  constructor(e2, t2) {\n    this.cache = e2, this.clientId = t2, this.manifestKey = this.createManifestKeyFrom(this.clientId);\n  }\n  async add(e2) {\n    var t2;\n    const i2 = new Set((null === (t2 = await this.cache.get(this.manifestKey)) || void 0 === t2 ? void 0 : t2.keys) || []);\n    i2.add(e2), await this.cache.set(this.manifestKey, { keys: [...i2] });\n  }\n  async remove(e2) {\n    const t2 = await this.cache.get(this.manifestKey);\n    if (t2) {\n      const i2 = new Set(t2.keys);\n      return i2.delete(e2), i2.size > 0 ? await this.cache.set(this.manifestKey, { keys: [...i2] }) : await this.cache.remove(this.manifestKey);\n    }\n  }\n  get() {\n    return this.cache.get(this.manifestKey);\n  }\n  clear() {\n    return this.cache.remove(this.manifestKey);\n  }\n  createManifestKeyFrom(e2) {\n    return `@@auth0spajs@@::${e2}`;\n  }\n};\nvar $ = { memory: () => new P().enclosedCache, localstorage: () => new z() };\nvar q = (e2) => $[e2];\nvar Q = (t2) => {\n  const { openUrl: i2, onRedirect: o2 } = t2, n2 = e(t2, [\"openUrl\", \"onRedirect\"]);\n  return Object.assign(Object.assign({}, n2), { openUrl: false === i2 || i2 ? i2 : o2 });\n};\nvar ee = new a();\nvar te = class {\n  constructor(e2) {\n    let t2, i2;\n    if (this.userCache = new P().enclosedCache, this.defaultOptions = { authorizationParams: { scope: \"openid profile email\" }, useRefreshTokensFallback: false, useFormData: true }, this._releaseLockOnPageHide = async () => {\n      await ee.releaseLock(\"auth0.lock.getTokenSilently\"), window.removeEventListener(\"pagehide\", this._releaseLockOnPageHide);\n    }, this.options = Object.assign(Object.assign(Object.assign({}, this.defaultOptions), e2), { authorizationParams: Object.assign(Object.assign({}, this.defaultOptions.authorizationParams), e2.authorizationParams) }), \"undefined\" != typeof window && (() => {\n      if (!w())\n        throw new Error(\"For security reasons, `window.crypto` is required to run `auth0-spa-js`.\");\n      if (void 0 === w().subtle)\n        throw new Error(\"\\n      auth0-spa-js must run on a secure origin. See https://github.com/auth0/auth0-spa-js/blob/main/FAQ.md#why-do-i-get-auth0-spa-js-must-run-on-a-secure-origin for more information.\\n    \");\n    })(), e2.cache && e2.cacheLocation && console.warn(\"Both `cache` and `cacheLocation` options have been specified in the Auth0Client configuration; ignoring `cacheLocation` and using `cache`.\"), e2.cache)\n      i2 = e2.cache;\n    else {\n      if (t2 = e2.cacheLocation || \"memory\", !q(t2))\n        throw new Error(`Invalid cache location \"${t2}\"`);\n      i2 = q(t2)();\n    }\n    this.httpTimeoutMs = e2.httpTimeoutInSeconds ? 1e3 * e2.httpTimeoutInSeconds : 1e4, this.cookieStorage = false === e2.legacySameSiteCookie ? X : N, this.orgHintCookieName = `auth0.${this.options.clientId}.organization_hint`, this.isAuthenticatedCookieName = ((e3) => `auth0.${e3}.is.authenticated`)(this.options.clientId), this.sessionCheckExpiryDays = e2.sessionCheckExpiryDays || 1;\n    const o2 = e2.useCookiesForTransactions ? this.cookieStorage : J;\n    var n2;\n    this.scope = j(\"openid\", this.options.authorizationParams.scope, this.options.useRefreshTokens ? \"offline_access\" : \"\"), this.transactionManager = new Z(o2, this.options.clientId, this.options.cookieDomain), this.nowProvider = this.options.nowProvider || c, this.cacheManager = new x(i2, i2.allKeys ? void 0 : new B(i2, this.options.clientId), this.nowProvider), this.domainUrl = (n2 = this.options.domain, /^https?:\\/\\//.test(n2) ? n2 : `https://${n2}`), this.tokenIssuer = ((e3, t3) => e3 ? e3.startsWith(\"https://\") ? e3 : `https://${e3}/` : `${t3}/`)(this.options.issuer, this.domainUrl), \"undefined\" != typeof window && window.Worker && this.options.useRefreshTokens && \"memory\" === t2 && (this.options.workerUrl ? this.worker = new Worker(this.options.workerUrl) : this.worker = new M());\n  }\n  _url(e2) {\n    const t2 = encodeURIComponent(btoa(JSON.stringify(this.options.auth0Client || s)));\n    return `${this.domainUrl}${e2}&auth0Client=${t2}`;\n  }\n  _authorizeUrl(e2) {\n    return this._url(`/authorize?${v(e2)}`);\n  }\n  async _verifyIdToken(e2, t2, i2) {\n    const o2 = await this.nowProvider();\n    return E({ iss: this.tokenIssuer, aud: this.options.clientId, id_token: e2, nonce: t2, organization: i2, leeway: this.options.leeway, max_age: (n2 = this.options.authorizationParams.max_age, \"string\" != typeof n2 ? n2 : parseInt(n2, 10) || void 0), now: o2 });\n    var n2;\n  }\n  _processOrgHint(e2) {\n    e2 ? this.cookieStorage.save(this.orgHintCookieName, e2, { daysUntilExpire: this.sessionCheckExpiryDays, cookieDomain: this.options.cookieDomain }) : this.cookieStorage.remove(this.orgHintCookieName, { cookieDomain: this.options.cookieDomain });\n  }\n  async _prepareAuthorizeUrl(e2, t2, i2) {\n    const o2 = k(y()), n2 = k(y()), a2 = y(), r2 = ((e3) => {\n      const t3 = new Uint8Array(e3);\n      return ((e4) => {\n        const t4 = { \"+\": \"-\", \"/\": \"_\", \"=\": \"\" };\n        return e4.replace(/[+/=]/g, (e5) => t4[e5]);\n      })(window.btoa(String.fromCharCode(...Array.from(t3))));\n    })(await (async (e3) => {\n      const t3 = w().subtle.digest({ name: \"SHA-256\" }, new TextEncoder().encode(e3));\n      return await t3;\n    })(a2)), s2 = ((e3, t3, i3, o3, n3, a3, r3, s3) => Object.assign(Object.assign(Object.assign({ client_id: e3.clientId }, e3.authorizationParams), i3), { scope: j(t3, i3.scope), response_type: \"code\", response_mode: s3 || \"query\", state: o3, nonce: n3, redirect_uri: r3 || e3.authorizationParams.redirect_uri, code_challenge: a3, code_challenge_method: \"S256\" }))(this.options, this.scope, e2, o2, n2, r2, e2.redirect_uri || this.options.authorizationParams.redirect_uri || i2, null == t2 ? void 0 : t2.response_mode), c2 = this._authorizeUrl(s2);\n    return { nonce: n2, code_verifier: a2, scope: s2.scope, audience: s2.audience || \"default\", redirect_uri: s2.redirect_uri, state: o2, url: c2 };\n  }\n  async loginWithPopup(e2, t2) {\n    var i2;\n    if (e2 = e2 || {}, !(t2 = t2 || {}).popup && (t2.popup = ((e3) => {\n      const t3 = window.screenX + (window.innerWidth - 400) / 2, i3 = window.screenY + (window.innerHeight - 600) / 2;\n      return window.open(e3, \"auth0:authorize:popup\", `left=${t3},top=${i3},width=400,height=600,resizable,scrollbars=yes,status=1`);\n    })(\"\"), !t2.popup))\n      throw new Error(\"Unable to open a popup for loginWithPopup - window.open returned `null`\");\n    const o2 = await this._prepareAuthorizeUrl(e2.authorizationParams || {}, { response_mode: \"web_message\" }, window.location.origin);\n    t2.popup.location.href = o2.url;\n    const n2 = await ((e3) => new Promise((t3, i3) => {\n      let o3;\n      const n3 = setInterval(() => {\n        e3.popup && e3.popup.closed && (clearInterval(n3), clearTimeout(a3), window.removeEventListener(\"message\", o3, false), i3(new p(e3.popup)));\n      }, 1e3), a3 = setTimeout(() => {\n        clearInterval(n3), i3(new h(e3.popup)), window.removeEventListener(\"message\", o3, false);\n      }, 1e3 * (e3.timeoutInSeconds || 60));\n      o3 = function(r2) {\n        if (r2.data && \"authorization_response\" === r2.data.type) {\n          if (clearTimeout(a3), clearInterval(n3), window.removeEventListener(\"message\", o3, false), e3.popup.close(), r2.data.response.error)\n            return i3(d.fromPayload(r2.data.response));\n          t3(r2.data.response);\n        }\n      }, window.addEventListener(\"message\", o3);\n    }))(Object.assign(Object.assign({}, t2), { timeoutInSeconds: t2.timeoutInSeconds || this.options.authorizeTimeoutInSeconds || 60 }));\n    if (o2.state !== n2.state)\n      throw new d(\"state_mismatch\", \"Invalid state\");\n    const a2 = (null === (i2 = e2.authorizationParams) || void 0 === i2 ? void 0 : i2.organization) || this.options.authorizationParams.organization;\n    await this._requestToken({ audience: o2.audience, scope: o2.scope, code_verifier: o2.code_verifier, grant_type: \"authorization_code\", code: n2.code, redirect_uri: o2.redirect_uri }, { nonceIn: o2.nonce, organization: a2 });\n  }\n  async getUser() {\n    var e2;\n    const t2 = await this._getIdTokenFromCache();\n    return null === (e2 = null == t2 ? void 0 : t2.decodedToken) || void 0 === e2 ? void 0 : e2.user;\n  }\n  async getIdTokenClaims() {\n    var e2;\n    const t2 = await this._getIdTokenFromCache();\n    return null === (e2 = null == t2 ? void 0 : t2.decodedToken) || void 0 === e2 ? void 0 : e2.claims;\n  }\n  async loginWithRedirect(t2 = {}) {\n    var i2;\n    const o2 = Q(t2), { openUrl: n2, fragment: a2, appState: r2 } = o2, s2 = e(o2, [\"openUrl\", \"fragment\", \"appState\"]), c2 = (null === (i2 = s2.authorizationParams) || void 0 === i2 ? void 0 : i2.organization) || this.options.authorizationParams.organization, d2 = await this._prepareAuthorizeUrl(s2.authorizationParams || {}), { url: u2 } = d2, l2 = e(d2, [\"url\"]);\n    this.transactionManager.create(Object.assign(Object.assign(Object.assign({}, l2), { appState: r2 }), c2 && { organization: c2 }));\n    const h2 = a2 ? `${u2}#${a2}` : u2;\n    n2 ? await n2(h2) : window.location.assign(h2);\n  }\n  async handleRedirectCallback(e2 = window.location.href) {\n    const t2 = e2.split(\"?\").slice(1);\n    if (0 === t2.length)\n      throw new Error(\"There are no query params available for parsing.\");\n    const { state: i2, code: o2, error: n2, error_description: a2 } = ((e3) => {\n      e3.indexOf(\"#\") > -1 && (e3 = e3.substring(0, e3.indexOf(\"#\")));\n      const t3 = new URLSearchParams(e3);\n      return { state: t3.get(\"state\"), code: t3.get(\"code\") || void 0, error: t3.get(\"error\") || void 0, error_description: t3.get(\"error_description\") || void 0 };\n    })(t2.join(\"\")), r2 = this.transactionManager.get();\n    if (!r2)\n      throw new d(\"missing_transaction\", \"Invalid state\");\n    if (this.transactionManager.remove(), n2)\n      throw new u(n2, a2 || n2, i2, r2.appState);\n    if (!r2.code_verifier || r2.state && r2.state !== i2)\n      throw new d(\"state_mismatch\", \"Invalid state\");\n    const s2 = r2.organization, c2 = r2.nonce, l2 = r2.redirect_uri;\n    return await this._requestToken(Object.assign({ audience: r2.audience, scope: r2.scope, code_verifier: r2.code_verifier, grant_type: \"authorization_code\", code: o2 }, l2 ? { redirect_uri: l2 } : {}), { nonceIn: c2, organization: s2 }), { appState: r2.appState };\n  }\n  async checkSession(e2) {\n    if (!this.cookieStorage.get(this.isAuthenticatedCookieName)) {\n      if (!this.cookieStorage.get(\"auth0.is.authenticated\"))\n        return;\n      this.cookieStorage.save(this.isAuthenticatedCookieName, true, { daysUntilExpire: this.sessionCheckExpiryDays, cookieDomain: this.options.cookieDomain }), this.cookieStorage.remove(\"auth0.is.authenticated\");\n    }\n    try {\n      await this.getTokenSilently(e2);\n    } catch (e3) {\n    }\n  }\n  async getTokenSilently(e2 = {}) {\n    var t2;\n    const i2 = Object.assign(Object.assign({ cacheMode: \"on\" }, e2), { authorizationParams: Object.assign(Object.assign(Object.assign({}, this.options.authorizationParams), e2.authorizationParams), { scope: j(this.scope, null === (t2 = e2.authorizationParams) || void 0 === t2 ? void 0 : t2.scope) }) }), o2 = await ((e3, t3) => {\n      let i3 = A[t3];\n      return i3 || (i3 = e3().finally(() => {\n        delete A[t3], i3 = null;\n      }), A[t3] = i3), i3;\n    })(() => this._getTokenSilently(i2), `${this.options.clientId}::${i2.authorizationParams.audience}::${i2.authorizationParams.scope}`);\n    return e2.detailedResponse ? o2 : null == o2 ? void 0 : o2.access_token;\n  }\n  async _getTokenSilently(t2) {\n    const { cacheMode: i2 } = t2, o2 = e(t2, [\"cacheMode\"]);\n    if (\"off\" !== i2) {\n      const e2 = await this._getEntryFromCache({ scope: o2.authorizationParams.scope, audience: o2.authorizationParams.audience || \"default\", clientId: this.options.clientId });\n      if (e2)\n        return e2;\n    }\n    if (\"cache-only\" !== i2) {\n      if (!await (async (e2, t3 = 3) => {\n        for (let i3 = 0; i3 < t3; i3++)\n          if (await e2())\n            return true;\n        return false;\n      })(() => ee.acquireLock(\"auth0.lock.getTokenSilently\", 5e3), 10))\n        throw new l();\n      try {\n        if (window.addEventListener(\"pagehide\", this._releaseLockOnPageHide), \"off\" !== i2) {\n          const e3 = await this._getEntryFromCache({ scope: o2.authorizationParams.scope, audience: o2.authorizationParams.audience || \"default\", clientId: this.options.clientId });\n          if (e3)\n            return e3;\n        }\n        const e2 = this.options.useRefreshTokens ? await this._getTokenUsingRefreshToken(o2) : await this._getTokenFromIFrame(o2), { id_token: t3, access_token: n2, oauthTokenScope: a2, expires_in: r2 } = e2;\n        return Object.assign(Object.assign({ id_token: t3, access_token: n2 }, a2 ? { scope: a2 } : null), { expires_in: r2 });\n      } finally {\n        await ee.releaseLock(\"auth0.lock.getTokenSilently\"), window.removeEventListener(\"pagehide\", this._releaseLockOnPageHide);\n      }\n    }\n  }\n  async getTokenWithPopup(e2 = {}, t2 = {}) {\n    var i2;\n    const o2 = Object.assign(Object.assign({}, e2), { authorizationParams: Object.assign(Object.assign(Object.assign({}, this.options.authorizationParams), e2.authorizationParams), { scope: j(this.scope, null === (i2 = e2.authorizationParams) || void 0 === i2 ? void 0 : i2.scope) }) });\n    t2 = Object.assign(Object.assign({}, r), t2), await this.loginWithPopup(o2, t2);\n    return (await this.cacheManager.get(new C({ scope: o2.authorizationParams.scope, audience: o2.authorizationParams.audience || \"default\", clientId: this.options.clientId }))).access_token;\n  }\n  async isAuthenticated() {\n    return !!await this.getUser();\n  }\n  _buildLogoutUrl(t2) {\n    null !== t2.clientId ? t2.clientId = t2.clientId || this.options.clientId : delete t2.clientId;\n    const i2 = t2.logoutParams || {}, { federated: o2 } = i2, n2 = e(i2, [\"federated\"]), a2 = o2 ? \"&federated\" : \"\";\n    return this._url(`/v2/logout?${v(Object.assign({ clientId: t2.clientId }, n2))}`) + a2;\n  }\n  async logout(t2 = {}) {\n    const i2 = Q(t2), { openUrl: o2 } = i2, n2 = e(i2, [\"openUrl\"]);\n    null === t2.clientId ? await this.cacheManager.clear() : await this.cacheManager.clear(t2.clientId || this.options.clientId), this.cookieStorage.remove(this.orgHintCookieName, { cookieDomain: this.options.cookieDomain }), this.cookieStorage.remove(this.isAuthenticatedCookieName, { cookieDomain: this.options.cookieDomain }), this.userCache.remove(\"@@user@@\");\n    const a2 = this._buildLogoutUrl(n2);\n    o2 ? await o2(a2) : false !== o2 && window.location.assign(a2);\n  }\n  async _getTokenFromIFrame(e2) {\n    const t2 = Object.assign(Object.assign({}, e2.authorizationParams), { prompt: \"none\" }), i2 = this.cookieStorage.get(this.orgHintCookieName);\n    i2 && !t2.organization && (t2.organization = i2);\n    const { url: o2, state: n2, nonce: a2, code_verifier: r2, redirect_uri: s2, scope: c2, audience: u2 } = await this._prepareAuthorizeUrl(t2, { response_mode: \"web_message\" }, window.location.origin);\n    try {\n      if (window.crossOriginIsolated)\n        throw new d(\"login_required\", \"The application is running in a Cross-Origin Isolated context, silently retrieving a token without refresh token is not possible.\");\n      const i3 = e2.timeoutInSeconds || this.options.authorizeTimeoutInSeconds, h2 = await ((e3, t3, i4 = 60) => new Promise((o3, n3) => {\n        const a3 = window.document.createElement(\"iframe\");\n        a3.setAttribute(\"width\", \"0\"), a3.setAttribute(\"height\", \"0\"), a3.style.display = \"none\";\n        const r3 = () => {\n          window.document.body.contains(a3) && (window.document.body.removeChild(a3), window.removeEventListener(\"message\", s3, false));\n        };\n        let s3;\n        const c3 = setTimeout(() => {\n          n3(new l()), r3();\n        }, 1e3 * i4);\n        s3 = function(e4) {\n          if (e4.origin != t3)\n            return;\n          if (!e4.data || \"authorization_response\" !== e4.data.type)\n            return;\n          const i5 = e4.source;\n          i5 && i5.close(), e4.data.response.error ? n3(d.fromPayload(e4.data.response)) : o3(e4.data.response), clearTimeout(c3), window.removeEventListener(\"message\", s3, false), setTimeout(r3, 2e3);\n        }, window.addEventListener(\"message\", s3, false), window.document.body.appendChild(a3), a3.setAttribute(\"src\", e3);\n      }))(o2, this.domainUrl, i3);\n      if (n2 !== h2.state)\n        throw new d(\"state_mismatch\", \"Invalid state\");\n      const p2 = await this._requestToken(Object.assign(Object.assign({}, e2.authorizationParams), { code_verifier: r2, code: h2.code, grant_type: \"authorization_code\", redirect_uri: s2, timeout: e2.authorizationParams.timeout || this.httpTimeoutMs }), { nonceIn: a2, organization: t2.organization });\n      return Object.assign(Object.assign({}, p2), { scope: c2, oauthTokenScope: p2.scope, audience: u2 });\n    } catch (e3) {\n      throw \"login_required\" === e3.error && this.logout({ openUrl: false }), e3;\n    }\n  }\n  async _getTokenUsingRefreshToken(e2) {\n    const t2 = await this.cacheManager.get(new C({ scope: e2.authorizationParams.scope, audience: e2.authorizationParams.audience || \"default\", clientId: this.options.clientId }));\n    if (!(t2 && t2.refresh_token || this.worker)) {\n      if (this.options.useRefreshTokensFallback)\n        return await this._getTokenFromIFrame(e2);\n      throw new f(e2.authorizationParams.audience || \"default\", e2.authorizationParams.scope);\n    }\n    const i2 = e2.authorizationParams.redirect_uri || this.options.authorizationParams.redirect_uri || window.location.origin, o2 = \"number\" == typeof e2.timeoutInSeconds ? 1e3 * e2.timeoutInSeconds : null;\n    try {\n      const n2 = await this._requestToken(Object.assign(Object.assign(Object.assign({}, e2.authorizationParams), { grant_type: \"refresh_token\", refresh_token: t2 && t2.refresh_token, redirect_uri: i2 }), o2 && { timeout: o2 }));\n      return Object.assign(Object.assign({}, n2), { scope: e2.authorizationParams.scope, oauthTokenScope: n2.scope, audience: e2.authorizationParams.audience || \"default\" });\n    } catch (t3) {\n      if ((t3.message.indexOf(\"Missing Refresh Token\") > -1 || t3.message && t3.message.indexOf(\"invalid refresh token\") > -1) && this.options.useRefreshTokensFallback)\n        return await this._getTokenFromIFrame(e2);\n      throw t3;\n    }\n  }\n  async _saveEntryInCache(t2) {\n    const { id_token: i2, decodedToken: o2 } = t2, n2 = e(t2, [\"id_token\", \"decodedToken\"]);\n    this.userCache.set(\"@@user@@\", { id_token: i2, decodedToken: o2 }), await this.cacheManager.setIdToken(this.options.clientId, t2.id_token, t2.decodedToken), await this.cacheManager.set(n2);\n  }\n  async _getIdTokenFromCache() {\n    const e2 = this.options.authorizationParams.audience || \"default\", t2 = await this.cacheManager.getIdToken(new C({ clientId: this.options.clientId, audience: e2, scope: this.scope })), i2 = this.userCache.get(\"@@user@@\");\n    return t2 && t2.id_token === (null == i2 ? void 0 : i2.id_token) ? i2 : (this.userCache.set(\"@@user@@\", t2), t2);\n  }\n  async _getEntryFromCache({ scope: e2, audience: t2, clientId: i2 }) {\n    const o2 = await this.cacheManager.get(new C({ scope: e2, audience: t2, clientId: i2 }), 60);\n    if (o2 && o2.access_token) {\n      const { access_token: e3, oauthTokenScope: t3, expires_in: i3 } = o2, n2 = await this._getIdTokenFromCache();\n      return n2 && Object.assign(Object.assign({ id_token: n2.id_token, access_token: e3 }, t3 ? { scope: t3 } : null), { expires_in: i3 });\n    }\n  }\n  async _requestToken(e2, t2) {\n    const { nonceIn: i2, organization: o2 } = t2 || {}, n2 = await T(Object.assign({ baseUrl: this.domainUrl, client_id: this.options.clientId, auth0Client: this.options.auth0Client, useFormData: this.options.useFormData, timeout: this.httpTimeoutMs }, e2), this.worker), a2 = await this._verifyIdToken(n2.id_token, i2, o2);\n    return await this._saveEntryInCache(Object.assign(Object.assign(Object.assign(Object.assign({}, n2), { decodedToken: a2, scope: e2.scope, audience: e2.audience || \"default\" }), n2.scope ? { oauthTokenScope: n2.scope } : null), { client_id: this.options.clientId })), this.cookieStorage.save(this.isAuthenticatedCookieName, true, { daysUntilExpire: this.sessionCheckExpiryDays, cookieDomain: this.options.cookieDomain }), this._processOrgHint(o2 || a2.claims.org_id), Object.assign(Object.assign({}, n2), { decodedToken: a2 });\n  }\n};\nvar ie = class {\n};\nvar initialAuthState = {\n  isAuthenticated: false,\n  isLoading: true\n};\nvar stub = function() {\n  throw new Error(\"You forgot to wrap your component in <Auth0Provider>.\");\n};\nvar initialContext = __assign(__assign({}, initialAuthState), { buildAuthorizeUrl: stub, buildLogoutUrl: stub, getAccessTokenSilently: stub, getAccessTokenWithPopup: stub, getIdTokenClaims: stub, loginWithRedirect: stub, loginWithPopup: stub, logout: stub, handleRedirectCallback: stub });\nvar Auth0Context = (0, import_react.createContext)(initialContext);\nvar OAuthError = (\n  /** @class */\n  function(_super) {\n    __extends(OAuthError2, _super);\n    function OAuthError2(error, error_description) {\n      var _this = _super.call(this, error_description || error) || this;\n      _this.error = error;\n      _this.error_description = error_description;\n      Object.setPrototypeOf(_this, OAuthError2.prototype);\n      return _this;\n    }\n    return OAuthError2;\n  }(Error)\n);\nvar CODE_RE = /[?&]code=[^&]+/;\nvar STATE_RE = /[?&]state=[^&]+/;\nvar ERROR_RE = /[?&]error=[^&]+/;\nvar hasAuthParams = function(searchParams) {\n  if (searchParams === void 0) {\n    searchParams = window.location.search;\n  }\n  return (CODE_RE.test(searchParams) || ERROR_RE.test(searchParams)) && STATE_RE.test(searchParams);\n};\nvar normalizeErrorFn = function(fallbackMessage) {\n  return function(error) {\n    if (error instanceof Error) {\n      return error;\n    }\n    if (error !== null && typeof error === \"object\" && \"error\" in error && typeof error.error === \"string\") {\n      if (\"error_description\" in error && typeof error.error_description === \"string\") {\n        return new OAuthError(error.error, error.error_description);\n      }\n      return new OAuthError(error.error);\n    }\n    return new Error(fallbackMessage);\n  };\n};\nvar loginError = normalizeErrorFn(\"Login failed\");\nvar tokenError = normalizeErrorFn(\"Get access token failed\");\nvar deprecateRedirectUri = function(options) {\n  var _a;\n  if (options === null || options === void 0 ? void 0 : options.redirectUri) {\n    console.warn(\"Using `redirectUri` has been deprecated, please use `authorizationParams.redirect_uri` instead as `redirectUri` will be no longer supported in a future version\");\n    options.authorizationParams = options.authorizationParams || {};\n    options.authorizationParams.redirect_uri = options.redirectUri;\n    delete options.redirectUri;\n  }\n  if ((_a = options === null || options === void 0 ? void 0 : options.authorizationParams) === null || _a === void 0 ? void 0 : _a.redirectUri) {\n    console.warn(\"Using `authorizationParams.redirectUri` has been deprecated, please use `authorizationParams.redirect_uri` instead as `authorizationParams.redirectUri` will be removed in a future version\");\n    options.authorizationParams.redirect_uri = options.authorizationParams.redirectUri;\n    delete options.authorizationParams.redirectUri;\n  }\n};\nvar reducer = function(state, action) {\n  switch (action.type) {\n    case \"LOGIN_POPUP_STARTED\":\n      return __assign(__assign({}, state), { isLoading: true });\n    case \"LOGIN_POPUP_COMPLETE\":\n    case \"INITIALISED\":\n      return __assign(__assign({}, state), { isAuthenticated: !!action.user, user: action.user, isLoading: false, error: void 0 });\n    case \"HANDLE_REDIRECT_COMPLETE\":\n    case \"GET_ACCESS_TOKEN_COMPLETE\":\n      if (state.user === action.user) {\n        return state;\n      }\n      return __assign(__assign({}, state), { isAuthenticated: !!action.user, user: action.user });\n    case \"LOGOUT\":\n      return __assign(__assign({}, state), { isAuthenticated: false, user: void 0 });\n    case \"ERROR\":\n      return __assign(__assign({}, state), { isLoading: false, error: action.error });\n  }\n};\nvar toAuth0ClientOptions = function(opts) {\n  deprecateRedirectUri(opts);\n  return __assign(__assign({}, opts), { auth0Client: {\n    name: \"auth0-react\",\n    version: \"2.2.4\"\n  } });\n};\nvar defaultOnRedirectCallback = function(appState) {\n  window.history.replaceState({}, document.title, (appState === null || appState === void 0 ? void 0 : appState.returnTo) || window.location.pathname);\n};\nvar Auth0Provider = function(opts) {\n  var children = opts.children, skipRedirectCallback = opts.skipRedirectCallback, _a = opts.onRedirectCallback, onRedirectCallback = _a === void 0 ? defaultOnRedirectCallback : _a, _b = opts.context, context = _b === void 0 ? Auth0Context : _b, clientOpts = __rest(opts, [\"children\", \"skipRedirectCallback\", \"onRedirectCallback\", \"context\"]);\n  var client = (0, import_react.useState)(function() {\n    return new te(toAuth0ClientOptions(clientOpts));\n  })[0];\n  var _c = (0, import_react.useReducer)(reducer, initialAuthState), state = _c[0], dispatch = _c[1];\n  var didInitialise = (0, import_react.useRef)(false);\n  (0, import_react.useEffect)(function() {\n    if (didInitialise.current) {\n      return;\n    }\n    didInitialise.current = true;\n    (function() {\n      return __awaiter(void 0, void 0, void 0, function() {\n        var user, appState, error_1;\n        return __generator(this, function(_a2) {\n          switch (_a2.label) {\n            case 0:\n              _a2.trys.push([0, 7, , 8]);\n              user = void 0;\n              if (!(hasAuthParams() && !skipRedirectCallback))\n                return [3, 3];\n              return [4, client.handleRedirectCallback()];\n            case 1:\n              appState = _a2.sent().appState;\n              return [4, client.getUser()];\n            case 2:\n              user = _a2.sent();\n              onRedirectCallback(appState, user);\n              return [3, 6];\n            case 3:\n              return [4, client.checkSession()];\n            case 4:\n              _a2.sent();\n              return [4, client.getUser()];\n            case 5:\n              user = _a2.sent();\n              _a2.label = 6;\n            case 6:\n              dispatch({ type: \"INITIALISED\", user });\n              return [3, 8];\n            case 7:\n              error_1 = _a2.sent();\n              dispatch({ type: \"ERROR\", error: loginError(error_1) });\n              return [3, 8];\n            case 8:\n              return [\n                2\n                /*return*/\n              ];\n          }\n        });\n      });\n    })();\n  }, [client, onRedirectCallback, skipRedirectCallback]);\n  var loginWithRedirect = (0, import_react.useCallback)(function(opts2) {\n    deprecateRedirectUri(opts2);\n    return client.loginWithRedirect(opts2);\n  }, [client]);\n  var loginWithPopup = (0, import_react.useCallback)(function(options, config) {\n    return __awaiter(void 0, void 0, void 0, function() {\n      var error_2, user;\n      return __generator(this, function(_a2) {\n        switch (_a2.label) {\n          case 0:\n            dispatch({ type: \"LOGIN_POPUP_STARTED\" });\n            _a2.label = 1;\n          case 1:\n            _a2.trys.push([1, 3, , 4]);\n            return [4, client.loginWithPopup(options, config)];\n          case 2:\n            _a2.sent();\n            return [3, 4];\n          case 3:\n            error_2 = _a2.sent();\n            dispatch({ type: \"ERROR\", error: loginError(error_2) });\n            return [\n              2\n              /*return*/\n            ];\n          case 4:\n            return [4, client.getUser()];\n          case 5:\n            user = _a2.sent();\n            dispatch({ type: \"LOGIN_POPUP_COMPLETE\", user });\n            return [\n              2\n              /*return*/\n            ];\n        }\n      });\n    });\n  }, [client]);\n  var logout = (0, import_react.useCallback)(function(opts2) {\n    if (opts2 === void 0) {\n      opts2 = {};\n    }\n    return __awaiter(void 0, void 0, void 0, function() {\n      return __generator(this, function(_a2) {\n        switch (_a2.label) {\n          case 0:\n            return [4, client.logout(opts2)];\n          case 1:\n            _a2.sent();\n            if (opts2.openUrl || opts2.openUrl === false) {\n              dispatch({ type: \"LOGOUT\" });\n            }\n            return [\n              2\n              /*return*/\n            ];\n        }\n      });\n    });\n  }, [client]);\n  var getAccessTokenSilently = (0, import_react.useCallback)(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    function(opts2) {\n      return __awaiter(void 0, void 0, void 0, function() {\n        var token, error_3, _a2;\n        var _b2;\n        return __generator(this, function(_c2) {\n          switch (_c2.label) {\n            case 0:\n              _c2.trys.push([0, 2, 3, 5]);\n              return [4, client.getTokenSilently(opts2)];\n            case 1:\n              token = _c2.sent();\n              return [3, 5];\n            case 2:\n              error_3 = _c2.sent();\n              throw tokenError(error_3);\n            case 3:\n              _a2 = dispatch;\n              _b2 = {\n                type: \"GET_ACCESS_TOKEN_COMPLETE\"\n              };\n              return [4, client.getUser()];\n            case 4:\n              _a2.apply(void 0, [(_b2.user = _c2.sent(), _b2)]);\n              return [\n                7\n                /*endfinally*/\n              ];\n            case 5:\n              return [2, token];\n          }\n        });\n      });\n    },\n    [client]\n  );\n  var getAccessTokenWithPopup = (0, import_react.useCallback)(function(opts2, config) {\n    return __awaiter(void 0, void 0, void 0, function() {\n      var token, error_4, _a2;\n      var _b2;\n      return __generator(this, function(_c2) {\n        switch (_c2.label) {\n          case 0:\n            _c2.trys.push([0, 2, 3, 5]);\n            return [4, client.getTokenWithPopup(opts2, config)];\n          case 1:\n            token = _c2.sent();\n            return [3, 5];\n          case 2:\n            error_4 = _c2.sent();\n            throw tokenError(error_4);\n          case 3:\n            _a2 = dispatch;\n            _b2 = {\n              type: \"GET_ACCESS_TOKEN_COMPLETE\"\n            };\n            return [4, client.getUser()];\n          case 4:\n            _a2.apply(void 0, [(_b2.user = _c2.sent(), _b2)]);\n            return [\n              7\n              /*endfinally*/\n            ];\n          case 5:\n            return [2, token];\n        }\n      });\n    });\n  }, [client]);\n  var getIdTokenClaims = (0, import_react.useCallback)(function() {\n    return client.getIdTokenClaims();\n  }, [client]);\n  var handleRedirectCallback = (0, import_react.useCallback)(function(url) {\n    return __awaiter(void 0, void 0, void 0, function() {\n      var error_5, _a2;\n      var _b2;\n      return __generator(this, function(_c2) {\n        switch (_c2.label) {\n          case 0:\n            _c2.trys.push([0, 2, 3, 5]);\n            return [4, client.handleRedirectCallback(url)];\n          case 1:\n            return [2, _c2.sent()];\n          case 2:\n            error_5 = _c2.sent();\n            throw tokenError(error_5);\n          case 3:\n            _a2 = dispatch;\n            _b2 = {\n              type: \"HANDLE_REDIRECT_COMPLETE\"\n            };\n            return [4, client.getUser()];\n          case 4:\n            _a2.apply(void 0, [(_b2.user = _c2.sent(), _b2)]);\n            return [\n              7\n              /*endfinally*/\n            ];\n          case 5:\n            return [\n              2\n              /*return*/\n            ];\n        }\n      });\n    });\n  }, [client]);\n  var contextValue = (0, import_react.useMemo)(function() {\n    return __assign(__assign({}, state), { getAccessTokenSilently, getAccessTokenWithPopup, getIdTokenClaims, loginWithRedirect, loginWithPopup, logout, handleRedirectCallback });\n  }, [\n    state,\n    getAccessTokenSilently,\n    getAccessTokenWithPopup,\n    getIdTokenClaims,\n    loginWithRedirect,\n    loginWithPopup,\n    logout,\n    handleRedirectCallback\n  ]);\n  return import_react.default.createElement(context.Provider, { value: contextValue }, children);\n};\nvar useAuth0 = function(context) {\n  if (context === void 0) {\n    context = Auth0Context;\n  }\n  return (0, import_react.useContext)(context);\n};\nvar withAuth0 = function(Component, context) {\n  if (context === void 0) {\n    context = Auth0Context;\n  }\n  return function WithAuth(props) {\n    return import_react.default.createElement(context.Consumer, null, function(auth) {\n      return import_react.default.createElement(Component, __assign({}, props, { auth0: auth }));\n    });\n  };\n};\nvar defaultOnRedirecting = function() {\n  return import_react.default.createElement(import_react.default.Fragment, null);\n};\nvar defaultOnBeforeAuthentication = function() {\n  return __awaiter(void 0, void 0, void 0, function() {\n    return __generator(this, function(_a) {\n      return [\n        2\n        /*return*/\n      ];\n    });\n  });\n};\nvar defaultReturnTo = function() {\n  return \"\".concat(window.location.pathname).concat(window.location.search);\n};\nvar withAuthenticationRequired = function(Component, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return function WithAuthenticationRequired(props) {\n    var _this = this;\n    var _a = options.returnTo, returnTo = _a === void 0 ? defaultReturnTo : _a, _b = options.onRedirecting, onRedirecting = _b === void 0 ? defaultOnRedirecting : _b, _c = options.onBeforeAuthentication, onBeforeAuthentication = _c === void 0 ? defaultOnBeforeAuthentication : _c, loginOptions = options.loginOptions, _d = options.context, context = _d === void 0 ? Auth0Context : _d;\n    var _e = useAuth0(context), isAuthenticated = _e.isAuthenticated, isLoading = _e.isLoading, loginWithRedirect = _e.loginWithRedirect;\n    (0, import_react.useEffect)(function() {\n      if (isLoading || isAuthenticated) {\n        return;\n      }\n      var opts = __assign(__assign({}, loginOptions), { appState: __assign(__assign({}, loginOptions && loginOptions.appState), { returnTo: typeof returnTo === \"function\" ? returnTo() : returnTo }) });\n      (function() {\n        return __awaiter(_this, void 0, void 0, function() {\n          return __generator(this, function(_a2) {\n            switch (_a2.label) {\n              case 0:\n                return [4, onBeforeAuthentication()];\n              case 1:\n                _a2.sent();\n                return [4, loginWithRedirect(opts)];\n              case 2:\n                _a2.sent();\n                return [\n                  2\n                  /*return*/\n                ];\n            }\n          });\n        });\n      })();\n    }, [\n      isLoading,\n      isAuthenticated,\n      loginWithRedirect,\n      onBeforeAuthentication,\n      loginOptions,\n      returnTo\n    ]);\n    return isAuthenticated ? import_react.default.createElement(Component, __assign({}, props)) : onRedirecting();\n  };\n};\nexport {\n  Auth0Context,\n  Auth0Provider,\n  u as AuthenticationError,\n  d as GenericError,\n  P as InMemoryCache,\n  z as LocalStorageCache,\n  m as MfaRequiredError,\n  f as MissingRefreshTokenError,\n  OAuthError,\n  p as PopupCancelledError,\n  h as PopupTimeoutError,\n  l as TimeoutError,\n  ie as User,\n  initialContext,\n  useAuth0,\n  withAuth0,\n  withAuthenticationRequired\n};\n//# sourceMappingURL=@auth0_auth0-react.js.map\n",
      "start": 1703474742330,
      "end": 1703474742331,
      "order": "normal",
      "sourcemaps": null
    }
  ]
}
