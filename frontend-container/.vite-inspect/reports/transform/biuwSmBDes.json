{
  "resolvedId": "/@react-refresh",
  "transforms": [
    {
      "name": "vite:react-refresh",
      "result": "\nconst exports = {}\n/**\n * @license React\n * react-refresh-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n'use strict';\n\n// ATTENTION\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\n\nvar PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map; // We never remove these associations.\n// It's OK to reference families, but use WeakMap/Set for types.\n\nvar allFamiliesByID = new Map();\nvar allFamiliesByType = new PossiblyWeakMap();\nvar allSignaturesByType = new PossiblyWeakMap(); // This WeakMap is read by React, so we only put families\n// that have actually been edited here. This keeps checks fast.\n// $FlowIssue\n\nvar updatedFamiliesByType = new PossiblyWeakMap(); // This is cleared on every performReactRefresh() call.\n// It is an array of [Family, NextType] tuples.\n\nvar pendingUpdates = []; // This is injected by the renderer via DevTools global hook.\n\nvar helpersByRendererID = new Map();\nvar helpersByRoot = new Map(); // We keep track of mounted roots so we can schedule updates.\n\nvar mountedRoots = new Set(); // If a root captures an error, we remember it so we can retry on edit.\n\nvar failedRoots = new Set(); // In environments that support WeakMap, we also remember the last element for every root.\n// It needs to be weak because we do this even for roots that failed to mount.\n// If there is no WeakMap, we won't attempt to do retrying.\n// $FlowIssue\n\nvar rootElements = // $FlowIssue\ntypeof WeakMap === 'function' ? new WeakMap() : null;\nvar isPerformingRefresh = false;\n\nfunction computeFullKey(signature) {\n  if (signature.fullKey !== null) {\n    return signature.fullKey;\n  }\n\n  var fullKey = signature.ownKey;\n  var hooks;\n\n  try {\n    hooks = signature.getCustomHooks();\n  } catch (err) {\n    // This can happen in an edge case, e.g. if expression like Foo.useSomething\n    // depends on Foo which is lazily initialized during rendering.\n    // In that case just assume we'll have to remount.\n    signature.forceReset = true;\n    signature.fullKey = fullKey;\n    return fullKey;\n  }\n\n  for (var i = 0; i < hooks.length; i++) {\n    var hook = hooks[i];\n\n    if (typeof hook !== 'function') {\n      // Something's wrong. Assume we need to remount.\n      signature.forceReset = true;\n      signature.fullKey = fullKey;\n      return fullKey;\n    }\n\n    var nestedHookSignature = allSignaturesByType.get(hook);\n\n    if (nestedHookSignature === undefined) {\n      // No signature means Hook wasn't in the source code, e.g. in a library.\n      // We'll skip it because we can assume it won't change during this session.\n      continue;\n    }\n\n    var nestedHookKey = computeFullKey(nestedHookSignature);\n\n    if (nestedHookSignature.forceReset) {\n      signature.forceReset = true;\n    }\n\n    fullKey += '\\n---\\n' + nestedHookKey;\n  }\n\n  signature.fullKey = fullKey;\n  return fullKey;\n}\n\nfunction haveEqualSignatures(prevType, nextType) {\n  var prevSignature = allSignaturesByType.get(prevType);\n  var nextSignature = allSignaturesByType.get(nextType);\n\n  if (prevSignature === undefined && nextSignature === undefined) {\n    return true;\n  }\n\n  if (prevSignature === undefined || nextSignature === undefined) {\n    return false;\n  }\n\n  if (computeFullKey(prevSignature) !== computeFullKey(nextSignature)) {\n    return false;\n  }\n\n  if (nextSignature.forceReset) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction isReactClass(type) {\n  return type.prototype && type.prototype.isReactComponent;\n}\n\nfunction canPreserveStateBetween(prevType, nextType) {\n  if (isReactClass(prevType) || isReactClass(nextType)) {\n    return false;\n  }\n\n  if (haveEqualSignatures(prevType, nextType)) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction resolveFamily(type) {\n  // Only check updated types to keep lookups fast.\n  return updatedFamiliesByType.get(type);\n} // If we didn't care about IE11, we could use new Map/Set(iterable).\n\n\nfunction cloneMap(map) {\n  var clone = new Map();\n  map.forEach(function (value, key) {\n    clone.set(key, value);\n  });\n  return clone;\n}\n\nfunction cloneSet(set) {\n  var clone = new Set();\n  set.forEach(function (value) {\n    clone.add(value);\n  });\n  return clone;\n} // This is a safety mechanism to protect against rogue getters and Proxies.\n\n\nfunction getProperty(object, property) {\n  try {\n    return object[property];\n  } catch (err) {\n    // Intentionally ignore.\n    return undefined;\n  }\n}\n\nfunction performReactRefresh() {\n\n  if (pendingUpdates.length === 0) {\n    return null;\n  }\n\n  if (isPerformingRefresh) {\n    return null;\n  }\n\n  isPerformingRefresh = true;\n\n  try {\n    var staleFamilies = new Set();\n    var updatedFamilies = new Set();\n    var updates = pendingUpdates;\n    pendingUpdates = [];\n    updates.forEach(function (_ref) {\n      var family = _ref[0],\n          nextType = _ref[1];\n      // Now that we got a real edit, we can create associations\n      // that will be read by the React reconciler.\n      var prevType = family.current;\n      updatedFamiliesByType.set(prevType, family);\n      updatedFamiliesByType.set(nextType, family);\n      family.current = nextType; // Determine whether this should be a re-render or a re-mount.\n\n      if (canPreserveStateBetween(prevType, nextType)) {\n        updatedFamilies.add(family);\n      } else {\n        staleFamilies.add(family);\n      }\n    }); // TODO: rename these fields to something more meaningful.\n\n    var update = {\n      updatedFamilies: updatedFamilies,\n      // Families that will re-render preserving state\n      staleFamilies: staleFamilies // Families that will be remounted\n\n    };\n    helpersByRendererID.forEach(function (helpers) {\n      // Even if there are no roots, set the handler on first update.\n      // This ensures that if *new* roots are mounted, they'll use the resolve handler.\n      helpers.setRefreshHandler(resolveFamily);\n    });\n    var didError = false;\n    var firstError = null; // We snapshot maps and sets that are mutated during commits.\n    // If we don't do this, there is a risk they will be mutated while\n    // we iterate over them. For example, trying to recover a failed root\n    // may cause another root to be added to the failed list -- an infinite loop.\n\n    var failedRootsSnapshot = cloneSet(failedRoots);\n    var mountedRootsSnapshot = cloneSet(mountedRoots);\n    var helpersByRootSnapshot = cloneMap(helpersByRoot);\n    failedRootsSnapshot.forEach(function (root) {\n      var helpers = helpersByRootSnapshot.get(root);\n\n      if (helpers === undefined) {\n        throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');\n      }\n\n      if (!failedRoots.has(root)) {// No longer failed.\n      }\n\n      if (rootElements === null) {\n        return;\n      }\n\n      if (!rootElements.has(root)) {\n        return;\n      }\n\n      var element = rootElements.get(root);\n\n      try {\n        helpers.scheduleRoot(root, element);\n      } catch (err) {\n        if (!didError) {\n          didError = true;\n          firstError = err;\n        } // Keep trying other roots.\n\n      }\n    });\n    mountedRootsSnapshot.forEach(function (root) {\n      var helpers = helpersByRootSnapshot.get(root);\n\n      if (helpers === undefined) {\n        throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');\n      }\n\n      if (!mountedRoots.has(root)) {// No longer mounted.\n      }\n\n      try {\n        helpers.scheduleRefresh(root, update);\n      } catch (err) {\n        if (!didError) {\n          didError = true;\n          firstError = err;\n        } // Keep trying other roots.\n\n      }\n    });\n\n    if (didError) {\n      throw firstError;\n    }\n\n    return update;\n  } finally {\n    isPerformingRefresh = false;\n  }\n}\nfunction register(type, id) {\n  {\n    if (type === null) {\n      return;\n    }\n\n    if (typeof type !== 'function' && typeof type !== 'object') {\n      return;\n    } // This can happen in an edge case, e.g. if we register\n    // return value of a HOC but it returns a cached component.\n    // Ignore anything but the first registration for each type.\n\n\n    if (allFamiliesByType.has(type)) {\n      return;\n    } // Create family or remember to update it.\n    // None of this bookkeeping affects reconciliation\n    // until the first performReactRefresh() call above.\n\n\n    var family = allFamiliesByID.get(id);\n\n    if (family === undefined) {\n      family = {\n        current: type\n      };\n      allFamiliesByID.set(id, family);\n    } else {\n      pendingUpdates.push([family, type]);\n    }\n\n    allFamiliesByType.set(type, family); // Visit inner types because we might not have registered them.\n\n    if (typeof type === 'object' && type !== null) {\n      switch (getProperty(type, '$$typeof')) {\n        case REACT_FORWARD_REF_TYPE:\n          register(type.render, id + '$render');\n          break;\n\n        case REACT_MEMO_TYPE:\n          register(type.type, id + '$type');\n          break;\n      }\n    }\n  }\n}\nfunction setSignature(type, key) {\n  var forceReset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var getCustomHooks = arguments.length > 3 ? arguments[3] : undefined;\n\n  {\n    if (!allSignaturesByType.has(type)) {\n      allSignaturesByType.set(type, {\n        forceReset: forceReset,\n        ownKey: key,\n        fullKey: null,\n        getCustomHooks: getCustomHooks || function () {\n          return [];\n        }\n      });\n    } // Visit inner types because we might not have signed them.\n\n\n    if (typeof type === 'object' && type !== null) {\n      switch (getProperty(type, '$$typeof')) {\n        case REACT_FORWARD_REF_TYPE:\n          setSignature(type.render, key, forceReset, getCustomHooks);\n          break;\n\n        case REACT_MEMO_TYPE:\n          setSignature(type.type, key, forceReset, getCustomHooks);\n          break;\n      }\n    }\n  }\n} // This is lazily called during first render for a type.\n// It captures Hook list at that time so inline requires don't break comparisons.\n\nfunction collectCustomHooksForSignature(type) {\n  {\n    var signature = allSignaturesByType.get(type);\n\n    if (signature !== undefined) {\n      computeFullKey(signature);\n    }\n  }\n}\nfunction getFamilyByID(id) {\n  {\n    return allFamiliesByID.get(id);\n  }\n}\nfunction getFamilyByType(type) {\n  {\n    return allFamiliesByType.get(type);\n  }\n}\nfunction findAffectedHostInstances(families) {\n  {\n    var affectedInstances = new Set();\n    mountedRoots.forEach(function (root) {\n      var helpers = helpersByRoot.get(root);\n\n      if (helpers === undefined) {\n        throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');\n      }\n\n      var instancesForRoot = helpers.findHostInstancesForRefresh(root, families);\n      instancesForRoot.forEach(function (inst) {\n        affectedInstances.add(inst);\n      });\n    });\n    return affectedInstances;\n  }\n}\nfunction injectIntoGlobalHook(globalObject) {\n  {\n    // For React Native, the global hook will be set up by require('react-devtools-core').\n    // That code will run before us. So we need to monkeypatch functions on existing hook.\n    // For React Web, the global hook will be set up by the extension.\n    // This will also run before us.\n    var hook = globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__;\n\n    if (hook === undefined) {\n      // However, if there is no DevTools extension, we'll need to set up the global hook ourselves.\n      // Note that in this case it's important that renderer code runs *after* this method call.\n      // Otherwise, the renderer will think that there is no global hook, and won't do the injection.\n      var nextID = 0;\n      globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__ = hook = {\n        renderers: new Map(),\n        supportsFiber: true,\n        inject: function (injected) {\n          return nextID++;\n        },\n        onScheduleFiberRoot: function (id, root, children) {},\n        onCommitFiberRoot: function (id, root, maybePriorityLevel, didError) {},\n        onCommitFiberUnmount: function () {}\n      };\n    }\n\n    if (hook.isDisabled) {\n      // This isn't a real property on the hook, but it can be set to opt out\n      // of DevTools integration and associated warnings and logs.\n      // Using console['warn'] to evade Babel and ESLint\n      console['warn']('Something has shimmed the React DevTools global hook (__REACT_DEVTOOLS_GLOBAL_HOOK__). ' + 'Fast Refresh is not compatible with this shim and will be disabled.');\n      return;\n    } // Here, we just want to get a reference to scheduleRefresh.\n\n\n    var oldInject = hook.inject;\n\n    hook.inject = function (injected) {\n      var id = oldInject.apply(this, arguments);\n\n      if (typeof injected.scheduleRefresh === 'function' && typeof injected.setRefreshHandler === 'function') {\n        // This version supports React Refresh.\n        helpersByRendererID.set(id, injected);\n      }\n\n      return id;\n    }; // Do the same for any already injected roots.\n    // This is useful if ReactDOM has already been initialized.\n    // https://github.com/facebook/react/issues/17626\n\n\n    hook.renderers.forEach(function (injected, id) {\n      if (typeof injected.scheduleRefresh === 'function' && typeof injected.setRefreshHandler === 'function') {\n        // This version supports React Refresh.\n        helpersByRendererID.set(id, injected);\n      }\n    }); // We also want to track currently mounted roots.\n\n    var oldOnCommitFiberRoot = hook.onCommitFiberRoot;\n\n    var oldOnScheduleFiberRoot = hook.onScheduleFiberRoot || function () {};\n\n    hook.onScheduleFiberRoot = function (id, root, children) {\n      if (!isPerformingRefresh) {\n        // If it was intentionally scheduled, don't attempt to restore.\n        // This includes intentionally scheduled unmounts.\n        failedRoots.delete(root);\n\n        if (rootElements !== null) {\n          rootElements.set(root, children);\n        }\n      }\n\n      return oldOnScheduleFiberRoot.apply(this, arguments);\n    };\n\n    hook.onCommitFiberRoot = function (id, root, maybePriorityLevel, didError) {\n      var helpers = helpersByRendererID.get(id);\n\n      if (helpers !== undefined) {\n        helpersByRoot.set(root, helpers);\n        var current = root.current;\n        var alternate = current.alternate; // We need to determine whether this root has just (un)mounted.\n        // This logic is copy-pasted from similar logic in the DevTools backend.\n        // If this breaks with some refactoring, you'll want to update DevTools too.\n\n        if (alternate !== null) {\n          var wasMounted = alternate.memoizedState != null && alternate.memoizedState.element != null && mountedRoots.has(root);\n          var isMounted = current.memoizedState != null && current.memoizedState.element != null;\n\n          if (!wasMounted && isMounted) {\n            // Mount a new root.\n            mountedRoots.add(root);\n            failedRoots.delete(root);\n          } else if (wasMounted && isMounted) ; else if (wasMounted && !isMounted) {\n            // Unmount an existing root.\n            mountedRoots.delete(root);\n\n            if (didError) {\n              // We'll remount it on future edits.\n              failedRoots.add(root);\n            } else {\n              helpersByRoot.delete(root);\n            }\n          } else if (!wasMounted && !isMounted) {\n            if (didError) {\n              // We'll remount it on future edits.\n              failedRoots.add(root);\n            }\n          }\n        } else {\n          // Mount a new root.\n          mountedRoots.add(root);\n        }\n      } // Always call the decorated DevTools hook.\n\n\n      return oldOnCommitFiberRoot.apply(this, arguments);\n    };\n  }\n}\nfunction hasUnrecoverableErrors() {\n  // TODO: delete this after removing dependency in RN.\n  return false;\n} // Exposed for testing.\n\nfunction _getMountedRootCount() {\n  {\n    return mountedRoots.size;\n  }\n} // This is a wrapper over more primitive functions for setting signature.\n// Signatures let us decide whether the Hook order has changed on refresh.\n//\n// This function is intended to be used as a transform target, e.g.:\n// var _s = createSignatureFunctionForTransform()\n//\n// function Hello() {\n//   const [foo, setFoo] = useState(0);\n//   const value = useCustomHook();\n//   _s(); /* Call without arguments triggers collecting the custom Hook list.\n//          * This doesn't happen during the module evaluation because we\n//          * don't want to change the module order with inline requires.\n//          * Next calls are noops. */\n//   return <h1>Hi</h1>;\n// }\n//\n// /* Call with arguments attaches the signature to the type: */\n// _s(\n//   Hello,\n//   'useState{[foo, setFoo]}(0)',\n//   () => [useCustomHook], /* Lazy to avoid triggering inline requires */\n// );\n\nfunction createSignatureFunctionForTransform() {\n  {\n    var savedType;\n    var hasCustomHooks;\n    var didCollectHooks = false;\n    return function (type, key, forceReset, getCustomHooks) {\n      if (typeof key === 'string') {\n        // We're in the initial phase that associates signatures\n        // with the functions. Note this may be called multiple times\n        // in HOC chains like _s(hoc1(_s(hoc2(_s(actualFunction))))).\n        if (!savedType) {\n          // We're in the innermost call, so this is the actual type.\n          savedType = type;\n          hasCustomHooks = typeof getCustomHooks === 'function';\n        } // Set the signature for all types (even wrappers!) in case\n        // they have no signatures of their own. This is to prevent\n        // problems like https://github.com/facebook/react/issues/20417.\n\n\n        if (type != null && (typeof type === 'function' || typeof type === 'object')) {\n          setSignature(type, key, forceReset, getCustomHooks);\n        }\n\n        return type;\n      } else {\n        // We're in the _s() call without arguments, which means\n        // this is the time to collect custom Hook signatures.\n        // Only do this once. This path is hot and runs *inside* every render!\n        if (!didCollectHooks && hasCustomHooks) {\n          didCollectHooks = true;\n          collectCustomHooksForSignature(savedType);\n        }\n      }\n    };\n  }\n}\nfunction isLikelyComponentType(type) {\n  {\n    switch (typeof type) {\n      case 'function':\n        {\n          // First, deal with classes.\n          if (type.prototype != null) {\n            if (type.prototype.isReactComponent) {\n              // React class.\n              return true;\n            }\n\n            var ownNames = Object.getOwnPropertyNames(type.prototype);\n\n            if (ownNames.length > 1 || ownNames[0] !== 'constructor') {\n              // This looks like a class.\n              return false;\n            } // eslint-disable-next-line no-proto\n\n\n            if (type.prototype.__proto__ !== Object.prototype) {\n              // It has a superclass.\n              return false;\n            } // Pass through.\n            // This looks like a regular function with empty prototype.\n\n          } // For plain functions and arrows, use name as a heuristic.\n\n\n          var name = type.name || type.displayName;\n          return typeof name === 'string' && /^[A-Z]/.test(name);\n        }\n\n      case 'object':\n        {\n          if (type != null) {\n            switch (getProperty(type, '$$typeof')) {\n              case REACT_FORWARD_REF_TYPE:\n              case REACT_MEMO_TYPE:\n                // Definitely React components.\n                return true;\n\n              default:\n                return false;\n            }\n          }\n\n          return false;\n        }\n\n      default:\n        {\n          return false;\n        }\n    }\n  }\n}\n\nexports._getMountedRootCount = _getMountedRootCount;\nexports.collectCustomHooksForSignature = collectCustomHooksForSignature;\nexports.createSignatureFunctionForTransform = createSignatureFunctionForTransform;\nexports.findAffectedHostInstances = findAffectedHostInstances;\nexports.getFamilyByID = getFamilyByID;\nexports.getFamilyByType = getFamilyByType;\nexports.hasUnrecoverableErrors = hasUnrecoverableErrors;\nexports.injectIntoGlobalHook = injectIntoGlobalHook;\nexports.isLikelyComponentType = isLikelyComponentType;\nexports.performReactRefresh = performReactRefresh;\nexports.register = register;\nexports.setSignature = setSignature;\n  })();\n}\n\nfunction debounce(fn, delay) {\n  let handle\n  return () => {\n    clearTimeout(handle)\n    handle = setTimeout(fn, delay)\n  }\n}\n\n/* eslint-disable no-undef */\nconst enqueueUpdate = debounce(exports.performReactRefresh, 16)\n\n// Taken from https://github.com/pmmmwh/react-refresh-webpack-plugin/blob/main/lib/runtime/RefreshUtils.js#L141\n// This allows to resister components not detected by SWC like styled component\nfunction registerExportsForReactRefresh(filename, moduleExports) {\n  for (const key in moduleExports) {\n    if (key === '__esModule') continue\n    const exportValue = moduleExports[key]\n    if (exports.isLikelyComponentType(exportValue)) {\n      // 'export' is required to avoid key collision when renamed exports that\n      // shadow a local component name: https://github.com/vitejs/vite-plugin-react/issues/116\n      // The register function has an identity check to not register twice the same component,\n      // so this is safe to not used the same key here.\n      exports.register(exportValue, filename + ' export ' + key)\n    }\n  }\n}\n\nfunction validateRefreshBoundaryAndEnqueueUpdate(prevExports, nextExports) {\n  if (!predicateOnExport(prevExports, (key) => key in nextExports)) {\n    return 'Could not Fast Refresh (export removed)'\n  }\n  if (!predicateOnExport(nextExports, (key) => key in prevExports)) {\n    return 'Could not Fast Refresh (new export)'\n  }\n\n  let hasExports = false\n  const allExportsAreComponentsOrUnchanged = predicateOnExport(\n    nextExports,\n    (key, value) => {\n      hasExports = true\n      if (exports.isLikelyComponentType(value)) return true\n      return prevExports[key] === nextExports[key]\n    },\n  )\n  if (hasExports && allExportsAreComponentsOrUnchanged) {\n    enqueueUpdate()\n  } else {\n    return 'Could not Fast Refresh. Learn more at https://github.com/vitejs/vite-plugin-react/tree/main/packages/plugin-react#consistent-components-exports'\n  }\n}\n\nfunction predicateOnExport(moduleExports, predicate) {\n  for (const key in moduleExports) {\n    if (key === '__esModule') continue\n    const desc = Object.getOwnPropertyDescriptor(moduleExports, key)\n    if (desc && desc.get) return false\n    if (!predicate(key, moduleExports[key])) return false\n  }\n  return true\n}\n\n// Hides vite-ignored dynamic import so that Vite can skip analysis if no other\n// dynamic import is present (https://github.com/vitejs/vite/pull/12732)\nfunction __hmr_import(module) {\n  return import(/* @vite-ignore */ module)\n}\n\nexports.__hmr_import = __hmr_import\nexports.registerExportsForReactRefresh = registerExportsForReactRefresh\nexports.validateRefreshBoundaryAndEnqueueUpdate =\n  validateRefreshBoundaryAndEnqueueUpdate\n\nexport default exports\n",
      "start": 1703474738283,
      "end": 1703474738283,
      "sourcemaps": null
    },
    {
      "name": "vite:react-babel",
      "start": 1703474738283,
      "end": 1703474738283,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1703474738283,
      "end": 1703474738283,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1703474738284,
      "end": 1703474738284,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1703474738284,
      "end": 1703474738284,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1703474738284,
      "end": 1703474738284,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1703474738284,
      "end": 1703474738284,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1703474738284,
      "end": 1703474738285,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1703474738285,
      "end": 1703474738285,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1703474738285,
      "end": 1703474738285,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1703474738285,
      "end": 1703474738286,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1703474738286,
      "end": 1703474738286,
      "order": "normal"
    },
    {
      "name": "vite:client-inject",
      "result": "const exports = {};\n/**\n * @license React\n * react-refresh-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\"use strict\";\nif (true) {\n  (function() {\n    \"use strict\";\n    var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n    var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n    var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map;\n    var allFamiliesByID = /* @__PURE__ */ new Map();\n    var allFamiliesByType = new PossiblyWeakMap();\n    var allSignaturesByType = new PossiblyWeakMap();\n    var updatedFamiliesByType = new PossiblyWeakMap();\n    var pendingUpdates = [];\n    var helpersByRendererID = /* @__PURE__ */ new Map();\n    var helpersByRoot = /* @__PURE__ */ new Map();\n    var mountedRoots = /* @__PURE__ */ new Set();\n    var failedRoots = /* @__PURE__ */ new Set();\n    var rootElements = (\n      // $FlowIssue\n      typeof WeakMap === \"function\" ? /* @__PURE__ */ new WeakMap() : null\n    );\n    var isPerformingRefresh = false;\n    function computeFullKey(signature) {\n      if (signature.fullKey !== null) {\n        return signature.fullKey;\n      }\n      var fullKey = signature.ownKey;\n      var hooks;\n      try {\n        hooks = signature.getCustomHooks();\n      } catch (err) {\n        signature.forceReset = true;\n        signature.fullKey = fullKey;\n        return fullKey;\n      }\n      for (var i = 0; i < hooks.length; i++) {\n        var hook = hooks[i];\n        if (typeof hook !== \"function\") {\n          signature.forceReset = true;\n          signature.fullKey = fullKey;\n          return fullKey;\n        }\n        var nestedHookSignature = allSignaturesByType.get(hook);\n        if (nestedHookSignature === void 0) {\n          continue;\n        }\n        var nestedHookKey = computeFullKey(nestedHookSignature);\n        if (nestedHookSignature.forceReset) {\n          signature.forceReset = true;\n        }\n        fullKey += \"\\n---\\n\" + nestedHookKey;\n      }\n      signature.fullKey = fullKey;\n      return fullKey;\n    }\n    function haveEqualSignatures(prevType, nextType) {\n      var prevSignature = allSignaturesByType.get(prevType);\n      var nextSignature = allSignaturesByType.get(nextType);\n      if (prevSignature === void 0 && nextSignature === void 0) {\n        return true;\n      }\n      if (prevSignature === void 0 || nextSignature === void 0) {\n        return false;\n      }\n      if (computeFullKey(prevSignature) !== computeFullKey(nextSignature)) {\n        return false;\n      }\n      if (nextSignature.forceReset) {\n        return false;\n      }\n      return true;\n    }\n    function isReactClass(type) {\n      return type.prototype && type.prototype.isReactComponent;\n    }\n    function canPreserveStateBetween(prevType, nextType) {\n      if (isReactClass(prevType) || isReactClass(nextType)) {\n        return false;\n      }\n      if (haveEqualSignatures(prevType, nextType)) {\n        return true;\n      }\n      return false;\n    }\n    function resolveFamily(type) {\n      return updatedFamiliesByType.get(type);\n    }\n    function cloneMap(map) {\n      var clone = /* @__PURE__ */ new Map();\n      map.forEach(function(value, key) {\n        clone.set(key, value);\n      });\n      return clone;\n    }\n    function cloneSet(set) {\n      var clone = /* @__PURE__ */ new Set();\n      set.forEach(function(value) {\n        clone.add(value);\n      });\n      return clone;\n    }\n    function getProperty(object, property) {\n      try {\n        return object[property];\n      } catch (err) {\n        return void 0;\n      }\n    }\n    function performReactRefresh() {\n      if (pendingUpdates.length === 0) {\n        return null;\n      }\n      if (isPerformingRefresh) {\n        return null;\n      }\n      isPerformingRefresh = true;\n      try {\n        var staleFamilies = /* @__PURE__ */ new Set();\n        var updatedFamilies = /* @__PURE__ */ new Set();\n        var updates = pendingUpdates;\n        pendingUpdates = [];\n        updates.forEach(function(_ref) {\n          var family = _ref[0], nextType = _ref[1];\n          var prevType = family.current;\n          updatedFamiliesByType.set(prevType, family);\n          updatedFamiliesByType.set(nextType, family);\n          family.current = nextType;\n          if (canPreserveStateBetween(prevType, nextType)) {\n            updatedFamilies.add(family);\n          } else {\n            staleFamilies.add(family);\n          }\n        });\n        var update = {\n          updatedFamilies,\n          // Families that will re-render preserving state\n          staleFamilies\n          // Families that will be remounted\n        };\n        helpersByRendererID.forEach(function(helpers) {\n          helpers.setRefreshHandler(resolveFamily);\n        });\n        var didError = false;\n        var firstError = null;\n        var failedRootsSnapshot = cloneSet(failedRoots);\n        var mountedRootsSnapshot = cloneSet(mountedRoots);\n        var helpersByRootSnapshot = cloneMap(helpersByRoot);\n        failedRootsSnapshot.forEach(function(root) {\n          var helpers = helpersByRootSnapshot.get(root);\n          if (helpers === void 0) {\n            throw new Error(\"Could not find helpers for a root. This is a bug in React Refresh.\");\n          }\n          if (!failedRoots.has(root)) {\n          }\n          if (rootElements === null) {\n            return;\n          }\n          if (!rootElements.has(root)) {\n            return;\n          }\n          var element = rootElements.get(root);\n          try {\n            helpers.scheduleRoot(root, element);\n          } catch (err) {\n            if (!didError) {\n              didError = true;\n              firstError = err;\n            }\n          }\n        });\n        mountedRootsSnapshot.forEach(function(root) {\n          var helpers = helpersByRootSnapshot.get(root);\n          if (helpers === void 0) {\n            throw new Error(\"Could not find helpers for a root. This is a bug in React Refresh.\");\n          }\n          if (!mountedRoots.has(root)) {\n          }\n          try {\n            helpers.scheduleRefresh(root, update);\n          } catch (err) {\n            if (!didError) {\n              didError = true;\n              firstError = err;\n            }\n          }\n        });\n        if (didError) {\n          throw firstError;\n        }\n        return update;\n      } finally {\n        isPerformingRefresh = false;\n      }\n    }\n    function register(type, id) {\n      {\n        if (type === null) {\n          return;\n        }\n        if (typeof type !== \"function\" && typeof type !== \"object\") {\n          return;\n        }\n        if (allFamiliesByType.has(type)) {\n          return;\n        }\n        var family = allFamiliesByID.get(id);\n        if (family === void 0) {\n          family = {\n            current: type\n          };\n          allFamiliesByID.set(id, family);\n        } else {\n          pendingUpdates.push([family, type]);\n        }\n        allFamiliesByType.set(type, family);\n        if (typeof type === \"object\" && type !== null) {\n          switch (getProperty(type, \"$$typeof\")) {\n            case REACT_FORWARD_REF_TYPE:\n              register(type.render, id + \"$render\");\n              break;\n            case REACT_MEMO_TYPE:\n              register(type.type, id + \"$type\");\n              break;\n          }\n        }\n      }\n    }\n    function setSignature(type, key) {\n      var forceReset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n      var getCustomHooks = arguments.length > 3 ? arguments[3] : void 0;\n      {\n        if (!allSignaturesByType.has(type)) {\n          allSignaturesByType.set(type, {\n            forceReset,\n            ownKey: key,\n            fullKey: null,\n            getCustomHooks: getCustomHooks || function() {\n              return [];\n            }\n          });\n        }\n        if (typeof type === \"object\" && type !== null) {\n          switch (getProperty(type, \"$$typeof\")) {\n            case REACT_FORWARD_REF_TYPE:\n              setSignature(type.render, key, forceReset, getCustomHooks);\n              break;\n            case REACT_MEMO_TYPE:\n              setSignature(type.type, key, forceReset, getCustomHooks);\n              break;\n          }\n        }\n      }\n    }\n    function collectCustomHooksForSignature(type) {\n      {\n        var signature = allSignaturesByType.get(type);\n        if (signature !== void 0) {\n          computeFullKey(signature);\n        }\n      }\n    }\n    function getFamilyByID(id) {\n      {\n        return allFamiliesByID.get(id);\n      }\n    }\n    function getFamilyByType(type) {\n      {\n        return allFamiliesByType.get(type);\n      }\n    }\n    function findAffectedHostInstances(families) {\n      {\n        var affectedInstances = /* @__PURE__ */ new Set();\n        mountedRoots.forEach(function(root) {\n          var helpers = helpersByRoot.get(root);\n          if (helpers === void 0) {\n            throw new Error(\"Could not find helpers for a root. This is a bug in React Refresh.\");\n          }\n          var instancesForRoot = helpers.findHostInstancesForRefresh(root, families);\n          instancesForRoot.forEach(function(inst) {\n            affectedInstances.add(inst);\n          });\n        });\n        return affectedInstances;\n      }\n    }\n    function injectIntoGlobalHook(globalObject) {\n      {\n        var hook = globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__;\n        if (hook === void 0) {\n          var nextID = 0;\n          globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__ = hook = {\n            renderers: /* @__PURE__ */ new Map(),\n            supportsFiber: true,\n            inject: function(injected) {\n              return nextID++;\n            },\n            onScheduleFiberRoot: function(id, root, children) {\n            },\n            onCommitFiberRoot: function(id, root, maybePriorityLevel, didError) {\n            },\n            onCommitFiberUnmount: function() {\n            }\n          };\n        }\n        if (hook.isDisabled) {\n          console[\"warn\"](\"Something has shimmed the React DevTools global hook (__REACT_DEVTOOLS_GLOBAL_HOOK__). Fast Refresh is not compatible with this shim and will be disabled.\");\n          return;\n        }\n        var oldInject = hook.inject;\n        hook.inject = function(injected) {\n          var id = oldInject.apply(this, arguments);\n          if (typeof injected.scheduleRefresh === \"function\" && typeof injected.setRefreshHandler === \"function\") {\n            helpersByRendererID.set(id, injected);\n          }\n          return id;\n        };\n        hook.renderers.forEach(function(injected, id) {\n          if (typeof injected.scheduleRefresh === \"function\" && typeof injected.setRefreshHandler === \"function\") {\n            helpersByRendererID.set(id, injected);\n          }\n        });\n        var oldOnCommitFiberRoot = hook.onCommitFiberRoot;\n        var oldOnScheduleFiberRoot = hook.onScheduleFiberRoot || function() {\n        };\n        hook.onScheduleFiberRoot = function(id, root, children) {\n          if (!isPerformingRefresh) {\n            failedRoots.delete(root);\n            if (rootElements !== null) {\n              rootElements.set(root, children);\n            }\n          }\n          return oldOnScheduleFiberRoot.apply(this, arguments);\n        };\n        hook.onCommitFiberRoot = function(id, root, maybePriorityLevel, didError) {\n          var helpers = helpersByRendererID.get(id);\n          if (helpers !== void 0) {\n            helpersByRoot.set(root, helpers);\n            var current = root.current;\n            var alternate = current.alternate;\n            if (alternate !== null) {\n              var wasMounted = alternate.memoizedState != null && alternate.memoizedState.element != null && mountedRoots.has(root);\n              var isMounted = current.memoizedState != null && current.memoizedState.element != null;\n              if (!wasMounted && isMounted) {\n                mountedRoots.add(root);\n                failedRoots.delete(root);\n              } else if (wasMounted && isMounted)\n                ;\n              else if (wasMounted && !isMounted) {\n                mountedRoots.delete(root);\n                if (didError) {\n                  failedRoots.add(root);\n                } else {\n                  helpersByRoot.delete(root);\n                }\n              } else if (!wasMounted && !isMounted) {\n                if (didError) {\n                  failedRoots.add(root);\n                }\n              }\n            } else {\n              mountedRoots.add(root);\n            }\n          }\n          return oldOnCommitFiberRoot.apply(this, arguments);\n        };\n      }\n    }\n    function hasUnrecoverableErrors() {\n      return false;\n    }\n    function _getMountedRootCount() {\n      {\n        return mountedRoots.size;\n      }\n    }\n    function createSignatureFunctionForTransform() {\n      {\n        var savedType;\n        var hasCustomHooks;\n        var didCollectHooks = false;\n        return function(type, key, forceReset, getCustomHooks) {\n          if (typeof key === \"string\") {\n            if (!savedType) {\n              savedType = type;\n              hasCustomHooks = typeof getCustomHooks === \"function\";\n            }\n            if (type != null && (typeof type === \"function\" || typeof type === \"object\")) {\n              setSignature(type, key, forceReset, getCustomHooks);\n            }\n            return type;\n          } else {\n            if (!didCollectHooks && hasCustomHooks) {\n              didCollectHooks = true;\n              collectCustomHooksForSignature(savedType);\n            }\n          }\n        };\n      }\n    }\n    function isLikelyComponentType(type) {\n      {\n        switch (typeof type) {\n          case \"function\": {\n            if (type.prototype != null) {\n              if (type.prototype.isReactComponent) {\n                return true;\n              }\n              var ownNames = Object.getOwnPropertyNames(type.prototype);\n              if (ownNames.length > 1 || ownNames[0] !== \"constructor\") {\n                return false;\n              }\n              if (type.prototype.__proto__ !== Object.prototype) {\n                return false;\n              }\n            }\n            var name = type.name || type.displayName;\n            return typeof name === \"string\" && /^[A-Z]/.test(name);\n          }\n          case \"object\": {\n            if (type != null) {\n              switch (getProperty(type, \"$$typeof\")) {\n                case REACT_FORWARD_REF_TYPE:\n                case REACT_MEMO_TYPE:\n                  return true;\n                default:\n                  return false;\n              }\n            }\n            return false;\n          }\n          default: {\n            return false;\n          }\n        }\n      }\n    }\n    exports._getMountedRootCount = _getMountedRootCount;\n    exports.collectCustomHooksForSignature = collectCustomHooksForSignature;\n    exports.createSignatureFunctionForTransform = createSignatureFunctionForTransform;\n    exports.findAffectedHostInstances = findAffectedHostInstances;\n    exports.getFamilyByID = getFamilyByID;\n    exports.getFamilyByType = getFamilyByType;\n    exports.hasUnrecoverableErrors = hasUnrecoverableErrors;\n    exports.injectIntoGlobalHook = injectIntoGlobalHook;\n    exports.isLikelyComponentType = isLikelyComponentType;\n    exports.performReactRefresh = performReactRefresh;\n    exports.register = register;\n    exports.setSignature = setSignature;\n  })();\n}\nfunction debounce(fn, delay) {\n  let handle;\n  return () => {\n    clearTimeout(handle);\n    handle = setTimeout(fn, delay);\n  };\n}\nconst enqueueUpdate = debounce(exports.performReactRefresh, 16);\nfunction registerExportsForReactRefresh(filename, moduleExports) {\n  for (const key in moduleExports) {\n    if (key === \"__esModule\")\n      continue;\n    const exportValue = moduleExports[key];\n    if (exports.isLikelyComponentType(exportValue)) {\n      exports.register(exportValue, filename + \" export \" + key);\n    }\n  }\n}\nfunction validateRefreshBoundaryAndEnqueueUpdate(prevExports, nextExports) {\n  if (!predicateOnExport(prevExports, (key) => key in nextExports)) {\n    return \"Could not Fast Refresh (export removed)\";\n  }\n  if (!predicateOnExport(nextExports, (key) => key in prevExports)) {\n    return \"Could not Fast Refresh (new export)\";\n  }\n  let hasExports = false;\n  const allExportsAreComponentsOrUnchanged = predicateOnExport(\n    nextExports,\n    (key, value) => {\n      hasExports = true;\n      if (exports.isLikelyComponentType(value))\n        return true;\n      return prevExports[key] === nextExports[key];\n    }\n  );\n  if (hasExports && allExportsAreComponentsOrUnchanged) {\n    enqueueUpdate();\n  } else {\n    return \"Could not Fast Refresh. Learn more at https://github.com/vitejs/vite-plugin-react/tree/main/packages/plugin-react#consistent-components-exports\";\n  }\n}\nfunction predicateOnExport(moduleExports, predicate) {\n  for (const key in moduleExports) {\n    if (key === \"__esModule\")\n      continue;\n    const desc = Object.getOwnPropertyDescriptor(moduleExports, key);\n    if (desc && desc.get)\n      return false;\n    if (!predicate(key, moduleExports[key]))\n      return false;\n  }\n  return true;\n}\nfunction __hmr_import(module) {\n  return import(\n    /* @vite-ignore */\n    module\n  );\n}\nexports.__hmr_import = __hmr_import;\nexports.registerExportsForReactRefresh = registerExportsForReactRefresh;\nexports.validateRefreshBoundaryAndEnqueueUpdate = validateRefreshBoundaryAndEnqueueUpdate;\nexport default exports;\n",
      "start": 1703474738286,
      "end": 1703474738430,
      "order": "normal",
      "sourcemaps": "{\n  \"version\": 3,\n  \"sources\": [\"/@react-refresh\"],\n  \"sourcesContent\": [\"\\nconst exports = {}\\n/**\\n * @license React\\n * react-refresh-runtime.development.js\\n *\\n * Copyright (c) Facebook, Inc. and its affiliates.\\n *\\n * This source code is licensed under the MIT license found in the\\n * LICENSE file in the root directory of this source tree.\\n */\\n\\n'use strict';\\n\\nif (process.env.NODE_ENV !== \\\"production\\\") {\\n  (function() {\\n'use strict';\\n\\n// ATTENTION\\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\\n\\nvar PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map; // We never remove these associations.\\n// It's OK to reference families, but use WeakMap/Set for types.\\n\\nvar allFamiliesByID = new Map();\\nvar allFamiliesByType = new PossiblyWeakMap();\\nvar allSignaturesByType = new PossiblyWeakMap(); // This WeakMap is read by React, so we only put families\\n// that have actually been edited here. This keeps checks fast.\\n// $FlowIssue\\n\\nvar updatedFamiliesByType = new PossiblyWeakMap(); // This is cleared on every performReactRefresh() call.\\n// It is an array of [Family, NextType] tuples.\\n\\nvar pendingUpdates = []; // This is injected by the renderer via DevTools global hook.\\n\\nvar helpersByRendererID = new Map();\\nvar helpersByRoot = new Map(); // We keep track of mounted roots so we can schedule updates.\\n\\nvar mountedRoots = new Set(); // If a root captures an error, we remember it so we can retry on edit.\\n\\nvar failedRoots = new Set(); // In environments that support WeakMap, we also remember the last element for every root.\\n// It needs to be weak because we do this even for roots that failed to mount.\\n// If there is no WeakMap, we won't attempt to do retrying.\\n// $FlowIssue\\n\\nvar rootElements = // $FlowIssue\\ntypeof WeakMap === 'function' ? new WeakMap() : null;\\nvar isPerformingRefresh = false;\\n\\nfunction computeFullKey(signature) {\\n  if (signature.fullKey !== null) {\\n    return signature.fullKey;\\n  }\\n\\n  var fullKey = signature.ownKey;\\n  var hooks;\\n\\n  try {\\n    hooks = signature.getCustomHooks();\\n  } catch (err) {\\n    // This can happen in an edge case, e.g. if expression like Foo.useSomething\\n    // depends on Foo which is lazily initialized during rendering.\\n    // In that case just assume we'll have to remount.\\n    signature.forceReset = true;\\n    signature.fullKey = fullKey;\\n    return fullKey;\\n  }\\n\\n  for (var i = 0; i < hooks.length; i++) {\\n    var hook = hooks[i];\\n\\n    if (typeof hook !== 'function') {\\n      // Something's wrong. Assume we need to remount.\\n      signature.forceReset = true;\\n      signature.fullKey = fullKey;\\n      return fullKey;\\n    }\\n\\n    var nestedHookSignature = allSignaturesByType.get(hook);\\n\\n    if (nestedHookSignature === undefined) {\\n      // No signature means Hook wasn't in the source code, e.g. in a library.\\n      // We'll skip it because we can assume it won't change during this session.\\n      continue;\\n    }\\n\\n    var nestedHookKey = computeFullKey(nestedHookSignature);\\n\\n    if (nestedHookSignature.forceReset) {\\n      signature.forceReset = true;\\n    }\\n\\n    fullKey += '\\\\n---\\\\n' + nestedHookKey;\\n  }\\n\\n  signature.fullKey = fullKey;\\n  return fullKey;\\n}\\n\\nfunction haveEqualSignatures(prevType, nextType) {\\n  var prevSignature = allSignaturesByType.get(prevType);\\n  var nextSignature = allSignaturesByType.get(nextType);\\n\\n  if (prevSignature === undefined && nextSignature === undefined) {\\n    return true;\\n  }\\n\\n  if (prevSignature === undefined || nextSignature === undefined) {\\n    return false;\\n  }\\n\\n  if (computeFullKey(prevSignature) !== computeFullKey(nextSignature)) {\\n    return false;\\n  }\\n\\n  if (nextSignature.forceReset) {\\n    return false;\\n  }\\n\\n  return true;\\n}\\n\\nfunction isReactClass(type) {\\n  return type.prototype && type.prototype.isReactComponent;\\n}\\n\\nfunction canPreserveStateBetween(prevType, nextType) {\\n  if (isReactClass(prevType) || isReactClass(nextType)) {\\n    return false;\\n  }\\n\\n  if (haveEqualSignatures(prevType, nextType)) {\\n    return true;\\n  }\\n\\n  return false;\\n}\\n\\nfunction resolveFamily(type) {\\n  // Only check updated types to keep lookups fast.\\n  return updatedFamiliesByType.get(type);\\n} // If we didn't care about IE11, we could use new Map/Set(iterable).\\n\\n\\nfunction cloneMap(map) {\\n  var clone = new Map();\\n  map.forEach(function (value, key) {\\n    clone.set(key, value);\\n  });\\n  return clone;\\n}\\n\\nfunction cloneSet(set) {\\n  var clone = new Set();\\n  set.forEach(function (value) {\\n    clone.add(value);\\n  });\\n  return clone;\\n} // This is a safety mechanism to protect against rogue getters and Proxies.\\n\\n\\nfunction getProperty(object, property) {\\n  try {\\n    return object[property];\\n  } catch (err) {\\n    // Intentionally ignore.\\n    return undefined;\\n  }\\n}\\n\\nfunction performReactRefresh() {\\n\\n  if (pendingUpdates.length === 0) {\\n    return null;\\n  }\\n\\n  if (isPerformingRefresh) {\\n    return null;\\n  }\\n\\n  isPerformingRefresh = true;\\n\\n  try {\\n    var staleFamilies = new Set();\\n    var updatedFamilies = new Set();\\n    var updates = pendingUpdates;\\n    pendingUpdates = [];\\n    updates.forEach(function (_ref) {\\n      var family = _ref[0],\\n          nextType = _ref[1];\\n      // Now that we got a real edit, we can create associations\\n      // that will be read by the React reconciler.\\n      var prevType = family.current;\\n      updatedFamiliesByType.set(prevType, family);\\n      updatedFamiliesByType.set(nextType, family);\\n      family.current = nextType; // Determine whether this should be a re-render or a re-mount.\\n\\n      if (canPreserveStateBetween(prevType, nextType)) {\\n        updatedFamilies.add(family);\\n      } else {\\n        staleFamilies.add(family);\\n      }\\n    }); // TODO: rename these fields to something more meaningful.\\n\\n    var update = {\\n      updatedFamilies: updatedFamilies,\\n      // Families that will re-render preserving state\\n      staleFamilies: staleFamilies // Families that will be remounted\\n\\n    };\\n    helpersByRendererID.forEach(function (helpers) {\\n      // Even if there are no roots, set the handler on first update.\\n      // This ensures that if *new* roots are mounted, they'll use the resolve handler.\\n      helpers.setRefreshHandler(resolveFamily);\\n    });\\n    var didError = false;\\n    var firstError = null; // We snapshot maps and sets that are mutated during commits.\\n    // If we don't do this, there is a risk they will be mutated while\\n    // we iterate over them. For example, trying to recover a failed root\\n    // may cause another root to be added to the failed list -- an infinite loop.\\n\\n    var failedRootsSnapshot = cloneSet(failedRoots);\\n    var mountedRootsSnapshot = cloneSet(mountedRoots);\\n    var helpersByRootSnapshot = cloneMap(helpersByRoot);\\n    failedRootsSnapshot.forEach(function (root) {\\n      var helpers = helpersByRootSnapshot.get(root);\\n\\n      if (helpers === undefined) {\\n        throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');\\n      }\\n\\n      if (!failedRoots.has(root)) {// No longer failed.\\n      }\\n\\n      if (rootElements === null) {\\n        return;\\n      }\\n\\n      if (!rootElements.has(root)) {\\n        return;\\n      }\\n\\n      var element = rootElements.get(root);\\n\\n      try {\\n        helpers.scheduleRoot(root, element);\\n      } catch (err) {\\n        if (!didError) {\\n          didError = true;\\n          firstError = err;\\n        } // Keep trying other roots.\\n\\n      }\\n    });\\n    mountedRootsSnapshot.forEach(function (root) {\\n      var helpers = helpersByRootSnapshot.get(root);\\n\\n      if (helpers === undefined) {\\n        throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');\\n      }\\n\\n      if (!mountedRoots.has(root)) {// No longer mounted.\\n      }\\n\\n      try {\\n        helpers.scheduleRefresh(root, update);\\n      } catch (err) {\\n        if (!didError) {\\n          didError = true;\\n          firstError = err;\\n        } // Keep trying other roots.\\n\\n      }\\n    });\\n\\n    if (didError) {\\n      throw firstError;\\n    }\\n\\n    return update;\\n  } finally {\\n    isPerformingRefresh = false;\\n  }\\n}\\nfunction register(type, id) {\\n  {\\n    if (type === null) {\\n      return;\\n    }\\n\\n    if (typeof type !== 'function' && typeof type !== 'object') {\\n      return;\\n    } // This can happen in an edge case, e.g. if we register\\n    // return value of a HOC but it returns a cached component.\\n    // Ignore anything but the first registration for each type.\\n\\n\\n    if (allFamiliesByType.has(type)) {\\n      return;\\n    } // Create family or remember to update it.\\n    // None of this bookkeeping affects reconciliation\\n    // until the first performReactRefresh() call above.\\n\\n\\n    var family = allFamiliesByID.get(id);\\n\\n    if (family === undefined) {\\n      family = {\\n        current: type\\n      };\\n      allFamiliesByID.set(id, family);\\n    } else {\\n      pendingUpdates.push([family, type]);\\n    }\\n\\n    allFamiliesByType.set(type, family); // Visit inner types because we might not have registered them.\\n\\n    if (typeof type === 'object' && type !== null) {\\n      switch (getProperty(type, '$$typeof')) {\\n        case REACT_FORWARD_REF_TYPE:\\n          register(type.render, id + '$render');\\n          break;\\n\\n        case REACT_MEMO_TYPE:\\n          register(type.type, id + '$type');\\n          break;\\n      }\\n    }\\n  }\\n}\\nfunction setSignature(type, key) {\\n  var forceReset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\\n  var getCustomHooks = arguments.length > 3 ? arguments[3] : undefined;\\n\\n  {\\n    if (!allSignaturesByType.has(type)) {\\n      allSignaturesByType.set(type, {\\n        forceReset: forceReset,\\n        ownKey: key,\\n        fullKey: null,\\n        getCustomHooks: getCustomHooks || function () {\\n          return [];\\n        }\\n      });\\n    } // Visit inner types because we might not have signed them.\\n\\n\\n    if (typeof type === 'object' && type !== null) {\\n      switch (getProperty(type, '$$typeof')) {\\n        case REACT_FORWARD_REF_TYPE:\\n          setSignature(type.render, key, forceReset, getCustomHooks);\\n          break;\\n\\n        case REACT_MEMO_TYPE:\\n          setSignature(type.type, key, forceReset, getCustomHooks);\\n          break;\\n      }\\n    }\\n  }\\n} // This is lazily called during first render for a type.\\n// It captures Hook list at that time so inline requires don't break comparisons.\\n\\nfunction collectCustomHooksForSignature(type) {\\n  {\\n    var signature = allSignaturesByType.get(type);\\n\\n    if (signature !== undefined) {\\n      computeFullKey(signature);\\n    }\\n  }\\n}\\nfunction getFamilyByID(id) {\\n  {\\n    return allFamiliesByID.get(id);\\n  }\\n}\\nfunction getFamilyByType(type) {\\n  {\\n    return allFamiliesByType.get(type);\\n  }\\n}\\nfunction findAffectedHostInstances(families) {\\n  {\\n    var affectedInstances = new Set();\\n    mountedRoots.forEach(function (root) {\\n      var helpers = helpersByRoot.get(root);\\n\\n      if (helpers === undefined) {\\n        throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');\\n      }\\n\\n      var instancesForRoot = helpers.findHostInstancesForRefresh(root, families);\\n      instancesForRoot.forEach(function (inst) {\\n        affectedInstances.add(inst);\\n      });\\n    });\\n    return affectedInstances;\\n  }\\n}\\nfunction injectIntoGlobalHook(globalObject) {\\n  {\\n    // For React Native, the global hook will be set up by require('react-devtools-core').\\n    // That code will run before us. So we need to monkeypatch functions on existing hook.\\n    // For React Web, the global hook will be set up by the extension.\\n    // This will also run before us.\\n    var hook = globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__;\\n\\n    if (hook === undefined) {\\n      // However, if there is no DevTools extension, we'll need to set up the global hook ourselves.\\n      // Note that in this case it's important that renderer code runs *after* this method call.\\n      // Otherwise, the renderer will think that there is no global hook, and won't do the injection.\\n      var nextID = 0;\\n      globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__ = hook = {\\n        renderers: new Map(),\\n        supportsFiber: true,\\n        inject: function (injected) {\\n          return nextID++;\\n        },\\n        onScheduleFiberRoot: function (id, root, children) {},\\n        onCommitFiberRoot: function (id, root, maybePriorityLevel, didError) {},\\n        onCommitFiberUnmount: function () {}\\n      };\\n    }\\n\\n    if (hook.isDisabled) {\\n      // This isn't a real property on the hook, but it can be set to opt out\\n      // of DevTools integration and associated warnings and logs.\\n      // Using console['warn'] to evade Babel and ESLint\\n      console['warn']('Something has shimmed the React DevTools global hook (__REACT_DEVTOOLS_GLOBAL_HOOK__). ' + 'Fast Refresh is not compatible with this shim and will be disabled.');\\n      return;\\n    } // Here, we just want to get a reference to scheduleRefresh.\\n\\n\\n    var oldInject = hook.inject;\\n\\n    hook.inject = function (injected) {\\n      var id = oldInject.apply(this, arguments);\\n\\n      if (typeof injected.scheduleRefresh === 'function' && typeof injected.setRefreshHandler === 'function') {\\n        // This version supports React Refresh.\\n        helpersByRendererID.set(id, injected);\\n      }\\n\\n      return id;\\n    }; // Do the same for any already injected roots.\\n    // This is useful if ReactDOM has already been initialized.\\n    // https://github.com/facebook/react/issues/17626\\n\\n\\n    hook.renderers.forEach(function (injected, id) {\\n      if (typeof injected.scheduleRefresh === 'function' && typeof injected.setRefreshHandler === 'function') {\\n        // This version supports React Refresh.\\n        helpersByRendererID.set(id, injected);\\n      }\\n    }); // We also want to track currently mounted roots.\\n\\n    var oldOnCommitFiberRoot = hook.onCommitFiberRoot;\\n\\n    var oldOnScheduleFiberRoot = hook.onScheduleFiberRoot || function () {};\\n\\n    hook.onScheduleFiberRoot = function (id, root, children) {\\n      if (!isPerformingRefresh) {\\n        // If it was intentionally scheduled, don't attempt to restore.\\n        // This includes intentionally scheduled unmounts.\\n        failedRoots.delete(root);\\n\\n        if (rootElements !== null) {\\n          rootElements.set(root, children);\\n        }\\n      }\\n\\n      return oldOnScheduleFiberRoot.apply(this, arguments);\\n    };\\n\\n    hook.onCommitFiberRoot = function (id, root, maybePriorityLevel, didError) {\\n      var helpers = helpersByRendererID.get(id);\\n\\n      if (helpers !== undefined) {\\n        helpersByRoot.set(root, helpers);\\n        var current = root.current;\\n        var alternate = current.alternate; // We need to determine whether this root has just (un)mounted.\\n        // This logic is copy-pasted from similar logic in the DevTools backend.\\n        // If this breaks with some refactoring, you'll want to update DevTools too.\\n\\n        if (alternate !== null) {\\n          var wasMounted = alternate.memoizedState != null && alternate.memoizedState.element != null && mountedRoots.has(root);\\n          var isMounted = current.memoizedState != null && current.memoizedState.element != null;\\n\\n          if (!wasMounted && isMounted) {\\n            // Mount a new root.\\n            mountedRoots.add(root);\\n            failedRoots.delete(root);\\n          } else if (wasMounted && isMounted) ; else if (wasMounted && !isMounted) {\\n            // Unmount an existing root.\\n            mountedRoots.delete(root);\\n\\n            if (didError) {\\n              // We'll remount it on future edits.\\n              failedRoots.add(root);\\n            } else {\\n              helpersByRoot.delete(root);\\n            }\\n          } else if (!wasMounted && !isMounted) {\\n            if (didError) {\\n              // We'll remount it on future edits.\\n              failedRoots.add(root);\\n            }\\n          }\\n        } else {\\n          // Mount a new root.\\n          mountedRoots.add(root);\\n        }\\n      } // Always call the decorated DevTools hook.\\n\\n\\n      return oldOnCommitFiberRoot.apply(this, arguments);\\n    };\\n  }\\n}\\nfunction hasUnrecoverableErrors() {\\n  // TODO: delete this after removing dependency in RN.\\n  return false;\\n} // Exposed for testing.\\n\\nfunction _getMountedRootCount() {\\n  {\\n    return mountedRoots.size;\\n  }\\n} // This is a wrapper over more primitive functions for setting signature.\\n// Signatures let us decide whether the Hook order has changed on refresh.\\n//\\n// This function is intended to be used as a transform target, e.g.:\\n// var _s = createSignatureFunctionForTransform()\\n//\\n// function Hello() {\\n//   const [foo, setFoo] = useState(0);\\n//   const value = useCustomHook();\\n//   _s(); /* Call without arguments triggers collecting the custom Hook list.\\n//          * This doesn't happen during the module evaluation because we\\n//          * don't want to change the module order with inline requires.\\n//          * Next calls are noops. */\\n//   return <h1>Hi</h1>;\\n// }\\n//\\n// /* Call with arguments attaches the signature to the type: */\\n// _s(\\n//   Hello,\\n//   'useState{[foo, setFoo]}(0)',\\n//   () => [useCustomHook], /* Lazy to avoid triggering inline requires */\\n// );\\n\\nfunction createSignatureFunctionForTransform() {\\n  {\\n    var savedType;\\n    var hasCustomHooks;\\n    var didCollectHooks = false;\\n    return function (type, key, forceReset, getCustomHooks) {\\n      if (typeof key === 'string') {\\n        // We're in the initial phase that associates signatures\\n        // with the functions. Note this may be called multiple times\\n        // in HOC chains like _s(hoc1(_s(hoc2(_s(actualFunction))))).\\n        if (!savedType) {\\n          // We're in the innermost call, so this is the actual type.\\n          savedType = type;\\n          hasCustomHooks = typeof getCustomHooks === 'function';\\n        } // Set the signature for all types (even wrappers!) in case\\n        // they have no signatures of their own. This is to prevent\\n        // problems like https://github.com/facebook/react/issues/20417.\\n\\n\\n        if (type != null && (typeof type === 'function' || typeof type === 'object')) {\\n          setSignature(type, key, forceReset, getCustomHooks);\\n        }\\n\\n        return type;\\n      } else {\\n        // We're in the _s() call without arguments, which means\\n        // this is the time to collect custom Hook signatures.\\n        // Only do this once. This path is hot and runs *inside* every render!\\n        if (!didCollectHooks && hasCustomHooks) {\\n          didCollectHooks = true;\\n          collectCustomHooksForSignature(savedType);\\n        }\\n      }\\n    };\\n  }\\n}\\nfunction isLikelyComponentType(type) {\\n  {\\n    switch (typeof type) {\\n      case 'function':\\n        {\\n          // First, deal with classes.\\n          if (type.prototype != null) {\\n            if (type.prototype.isReactComponent) {\\n              // React class.\\n              return true;\\n            }\\n\\n            var ownNames = Object.getOwnPropertyNames(type.prototype);\\n\\n            if (ownNames.length > 1 || ownNames[0] !== 'constructor') {\\n              // This looks like a class.\\n              return false;\\n            } // eslint-disable-next-line no-proto\\n\\n\\n            if (type.prototype.__proto__ !== Object.prototype) {\\n              // It has a superclass.\\n              return false;\\n            } // Pass through.\\n            // This looks like a regular function with empty prototype.\\n\\n          } // For plain functions and arrows, use name as a heuristic.\\n\\n\\n          var name = type.name || type.displayName;\\n          return typeof name === 'string' && /^[A-Z]/.test(name);\\n        }\\n\\n      case 'object':\\n        {\\n          if (type != null) {\\n            switch (getProperty(type, '$$typeof')) {\\n              case REACT_FORWARD_REF_TYPE:\\n              case REACT_MEMO_TYPE:\\n                // Definitely React components.\\n                return true;\\n\\n              default:\\n                return false;\\n            }\\n          }\\n\\n          return false;\\n        }\\n\\n      default:\\n        {\\n          return false;\\n        }\\n    }\\n  }\\n}\\n\\nexports._getMountedRootCount = _getMountedRootCount;\\nexports.collectCustomHooksForSignature = collectCustomHooksForSignature;\\nexports.createSignatureFunctionForTransform = createSignatureFunctionForTransform;\\nexports.findAffectedHostInstances = findAffectedHostInstances;\\nexports.getFamilyByID = getFamilyByID;\\nexports.getFamilyByType = getFamilyByType;\\nexports.hasUnrecoverableErrors = hasUnrecoverableErrors;\\nexports.injectIntoGlobalHook = injectIntoGlobalHook;\\nexports.isLikelyComponentType = isLikelyComponentType;\\nexports.performReactRefresh = performReactRefresh;\\nexports.register = register;\\nexports.setSignature = setSignature;\\n  })();\\n}\\n\\nfunction debounce(fn, delay) {\\n  let handle\\n  return () => {\\n    clearTimeout(handle)\\n    handle = setTimeout(fn, delay)\\n  }\\n}\\n\\n/* eslint-disable no-undef */\\nconst enqueueUpdate = debounce(exports.performReactRefresh, 16)\\n\\n// Taken from https://github.com/pmmmwh/react-refresh-webpack-plugin/blob/main/lib/runtime/RefreshUtils.js#L141\\n// This allows to resister components not detected by SWC like styled component\\nfunction registerExportsForReactRefresh(filename, moduleExports) {\\n  for (const key in moduleExports) {\\n    if (key === '__esModule') continue\\n    const exportValue = moduleExports[key]\\n    if (exports.isLikelyComponentType(exportValue)) {\\n      // 'export' is required to avoid key collision when renamed exports that\\n      // shadow a local component name: https://github.com/vitejs/vite-plugin-react/issues/116\\n      // The register function has an identity check to not register twice the same component,\\n      // so this is safe to not used the same key here.\\n      exports.register(exportValue, filename + ' export ' + key)\\n    }\\n  }\\n}\\n\\nfunction validateRefreshBoundaryAndEnqueueUpdate(prevExports, nextExports) {\\n  if (!predicateOnExport(prevExports, (key) => key in nextExports)) {\\n    return 'Could not Fast Refresh (export removed)'\\n  }\\n  if (!predicateOnExport(nextExports, (key) => key in prevExports)) {\\n    return 'Could not Fast Refresh (new export)'\\n  }\\n\\n  let hasExports = false\\n  const allExportsAreComponentsOrUnchanged = predicateOnExport(\\n    nextExports,\\n    (key, value) => {\\n      hasExports = true\\n      if (exports.isLikelyComponentType(value)) return true\\n      return prevExports[key] === nextExports[key]\\n    },\\n  )\\n  if (hasExports && allExportsAreComponentsOrUnchanged) {\\n    enqueueUpdate()\\n  } else {\\n    return 'Could not Fast Refresh. Learn more at https://github.com/vitejs/vite-plugin-react/tree/main/packages/plugin-react#consistent-components-exports'\\n  }\\n}\\n\\nfunction predicateOnExport(moduleExports, predicate) {\\n  for (const key in moduleExports) {\\n    if (key === '__esModule') continue\\n    const desc = Object.getOwnPropertyDescriptor(moduleExports, key)\\n    if (desc && desc.get) return false\\n    if (!predicate(key, moduleExports[key])) return false\\n  }\\n  return true\\n}\\n\\n// Hides vite-ignored dynamic import so that Vite can skip analysis if no other\\n// dynamic import is present (https://github.com/vitejs/vite/pull/12732)\\nfunction __hmr_import(module) {\\n  return import(/* @vite-ignore */ module)\\n}\\n\\nexports.__hmr_import = __hmr_import\\nexports.registerExportsForReactRefresh = registerExportsForReactRefresh\\nexports.validateRefreshBoundaryAndEnqueueUpdate =\\n  validateRefreshBoundaryAndEnqueueUpdate\\n\\nexport default exports\\n\"],\n  \"mappings\": \"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\",\n  \"names\": []\n}\n"
    },
    {
      "name": "vite:import-analysis",
      "result": "import { injectQuery as __vite__injectQuery } from \"/@vite/client\";const exports = {};\n/**\n * @license React\n * react-refresh-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\"use strict\";\nif (true) {\n  (function() {\n    \"use strict\";\n    var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n    var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n    var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map;\n    var allFamiliesByID = /* @__PURE__ */ new Map();\n    var allFamiliesByType = new PossiblyWeakMap();\n    var allSignaturesByType = new PossiblyWeakMap();\n    var updatedFamiliesByType = new PossiblyWeakMap();\n    var pendingUpdates = [];\n    var helpersByRendererID = /* @__PURE__ */ new Map();\n    var helpersByRoot = /* @__PURE__ */ new Map();\n    var mountedRoots = /* @__PURE__ */ new Set();\n    var failedRoots = /* @__PURE__ */ new Set();\n    var rootElements = (\n      // $FlowIssue\n      typeof WeakMap === \"function\" ? /* @__PURE__ */ new WeakMap() : null\n    );\n    var isPerformingRefresh = false;\n    function computeFullKey(signature) {\n      if (signature.fullKey !== null) {\n        return signature.fullKey;\n      }\n      var fullKey = signature.ownKey;\n      var hooks;\n      try {\n        hooks = signature.getCustomHooks();\n      } catch (err) {\n        signature.forceReset = true;\n        signature.fullKey = fullKey;\n        return fullKey;\n      }\n      for (var i = 0; i < hooks.length; i++) {\n        var hook = hooks[i];\n        if (typeof hook !== \"function\") {\n          signature.forceReset = true;\n          signature.fullKey = fullKey;\n          return fullKey;\n        }\n        var nestedHookSignature = allSignaturesByType.get(hook);\n        if (nestedHookSignature === void 0) {\n          continue;\n        }\n        var nestedHookKey = computeFullKey(nestedHookSignature);\n        if (nestedHookSignature.forceReset) {\n          signature.forceReset = true;\n        }\n        fullKey += \"\\n---\\n\" + nestedHookKey;\n      }\n      signature.fullKey = fullKey;\n      return fullKey;\n    }\n    function haveEqualSignatures(prevType, nextType) {\n      var prevSignature = allSignaturesByType.get(prevType);\n      var nextSignature = allSignaturesByType.get(nextType);\n      if (prevSignature === void 0 && nextSignature === void 0) {\n        return true;\n      }\n      if (prevSignature === void 0 || nextSignature === void 0) {\n        return false;\n      }\n      if (computeFullKey(prevSignature) !== computeFullKey(nextSignature)) {\n        return false;\n      }\n      if (nextSignature.forceReset) {\n        return false;\n      }\n      return true;\n    }\n    function isReactClass(type) {\n      return type.prototype && type.prototype.isReactComponent;\n    }\n    function canPreserveStateBetween(prevType, nextType) {\n      if (isReactClass(prevType) || isReactClass(nextType)) {\n        return false;\n      }\n      if (haveEqualSignatures(prevType, nextType)) {\n        return true;\n      }\n      return false;\n    }\n    function resolveFamily(type) {\n      return updatedFamiliesByType.get(type);\n    }\n    function cloneMap(map) {\n      var clone = /* @__PURE__ */ new Map();\n      map.forEach(function(value, key) {\n        clone.set(key, value);\n      });\n      return clone;\n    }\n    function cloneSet(set) {\n      var clone = /* @__PURE__ */ new Set();\n      set.forEach(function(value) {\n        clone.add(value);\n      });\n      return clone;\n    }\n    function getProperty(object, property) {\n      try {\n        return object[property];\n      } catch (err) {\n        return void 0;\n      }\n    }\n    function performReactRefresh() {\n      if (pendingUpdates.length === 0) {\n        return null;\n      }\n      if (isPerformingRefresh) {\n        return null;\n      }\n      isPerformingRefresh = true;\n      try {\n        var staleFamilies = /* @__PURE__ */ new Set();\n        var updatedFamilies = /* @__PURE__ */ new Set();\n        var updates = pendingUpdates;\n        pendingUpdates = [];\n        updates.forEach(function(_ref) {\n          var family = _ref[0], nextType = _ref[1];\n          var prevType = family.current;\n          updatedFamiliesByType.set(prevType, family);\n          updatedFamiliesByType.set(nextType, family);\n          family.current = nextType;\n          if (canPreserveStateBetween(prevType, nextType)) {\n            updatedFamilies.add(family);\n          } else {\n            staleFamilies.add(family);\n          }\n        });\n        var update = {\n          updatedFamilies,\n          // Families that will re-render preserving state\n          staleFamilies\n          // Families that will be remounted\n        };\n        helpersByRendererID.forEach(function(helpers) {\n          helpers.setRefreshHandler(resolveFamily);\n        });\n        var didError = false;\n        var firstError = null;\n        var failedRootsSnapshot = cloneSet(failedRoots);\n        var mountedRootsSnapshot = cloneSet(mountedRoots);\n        var helpersByRootSnapshot = cloneMap(helpersByRoot);\n        failedRootsSnapshot.forEach(function(root) {\n          var helpers = helpersByRootSnapshot.get(root);\n          if (helpers === void 0) {\n            throw new Error(\"Could not find helpers for a root. This is a bug in React Refresh.\");\n          }\n          if (!failedRoots.has(root)) {\n          }\n          if (rootElements === null) {\n            return;\n          }\n          if (!rootElements.has(root)) {\n            return;\n          }\n          var element = rootElements.get(root);\n          try {\n            helpers.scheduleRoot(root, element);\n          } catch (err) {\n            if (!didError) {\n              didError = true;\n              firstError = err;\n            }\n          }\n        });\n        mountedRootsSnapshot.forEach(function(root) {\n          var helpers = helpersByRootSnapshot.get(root);\n          if (helpers === void 0) {\n            throw new Error(\"Could not find helpers for a root. This is a bug in React Refresh.\");\n          }\n          if (!mountedRoots.has(root)) {\n          }\n          try {\n            helpers.scheduleRefresh(root, update);\n          } catch (err) {\n            if (!didError) {\n              didError = true;\n              firstError = err;\n            }\n          }\n        });\n        if (didError) {\n          throw firstError;\n        }\n        return update;\n      } finally {\n        isPerformingRefresh = false;\n      }\n    }\n    function register(type, id) {\n      {\n        if (type === null) {\n          return;\n        }\n        if (typeof type !== \"function\" && typeof type !== \"object\") {\n          return;\n        }\n        if (allFamiliesByType.has(type)) {\n          return;\n        }\n        var family = allFamiliesByID.get(id);\n        if (family === void 0) {\n          family = {\n            current: type\n          };\n          allFamiliesByID.set(id, family);\n        } else {\n          pendingUpdates.push([family, type]);\n        }\n        allFamiliesByType.set(type, family);\n        if (typeof type === \"object\" && type !== null) {\n          switch (getProperty(type, \"$$typeof\")) {\n            case REACT_FORWARD_REF_TYPE:\n              register(type.render, id + \"$render\");\n              break;\n            case REACT_MEMO_TYPE:\n              register(type.type, id + \"$type\");\n              break;\n          }\n        }\n      }\n    }\n    function setSignature(type, key) {\n      var forceReset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n      var getCustomHooks = arguments.length > 3 ? arguments[3] : void 0;\n      {\n        if (!allSignaturesByType.has(type)) {\n          allSignaturesByType.set(type, {\n            forceReset,\n            ownKey: key,\n            fullKey: null,\n            getCustomHooks: getCustomHooks || function() {\n              return [];\n            }\n          });\n        }\n        if (typeof type === \"object\" && type !== null) {\n          switch (getProperty(type, \"$$typeof\")) {\n            case REACT_FORWARD_REF_TYPE:\n              setSignature(type.render, key, forceReset, getCustomHooks);\n              break;\n            case REACT_MEMO_TYPE:\n              setSignature(type.type, key, forceReset, getCustomHooks);\n              break;\n          }\n        }\n      }\n    }\n    function collectCustomHooksForSignature(type) {\n      {\n        var signature = allSignaturesByType.get(type);\n        if (signature !== void 0) {\n          computeFullKey(signature);\n        }\n      }\n    }\n    function getFamilyByID(id) {\n      {\n        return allFamiliesByID.get(id);\n      }\n    }\n    function getFamilyByType(type) {\n      {\n        return allFamiliesByType.get(type);\n      }\n    }\n    function findAffectedHostInstances(families) {\n      {\n        var affectedInstances = /* @__PURE__ */ new Set();\n        mountedRoots.forEach(function(root) {\n          var helpers = helpersByRoot.get(root);\n          if (helpers === void 0) {\n            throw new Error(\"Could not find helpers for a root. This is a bug in React Refresh.\");\n          }\n          var instancesForRoot = helpers.findHostInstancesForRefresh(root, families);\n          instancesForRoot.forEach(function(inst) {\n            affectedInstances.add(inst);\n          });\n        });\n        return affectedInstances;\n      }\n    }\n    function injectIntoGlobalHook(globalObject) {\n      {\n        var hook = globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__;\n        if (hook === void 0) {\n          var nextID = 0;\n          globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__ = hook = {\n            renderers: /* @__PURE__ */ new Map(),\n            supportsFiber: true,\n            inject: function(injected) {\n              return nextID++;\n            },\n            onScheduleFiberRoot: function(id, root, children) {\n            },\n            onCommitFiberRoot: function(id, root, maybePriorityLevel, didError) {\n            },\n            onCommitFiberUnmount: function() {\n            }\n          };\n        }\n        if (hook.isDisabled) {\n          console[\"warn\"](\"Something has shimmed the React DevTools global hook (__REACT_DEVTOOLS_GLOBAL_HOOK__). Fast Refresh is not compatible with this shim and will be disabled.\");\n          return;\n        }\n        var oldInject = hook.inject;\n        hook.inject = function(injected) {\n          var id = oldInject.apply(this, arguments);\n          if (typeof injected.scheduleRefresh === \"function\" && typeof injected.setRefreshHandler === \"function\") {\n            helpersByRendererID.set(id, injected);\n          }\n          return id;\n        };\n        hook.renderers.forEach(function(injected, id) {\n          if (typeof injected.scheduleRefresh === \"function\" && typeof injected.setRefreshHandler === \"function\") {\n            helpersByRendererID.set(id, injected);\n          }\n        });\n        var oldOnCommitFiberRoot = hook.onCommitFiberRoot;\n        var oldOnScheduleFiberRoot = hook.onScheduleFiberRoot || function() {\n        };\n        hook.onScheduleFiberRoot = function(id, root, children) {\n          if (!isPerformingRefresh) {\n            failedRoots.delete(root);\n            if (rootElements !== null) {\n              rootElements.set(root, children);\n            }\n          }\n          return oldOnScheduleFiberRoot.apply(this, arguments);\n        };\n        hook.onCommitFiberRoot = function(id, root, maybePriorityLevel, didError) {\n          var helpers = helpersByRendererID.get(id);\n          if (helpers !== void 0) {\n            helpersByRoot.set(root, helpers);\n            var current = root.current;\n            var alternate = current.alternate;\n            if (alternate !== null) {\n              var wasMounted = alternate.memoizedState != null && alternate.memoizedState.element != null && mountedRoots.has(root);\n              var isMounted = current.memoizedState != null && current.memoizedState.element != null;\n              if (!wasMounted && isMounted) {\n                mountedRoots.add(root);\n                failedRoots.delete(root);\n              } else if (wasMounted && isMounted)\n                ;\n              else if (wasMounted && !isMounted) {\n                mountedRoots.delete(root);\n                if (didError) {\n                  failedRoots.add(root);\n                } else {\n                  helpersByRoot.delete(root);\n                }\n              } else if (!wasMounted && !isMounted) {\n                if (didError) {\n                  failedRoots.add(root);\n                }\n              }\n            } else {\n              mountedRoots.add(root);\n            }\n          }\n          return oldOnCommitFiberRoot.apply(this, arguments);\n        };\n      }\n    }\n    function hasUnrecoverableErrors() {\n      return false;\n    }\n    function _getMountedRootCount() {\n      {\n        return mountedRoots.size;\n      }\n    }\n    function createSignatureFunctionForTransform() {\n      {\n        var savedType;\n        var hasCustomHooks;\n        var didCollectHooks = false;\n        return function(type, key, forceReset, getCustomHooks) {\n          if (typeof key === \"string\") {\n            if (!savedType) {\n              savedType = type;\n              hasCustomHooks = typeof getCustomHooks === \"function\";\n            }\n            if (type != null && (typeof type === \"function\" || typeof type === \"object\")) {\n              setSignature(type, key, forceReset, getCustomHooks);\n            }\n            return type;\n          } else {\n            if (!didCollectHooks && hasCustomHooks) {\n              didCollectHooks = true;\n              collectCustomHooksForSignature(savedType);\n            }\n          }\n        };\n      }\n    }\n    function isLikelyComponentType(type) {\n      {\n        switch (typeof type) {\n          case \"function\": {\n            if (type.prototype != null) {\n              if (type.prototype.isReactComponent) {\n                return true;\n              }\n              var ownNames = Object.getOwnPropertyNames(type.prototype);\n              if (ownNames.length > 1 || ownNames[0] !== \"constructor\") {\n                return false;\n              }\n              if (type.prototype.__proto__ !== Object.prototype) {\n                return false;\n              }\n            }\n            var name = type.name || type.displayName;\n            return typeof name === \"string\" && /^[A-Z]/.test(name);\n          }\n          case \"object\": {\n            if (type != null) {\n              switch (getProperty(type, \"$$typeof\")) {\n                case REACT_FORWARD_REF_TYPE:\n                case REACT_MEMO_TYPE:\n                  return true;\n                default:\n                  return false;\n              }\n            }\n            return false;\n          }\n          default: {\n            return false;\n          }\n        }\n      }\n    }\n    exports._getMountedRootCount = _getMountedRootCount;\n    exports.collectCustomHooksForSignature = collectCustomHooksForSignature;\n    exports.createSignatureFunctionForTransform = createSignatureFunctionForTransform;\n    exports.findAffectedHostInstances = findAffectedHostInstances;\n    exports.getFamilyByID = getFamilyByID;\n    exports.getFamilyByType = getFamilyByType;\n    exports.hasUnrecoverableErrors = hasUnrecoverableErrors;\n    exports.injectIntoGlobalHook = injectIntoGlobalHook;\n    exports.isLikelyComponentType = isLikelyComponentType;\n    exports.performReactRefresh = performReactRefresh;\n    exports.register = register;\n    exports.setSignature = setSignature;\n  })();\n}\nfunction debounce(fn, delay) {\n  let handle;\n  return () => {\n    clearTimeout(handle);\n    handle = setTimeout(fn, delay);\n  };\n}\nconst enqueueUpdate = debounce(exports.performReactRefresh, 16);\nfunction registerExportsForReactRefresh(filename, moduleExports) {\n  for (const key in moduleExports) {\n    if (key === \"__esModule\")\n      continue;\n    const exportValue = moduleExports[key];\n    if (exports.isLikelyComponentType(exportValue)) {\n      exports.register(exportValue, filename + \" export \" + key);\n    }\n  }\n}\nfunction validateRefreshBoundaryAndEnqueueUpdate(prevExports, nextExports) {\n  if (!predicateOnExport(prevExports, (key) => key in nextExports)) {\n    return \"Could not Fast Refresh (export removed)\";\n  }\n  if (!predicateOnExport(nextExports, (key) => key in prevExports)) {\n    return \"Could not Fast Refresh (new export)\";\n  }\n  let hasExports = false;\n  const allExportsAreComponentsOrUnchanged = predicateOnExport(\n    nextExports,\n    (key, value) => {\n      hasExports = true;\n      if (exports.isLikelyComponentType(value))\n        return true;\n      return prevExports[key] === nextExports[key];\n    }\n  );\n  if (hasExports && allExportsAreComponentsOrUnchanged) {\n    enqueueUpdate();\n  } else {\n    return \"Could not Fast Refresh. Learn more at https://github.com/vitejs/vite-plugin-react/tree/main/packages/plugin-react#consistent-components-exports\";\n  }\n}\nfunction predicateOnExport(moduleExports, predicate) {\n  for (const key in moduleExports) {\n    if (key === \"__esModule\")\n      continue;\n    const desc = Object.getOwnPropertyDescriptor(moduleExports, key);\n    if (desc && desc.get)\n      return false;\n    if (!predicate(key, moduleExports[key]))\n      return false;\n  }\n  return true;\n}\nfunction __hmr_import(module) {\n  return import(\n    /* @vite-ignore */\n    __vite__injectQuery(module, 'import')\n  );\n}\nexports.__hmr_import = __hmr_import;\nexports.registerExportsForReactRefresh = registerExportsForReactRefresh;\nexports.validateRefreshBoundaryAndEnqueueUpdate = validateRefreshBoundaryAndEnqueueUpdate;\nexport default exports;\n",
      "start": 1703474738430,
      "end": 1703474738432,
      "order": "normal",
      "sourcemaps": null
    }
  ]
}
