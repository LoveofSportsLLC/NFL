{
  "resolvedId": "/home/zepor/ssweb/frontend-container/node_modules/.vite/deps/amazon-cognito-identity-js.js?v=733ce8d4",
  "transforms": [
    {
      "name": "vite:optimized-deps",
      "result": "\"use strict\";\n(() => {\n  var __create = Object.create;\n  var __defProp = Object.defineProperty;\n  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n  var __getOwnPropNames = Object.getOwnPropertyNames;\n  var __getProtoOf = Object.getPrototypeOf;\n  var __hasOwnProp = Object.prototype.hasOwnProperty;\n  var __esm = (fn, res) => function __init() {\n    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;\n  };\n  var __commonJS = (cb, mod) => function __require() {\n    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n  };\n  var __copyProps = (to, from, except, desc) => {\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n      for (let key of __getOwnPropNames(from))\n        if (!__hasOwnProp.call(to, key) && key !== except)\n          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n    }\n    return to;\n  };\n  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n    // If the importer is in node compatibility mode or this is not an ESM\n    // file that has been converted to a CommonJS file using a Babel-\n    // compatible transform (i.e. \"__esModule\" has not been set), then set\n    // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n    isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n    mod\n  ));\n\n  // node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js\n  var require_base64_js = __commonJS({\n    \"node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js\"(exports) {\n      \"use strict\";\n      init_dist();\n      exports.byteLength = byteLength;\n      exports.toByteArray = toByteArray;\n      exports.fromByteArray = fromByteArray;\n      var lookup = [];\n      var revLookup = [];\n      var Arr = typeof Uint8Array !== \"undefined\" ? Uint8Array : Array;\n      var code = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n      for (i = 0, len = code.length; i < len; ++i) {\n        lookup[i] = code[i];\n        revLookup[code.charCodeAt(i)] = i;\n      }\n      var i;\n      var len;\n      revLookup[\"-\".charCodeAt(0)] = 62;\n      revLookup[\"_\".charCodeAt(0)] = 63;\n      function getLens(b64) {\n        var len2 = b64.length;\n        if (len2 % 4 > 0) {\n          throw new Error(\"Invalid string. Length must be a multiple of 4\");\n        }\n        var validLen = b64.indexOf(\"=\");\n        if (validLen === -1)\n          validLen = len2;\n        var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;\n        return [validLen, placeHoldersLen];\n      }\n      function byteLength(b64) {\n        var lens = getLens(b64);\n        var validLen = lens[0];\n        var placeHoldersLen = lens[1];\n        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n      }\n      function _byteLength(b64, validLen, placeHoldersLen) {\n        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n      }\n      function toByteArray(b64) {\n        var tmp;\n        var lens = getLens(b64);\n        var validLen = lens[0];\n        var placeHoldersLen = lens[1];\n        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n        var curByte = 0;\n        var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;\n        var i2;\n        for (i2 = 0; i2 < len2; i2 += 4) {\n          tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];\n          arr[curByte++] = tmp >> 16 & 255;\n          arr[curByte++] = tmp >> 8 & 255;\n          arr[curByte++] = tmp & 255;\n        }\n        if (placeHoldersLen === 2) {\n          tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;\n          arr[curByte++] = tmp & 255;\n        }\n        if (placeHoldersLen === 1) {\n          tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;\n          arr[curByte++] = tmp >> 8 & 255;\n          arr[curByte++] = tmp & 255;\n        }\n        return arr;\n      }\n      function tripletToBase64(num) {\n        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];\n      }\n      function encodeChunk(uint8, start, end) {\n        var tmp;\n        var output = [];\n        for (var i2 = start; i2 < end; i2 += 3) {\n          tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);\n          output.push(tripletToBase64(tmp));\n        }\n        return output.join(\"\");\n      }\n      function fromByteArray(uint8) {\n        var tmp;\n        var len2 = uint8.length;\n        var extraBytes = len2 % 3;\n        var parts = [];\n        var maxChunkLength = 16383;\n        for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {\n          parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));\n        }\n        if (extraBytes === 1) {\n          tmp = uint8[len2 - 1];\n          parts.push(\n            lookup[tmp >> 2] + lookup[tmp << 4 & 63] + \"==\"\n          );\n        } else if (extraBytes === 2) {\n          tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];\n          parts.push(\n            lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + \"=\"\n          );\n        }\n        return parts.join(\"\");\n      }\n    }\n  });\n\n  // node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js\n  var require_ieee754 = __commonJS({\n    \"node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js\"(exports) {\n      init_dist();\n      exports.read = function(buffer, offset, isLE, mLen, nBytes) {\n        var e, m;\n        var eLen = nBytes * 8 - mLen - 1;\n        var eMax = (1 << eLen) - 1;\n        var eBias = eMax >> 1;\n        var nBits = -7;\n        var i = isLE ? nBytes - 1 : 0;\n        var d = isLE ? -1 : 1;\n        var s2 = buffer[offset + i];\n        i += d;\n        e = s2 & (1 << -nBits) - 1;\n        s2 >>= -nBits;\n        nBits += eLen;\n        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {\n        }\n        m = e & (1 << -nBits) - 1;\n        e >>= -nBits;\n        nBits += mLen;\n        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {\n        }\n        if (e === 0) {\n          e = 1 - eBias;\n        } else if (e === eMax) {\n          return m ? NaN : (s2 ? -1 : 1) * Infinity;\n        } else {\n          m = m + Math.pow(2, mLen);\n          e = e - eBias;\n        }\n        return (s2 ? -1 : 1) * m * Math.pow(2, e - mLen);\n      };\n      exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {\n        var e, m, c;\n        var eLen = nBytes * 8 - mLen - 1;\n        var eMax = (1 << eLen) - 1;\n        var eBias = eMax >> 1;\n        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n        var i = isLE ? 0 : nBytes - 1;\n        var d = isLE ? 1 : -1;\n        var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n        value = Math.abs(value);\n        if (isNaN(value) || value === Infinity) {\n          m = isNaN(value) ? 1 : 0;\n          e = eMax;\n        } else {\n          e = Math.floor(Math.log(value) / Math.LN2);\n          if (value * (c = Math.pow(2, -e)) < 1) {\n            e--;\n            c *= 2;\n          }\n          if (e + eBias >= 1) {\n            value += rt / c;\n          } else {\n            value += rt * Math.pow(2, 1 - eBias);\n          }\n          if (value * c >= 2) {\n            e++;\n            c /= 2;\n          }\n          if (e + eBias >= eMax) {\n            m = 0;\n            e = eMax;\n          } else if (e + eBias >= 1) {\n            m = (value * c - 1) * Math.pow(2, mLen);\n            e = e + eBias;\n          } else {\n            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n            e = 0;\n          }\n        }\n        for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {\n        }\n        e = e << mLen | m;\n        eLen += mLen;\n        for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {\n        }\n        buffer[offset + i - d] |= s2 * 128;\n      };\n    }\n  });\n\n  // node_modules/.pnpm/buffer@6.0.3_patch_hash=zkkuxompt5d553skpnegwi5wuy/node_modules/buffer/index.js\n  var require_buffer = __commonJS({\n    \"node_modules/.pnpm/buffer@6.0.3_patch_hash=zkkuxompt5d553skpnegwi5wuy/node_modules/buffer/index.js\"(exports) {\n      \"use strict\";\n      init_dist();\n      var base64 = require_base64_js();\n      var ieee754 = require_ieee754();\n      var customInspectSymbol = typeof Symbol === \"function\" && typeof Symbol[\"for\"] === \"function\" ? Symbol[\"for\"](\"nodejs.util.inspect.custom\") : null;\n      exports.Buffer = Buffer2;\n      exports.SlowBuffer = SlowBuffer;\n      exports.INSPECT_MAX_BYTES = 50;\n      var K_MAX_LENGTH = 2147483647;\n      exports.kMaxLength = K_MAX_LENGTH;\n      var { Uint8Array: GlobalUint8Array, ArrayBuffer: GlobalArrayBuffer, SharedArrayBuffer: GlobalSharedArrayBuffer } = globalThis;\n      Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();\n      if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== \"undefined\" && typeof console.error === \"function\") {\n        console.error(\n          \"This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.\"\n        );\n      }\n      function typedArraySupport() {\n        try {\n          const arr = new GlobalUint8Array(1);\n          const proto = { foo: function() {\n            return 42;\n          } };\n          Object.setPrototypeOf(proto, GlobalUint8Array.prototype);\n          Object.setPrototypeOf(arr, proto);\n          return arr.foo() === 42;\n        } catch (e) {\n          return false;\n        }\n      }\n      Object.defineProperty(Buffer2.prototype, \"parent\", {\n        enumerable: true,\n        get: function() {\n          if (!Buffer2.isBuffer(this))\n            return void 0;\n          return this.buffer;\n        }\n      });\n      Object.defineProperty(Buffer2.prototype, \"offset\", {\n        enumerable: true,\n        get: function() {\n          if (!Buffer2.isBuffer(this))\n            return void 0;\n          return this.byteOffset;\n        }\n      });\n      function createBuffer(length) {\n        if (length > K_MAX_LENGTH) {\n          throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"');\n        }\n        const buf = new GlobalUint8Array(length);\n        Object.setPrototypeOf(buf, Buffer2.prototype);\n        return buf;\n      }\n      function Buffer2(arg, encodingOrOffset, length) {\n        if (typeof arg === \"number\") {\n          if (typeof encodingOrOffset === \"string\") {\n            throw new TypeError(\n              'The \"string\" argument must be of type string. Received type number'\n            );\n          }\n          return allocUnsafe(arg);\n        }\n        return from(arg, encodingOrOffset, length);\n      }\n      Buffer2.poolSize = 8192;\n      function from(value, encodingOrOffset, length) {\n        if (typeof value === \"string\") {\n          return fromString(value, encodingOrOffset);\n        }\n        if (GlobalArrayBuffer.isView(value)) {\n          return fromArrayView(value);\n        }\n        if (value == null) {\n          throw new TypeError(\n            \"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value\n          );\n        }\n        if (isInstance(value, GlobalArrayBuffer) || value && isInstance(value.buffer, GlobalArrayBuffer)) {\n          return fromArrayBuffer(value, encodingOrOffset, length);\n        }\n        if (typeof GlobalSharedArrayBuffer !== \"undefined\" && (isInstance(value, GlobalSharedArrayBuffer) || value && isInstance(value.buffer, GlobalSharedArrayBuffer))) {\n          return fromArrayBuffer(value, encodingOrOffset, length);\n        }\n        if (typeof value === \"number\") {\n          throw new TypeError(\n            'The \"value\" argument must not be of type number. Received type number'\n          );\n        }\n        const valueOf = value.valueOf && value.valueOf();\n        if (valueOf != null && valueOf !== value) {\n          return Buffer2.from(valueOf, encodingOrOffset, length);\n        }\n        const b = fromObject(value);\n        if (b)\n          return b;\n        if (typeof Symbol !== \"undefined\" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === \"function\") {\n          return Buffer2.from(value[Symbol.toPrimitive](\"string\"), encodingOrOffset, length);\n        }\n        throw new TypeError(\n          \"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value\n        );\n      }\n      Buffer2.from = function(value, encodingOrOffset, length) {\n        return from(value, encodingOrOffset, length);\n      };\n      Object.setPrototypeOf(Buffer2.prototype, GlobalUint8Array.prototype);\n      Object.setPrototypeOf(Buffer2, GlobalUint8Array);\n      function assertSize(size) {\n        if (typeof size !== \"number\") {\n          throw new TypeError('\"size\" argument must be of type number');\n        } else if (size < 0) {\n          throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"');\n        }\n      }\n      function alloc(size, fill, encoding) {\n        assertSize(size);\n        if (size <= 0) {\n          return createBuffer(size);\n        }\n        if (fill !== void 0) {\n          return typeof encoding === \"string\" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);\n        }\n        return createBuffer(size);\n      }\n      Buffer2.alloc = function(size, fill, encoding) {\n        return alloc(size, fill, encoding);\n      };\n      function allocUnsafe(size) {\n        assertSize(size);\n        return createBuffer(size < 0 ? 0 : checked(size) | 0);\n      }\n      Buffer2.allocUnsafe = function(size) {\n        return allocUnsafe(size);\n      };\n      Buffer2.allocUnsafeSlow = function(size) {\n        return allocUnsafe(size);\n      };\n      function fromString(string, encoding) {\n        if (typeof encoding !== \"string\" || encoding === \"\") {\n          encoding = \"utf8\";\n        }\n        if (!Buffer2.isEncoding(encoding)) {\n          throw new TypeError(\"Unknown encoding: \" + encoding);\n        }\n        const length = byteLength(string, encoding) | 0;\n        let buf = createBuffer(length);\n        const actual = buf.write(string, encoding);\n        if (actual !== length) {\n          buf = buf.slice(0, actual);\n        }\n        return buf;\n      }\n      function fromArrayLike(array) {\n        const length = array.length < 0 ? 0 : checked(array.length) | 0;\n        const buf = createBuffer(length);\n        for (let i = 0; i < length; i += 1) {\n          buf[i] = array[i] & 255;\n        }\n        return buf;\n      }\n      function fromArrayView(arrayView) {\n        if (isInstance(arrayView, GlobalUint8Array)) {\n          const copy = new GlobalUint8Array(arrayView);\n          return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);\n        }\n        return fromArrayLike(arrayView);\n      }\n      function fromArrayBuffer(array, byteOffset, length) {\n        if (byteOffset < 0 || array.byteLength < byteOffset) {\n          throw new RangeError('\"offset\" is outside of buffer bounds');\n        }\n        if (array.byteLength < byteOffset + (length || 0)) {\n          throw new RangeError('\"length\" is outside of buffer bounds');\n        }\n        let buf;\n        if (byteOffset === void 0 && length === void 0) {\n          buf = new GlobalUint8Array(array);\n        } else if (length === void 0) {\n          buf = new GlobalUint8Array(array, byteOffset);\n        } else {\n          buf = new GlobalUint8Array(array, byteOffset, length);\n        }\n        Object.setPrototypeOf(buf, Buffer2.prototype);\n        return buf;\n      }\n      function fromObject(obj) {\n        if (Buffer2.isBuffer(obj)) {\n          const len = checked(obj.length) | 0;\n          const buf = createBuffer(len);\n          if (buf.length === 0) {\n            return buf;\n          }\n          obj.copy(buf, 0, 0, len);\n          return buf;\n        }\n        if (obj.length !== void 0) {\n          if (typeof obj.length !== \"number\" || numberIsNaN(obj.length)) {\n            return createBuffer(0);\n          }\n          return fromArrayLike(obj);\n        }\n        if (obj.type === \"Buffer\" && Array.isArray(obj.data)) {\n          return fromArrayLike(obj.data);\n        }\n      }\n      function checked(length) {\n        if (length >= K_MAX_LENGTH) {\n          throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\" + K_MAX_LENGTH.toString(16) + \" bytes\");\n        }\n        return length | 0;\n      }\n      function SlowBuffer(length) {\n        if (+length != length) {\n          length = 0;\n        }\n        return Buffer2.alloc(+length);\n      }\n      Buffer2.isBuffer = function isBuffer(b) {\n        return b != null && b._isBuffer === true && b !== Buffer2.prototype;\n      };\n      Buffer2.compare = function compare(a, b) {\n        if (isInstance(a, GlobalUint8Array))\n          a = Buffer2.from(a, a.offset, a.byteLength);\n        if (isInstance(b, GlobalUint8Array))\n          b = Buffer2.from(b, b.offset, b.byteLength);\n        if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {\n          throw new TypeError(\n            'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n          );\n        }\n        if (a === b)\n          return 0;\n        let x = a.length;\n        let y = b.length;\n        for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n          if (a[i] !== b[i]) {\n            x = a[i];\n            y = b[i];\n            break;\n          }\n        }\n        if (x < y)\n          return -1;\n        if (y < x)\n          return 1;\n        return 0;\n      };\n      Buffer2.isEncoding = function isEncoding(encoding) {\n        switch (String(encoding).toLowerCase()) {\n          case \"hex\":\n          case \"utf8\":\n          case \"utf-8\":\n          case \"ascii\":\n          case \"latin1\":\n          case \"binary\":\n          case \"base64\":\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return true;\n          default:\n            return false;\n        }\n      };\n      Buffer2.concat = function concat(list, length) {\n        if (!Array.isArray(list)) {\n          throw new TypeError('\"list\" argument must be an Array of Buffers');\n        }\n        if (list.length === 0) {\n          return Buffer2.alloc(0);\n        }\n        let i;\n        if (length === void 0) {\n          length = 0;\n          for (i = 0; i < list.length; ++i) {\n            length += list[i].length;\n          }\n        }\n        const buffer = Buffer2.allocUnsafe(length);\n        let pos = 0;\n        for (i = 0; i < list.length; ++i) {\n          let buf = list[i];\n          if (isInstance(buf, GlobalUint8Array)) {\n            if (pos + buf.length > buffer.length) {\n              if (!Buffer2.isBuffer(buf))\n                buf = Buffer2.from(buf);\n              buf.copy(buffer, pos);\n            } else {\n              GlobalUint8Array.prototype.set.call(\n                buffer,\n                buf,\n                pos\n              );\n            }\n          } else if (!Buffer2.isBuffer(buf)) {\n            throw new TypeError('\"list\" argument must be an Array of Buffers');\n          } else {\n            buf.copy(buffer, pos);\n          }\n          pos += buf.length;\n        }\n        return buffer;\n      };\n      function byteLength(string, encoding) {\n        if (Buffer2.isBuffer(string)) {\n          return string.length;\n        }\n        if (GlobalArrayBuffer.isView(string) || isInstance(string, GlobalArrayBuffer)) {\n          return string.byteLength;\n        }\n        if (typeof string !== \"string\") {\n          throw new TypeError(\n            'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string\n          );\n        }\n        const len = string.length;\n        const mustMatch = arguments.length > 2 && arguments[2] === true;\n        if (!mustMatch && len === 0)\n          return 0;\n        let loweredCase = false;\n        for (; ; ) {\n          switch (encoding) {\n            case \"ascii\":\n            case \"latin1\":\n            case \"binary\":\n              return len;\n            case \"utf8\":\n            case \"utf-8\":\n              return utf8ToBytes(string).length;\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n              return len * 2;\n            case \"hex\":\n              return len >>> 1;\n            case \"base64\":\n              return base64ToBytes(string).length;\n            default:\n              if (loweredCase) {\n                return mustMatch ? -1 : utf8ToBytes(string).length;\n              }\n              encoding = (\"\" + encoding).toLowerCase();\n              loweredCase = true;\n          }\n        }\n      }\n      Buffer2.byteLength = byteLength;\n      function slowToString(encoding, start, end) {\n        let loweredCase = false;\n        if (start === void 0 || start < 0) {\n          start = 0;\n        }\n        if (start > this.length) {\n          return \"\";\n        }\n        if (end === void 0 || end > this.length) {\n          end = this.length;\n        }\n        if (end <= 0) {\n          return \"\";\n        }\n        end >>>= 0;\n        start >>>= 0;\n        if (end <= start) {\n          return \"\";\n        }\n        if (!encoding)\n          encoding = \"utf8\";\n        while (true) {\n          switch (encoding) {\n            case \"hex\":\n              return hexSlice(this, start, end);\n            case \"utf8\":\n            case \"utf-8\":\n              return utf8Slice(this, start, end);\n            case \"ascii\":\n              return asciiSlice(this, start, end);\n            case \"latin1\":\n            case \"binary\":\n              return latin1Slice(this, start, end);\n            case \"base64\":\n              return base64Slice(this, start, end);\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n              return utf16leSlice(this, start, end);\n            default:\n              if (loweredCase)\n                throw new TypeError(\"Unknown encoding: \" + encoding);\n              encoding = (encoding + \"\").toLowerCase();\n              loweredCase = true;\n          }\n        }\n      }\n      Buffer2.prototype._isBuffer = true;\n      function swap(b, n, m) {\n        const i = b[n];\n        b[n] = b[m];\n        b[m] = i;\n      }\n      Buffer2.prototype.swap16 = function swap16() {\n        const len = this.length;\n        if (len % 2 !== 0) {\n          throw new RangeError(\"Buffer size must be a multiple of 16-bits\");\n        }\n        for (let i = 0; i < len; i += 2) {\n          swap(this, i, i + 1);\n        }\n        return this;\n      };\n      Buffer2.prototype.swap32 = function swap32() {\n        const len = this.length;\n        if (len % 4 !== 0) {\n          throw new RangeError(\"Buffer size must be a multiple of 32-bits\");\n        }\n        for (let i = 0; i < len; i += 4) {\n          swap(this, i, i + 3);\n          swap(this, i + 1, i + 2);\n        }\n        return this;\n      };\n      Buffer2.prototype.swap64 = function swap64() {\n        const len = this.length;\n        if (len % 8 !== 0) {\n          throw new RangeError(\"Buffer size must be a multiple of 64-bits\");\n        }\n        for (let i = 0; i < len; i += 8) {\n          swap(this, i, i + 7);\n          swap(this, i + 1, i + 6);\n          swap(this, i + 2, i + 5);\n          swap(this, i + 3, i + 4);\n        }\n        return this;\n      };\n      Buffer2.prototype.toString = function toString() {\n        const length = this.length;\n        if (length === 0)\n          return \"\";\n        if (arguments.length === 0)\n          return utf8Slice(this, 0, length);\n        return slowToString.apply(this, arguments);\n      };\n      Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;\n      Buffer2.prototype.equals = function equals(b) {\n        if (!Buffer2.isBuffer(b))\n          throw new TypeError(\"Argument must be a Buffer\");\n        if (this === b)\n          return true;\n        return Buffer2.compare(this, b) === 0;\n      };\n      Buffer2.prototype.inspect = function inspect() {\n        let str = \"\";\n        const max = exports.INSPECT_MAX_BYTES;\n        str = this.toString(\"hex\", 0, max).replace(/(.{2})/g, \"$1 \").trim();\n        if (this.length > max)\n          str += \" ... \";\n        return \"<Buffer \" + str + \">\";\n      };\n      if (customInspectSymbol) {\n        Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;\n      }\n      Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n        if (isInstance(target, GlobalUint8Array)) {\n          target = Buffer2.from(target, target.offset, target.byteLength);\n        }\n        if (!Buffer2.isBuffer(target)) {\n          throw new TypeError(\n            'The \"target\" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target\n          );\n        }\n        if (start === void 0) {\n          start = 0;\n        }\n        if (end === void 0) {\n          end = target ? target.length : 0;\n        }\n        if (thisStart === void 0) {\n          thisStart = 0;\n        }\n        if (thisEnd === void 0) {\n          thisEnd = this.length;\n        }\n        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n          throw new RangeError(\"out of range index\");\n        }\n        if (thisStart >= thisEnd && start >= end) {\n          return 0;\n        }\n        if (thisStart >= thisEnd) {\n          return -1;\n        }\n        if (start >= end) {\n          return 1;\n        }\n        start >>>= 0;\n        end >>>= 0;\n        thisStart >>>= 0;\n        thisEnd >>>= 0;\n        if (this === target)\n          return 0;\n        let x = thisEnd - thisStart;\n        let y = end - start;\n        const len = Math.min(x, y);\n        const thisCopy = this.slice(thisStart, thisEnd);\n        const targetCopy = target.slice(start, end);\n        for (let i = 0; i < len; ++i) {\n          if (thisCopy[i] !== targetCopy[i]) {\n            x = thisCopy[i];\n            y = targetCopy[i];\n            break;\n          }\n        }\n        if (x < y)\n          return -1;\n        if (y < x)\n          return 1;\n        return 0;\n      };\n      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n        if (buffer.length === 0)\n          return -1;\n        if (typeof byteOffset === \"string\") {\n          encoding = byteOffset;\n          byteOffset = 0;\n        } else if (byteOffset > 2147483647) {\n          byteOffset = 2147483647;\n        } else if (byteOffset < -2147483648) {\n          byteOffset = -2147483648;\n        }\n        byteOffset = +byteOffset;\n        if (numberIsNaN(byteOffset)) {\n          byteOffset = dir ? 0 : buffer.length - 1;\n        }\n        if (byteOffset < 0)\n          byteOffset = buffer.length + byteOffset;\n        if (byteOffset >= buffer.length) {\n          if (dir)\n            return -1;\n          else\n            byteOffset = buffer.length - 1;\n        } else if (byteOffset < 0) {\n          if (dir)\n            byteOffset = 0;\n          else\n            return -1;\n        }\n        if (typeof val === \"string\") {\n          val = Buffer2.from(val, encoding);\n        }\n        if (Buffer2.isBuffer(val)) {\n          if (val.length === 0) {\n            return -1;\n          }\n          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n        } else if (typeof val === \"number\") {\n          val = val & 255;\n          if (typeof GlobalUint8Array.prototype.indexOf === \"function\") {\n            if (dir) {\n              return GlobalUint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n            } else {\n              return GlobalUint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n            }\n          }\n          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);\n        }\n        throw new TypeError(\"val must be string, number or Buffer\");\n      }\n      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n        let indexSize = 1;\n        let arrLength = arr.length;\n        let valLength = val.length;\n        if (encoding !== void 0) {\n          encoding = String(encoding).toLowerCase();\n          if (encoding === \"ucs2\" || encoding === \"ucs-2\" || encoding === \"utf16le\" || encoding === \"utf-16le\") {\n            if (arr.length < 2 || val.length < 2) {\n              return -1;\n            }\n            indexSize = 2;\n            arrLength /= 2;\n            valLength /= 2;\n            byteOffset /= 2;\n          }\n        }\n        function read(buf, i2) {\n          if (indexSize === 1) {\n            return buf[i2];\n          } else {\n            return buf.readUInt16BE(i2 * indexSize);\n          }\n        }\n        let i;\n        if (dir) {\n          let foundIndex = -1;\n          for (i = byteOffset; i < arrLength; i++) {\n            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n              if (foundIndex === -1)\n                foundIndex = i;\n              if (i - foundIndex + 1 === valLength)\n                return foundIndex * indexSize;\n            } else {\n              if (foundIndex !== -1)\n                i -= i - foundIndex;\n              foundIndex = -1;\n            }\n          }\n        } else {\n          if (byteOffset + valLength > arrLength)\n            byteOffset = arrLength - valLength;\n          for (i = byteOffset; i >= 0; i--) {\n            let found = true;\n            for (let j = 0; j < valLength; j++) {\n              if (read(arr, i + j) !== read(val, j)) {\n                found = false;\n                break;\n              }\n            }\n            if (found)\n              return i;\n          }\n        }\n        return -1;\n      }\n      Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {\n        return this.indexOf(val, byteOffset, encoding) !== -1;\n      };\n      Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n      };\n      Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n      };\n      function hexWrite(buf, string, offset, length) {\n        offset = Number(offset) || 0;\n        const remaining = buf.length - offset;\n        if (!length) {\n          length = remaining;\n        } else {\n          length = Number(length);\n          if (length > remaining) {\n            length = remaining;\n          }\n        }\n        const strLen = string.length;\n        if (length > strLen / 2) {\n          length = strLen / 2;\n        }\n        let i;\n        for (i = 0; i < length; ++i) {\n          const parsed = parseInt(string.substr(i * 2, 2), 16);\n          if (numberIsNaN(parsed))\n            return i;\n          buf[offset + i] = parsed;\n        }\n        return i;\n      }\n      function utf8Write(buf, string, offset, length) {\n        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n      }\n      function asciiWrite(buf, string, offset, length) {\n        return blitBuffer(asciiToBytes(string), buf, offset, length);\n      }\n      function base64Write(buf, string, offset, length) {\n        return blitBuffer(base64ToBytes(string), buf, offset, length);\n      }\n      function ucs2Write(buf, string, offset, length) {\n        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n      }\n      Buffer2.prototype.write = function write(string, offset, length, encoding) {\n        if (offset === void 0) {\n          encoding = \"utf8\";\n          length = this.length;\n          offset = 0;\n        } else if (length === void 0 && typeof offset === \"string\") {\n          encoding = offset;\n          length = this.length;\n          offset = 0;\n        } else if (isFinite(offset)) {\n          offset = offset >>> 0;\n          if (isFinite(length)) {\n            length = length >>> 0;\n            if (encoding === void 0)\n              encoding = \"utf8\";\n          } else {\n            encoding = length;\n            length = void 0;\n          }\n        } else {\n          throw new Error(\n            \"Buffer.write(string, encoding, offset[, length]) is no longer supported\"\n          );\n        }\n        const remaining = this.length - offset;\n        if (length === void 0 || length > remaining)\n          length = remaining;\n        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n          throw new RangeError(\"Attempt to write outside buffer bounds\");\n        }\n        if (!encoding)\n          encoding = \"utf8\";\n        let loweredCase = false;\n        for (; ; ) {\n          switch (encoding) {\n            case \"hex\":\n              return hexWrite(this, string, offset, length);\n            case \"utf8\":\n            case \"utf-8\":\n              return utf8Write(this, string, offset, length);\n            case \"ascii\":\n            case \"latin1\":\n            case \"binary\":\n              return asciiWrite(this, string, offset, length);\n            case \"base64\":\n              return base64Write(this, string, offset, length);\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n              return ucs2Write(this, string, offset, length);\n            default:\n              if (loweredCase)\n                throw new TypeError(\"Unknown encoding: \" + encoding);\n              encoding = (\"\" + encoding).toLowerCase();\n              loweredCase = true;\n          }\n        }\n      };\n      Buffer2.prototype.toJSON = function toJSON() {\n        return {\n          type: \"Buffer\",\n          data: Array.prototype.slice.call(this._arr || this, 0)\n        };\n      };\n      function base64Slice(buf, start, end) {\n        if (start === 0 && end === buf.length) {\n          return base64.fromByteArray(buf);\n        } else {\n          return base64.fromByteArray(buf.slice(start, end));\n        }\n      }\n      function utf8Slice(buf, start, end) {\n        end = Math.min(buf.length, end);\n        const res = [];\n        let i = start;\n        while (i < end) {\n          const firstByte = buf[i];\n          let codePoint = null;\n          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;\n          if (i + bytesPerSequence <= end) {\n            let secondByte, thirdByte, fourthByte, tempCodePoint;\n            switch (bytesPerSequence) {\n              case 1:\n                if (firstByte < 128) {\n                  codePoint = firstByte;\n                }\n                break;\n              case 2:\n                secondByte = buf[i + 1];\n                if ((secondByte & 192) === 128) {\n                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;\n                  if (tempCodePoint > 127) {\n                    codePoint = tempCodePoint;\n                  }\n                }\n                break;\n              case 3:\n                secondByte = buf[i + 1];\n                thirdByte = buf[i + 2];\n                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {\n                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;\n                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {\n                    codePoint = tempCodePoint;\n                  }\n                }\n                break;\n              case 4:\n                secondByte = buf[i + 1];\n                thirdByte = buf[i + 2];\n                fourthByte = buf[i + 3];\n                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {\n                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;\n                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {\n                    codePoint = tempCodePoint;\n                  }\n                }\n            }\n          }\n          if (codePoint === null) {\n            codePoint = 65533;\n            bytesPerSequence = 1;\n          } else if (codePoint > 65535) {\n            codePoint -= 65536;\n            res.push(codePoint >>> 10 & 1023 | 55296);\n            codePoint = 56320 | codePoint & 1023;\n          }\n          res.push(codePoint);\n          i += bytesPerSequence;\n        }\n        return decodeCodePointsArray(res);\n      }\n      var MAX_ARGUMENTS_LENGTH = 4096;\n      function decodeCodePointsArray(codePoints) {\n        const len = codePoints.length;\n        if (len <= MAX_ARGUMENTS_LENGTH) {\n          return String.fromCharCode.apply(String, codePoints);\n        }\n        let res = \"\";\n        let i = 0;\n        while (i < len) {\n          res += String.fromCharCode.apply(\n            String,\n            codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n          );\n        }\n        return res;\n      }\n      function asciiSlice(buf, start, end) {\n        let ret = \"\";\n        end = Math.min(buf.length, end);\n        for (let i = start; i < end; ++i) {\n          ret += String.fromCharCode(buf[i] & 127);\n        }\n        return ret;\n      }\n      function latin1Slice(buf, start, end) {\n        let ret = \"\";\n        end = Math.min(buf.length, end);\n        for (let i = start; i < end; ++i) {\n          ret += String.fromCharCode(buf[i]);\n        }\n        return ret;\n      }\n      function hexSlice(buf, start, end) {\n        const len = buf.length;\n        if (!start || start < 0)\n          start = 0;\n        if (!end || end < 0 || end > len)\n          end = len;\n        let out = \"\";\n        for (let i = start; i < end; ++i) {\n          out += hexSliceLookupTable[buf[i]];\n        }\n        return out;\n      }\n      function utf16leSlice(buf, start, end) {\n        const bytes = buf.slice(start, end);\n        let res = \"\";\n        for (let i = 0; i < bytes.length - 1; i += 2) {\n          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n        }\n        return res;\n      }\n      Buffer2.prototype.slice = function slice(start, end) {\n        const len = this.length;\n        start = ~~start;\n        end = end === void 0 ? len : ~~end;\n        if (start < 0) {\n          start += len;\n          if (start < 0)\n            start = 0;\n        } else if (start > len) {\n          start = len;\n        }\n        if (end < 0) {\n          end += len;\n          if (end < 0)\n            end = 0;\n        } else if (end > len) {\n          end = len;\n        }\n        if (end < start)\n          end = start;\n        const newBuf = this.subarray(start, end);\n        Object.setPrototypeOf(newBuf, Buffer2.prototype);\n        return newBuf;\n      };\n      function checkOffset(offset, ext, length) {\n        if (offset % 1 !== 0 || offset < 0)\n          throw new RangeError(\"offset is not uint\");\n        if (offset + ext > length)\n          throw new RangeError(\"Trying to access beyond buffer length\");\n      }\n      Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert)\n          checkOffset(offset, byteLength2, this.length);\n        let val = this[offset];\n        let mul = 1;\n        let i = 0;\n        while (++i < byteLength2 && (mul *= 256)) {\n          val += this[offset + i] * mul;\n        }\n        return val;\n      };\n      Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert) {\n          checkOffset(offset, byteLength2, this.length);\n        }\n        let val = this[offset + --byteLength2];\n        let mul = 1;\n        while (byteLength2 > 0 && (mul *= 256)) {\n          val += this[offset + --byteLength2] * mul;\n        }\n        return val;\n      };\n      Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 1, this.length);\n        return this[offset];\n      };\n      Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 2, this.length);\n        return this[offset] | this[offset + 1] << 8;\n      };\n      Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 2, this.length);\n        return this[offset] << 8 | this[offset + 1];\n      };\n      Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;\n      };\n      Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n      };\n      Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {\n        offset = offset >>> 0;\n        validateNumber(offset, \"offset\");\n        const first = this[offset];\n        const last = this[offset + 7];\n        if (first === void 0 || last === void 0) {\n          boundsError(offset, this.length - 8);\n        }\n        const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;\n        const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;\n        return BigInt(lo) + (BigInt(hi) << BigInt(32));\n      });\n      Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {\n        offset = offset >>> 0;\n        validateNumber(offset, \"offset\");\n        const first = this[offset];\n        const last = this[offset + 7];\n        if (first === void 0 || last === void 0) {\n          boundsError(offset, this.length - 8);\n        }\n        const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];\n        const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;\n        return (BigInt(hi) << BigInt(32)) + BigInt(lo);\n      });\n      Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert)\n          checkOffset(offset, byteLength2, this.length);\n        let val = this[offset];\n        let mul = 1;\n        let i = 0;\n        while (++i < byteLength2 && (mul *= 256)) {\n          val += this[offset + i] * mul;\n        }\n        mul *= 128;\n        if (val >= mul)\n          val -= Math.pow(2, 8 * byteLength2);\n        return val;\n      };\n      Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert)\n          checkOffset(offset, byteLength2, this.length);\n        let i = byteLength2;\n        let mul = 1;\n        let val = this[offset + --i];\n        while (i > 0 && (mul *= 256)) {\n          val += this[offset + --i] * mul;\n        }\n        mul *= 128;\n        if (val >= mul)\n          val -= Math.pow(2, 8 * byteLength2);\n        return val;\n      };\n      Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 1, this.length);\n        if (!(this[offset] & 128))\n          return this[offset];\n        return (255 - this[offset] + 1) * -1;\n      };\n      Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 2, this.length);\n        const val = this[offset] | this[offset + 1] << 8;\n        return val & 32768 ? val | 4294901760 : val;\n      };\n      Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 2, this.length);\n        const val = this[offset + 1] | this[offset] << 8;\n        return val & 32768 ? val | 4294901760 : val;\n      };\n      Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n      };\n      Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n      };\n      Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {\n        offset = offset >>> 0;\n        validateNumber(offset, \"offset\");\n        const first = this[offset];\n        const last = this[offset + 7];\n        if (first === void 0 || last === void 0) {\n          boundsError(offset, this.length - 8);\n        }\n        const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);\n        return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);\n      });\n      Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {\n        offset = offset >>> 0;\n        validateNumber(offset, \"offset\");\n        const first = this[offset];\n        const last = this[offset + 7];\n        if (first === void 0 || last === void 0) {\n          boundsError(offset, this.length - 8);\n        }\n        const val = (first << 24) + // Overflow\n        this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];\n        return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);\n      });\n      Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return ieee754.read(this, offset, true, 23, 4);\n      };\n      Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return ieee754.read(this, offset, false, 23, 4);\n      };\n      Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 8, this.length);\n        return ieee754.read(this, offset, true, 52, 8);\n      };\n      Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 8, this.length);\n        return ieee754.read(this, offset, false, 52, 8);\n      };\n      function checkInt(buf, value, offset, ext, max, min) {\n        if (!Buffer2.isBuffer(buf))\n          throw new TypeError('\"buffer\" argument must be a Buffer instance');\n        if (value > max || value < min)\n          throw new RangeError('\"value\" argument is out of bounds');\n        if (offset + ext > buf.length)\n          throw new RangeError(\"Index out of range\");\n      }\n      Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert) {\n          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;\n          checkInt(this, value, offset, byteLength2, maxBytes, 0);\n        }\n        let mul = 1;\n        let i = 0;\n        this[offset] = value & 255;\n        while (++i < byteLength2 && (mul *= 256)) {\n          this[offset + i] = value / mul & 255;\n        }\n        return offset + byteLength2;\n      };\n      Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert) {\n          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;\n          checkInt(this, value, offset, byteLength2, maxBytes, 0);\n        }\n        let i = byteLength2 - 1;\n        let mul = 1;\n        this[offset + i] = value & 255;\n        while (--i >= 0 && (mul *= 256)) {\n          this[offset + i] = value / mul & 255;\n        }\n        return offset + byteLength2;\n      };\n      Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 1, 255, 0);\n        this[offset] = value & 255;\n        return offset + 1;\n      };\n      Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 2, 65535, 0);\n        this[offset] = value & 255;\n        this[offset + 1] = value >>> 8;\n        return offset + 2;\n      };\n      Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 2, 65535, 0);\n        this[offset] = value >>> 8;\n        this[offset + 1] = value & 255;\n        return offset + 2;\n      };\n      Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 4, 4294967295, 0);\n        this[offset + 3] = value >>> 24;\n        this[offset + 2] = value >>> 16;\n        this[offset + 1] = value >>> 8;\n        this[offset] = value & 255;\n        return offset + 4;\n      };\n      Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 4, 4294967295, 0);\n        this[offset] = value >>> 24;\n        this[offset + 1] = value >>> 16;\n        this[offset + 2] = value >>> 8;\n        this[offset + 3] = value & 255;\n        return offset + 4;\n      };\n      function wrtBigUInt64LE(buf, value, offset, min, max) {\n        checkIntBI(value, min, max, buf, offset, 7);\n        let lo = Number(value & BigInt(4294967295));\n        buf[offset++] = lo;\n        lo = lo >> 8;\n        buf[offset++] = lo;\n        lo = lo >> 8;\n        buf[offset++] = lo;\n        lo = lo >> 8;\n        buf[offset++] = lo;\n        let hi = Number(value >> BigInt(32) & BigInt(4294967295));\n        buf[offset++] = hi;\n        hi = hi >> 8;\n        buf[offset++] = hi;\n        hi = hi >> 8;\n        buf[offset++] = hi;\n        hi = hi >> 8;\n        buf[offset++] = hi;\n        return offset;\n      }\n      function wrtBigUInt64BE(buf, value, offset, min, max) {\n        checkIntBI(value, min, max, buf, offset, 7);\n        let lo = Number(value & BigInt(4294967295));\n        buf[offset + 7] = lo;\n        lo = lo >> 8;\n        buf[offset + 6] = lo;\n        lo = lo >> 8;\n        buf[offset + 5] = lo;\n        lo = lo >> 8;\n        buf[offset + 4] = lo;\n        let hi = Number(value >> BigInt(32) & BigInt(4294967295));\n        buf[offset + 3] = hi;\n        hi = hi >> 8;\n        buf[offset + 2] = hi;\n        hi = hi >> 8;\n        buf[offset + 1] = hi;\n        hi = hi >> 8;\n        buf[offset] = hi;\n        return offset + 8;\n      }\n      Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {\n        return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n      });\n      Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {\n        return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n      });\n      Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          const limit = Math.pow(2, 8 * byteLength2 - 1);\n          checkInt(this, value, offset, byteLength2, limit - 1, -limit);\n        }\n        let i = 0;\n        let mul = 1;\n        let sub = 0;\n        this[offset] = value & 255;\n        while (++i < byteLength2 && (mul *= 256)) {\n          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n            sub = 1;\n          }\n          this[offset + i] = (value / mul >> 0) - sub & 255;\n        }\n        return offset + byteLength2;\n      };\n      Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          const limit = Math.pow(2, 8 * byteLength2 - 1);\n          checkInt(this, value, offset, byteLength2, limit - 1, -limit);\n        }\n        let i = byteLength2 - 1;\n        let mul = 1;\n        let sub = 0;\n        this[offset + i] = value & 255;\n        while (--i >= 0 && (mul *= 256)) {\n          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n            sub = 1;\n          }\n          this[offset + i] = (value / mul >> 0) - sub & 255;\n        }\n        return offset + byteLength2;\n      };\n      Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 1, 127, -128);\n        if (value < 0)\n          value = 255 + value + 1;\n        this[offset] = value & 255;\n        return offset + 1;\n      };\n      Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 2, 32767, -32768);\n        this[offset] = value & 255;\n        this[offset + 1] = value >>> 8;\n        return offset + 2;\n      };\n      Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 2, 32767, -32768);\n        this[offset] = value >>> 8;\n        this[offset + 1] = value & 255;\n        return offset + 2;\n      };\n      Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 4, 2147483647, -2147483648);\n        this[offset] = value & 255;\n        this[offset + 1] = value >>> 8;\n        this[offset + 2] = value >>> 16;\n        this[offset + 3] = value >>> 24;\n        return offset + 4;\n      };\n      Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 4, 2147483647, -2147483648);\n        if (value < 0)\n          value = 4294967295 + value + 1;\n        this[offset] = value >>> 24;\n        this[offset + 1] = value >>> 16;\n        this[offset + 2] = value >>> 8;\n        this[offset + 3] = value & 255;\n        return offset + 4;\n      };\n      Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {\n        return wrtBigUInt64LE(this, value, offset, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n      });\n      Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {\n        return wrtBigUInt64BE(this, value, offset, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n      });\n      function checkIEEE754(buf, value, offset, ext, max, min) {\n        if (offset + ext > buf.length)\n          throw new RangeError(\"Index out of range\");\n        if (offset < 0)\n          throw new RangeError(\"Index out of range\");\n      }\n      function writeFloat(buf, value, offset, littleEndian, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);\n        }\n        ieee754.write(buf, value, offset, littleEndian, 23, 4);\n        return offset + 4;\n      }\n      Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n        return writeFloat(this, value, offset, true, noAssert);\n      };\n      Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n        return writeFloat(this, value, offset, false, noAssert);\n      };\n      function writeDouble(buf, value, offset, littleEndian, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);\n        }\n        ieee754.write(buf, value, offset, littleEndian, 52, 8);\n        return offset + 8;\n      }\n      Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n        return writeDouble(this, value, offset, true, noAssert);\n      };\n      Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n        return writeDouble(this, value, offset, false, noAssert);\n      };\n      Buffer2.prototype.copy = function copy(target, targetStart, start, end) {\n        if (!Buffer2.isBuffer(target))\n          throw new TypeError(\"argument should be a Buffer\");\n        if (!start)\n          start = 0;\n        if (!end && end !== 0)\n          end = this.length;\n        if (targetStart >= target.length)\n          targetStart = target.length;\n        if (!targetStart)\n          targetStart = 0;\n        if (end > 0 && end < start)\n          end = start;\n        if (end === start)\n          return 0;\n        if (target.length === 0 || this.length === 0)\n          return 0;\n        if (targetStart < 0) {\n          throw new RangeError(\"targetStart out of bounds\");\n        }\n        if (start < 0 || start >= this.length)\n          throw new RangeError(\"Index out of range\");\n        if (end < 0)\n          throw new RangeError(\"sourceEnd out of bounds\");\n        if (end > this.length)\n          end = this.length;\n        if (target.length - targetStart < end - start) {\n          end = target.length - targetStart + start;\n        }\n        const len = end - start;\n        if (this === target && typeof GlobalUint8Array.prototype.copyWithin === \"function\") {\n          this.copyWithin(targetStart, start, end);\n        } else {\n          GlobalUint8Array.prototype.set.call(\n            target,\n            this.subarray(start, end),\n            targetStart\n          );\n        }\n        return len;\n      };\n      Buffer2.prototype.fill = function fill(val, start, end, encoding) {\n        if (typeof val === \"string\") {\n          if (typeof start === \"string\") {\n            encoding = start;\n            start = 0;\n            end = this.length;\n          } else if (typeof end === \"string\") {\n            encoding = end;\n            end = this.length;\n          }\n          if (encoding !== void 0 && typeof encoding !== \"string\") {\n            throw new TypeError(\"encoding must be a string\");\n          }\n          if (typeof encoding === \"string\" && !Buffer2.isEncoding(encoding)) {\n            throw new TypeError(\"Unknown encoding: \" + encoding);\n          }\n          if (val.length === 1) {\n            const code = val.charCodeAt(0);\n            if (encoding === \"utf8\" && code < 128 || encoding === \"latin1\") {\n              val = code;\n            }\n          }\n        } else if (typeof val === \"number\") {\n          val = val & 255;\n        } else if (typeof val === \"boolean\") {\n          val = Number(val);\n        }\n        if (start < 0 || this.length < start || this.length < end) {\n          throw new RangeError(\"Out of range index\");\n        }\n        if (end <= start) {\n          return this;\n        }\n        start = start >>> 0;\n        end = end === void 0 ? this.length : end >>> 0;\n        if (!val)\n          val = 0;\n        let i;\n        if (typeof val === \"number\") {\n          for (i = start; i < end; ++i) {\n            this[i] = val;\n          }\n        } else {\n          const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);\n          const len = bytes.length;\n          if (len === 0) {\n            throw new TypeError('The value \"' + val + '\" is invalid for argument \"value\"');\n          }\n          for (i = 0; i < end - start; ++i) {\n            this[i + start] = bytes[i % len];\n          }\n        }\n        return this;\n      };\n      var errors = {};\n      function E(sym, getMessage, Base) {\n        errors[sym] = class NodeError extends Base {\n          constructor() {\n            super();\n            Object.defineProperty(this, \"message\", {\n              value: getMessage.apply(this, arguments),\n              writable: true,\n              configurable: true\n            });\n            this.name = `${this.name} [${sym}]`;\n            this.stack;\n            delete this.name;\n          }\n          get code() {\n            return sym;\n          }\n          set code(value) {\n            Object.defineProperty(this, \"code\", {\n              configurable: true,\n              enumerable: true,\n              value,\n              writable: true\n            });\n          }\n          toString() {\n            return `${this.name} [${sym}]: ${this.message}`;\n          }\n        };\n      }\n      E(\n        \"ERR_BUFFER_OUT_OF_BOUNDS\",\n        function(name) {\n          if (name) {\n            return `${name} is outside of buffer bounds`;\n          }\n          return \"Attempt to access memory outside buffer bounds\";\n        },\n        RangeError\n      );\n      E(\n        \"ERR_INVALID_ARG_TYPE\",\n        function(name, actual) {\n          return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`;\n        },\n        TypeError\n      );\n      E(\n        \"ERR_OUT_OF_RANGE\",\n        function(str, range, input) {\n          let msg = `The value of \"${str}\" is out of range.`;\n          let received = input;\n          if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n            received = addNumericalSeparator(String(input));\n          } else if (typeof input === \"bigint\") {\n            received = String(input);\n            if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n              received = addNumericalSeparator(received);\n            }\n            received += \"n\";\n          }\n          msg += ` It must be ${range}. Received ${received}`;\n          return msg;\n        },\n        RangeError\n      );\n      function addNumericalSeparator(val) {\n        let res = \"\";\n        let i = val.length;\n        const start = val[0] === \"-\" ? 1 : 0;\n        for (; i >= start + 4; i -= 3) {\n          res = `_${val.slice(i - 3, i)}${res}`;\n        }\n        return `${val.slice(0, i)}${res}`;\n      }\n      function checkBounds(buf, offset, byteLength2) {\n        validateNumber(offset, \"offset\");\n        if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {\n          boundsError(offset, buf.length - (byteLength2 + 1));\n        }\n      }\n      function checkIntBI(value, min, max, buf, offset, byteLength2) {\n        if (value > max || value < min) {\n          const n = typeof min === \"bigint\" ? \"n\" : \"\";\n          let range;\n          if (byteLength2 > 3) {\n            if (min === 0 || min === BigInt(0)) {\n              range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;\n            } else {\n              range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;\n            }\n          } else {\n            range = `>= ${min}${n} and <= ${max}${n}`;\n          }\n          throw new errors.ERR_OUT_OF_RANGE(\"value\", range, value);\n        }\n        checkBounds(buf, offset, byteLength2);\n      }\n      function validateNumber(value, name) {\n        if (typeof value !== \"number\") {\n          throw new errors.ERR_INVALID_ARG_TYPE(name, \"number\", value);\n        }\n      }\n      function boundsError(value, length, type) {\n        if (Math.floor(value) !== value) {\n          validateNumber(value, type);\n          throw new errors.ERR_OUT_OF_RANGE(type || \"offset\", \"an integer\", value);\n        }\n        if (length < 0) {\n          throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();\n        }\n        throw new errors.ERR_OUT_OF_RANGE(\n          type || \"offset\",\n          `>= ${type ? 1 : 0} and <= ${length}`,\n          value\n        );\n      }\n      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;\n      function base64clean(str) {\n        str = str.split(\"=\")[0];\n        str = str.trim().replace(INVALID_BASE64_RE, \"\");\n        if (str.length < 2)\n          return \"\";\n        while (str.length % 4 !== 0) {\n          str = str + \"=\";\n        }\n        return str;\n      }\n      function utf8ToBytes(string, units) {\n        units = units || Infinity;\n        let codePoint;\n        const length = string.length;\n        let leadSurrogate = null;\n        const bytes = [];\n        for (let i = 0; i < length; ++i) {\n          codePoint = string.charCodeAt(i);\n          if (codePoint > 55295 && codePoint < 57344) {\n            if (!leadSurrogate) {\n              if (codePoint > 56319) {\n                if ((units -= 3) > -1)\n                  bytes.push(239, 191, 189);\n                continue;\n              } else if (i + 1 === length) {\n                if ((units -= 3) > -1)\n                  bytes.push(239, 191, 189);\n                continue;\n              }\n              leadSurrogate = codePoint;\n              continue;\n            }\n            if (codePoint < 56320) {\n              if ((units -= 3) > -1)\n                bytes.push(239, 191, 189);\n              leadSurrogate = codePoint;\n              continue;\n            }\n            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;\n          } else if (leadSurrogate) {\n            if ((units -= 3) > -1)\n              bytes.push(239, 191, 189);\n          }\n          leadSurrogate = null;\n          if (codePoint < 128) {\n            if ((units -= 1) < 0)\n              break;\n            bytes.push(codePoint);\n          } else if (codePoint < 2048) {\n            if ((units -= 2) < 0)\n              break;\n            bytes.push(\n              codePoint >> 6 | 192,\n              codePoint & 63 | 128\n            );\n          } else if (codePoint < 65536) {\n            if ((units -= 3) < 0)\n              break;\n            bytes.push(\n              codePoint >> 12 | 224,\n              codePoint >> 6 & 63 | 128,\n              codePoint & 63 | 128\n            );\n          } else if (codePoint < 1114112) {\n            if ((units -= 4) < 0)\n              break;\n            bytes.push(\n              codePoint >> 18 | 240,\n              codePoint >> 12 & 63 | 128,\n              codePoint >> 6 & 63 | 128,\n              codePoint & 63 | 128\n            );\n          } else {\n            throw new Error(\"Invalid code point\");\n          }\n        }\n        return bytes;\n      }\n      function asciiToBytes(str) {\n        const byteArray = [];\n        for (let i = 0; i < str.length; ++i) {\n          byteArray.push(str.charCodeAt(i) & 255);\n        }\n        return byteArray;\n      }\n      function utf16leToBytes(str, units) {\n        let c, hi, lo;\n        const byteArray = [];\n        for (let i = 0; i < str.length; ++i) {\n          if ((units -= 2) < 0)\n            break;\n          c = str.charCodeAt(i);\n          hi = c >> 8;\n          lo = c % 256;\n          byteArray.push(lo);\n          byteArray.push(hi);\n        }\n        return byteArray;\n      }\n      function base64ToBytes(str) {\n        return base64.toByteArray(base64clean(str));\n      }\n      function blitBuffer(src, dst, offset, length) {\n        let i;\n        for (i = 0; i < length; ++i) {\n          if (i + offset >= dst.length || i >= src.length)\n            break;\n          dst[i + offset] = src[i];\n        }\n        return i;\n      }\n      function isInstance(obj, type) {\n        return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;\n      }\n      function numberIsNaN(obj) {\n        return obj !== obj;\n      }\n      var hexSliceLookupTable = function() {\n        const alphabet = \"0123456789abcdef\";\n        const table = new Array(256);\n        for (let i = 0; i < 16; ++i) {\n          const i16 = i * 16;\n          for (let j = 0; j < 16; ++j) {\n            table[i16 + j] = alphabet[i] + alphabet[j];\n          }\n        }\n        return table;\n      }();\n      function defineBigIntMethod(fn) {\n        return typeof BigInt === \"undefined\" ? BufferBigIntNotDefined : fn;\n      }\n      function BufferBigIntNotDefined() {\n        throw new Error(\"BigInt not supported\");\n      }\n    }\n  });\n\n  // node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js\n  var require_browser = __commonJS({\n    \"node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js\"(exports, module) {\n      init_dist();\n      var process = module.exports = {};\n      var cachedSetTimeout;\n      var cachedClearTimeout;\n      function defaultSetTimout() {\n        throw new Error(\"setTimeout has not been defined\");\n      }\n      function defaultClearTimeout() {\n        throw new Error(\"clearTimeout has not been defined\");\n      }\n      (function() {\n        try {\n          if (typeof setTimeout === \"function\") {\n            cachedSetTimeout = setTimeout;\n          } else {\n            cachedSetTimeout = defaultSetTimout;\n          }\n        } catch (e) {\n          cachedSetTimeout = defaultSetTimout;\n        }\n        try {\n          if (typeof clearTimeout === \"function\") {\n            cachedClearTimeout = clearTimeout;\n          } else {\n            cachedClearTimeout = defaultClearTimeout;\n          }\n        } catch (e) {\n          cachedClearTimeout = defaultClearTimeout;\n        }\n      })();\n      function runTimeout(fun) {\n        if (cachedSetTimeout === setTimeout) {\n          return setTimeout(fun, 0);\n        }\n        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n          cachedSetTimeout = setTimeout;\n          return setTimeout(fun, 0);\n        }\n        try {\n          return cachedSetTimeout(fun, 0);\n        } catch (e) {\n          try {\n            return cachedSetTimeout.call(null, fun, 0);\n          } catch (e2) {\n            return cachedSetTimeout.call(this, fun, 0);\n          }\n        }\n      }\n      function runClearTimeout(marker) {\n        if (cachedClearTimeout === clearTimeout) {\n          return clearTimeout(marker);\n        }\n        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n          cachedClearTimeout = clearTimeout;\n          return clearTimeout(marker);\n        }\n        try {\n          return cachedClearTimeout(marker);\n        } catch (e) {\n          try {\n            return cachedClearTimeout.call(null, marker);\n          } catch (e2) {\n            return cachedClearTimeout.call(this, marker);\n          }\n        }\n      }\n      var queue = [];\n      var draining = false;\n      var currentQueue;\n      var queueIndex = -1;\n      function cleanUpNextTick() {\n        if (!draining || !currentQueue) {\n          return;\n        }\n        draining = false;\n        if (currentQueue.length) {\n          queue = currentQueue.concat(queue);\n        } else {\n          queueIndex = -1;\n        }\n        if (queue.length) {\n          drainQueue();\n        }\n      }\n      function drainQueue() {\n        if (draining) {\n          return;\n        }\n        var timeout = runTimeout(cleanUpNextTick);\n        draining = true;\n        var len = queue.length;\n        while (len) {\n          currentQueue = queue;\n          queue = [];\n          while (++queueIndex < len) {\n            if (currentQueue) {\n              currentQueue[queueIndex].run();\n            }\n          }\n          queueIndex = -1;\n          len = queue.length;\n        }\n        currentQueue = null;\n        draining = false;\n        runClearTimeout(timeout);\n      }\n      process.nextTick = function(fun) {\n        var args = new Array(arguments.length - 1);\n        if (arguments.length > 1) {\n          for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n          }\n        }\n        queue.push(new Item(fun, args));\n        if (queue.length === 1 && !draining) {\n          runTimeout(drainQueue);\n        }\n      };\n      function Item(fun, array) {\n        this.fun = fun;\n        this.array = array;\n      }\n      Item.prototype.run = function() {\n        this.fun.apply(null, this.array);\n      };\n      process.title = \"browser\";\n      process.browser = true;\n      process.env = {};\n      process.argv = [];\n      process.version = \"\";\n      process.versions = {};\n      function noop() {\n      }\n      process.on = noop;\n      process.addListener = noop;\n      process.once = noop;\n      process.off = noop;\n      process.removeListener = noop;\n      process.removeAllListeners = noop;\n      process.emit = noop;\n      process.prependListener = noop;\n      process.prependOnceListener = noop;\n      process.listeners = function(name) {\n        return [];\n      };\n      process.binding = function(name) {\n        throw new Error(\"process.binding is not supported\");\n      };\n      process.cwd = function() {\n        return \"/\";\n      };\n      process.chdir = function(dir) {\n        throw new Error(\"process.chdir is not supported\");\n      };\n      process.umask = function() {\n        return 0;\n      };\n    }\n  });\n\n  // shims/dist/index.js\n  var import_buffer_polyfill, import_process, o;\n  var init_dist = __esm({\n    \"shims/dist/index.js\"() {\n      \"use strict\";\n      import_buffer_polyfill = __toESM(require_buffer(), 1);\n      import_process = __toESM(require_browser(), 1);\n      o = globalThis || void 0 || self;\n    }\n  });\n\n  // shims/banner/index.cjs\n  var require_banner = __commonJS({\n    \"shims/banner/index.cjs\"() {\n      init_dist();\n      globalThis.Buffer = globalThis.Buffer || import_buffer_polyfill.Buffer;\n      globalThis.global = globalThis.global || o;\n      globalThis.process = globalThis.process || import_process.default;\n    }\n  });\n  require_banner();\n})();\n/*! Bundled license information:\n\nieee754/index.js:\n  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)\n\nbuffer/index.js:\n  (*!\n   * The buffer module from node.js, for the browser.\n   *\n   * @author   Feross Aboukhadijeh <https://feross.org>\n   * @license  MIT\n   *)\n*/\n\nimport {\n  require_crypto_browserify\n} from \"./chunk-OYHNC6W5.js\";\nimport {\n  __commonJS,\n  __esm,\n  __export,\n  __require,\n  __toCommonJS,\n  __toESM,\n  require_buffer_polyfill,\n  require_dist\n} from \"./chunk-VMXIV7NB.js\";\n\n// node_modules/@aws-crypto/sha256-js/node_modules/tslib/tslib.es6.js\nvar tslib_es6_exports = {};\n__export(tslib_es6_exports, {\n  __assign: () => __assign,\n  __asyncDelegator: () => __asyncDelegator,\n  __asyncGenerator: () => __asyncGenerator,\n  __asyncValues: () => __asyncValues,\n  __await: () => __await,\n  __awaiter: () => __awaiter,\n  __classPrivateFieldGet: () => __classPrivateFieldGet,\n  __classPrivateFieldSet: () => __classPrivateFieldSet,\n  __createBinding: () => __createBinding,\n  __decorate: () => __decorate,\n  __exportStar: () => __exportStar,\n  __extends: () => __extends,\n  __generator: () => __generator,\n  __importDefault: () => __importDefault,\n  __importStar: () => __importStar,\n  __makeTemplateObject: () => __makeTemplateObject,\n  __metadata: () => __metadata,\n  __param: () => __param,\n  __read: () => __read,\n  __rest: () => __rest,\n  __spread: () => __spread,\n  __spreadArrays: () => __spreadArrays,\n  __values: () => __values\n});\nfunction __extends(d, b) {\n  extendStatics(d, b);\n  function __() {\n    this.constructor = d;\n  }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nfunction __rest(s, e) {\n  var t = {};\n  for (var p in s)\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n        t[p[i]] = s[p[i]];\n    }\n  return t;\n}\nfunction __decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n    r = Reflect.decorate(decorators, target, key, desc);\n  else\n    for (var i = decorators.length - 1; i >= 0; i--)\n      if (d = decorators[i])\n        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\nfunction __param(paramIndex, decorator) {\n  return function(target, key) {\n    decorator(target, key, paramIndex);\n  };\n}\nfunction __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\")\n    return Reflect.metadata(metadataKey, metadataValue);\n}\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function(resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function(resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\nfunction __generator(thisArg, body) {\n  var _ = { label: 0, sent: function() {\n    if (t[0] & 1)\n      throw t[1];\n    return t[1];\n  }, trys: [], ops: [] }, f, y, t, g;\n  return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n    return this;\n  }), g;\n  function verb(n) {\n    return function(v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f)\n      throw new TypeError(\"Generator is already executing.\");\n    while (_)\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n          return t;\n        if (y = 0, t)\n          op = [op[0] & 2, t.value];\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n          case 4:\n            _.label++;\n            return { value: op[1], done: false };\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n          case 7:\n            op = _.ops.pop();\n            _.trys.pop();\n            continue;\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n              _.ops.push(op);\n              break;\n            }\n            if (t[2])\n              _.ops.pop();\n            _.trys.pop();\n            continue;\n        }\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    if (op[0] & 5)\n      throw op[1];\n    return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\nfunction __createBinding(o, m, k, k2) {\n  if (k2 === void 0)\n    k2 = k;\n  o[k2] = m[k];\n}\nfunction __exportStar(m, exports) {\n  for (var p in m)\n    if (p !== \"default\" && !exports.hasOwnProperty(p))\n      exports[p] = m[p];\n}\nfunction __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m)\n    return m.call(o);\n  if (o && typeof o.length === \"number\")\n    return {\n      next: function() {\n        if (o && i >= o.length)\n          o = void 0;\n        return { value: o && o[i++], done: !o };\n      }\n    };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nfunction __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m)\n    return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)\n      ar.push(r.value);\n  } catch (error) {\n    e = { error };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"]))\n        m.call(i);\n    } finally {\n      if (e)\n        throw e.error;\n    }\n  }\n  return ar;\n}\nfunction __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n    ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\nfunction __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++)\n    s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++)\n    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n      r[k] = a[j];\n  return r;\n}\nfunction __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\nfunction __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator)\n    throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n    return this;\n  }, i;\n  function verb(n) {\n    if (g[n])\n      i[n] = function(v) {\n        return new Promise(function(a, b) {\n          q.push([n, v, a, b]) > 1 || resume(n, v);\n        });\n      };\n  }\n  function resume(n, v) {\n    try {\n      step(g[n](v));\n    } catch (e) {\n      settle(q[0][3], e);\n    }\n  }\n  function step(r) {\n    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n  }\n  function fulfill(value) {\n    resume(\"next\", value);\n  }\n  function reject(value) {\n    resume(\"throw\", value);\n  }\n  function settle(f, v) {\n    if (f(v), q.shift(), q.length)\n      resume(q[0][0], q[0][1]);\n  }\n}\nfunction __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function(e) {\n    throw e;\n  }), verb(\"return\"), i[Symbol.iterator] = function() {\n    return this;\n  }, i;\n  function verb(n, f) {\n    i[n] = o[n] ? function(v) {\n      return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v;\n    } : f;\n  }\n}\nfunction __asyncValues(o) {\n  if (!Symbol.asyncIterator)\n    throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n    return this;\n  }, i);\n  function verb(n) {\n    i[n] = o[n] && function(v) {\n      return new Promise(function(resolve, reject) {\n        v = o[n](v), settle(resolve, reject, v.done, v.value);\n      });\n    };\n  }\n  function settle(resolve, reject, d, v) {\n    Promise.resolve(v).then(function(v2) {\n      resolve({ value: v2, done: d });\n    }, reject);\n  }\n}\nfunction __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) {\n    Object.defineProperty(cooked, \"raw\", { value: raw });\n  } else {\n    cooked.raw = raw;\n  }\n  return cooked;\n}\nfunction __importStar(mod) {\n  if (mod && mod.__esModule)\n    return mod;\n  var result = {};\n  if (mod != null) {\n    for (var k in mod)\n      if (Object.hasOwnProperty.call(mod, k))\n        result[k] = mod[k];\n  }\n  result.default = mod;\n  return result;\n}\nfunction __importDefault(mod) {\n  return mod && mod.__esModule ? mod : { default: mod };\n}\nfunction __classPrivateFieldGet(receiver, privateMap) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to get private field on non-instance\");\n  }\n  return privateMap.get(receiver);\n}\nfunction __classPrivateFieldSet(receiver, privateMap, value) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to set private field on non-instance\");\n  }\n  privateMap.set(receiver, value);\n  return value;\n}\nvar import_dist4, extendStatics, __assign;\nvar init_tslib_es6 = __esm({\n  \"node_modules/@aws-crypto/sha256-js/node_modules/tslib/tslib.es6.js\"() {\n    import_dist4 = __toESM(require_dist());\n    extendStatics = function(d, b) {\n      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {\n        d2.__proto__ = b2;\n      } || function(d2, b2) {\n        for (var p in b2)\n          if (b2.hasOwnProperty(p))\n            d2[p] = b2[p];\n      };\n      return extendStatics(d, b);\n    };\n    __assign = function() {\n      __assign = Object.assign || function __assign2(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s)\n            if (Object.prototype.hasOwnProperty.call(s, p))\n              t[p] = s[p];\n        }\n        return t;\n      };\n      return __assign.apply(this, arguments);\n    };\n  }\n});\n\n// node_modules/@aws-crypto/sha256-js/build/constants.js\nvar require_constants = __commonJS({\n  \"node_modules/@aws-crypto/sha256-js/build/constants.js\"(exports) {\n    \"use strict\";\n    var import_dist28 = __toESM(require_dist());\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.MAX_HASHABLE_LENGTH = exports.INIT = exports.KEY = exports.DIGEST_LENGTH = exports.BLOCK_SIZE = void 0;\n    exports.BLOCK_SIZE = 64;\n    exports.DIGEST_LENGTH = 32;\n    exports.KEY = new Uint32Array([\n      1116352408,\n      1899447441,\n      3049323471,\n      3921009573,\n      961987163,\n      1508970993,\n      2453635748,\n      2870763221,\n      3624381080,\n      310598401,\n      607225278,\n      1426881987,\n      1925078388,\n      2162078206,\n      2614888103,\n      3248222580,\n      3835390401,\n      4022224774,\n      264347078,\n      604807628,\n      770255983,\n      1249150122,\n      1555081692,\n      1996064986,\n      2554220882,\n      2821834349,\n      2952996808,\n      3210313671,\n      3336571891,\n      3584528711,\n      113926993,\n      338241895,\n      666307205,\n      773529912,\n      1294757372,\n      1396182291,\n      1695183700,\n      1986661051,\n      2177026350,\n      2456956037,\n      2730485921,\n      2820302411,\n      3259730800,\n      3345764771,\n      3516065817,\n      3600352804,\n      4094571909,\n      275423344,\n      430227734,\n      506948616,\n      659060556,\n      883997877,\n      958139571,\n      1322822218,\n      1537002063,\n      1747873779,\n      1955562222,\n      2024104815,\n      2227730452,\n      2361852424,\n      2428436474,\n      2756734187,\n      3204031479,\n      3329325298\n    ]);\n    exports.INIT = [\n      1779033703,\n      3144134277,\n      1013904242,\n      2773480762,\n      1359893119,\n      2600822924,\n      528734635,\n      1541459225\n    ];\n    exports.MAX_HASHABLE_LENGTH = Math.pow(2, 53) - 1;\n  }\n});\n\n// node_modules/@aws-crypto/sha256-js/build/RawSha256.js\nvar require_RawSha256 = __commonJS({\n  \"node_modules/@aws-crypto/sha256-js/build/RawSha256.js\"(exports) {\n    \"use strict\";\n    var import_dist28 = __toESM(require_dist());\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.RawSha256 = void 0;\n    var constants_1 = require_constants();\n    var RawSha256 = (\n      /** @class */\n      function() {\n        function RawSha2562() {\n          this.state = Int32Array.from(constants_1.INIT);\n          this.temp = new Int32Array(64);\n          this.buffer = new Uint8Array(64);\n          this.bufferLength = 0;\n          this.bytesHashed = 0;\n          this.finished = false;\n        }\n        RawSha2562.prototype.update = function(data) {\n          if (this.finished) {\n            throw new Error(\"Attempted to update an already finished hash.\");\n          }\n          var position = 0;\n          var byteLength = data.byteLength;\n          this.bytesHashed += byteLength;\n          if (this.bytesHashed * 8 > constants_1.MAX_HASHABLE_LENGTH) {\n            throw new Error(\"Cannot hash more than 2^53 - 1 bits\");\n          }\n          while (byteLength > 0) {\n            this.buffer[this.bufferLength++] = data[position++];\n            byteLength--;\n            if (this.bufferLength === constants_1.BLOCK_SIZE) {\n              this.hashBuffer();\n              this.bufferLength = 0;\n            }\n          }\n        };\n        RawSha2562.prototype.digest = function() {\n          if (!this.finished) {\n            var bitsHashed = this.bytesHashed * 8;\n            var bufferView = new DataView(this.buffer.buffer, this.buffer.byteOffset, this.buffer.byteLength);\n            var undecoratedLength = this.bufferLength;\n            bufferView.setUint8(this.bufferLength++, 128);\n            if (undecoratedLength % constants_1.BLOCK_SIZE >= constants_1.BLOCK_SIZE - 8) {\n              for (var i = this.bufferLength; i < constants_1.BLOCK_SIZE; i++) {\n                bufferView.setUint8(i, 0);\n              }\n              this.hashBuffer();\n              this.bufferLength = 0;\n            }\n            for (var i = this.bufferLength; i < constants_1.BLOCK_SIZE - 8; i++) {\n              bufferView.setUint8(i, 0);\n            }\n            bufferView.setUint32(constants_1.BLOCK_SIZE - 8, Math.floor(bitsHashed / 4294967296), true);\n            bufferView.setUint32(constants_1.BLOCK_SIZE - 4, bitsHashed);\n            this.hashBuffer();\n            this.finished = true;\n          }\n          var out = new Uint8Array(constants_1.DIGEST_LENGTH);\n          for (var i = 0; i < 8; i++) {\n            out[i * 4] = this.state[i] >>> 24 & 255;\n            out[i * 4 + 1] = this.state[i] >>> 16 & 255;\n            out[i * 4 + 2] = this.state[i] >>> 8 & 255;\n            out[i * 4 + 3] = this.state[i] >>> 0 & 255;\n          }\n          return out;\n        };\n        RawSha2562.prototype.hashBuffer = function() {\n          var _a = this, buffer = _a.buffer, state = _a.state;\n          var state0 = state[0], state1 = state[1], state2 = state[2], state3 = state[3], state4 = state[4], state5 = state[5], state6 = state[6], state7 = state[7];\n          for (var i = 0; i < constants_1.BLOCK_SIZE; i++) {\n            if (i < 16) {\n              this.temp[i] = (buffer[i * 4] & 255) << 24 | (buffer[i * 4 + 1] & 255) << 16 | (buffer[i * 4 + 2] & 255) << 8 | buffer[i * 4 + 3] & 255;\n            } else {\n              var u = this.temp[i - 2];\n              var t1_1 = (u >>> 17 | u << 15) ^ (u >>> 19 | u << 13) ^ u >>> 10;\n              u = this.temp[i - 15];\n              var t2_1 = (u >>> 7 | u << 25) ^ (u >>> 18 | u << 14) ^ u >>> 3;\n              this.temp[i] = (t1_1 + this.temp[i - 7] | 0) + (t2_1 + this.temp[i - 16] | 0);\n            }\n            var t1 = (((state4 >>> 6 | state4 << 26) ^ (state4 >>> 11 | state4 << 21) ^ (state4 >>> 25 | state4 << 7)) + (state4 & state5 ^ ~state4 & state6) | 0) + (state7 + (constants_1.KEY[i] + this.temp[i] | 0) | 0) | 0;\n            var t2 = ((state0 >>> 2 | state0 << 30) ^ (state0 >>> 13 | state0 << 19) ^ (state0 >>> 22 | state0 << 10)) + (state0 & state1 ^ state0 & state2 ^ state1 & state2) | 0;\n            state7 = state6;\n            state6 = state5;\n            state5 = state4;\n            state4 = state3 + t1 | 0;\n            state3 = state2;\n            state2 = state1;\n            state1 = state0;\n            state0 = t1 + t2 | 0;\n          }\n          state[0] += state0;\n          state[1] += state1;\n          state[2] += state2;\n          state[3] += state3;\n          state[4] += state4;\n          state[5] += state5;\n          state[6] += state6;\n          state[7] += state7;\n        };\n        return RawSha2562;\n      }()\n    );\n    exports.RawSha256 = RawSha256;\n  }\n});\n\n// node_modules/@aws-sdk/util-utf8-browser/dist-es/pureJs.js\nvar import_dist5, fromUtf8, toUtf8;\nvar init_pureJs = __esm({\n  \"node_modules/@aws-sdk/util-utf8-browser/dist-es/pureJs.js\"() {\n    import_dist5 = __toESM(require_dist());\n    fromUtf8 = (input) => {\n      const bytes = [];\n      for (let i = 0, len = input.length; i < len; i++) {\n        const value = input.charCodeAt(i);\n        if (value < 128) {\n          bytes.push(value);\n        } else if (value < 2048) {\n          bytes.push(value >> 6 | 192, value & 63 | 128);\n        } else if (i + 1 < input.length && (value & 64512) === 55296 && (input.charCodeAt(i + 1) & 64512) === 56320) {\n          const surrogatePair = 65536 + ((value & 1023) << 10) + (input.charCodeAt(++i) & 1023);\n          bytes.push(surrogatePair >> 18 | 240, surrogatePair >> 12 & 63 | 128, surrogatePair >> 6 & 63 | 128, surrogatePair & 63 | 128);\n        } else {\n          bytes.push(value >> 12 | 224, value >> 6 & 63 | 128, value & 63 | 128);\n        }\n      }\n      return Uint8Array.from(bytes);\n    };\n    toUtf8 = (input) => {\n      let decoded = \"\";\n      for (let i = 0, len = input.length; i < len; i++) {\n        const byte = input[i];\n        if (byte < 128) {\n          decoded += String.fromCharCode(byte);\n        } else if (192 <= byte && byte < 224) {\n          const nextByte = input[++i];\n          decoded += String.fromCharCode((byte & 31) << 6 | nextByte & 63);\n        } else if (240 <= byte && byte < 365) {\n          const surrogatePair = [byte, input[++i], input[++i], input[++i]];\n          const encoded = \"%\" + surrogatePair.map((byteValue) => byteValue.toString(16)).join(\"%\");\n          decoded += decodeURIComponent(encoded);\n        } else {\n          decoded += String.fromCharCode((byte & 15) << 12 | (input[++i] & 63) << 6 | input[++i] & 63);\n        }\n      }\n      return decoded;\n    };\n  }\n});\n\n// node_modules/@aws-sdk/util-utf8-browser/dist-es/whatwgEncodingApi.js\nfunction fromUtf82(input) {\n  return new TextEncoder().encode(input);\n}\nfunction toUtf82(input) {\n  return new TextDecoder(\"utf-8\").decode(input);\n}\nvar import_dist6;\nvar init_whatwgEncodingApi = __esm({\n  \"node_modules/@aws-sdk/util-utf8-browser/dist-es/whatwgEncodingApi.js\"() {\n    import_dist6 = __toESM(require_dist());\n  }\n});\n\n// node_modules/@aws-sdk/util-utf8-browser/dist-es/index.js\nvar dist_es_exports = {};\n__export(dist_es_exports, {\n  fromUtf8: () => fromUtf83,\n  toUtf8: () => toUtf83\n});\nvar import_dist7, fromUtf83, toUtf83;\nvar init_dist_es = __esm({\n  \"node_modules/@aws-sdk/util-utf8-browser/dist-es/index.js\"() {\n    import_dist7 = __toESM(require_dist());\n    init_pureJs();\n    init_whatwgEncodingApi();\n    fromUtf83 = (input) => typeof TextEncoder === \"function\" ? fromUtf82(input) : fromUtf8(input);\n    toUtf83 = (input) => typeof TextDecoder === \"function\" ? toUtf82(input) : toUtf8(input);\n  }\n});\n\n// node_modules/@aws-crypto/util/build/convertToBuffer.js\nvar require_convertToBuffer = __commonJS({\n  \"node_modules/@aws-crypto/util/build/convertToBuffer.js\"(exports) {\n    \"use strict\";\n    var import_dist28 = __toESM(require_dist());\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.convertToBuffer = void 0;\n    var util_utf8_browser_1 = (init_dist_es(), __toCommonJS(dist_es_exports));\n    var fromUtf84 = typeof Buffer !== \"undefined\" && Buffer.from ? function(input) {\n      return Buffer.from(input, \"utf8\");\n    } : util_utf8_browser_1.fromUtf8;\n    function convertToBuffer(data) {\n      if (data instanceof Uint8Array)\n        return data;\n      if (typeof data === \"string\") {\n        return fromUtf84(data);\n      }\n      if (ArrayBuffer.isView(data)) {\n        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);\n      }\n      return new Uint8Array(data);\n    }\n    exports.convertToBuffer = convertToBuffer;\n  }\n});\n\n// node_modules/@aws-crypto/util/build/isEmptyData.js\nvar require_isEmptyData = __commonJS({\n  \"node_modules/@aws-crypto/util/build/isEmptyData.js\"(exports) {\n    \"use strict\";\n    var import_dist28 = __toESM(require_dist());\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.isEmptyData = void 0;\n    function isEmptyData(data) {\n      if (typeof data === \"string\") {\n        return data.length === 0;\n      }\n      return data.byteLength === 0;\n    }\n    exports.isEmptyData = isEmptyData;\n  }\n});\n\n// node_modules/@aws-crypto/util/build/numToUint8.js\nvar require_numToUint8 = __commonJS({\n  \"node_modules/@aws-crypto/util/build/numToUint8.js\"(exports) {\n    \"use strict\";\n    var import_dist28 = __toESM(require_dist());\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.numToUint8 = void 0;\n    function numToUint8(num) {\n      return new Uint8Array([\n        (num & 4278190080) >> 24,\n        (num & 16711680) >> 16,\n        (num & 65280) >> 8,\n        num & 255\n      ]);\n    }\n    exports.numToUint8 = numToUint8;\n  }\n});\n\n// node_modules/@aws-crypto/util/build/uint32ArrayFrom.js\nvar require_uint32ArrayFrom = __commonJS({\n  \"node_modules/@aws-crypto/util/build/uint32ArrayFrom.js\"(exports) {\n    \"use strict\";\n    var import_dist28 = __toESM(require_dist());\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.uint32ArrayFrom = void 0;\n    function uint32ArrayFrom(a_lookUpTable) {\n      if (!Array.from) {\n        var return_array = new Uint32Array(a_lookUpTable.length);\n        var a_index = 0;\n        while (a_index < a_lookUpTable.length) {\n          return_array[a_index] = a_lookUpTable[a_index];\n        }\n        return return_array;\n      }\n      return Uint32Array.from(a_lookUpTable);\n    }\n    exports.uint32ArrayFrom = uint32ArrayFrom;\n  }\n});\n\n// node_modules/@aws-crypto/util/build/index.js\nvar require_build = __commonJS({\n  \"node_modules/@aws-crypto/util/build/index.js\"(exports) {\n    \"use strict\";\n    var import_dist28 = __toESM(require_dist());\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.uint32ArrayFrom = exports.numToUint8 = exports.isEmptyData = exports.convertToBuffer = void 0;\n    var convertToBuffer_1 = require_convertToBuffer();\n    Object.defineProperty(exports, \"convertToBuffer\", { enumerable: true, get: function() {\n      return convertToBuffer_1.convertToBuffer;\n    } });\n    var isEmptyData_1 = require_isEmptyData();\n    Object.defineProperty(exports, \"isEmptyData\", { enumerable: true, get: function() {\n      return isEmptyData_1.isEmptyData;\n    } });\n    var numToUint8_1 = require_numToUint8();\n    Object.defineProperty(exports, \"numToUint8\", { enumerable: true, get: function() {\n      return numToUint8_1.numToUint8;\n    } });\n    var uint32ArrayFrom_1 = require_uint32ArrayFrom();\n    Object.defineProperty(exports, \"uint32ArrayFrom\", { enumerable: true, get: function() {\n      return uint32ArrayFrom_1.uint32ArrayFrom;\n    } });\n  }\n});\n\n// node_modules/@aws-crypto/sha256-js/build/jsSha256.js\nvar require_jsSha256 = __commonJS({\n  \"node_modules/@aws-crypto/sha256-js/build/jsSha256.js\"(exports) {\n    \"use strict\";\n    var import_dist28 = __toESM(require_dist());\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.Sha256 = void 0;\n    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));\n    var constants_1 = require_constants();\n    var RawSha256_1 = require_RawSha256();\n    var util_1 = require_build();\n    var Sha2563 = (\n      /** @class */\n      function() {\n        function Sha2564(secret) {\n          this.hash = new RawSha256_1.RawSha256();\n          if (secret) {\n            this.outer = new RawSha256_1.RawSha256();\n            var inner = bufferFromSecret(secret);\n            var outer = new Uint8Array(constants_1.BLOCK_SIZE);\n            outer.set(inner);\n            for (var i = 0; i < constants_1.BLOCK_SIZE; i++) {\n              inner[i] ^= 54;\n              outer[i] ^= 92;\n            }\n            this.hash.update(inner);\n            this.outer.update(outer);\n            for (var i = 0; i < inner.byteLength; i++) {\n              inner[i] = 0;\n            }\n          }\n        }\n        Sha2564.prototype.update = function(toHash) {\n          if ((0, util_1.isEmptyData)(toHash) || this.error) {\n            return;\n          }\n          try {\n            this.hash.update((0, util_1.convertToBuffer)(toHash));\n          } catch (e) {\n            this.error = e;\n          }\n        };\n        Sha2564.prototype.digestSync = function() {\n          if (this.error) {\n            throw this.error;\n          }\n          if (this.outer) {\n            if (!this.outer.finished) {\n              this.outer.update(this.hash.digest());\n            }\n            return this.outer.digest();\n          }\n          return this.hash.digest();\n        };\n        Sha2564.prototype.digest = function() {\n          return (0, tslib_1.__awaiter)(this, void 0, void 0, function() {\n            return (0, tslib_1.__generator)(this, function(_a) {\n              return [2, this.digestSync()];\n            });\n          });\n        };\n        return Sha2564;\n      }()\n    );\n    exports.Sha256 = Sha2563;\n    function bufferFromSecret(secret) {\n      var input = (0, util_1.convertToBuffer)(secret);\n      if (input.byteLength > constants_1.BLOCK_SIZE) {\n        var bufferHash = new RawSha256_1.RawSha256();\n        bufferHash.update(input);\n        input = bufferHash.digest();\n      }\n      var buffer = new Uint8Array(constants_1.BLOCK_SIZE);\n      buffer.set(input);\n      return buffer;\n    }\n  }\n});\n\n// node_modules/@aws-crypto/sha256-js/build/index.js\nvar require_build2 = __commonJS({\n  \"node_modules/@aws-crypto/sha256-js/build/index.js\"(exports) {\n    \"use strict\";\n    var import_dist28 = __toESM(require_dist());\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));\n    (0, tslib_1.__exportStar)(require_jsSha256(), exports);\n  }\n});\n\n// node_modules/unfetch/dist/unfetch.module.js\nvar unfetch_module_exports = {};\n__export(unfetch_module_exports, {\n  default: () => unfetch_module_default\n});\nfunction unfetch_module_default(e, n) {\n  return n = n || {}, new Promise(function(t, r) {\n    var s = new XMLHttpRequest(), o = [], u = [], i = {}, a = function() {\n      return { ok: 2 == (s.status / 100 | 0), statusText: s.statusText, status: s.status, url: s.responseURL, text: function() {\n        return Promise.resolve(s.responseText);\n      }, json: function() {\n        return Promise.resolve(s.responseText).then(JSON.parse);\n      }, blob: function() {\n        return Promise.resolve(new Blob([s.response]));\n      }, clone: a, headers: { keys: function() {\n        return o;\n      }, entries: function() {\n        return u;\n      }, get: function(e2) {\n        return i[e2.toLowerCase()];\n      }, has: function(e2) {\n        return e2.toLowerCase() in i;\n      } } };\n    };\n    for (var l in s.open(n.method || \"get\", e, true), s.onload = function() {\n      s.getAllResponseHeaders().replace(/^(.*?):[^\\S\\n]*([\\s\\S]*?)$/gm, function(e2, n2, t2) {\n        o.push(n2 = n2.toLowerCase()), u.push([n2, t2]), i[n2] = i[n2] ? i[n2] + \",\" + t2 : t2;\n      }), t(a());\n    }, s.onerror = r, s.withCredentials = \"include\" == n.credentials, n.headers)\n      s.setRequestHeader(l, n.headers[l]);\n    s.send(n.body || null);\n  });\n}\nvar import_dist21;\nvar init_unfetch_module = __esm({\n  \"node_modules/unfetch/dist/unfetch.module.js\"() {\n    import_dist21 = __toESM(require_dist());\n  }\n});\n\n// node_modules/isomorphic-unfetch/browser.js\nvar require_browser = __commonJS({\n  \"node_modules/isomorphic-unfetch/browser.js\"(exports, module) {\n    var import_dist28 = __toESM(require_dist());\n    module.exports = self.fetch || (self.fetch = (init_unfetch_module(), __toCommonJS(unfetch_module_exports)).default || (init_unfetch_module(), __toCommonJS(unfetch_module_exports)));\n  }\n});\n\n// node_modules/js-cookie/src/js.cookie.js\nvar require_js_cookie = __commonJS({\n  \"node_modules/js-cookie/src/js.cookie.js\"(exports, module) {\n    var import_dist28 = __toESM(require_dist());\n    (function(factory) {\n      var registeredInModuleLoader;\n      if (typeof define === \"function\" && define.amd) {\n        define(factory);\n        registeredInModuleLoader = true;\n      }\n      if (typeof exports === \"object\") {\n        module.exports = factory();\n        registeredInModuleLoader = true;\n      }\n      if (!registeredInModuleLoader) {\n        var OldCookies = window.Cookies;\n        var api = window.Cookies = factory();\n        api.noConflict = function() {\n          window.Cookies = OldCookies;\n          return api;\n        };\n      }\n    })(function() {\n      function extend() {\n        var i = 0;\n        var result = {};\n        for (; i < arguments.length; i++) {\n          var attributes = arguments[i];\n          for (var key in attributes) {\n            result[key] = attributes[key];\n          }\n        }\n        return result;\n      }\n      function decode(s) {\n        return s.replace(/(%[0-9A-Z]{2})+/g, decodeURIComponent);\n      }\n      function init(converter) {\n        function api() {\n        }\n        function set2(key, value, attributes) {\n          if (typeof document === \"undefined\") {\n            return;\n          }\n          attributes = extend({\n            path: \"/\"\n          }, api.defaults, attributes);\n          if (typeof attributes.expires === \"number\") {\n            attributes.expires = new Date(/* @__PURE__ */ new Date() * 1 + attributes.expires * 864e5);\n          }\n          attributes.expires = attributes.expires ? attributes.expires.toUTCString() : \"\";\n          try {\n            var result = JSON.stringify(value);\n            if (/^[\\{\\[]/.test(result)) {\n              value = result;\n            }\n          } catch (e) {\n          }\n          value = converter.write ? converter.write(value, key) : encodeURIComponent(String(value)).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);\n          key = encodeURIComponent(String(key)).replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent).replace(/[\\(\\)]/g, escape);\n          var stringifiedAttributes = \"\";\n          for (var attributeName in attributes) {\n            if (!attributes[attributeName]) {\n              continue;\n            }\n            stringifiedAttributes += \"; \" + attributeName;\n            if (attributes[attributeName] === true) {\n              continue;\n            }\n            stringifiedAttributes += \"=\" + attributes[attributeName].split(\";\")[0];\n          }\n          return document.cookie = key + \"=\" + value + stringifiedAttributes;\n        }\n        function get2(key, json) {\n          if (typeof document === \"undefined\") {\n            return;\n          }\n          var jar = {};\n          var cookies = document.cookie ? document.cookie.split(\"; \") : [];\n          var i = 0;\n          for (; i < cookies.length; i++) {\n            var parts = cookies[i].split(\"=\");\n            var cookie = parts.slice(1).join(\"=\");\n            if (!json && cookie.charAt(0) === '\"') {\n              cookie = cookie.slice(1, -1);\n            }\n            try {\n              var name = decode(parts[0]);\n              cookie = (converter.read || converter)(cookie, name) || decode(cookie);\n              if (json) {\n                try {\n                  cookie = JSON.parse(cookie);\n                } catch (e) {\n                }\n              }\n              jar[name] = cookie;\n              if (key === name) {\n                break;\n              }\n            } catch (e) {\n            }\n          }\n          return key ? jar[key] : jar;\n        }\n        api.set = set2;\n        api.get = function(key) {\n          return get2(\n            key,\n            false\n            /* read as raw */\n          );\n        };\n        api.getJSON = function(key) {\n          return get2(\n            key,\n            true\n            /* read as json */\n          );\n        };\n        api.remove = function(key, attributes) {\n          set2(key, \"\", extend(attributes, {\n            expires: -1\n          }));\n        };\n        api.defaults = {};\n        api.withConverter = init;\n        return api;\n      }\n      return init(function() {\n      });\n    });\n  }\n});\n\n// node_modules/amazon-cognito-identity-js/es/index.js\nvar import_dist27 = __toESM(require_dist());\n\n// node_modules/amazon-cognito-identity-js/es/AuthenticationDetails.js\nvar import_dist = __toESM(require_dist());\nvar AuthenticationDetails = function() {\n  function AuthenticationDetails2(data) {\n    var _ref = data || {}, ValidationData = _ref.ValidationData, Username = _ref.Username, Password = _ref.Password, AuthParameters = _ref.AuthParameters, ClientMetadata = _ref.ClientMetadata;\n    this.validationData = ValidationData || {};\n    this.authParameters = AuthParameters || {};\n    this.clientMetadata = ClientMetadata || {};\n    this.username = Username;\n    this.password = Password;\n  }\n  var _proto = AuthenticationDetails2.prototype;\n  _proto.getUsername = function getUsername() {\n    return this.username;\n  };\n  _proto.getPassword = function getPassword() {\n    return this.password;\n  };\n  _proto.getValidationData = function getValidationData() {\n    return this.validationData;\n  };\n  _proto.getAuthParameters = function getAuthParameters() {\n    return this.authParameters;\n  };\n  _proto.getClientMetadata = function getClientMetadata() {\n    return this.clientMetadata;\n  };\n  return AuthenticationDetails2;\n}();\n\n// node_modules/amazon-cognito-identity-js/es/AuthenticationHelper.js\nvar import_dist9 = __toESM(require_dist());\nvar import_buffer = __toESM(require_buffer_polyfill());\n\n// node_modules/amazon-cognito-identity-js/es/utils/WordArray.js\nvar import_dist3 = __toESM(require_dist());\n\n// node_modules/amazon-cognito-identity-js/es/utils/cryptoSecureRandomInt.js\nvar import_dist2 = __toESM(require_dist());\nvar crypto;\nif (typeof window !== \"undefined\" && window.crypto) {\n  crypto = window.crypto;\n}\nif (!crypto && typeof window !== \"undefined\" && window.msCrypto) {\n  crypto = window.msCrypto;\n}\nif (!crypto && typeof global !== \"undefined\" && global.crypto) {\n  crypto = global.crypto;\n}\nif (!crypto && typeof __require === \"function\") {\n  try {\n    crypto = require_crypto_browserify();\n  } catch (err) {\n  }\n}\nfunction cryptoSecureRandomInt() {\n  if (crypto) {\n    if (typeof crypto.getRandomValues === \"function\") {\n      try {\n        return crypto.getRandomValues(new Uint32Array(1))[0];\n      } catch (err) {\n      }\n    }\n    if (typeof crypto.randomBytes === \"function\") {\n      try {\n        return crypto.randomBytes(4).readInt32LE();\n      } catch (err) {\n      }\n    }\n  }\n  throw new Error(\"Native crypto module could not be used to get secure random number.\");\n}\n\n// node_modules/amazon-cognito-identity-js/es/utils/WordArray.js\nfunction hexStringify(wordArray) {\n  var words = wordArray.words;\n  var sigBytes = wordArray.sigBytes;\n  var hexChars = [];\n  for (var i = 0; i < sigBytes; i++) {\n    var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;\n    hexChars.push((bite >>> 4).toString(16));\n    hexChars.push((bite & 15).toString(16));\n  }\n  return hexChars.join(\"\");\n}\nvar WordArray = function() {\n  function WordArray2(words, sigBytes) {\n    words = this.words = words || [];\n    if (sigBytes != void 0) {\n      this.sigBytes = sigBytes;\n    } else {\n      this.sigBytes = words.length * 4;\n    }\n  }\n  var _proto = WordArray2.prototype;\n  _proto.random = function random(nBytes) {\n    var words = [];\n    for (var i = 0; i < nBytes; i += 4) {\n      words.push(cryptoSecureRandomInt());\n    }\n    return new WordArray2(words, nBytes);\n  };\n  _proto.toString = function toString() {\n    return hexStringify(this);\n  };\n  return WordArray2;\n}();\n\n// node_modules/amazon-cognito-identity-js/es/AuthenticationHelper.js\nvar import_sha256_js = __toESM(require_build2());\n\n// node_modules/amazon-cognito-identity-js/es/BigInteger.js\nvar import_dist8 = __toESM(require_dist());\nvar BigInteger_default = BigInteger;\nfunction BigInteger(a, b) {\n  if (a != null)\n    this.fromString(a, b);\n}\nfunction nbi() {\n  return new BigInteger(null);\n}\nvar dbits;\nvar canary = 244837814094590;\nvar j_lm = (canary & 16777215) == 15715070;\nfunction am1(i, x, w, j, c, n) {\n  while (--n >= 0) {\n    var v = x * this[i++] + w[j] + c;\n    c = Math.floor(v / 67108864);\n    w[j++] = v & 67108863;\n  }\n  return c;\n}\nfunction am2(i, x, w, j, c, n) {\n  var xl = x & 32767, xh = x >> 15;\n  while (--n >= 0) {\n    var l = this[i] & 32767;\n    var h = this[i++] >> 15;\n    var m = xh * l + h * xl;\n    l = xl * l + ((m & 32767) << 15) + w[j] + (c & 1073741823);\n    c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);\n    w[j++] = l & 1073741823;\n  }\n  return c;\n}\nfunction am3(i, x, w, j, c, n) {\n  var xl = x & 16383, xh = x >> 14;\n  while (--n >= 0) {\n    var l = this[i] & 16383;\n    var h = this[i++] >> 14;\n    var m = xh * l + h * xl;\n    l = xl * l + ((m & 16383) << 14) + w[j] + c;\n    c = (l >> 28) + (m >> 14) + xh * h;\n    w[j++] = l & 268435455;\n  }\n  return c;\n}\nvar inBrowser = typeof navigator !== \"undefined\";\nif (inBrowser && j_lm && navigator.appName == \"Microsoft Internet Explorer\") {\n  BigInteger.prototype.am = am2;\n  dbits = 30;\n} else if (inBrowser && j_lm && navigator.appName != \"Netscape\") {\n  BigInteger.prototype.am = am1;\n  dbits = 26;\n} else {\n  BigInteger.prototype.am = am3;\n  dbits = 28;\n}\nBigInteger.prototype.DB = dbits;\nBigInteger.prototype.DM = (1 << dbits) - 1;\nBigInteger.prototype.DV = 1 << dbits;\nvar BI_FP = 52;\nBigInteger.prototype.FV = Math.pow(2, BI_FP);\nBigInteger.prototype.F1 = BI_FP - dbits;\nBigInteger.prototype.F2 = 2 * dbits - BI_FP;\nvar BI_RM = \"0123456789abcdefghijklmnopqrstuvwxyz\";\nvar BI_RC = new Array();\nvar rr;\nvar vv;\nrr = \"0\".charCodeAt(0);\nfor (vv = 0; vv <= 9; ++vv)\n  BI_RC[rr++] = vv;\nrr = \"a\".charCodeAt(0);\nfor (vv = 10; vv < 36; ++vv)\n  BI_RC[rr++] = vv;\nrr = \"A\".charCodeAt(0);\nfor (vv = 10; vv < 36; ++vv)\n  BI_RC[rr++] = vv;\nfunction int2char(n) {\n  return BI_RM.charAt(n);\n}\nfunction intAt(s, i) {\n  var c = BI_RC[s.charCodeAt(i)];\n  return c == null ? -1 : c;\n}\nfunction bnpCopyTo(r) {\n  for (var i = this.t - 1; i >= 0; --i)\n    r[i] = this[i];\n  r.t = this.t;\n  r.s = this.s;\n}\nfunction bnpFromInt(x) {\n  this.t = 1;\n  this.s = x < 0 ? -1 : 0;\n  if (x > 0)\n    this[0] = x;\n  else if (x < -1)\n    this[0] = x + this.DV;\n  else\n    this.t = 0;\n}\nfunction nbv(i) {\n  var r = nbi();\n  r.fromInt(i);\n  return r;\n}\nfunction bnpFromString(s, b) {\n  var k;\n  if (b == 16)\n    k = 4;\n  else if (b == 8)\n    k = 3;\n  else if (b == 2)\n    k = 1;\n  else if (b == 32)\n    k = 5;\n  else if (b == 4)\n    k = 2;\n  else\n    throw new Error(\"Only radix 2, 4, 8, 16, 32 are supported\");\n  this.t = 0;\n  this.s = 0;\n  var i = s.length, mi = false, sh = 0;\n  while (--i >= 0) {\n    var x = intAt(s, i);\n    if (x < 0) {\n      if (s.charAt(i) == \"-\")\n        mi = true;\n      continue;\n    }\n    mi = false;\n    if (sh == 0)\n      this[this.t++] = x;\n    else if (sh + k > this.DB) {\n      this[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;\n      this[this.t++] = x >> this.DB - sh;\n    } else\n      this[this.t - 1] |= x << sh;\n    sh += k;\n    if (sh >= this.DB)\n      sh -= this.DB;\n  }\n  this.clamp();\n  if (mi)\n    BigInteger.ZERO.subTo(this, this);\n}\nfunction bnpClamp() {\n  var c = this.s & this.DM;\n  while (this.t > 0 && this[this.t - 1] == c)\n    --this.t;\n}\nfunction bnToString(b) {\n  if (this.s < 0)\n    return \"-\" + this.negate().toString(b);\n  var k;\n  if (b == 16)\n    k = 4;\n  else if (b == 8)\n    k = 3;\n  else if (b == 2)\n    k = 1;\n  else if (b == 32)\n    k = 5;\n  else if (b == 4)\n    k = 2;\n  else\n    throw new Error(\"Only radix 2, 4, 8, 16, 32 are supported\");\n  var km = (1 << k) - 1, d, m = false, r = \"\", i = this.t;\n  var p = this.DB - i * this.DB % k;\n  if (i-- > 0) {\n    if (p < this.DB && (d = this[i] >> p) > 0) {\n      m = true;\n      r = int2char(d);\n    }\n    while (i >= 0) {\n      if (p < k) {\n        d = (this[i] & (1 << p) - 1) << k - p;\n        d |= this[--i] >> (p += this.DB - k);\n      } else {\n        d = this[i] >> (p -= k) & km;\n        if (p <= 0) {\n          p += this.DB;\n          --i;\n        }\n      }\n      if (d > 0)\n        m = true;\n      if (m)\n        r += int2char(d);\n    }\n  }\n  return m ? r : \"0\";\n}\nfunction bnNegate() {\n  var r = nbi();\n  BigInteger.ZERO.subTo(this, r);\n  return r;\n}\nfunction bnAbs() {\n  return this.s < 0 ? this.negate() : this;\n}\nfunction bnCompareTo(a) {\n  var r = this.s - a.s;\n  if (r != 0)\n    return r;\n  var i = this.t;\n  r = i - a.t;\n  if (r != 0)\n    return this.s < 0 ? -r : r;\n  while (--i >= 0)\n    if ((r = this[i] - a[i]) != 0)\n      return r;\n  return 0;\n}\nfunction nbits(x) {\n  var r = 1, t;\n  if ((t = x >>> 16) != 0) {\n    x = t;\n    r += 16;\n  }\n  if ((t = x >> 8) != 0) {\n    x = t;\n    r += 8;\n  }\n  if ((t = x >> 4) != 0) {\n    x = t;\n    r += 4;\n  }\n  if ((t = x >> 2) != 0) {\n    x = t;\n    r += 2;\n  }\n  if ((t = x >> 1) != 0) {\n    x = t;\n    r += 1;\n  }\n  return r;\n}\nfunction bnBitLength() {\n  if (this.t <= 0)\n    return 0;\n  return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ this.s & this.DM);\n}\nfunction bnpDLShiftTo(n, r) {\n  var i;\n  for (i = this.t - 1; i >= 0; --i)\n    r[i + n] = this[i];\n  for (i = n - 1; i >= 0; --i)\n    r[i] = 0;\n  r.t = this.t + n;\n  r.s = this.s;\n}\nfunction bnpDRShiftTo(n, r) {\n  for (var i = n; i < this.t; ++i)\n    r[i - n] = this[i];\n  r.t = Math.max(this.t - n, 0);\n  r.s = this.s;\n}\nfunction bnpLShiftTo(n, r) {\n  var bs = n % this.DB;\n  var cbs = this.DB - bs;\n  var bm = (1 << cbs) - 1;\n  var ds = Math.floor(n / this.DB), c = this.s << bs & this.DM, i;\n  for (i = this.t - 1; i >= 0; --i) {\n    r[i + ds + 1] = this[i] >> cbs | c;\n    c = (this[i] & bm) << bs;\n  }\n  for (i = ds - 1; i >= 0; --i)\n    r[i] = 0;\n  r[ds] = c;\n  r.t = this.t + ds + 1;\n  r.s = this.s;\n  r.clamp();\n}\nfunction bnpRShiftTo(n, r) {\n  r.s = this.s;\n  var ds = Math.floor(n / this.DB);\n  if (ds >= this.t) {\n    r.t = 0;\n    return;\n  }\n  var bs = n % this.DB;\n  var cbs = this.DB - bs;\n  var bm = (1 << bs) - 1;\n  r[0] = this[ds] >> bs;\n  for (var i = ds + 1; i < this.t; ++i) {\n    r[i - ds - 1] |= (this[i] & bm) << cbs;\n    r[i - ds] = this[i] >> bs;\n  }\n  if (bs > 0)\n    r[this.t - ds - 1] |= (this.s & bm) << cbs;\n  r.t = this.t - ds;\n  r.clamp();\n}\nfunction bnpSubTo(a, r) {\n  var i = 0, c = 0, m = Math.min(a.t, this.t);\n  while (i < m) {\n    c += this[i] - a[i];\n    r[i++] = c & this.DM;\n    c >>= this.DB;\n  }\n  if (a.t < this.t) {\n    c -= a.s;\n    while (i < this.t) {\n      c += this[i];\n      r[i++] = c & this.DM;\n      c >>= this.DB;\n    }\n    c += this.s;\n  } else {\n    c += this.s;\n    while (i < a.t) {\n      c -= a[i];\n      r[i++] = c & this.DM;\n      c >>= this.DB;\n    }\n    c -= a.s;\n  }\n  r.s = c < 0 ? -1 : 0;\n  if (c < -1)\n    r[i++] = this.DV + c;\n  else if (c > 0)\n    r[i++] = c;\n  r.t = i;\n  r.clamp();\n}\nfunction bnpMultiplyTo(a, r) {\n  var x = this.abs(), y = a.abs();\n  var i = x.t;\n  r.t = i + y.t;\n  while (--i >= 0)\n    r[i] = 0;\n  for (i = 0; i < y.t; ++i)\n    r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);\n  r.s = 0;\n  r.clamp();\n  if (this.s != a.s)\n    BigInteger.ZERO.subTo(r, r);\n}\nfunction bnpSquareTo(r) {\n  var x = this.abs();\n  var i = r.t = 2 * x.t;\n  while (--i >= 0)\n    r[i] = 0;\n  for (i = 0; i < x.t - 1; ++i) {\n    var c = x.am(i, x[i], r, 2 * i, 0, 1);\n    if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {\n      r[i + x.t] -= x.DV;\n      r[i + x.t + 1] = 1;\n    }\n  }\n  if (r.t > 0)\n    r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);\n  r.s = 0;\n  r.clamp();\n}\nfunction bnpDivRemTo(m, q, r) {\n  var pm = m.abs();\n  if (pm.t <= 0)\n    return;\n  var pt = this.abs();\n  if (pt.t < pm.t) {\n    if (q != null)\n      q.fromInt(0);\n    if (r != null)\n      this.copyTo(r);\n    return;\n  }\n  if (r == null)\n    r = nbi();\n  var y = nbi(), ts = this.s, ms = m.s;\n  var nsh = this.DB - nbits(pm[pm.t - 1]);\n  if (nsh > 0) {\n    pm.lShiftTo(nsh, y);\n    pt.lShiftTo(nsh, r);\n  } else {\n    pm.copyTo(y);\n    pt.copyTo(r);\n  }\n  var ys = y.t;\n  var y0 = y[ys - 1];\n  if (y0 == 0)\n    return;\n  var yt = y0 * (1 << this.F1) + (ys > 1 ? y[ys - 2] >> this.F2 : 0);\n  var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;\n  var i = r.t, j = i - ys, t = q == null ? nbi() : q;\n  y.dlShiftTo(j, t);\n  if (r.compareTo(t) >= 0) {\n    r[r.t++] = 1;\n    r.subTo(t, r);\n  }\n  BigInteger.ONE.dlShiftTo(ys, t);\n  t.subTo(y, y);\n  while (y.t < ys)\n    y[y.t++] = 0;\n  while (--j >= 0) {\n    var qd = r[--i] == y0 ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);\n    if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) {\n      y.dlShiftTo(j, t);\n      r.subTo(t, r);\n      while (r[i] < --qd)\n        r.subTo(t, r);\n    }\n  }\n  if (q != null) {\n    r.drShiftTo(ys, q);\n    if (ts != ms)\n      BigInteger.ZERO.subTo(q, q);\n  }\n  r.t = ys;\n  r.clamp();\n  if (nsh > 0)\n    r.rShiftTo(nsh, r);\n  if (ts < 0)\n    BigInteger.ZERO.subTo(r, r);\n}\nfunction bnMod(a) {\n  var r = nbi();\n  this.abs().divRemTo(a, null, r);\n  if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0)\n    a.subTo(r, r);\n  return r;\n}\nfunction bnpInvDigit() {\n  if (this.t < 1)\n    return 0;\n  var x = this[0];\n  if ((x & 1) == 0)\n    return 0;\n  var y = x & 3;\n  y = y * (2 - (x & 15) * y) & 15;\n  y = y * (2 - (x & 255) * y) & 255;\n  y = y * (2 - ((x & 65535) * y & 65535)) & 65535;\n  y = y * (2 - x * y % this.DV) % this.DV;\n  return y > 0 ? this.DV - y : -y;\n}\nfunction bnEquals(a) {\n  return this.compareTo(a) == 0;\n}\nfunction bnpAddTo(a, r) {\n  var i = 0, c = 0, m = Math.min(a.t, this.t);\n  while (i < m) {\n    c += this[i] + a[i];\n    r[i++] = c & this.DM;\n    c >>= this.DB;\n  }\n  if (a.t < this.t) {\n    c += a.s;\n    while (i < this.t) {\n      c += this[i];\n      r[i++] = c & this.DM;\n      c >>= this.DB;\n    }\n    c += this.s;\n  } else {\n    c += this.s;\n    while (i < a.t) {\n      c += a[i];\n      r[i++] = c & this.DM;\n      c >>= this.DB;\n    }\n    c += a.s;\n  }\n  r.s = c < 0 ? -1 : 0;\n  if (c > 0)\n    r[i++] = c;\n  else if (c < -1)\n    r[i++] = this.DV + c;\n  r.t = i;\n  r.clamp();\n}\nfunction bnAdd(a) {\n  var r = nbi();\n  this.addTo(a, r);\n  return r;\n}\nfunction bnSubtract(a) {\n  var r = nbi();\n  this.subTo(a, r);\n  return r;\n}\nfunction bnMultiply(a) {\n  var r = nbi();\n  this.multiplyTo(a, r);\n  return r;\n}\nfunction bnDivide(a) {\n  var r = nbi();\n  this.divRemTo(a, r, null);\n  return r;\n}\nfunction Montgomery(m) {\n  this.m = m;\n  this.mp = m.invDigit();\n  this.mpl = this.mp & 32767;\n  this.mph = this.mp >> 15;\n  this.um = (1 << m.DB - 15) - 1;\n  this.mt2 = 2 * m.t;\n}\nfunction montConvert(x) {\n  var r = nbi();\n  x.abs().dlShiftTo(this.m.t, r);\n  r.divRemTo(this.m, null, r);\n  if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0)\n    this.m.subTo(r, r);\n  return r;\n}\nfunction montRevert(x) {\n  var r = nbi();\n  x.copyTo(r);\n  this.reduce(r);\n  return r;\n}\nfunction montReduce(x) {\n  while (x.t <= this.mt2)\n    x[x.t++] = 0;\n  for (var i = 0; i < this.m.t; ++i) {\n    var j = x[i] & 32767;\n    var u0 = j * this.mpl + ((j * this.mph + (x[i] >> 15) * this.mpl & this.um) << 15) & x.DM;\n    j = i + this.m.t;\n    x[j] += this.m.am(0, u0, x, i, 0, this.m.t);\n    while (x[j] >= x.DV) {\n      x[j] -= x.DV;\n      x[++j]++;\n    }\n  }\n  x.clamp();\n  x.drShiftTo(this.m.t, x);\n  if (x.compareTo(this.m) >= 0)\n    x.subTo(this.m, x);\n}\nfunction montSqrTo(x, r) {\n  x.squareTo(r);\n  this.reduce(r);\n}\nfunction montMulTo(x, y, r) {\n  x.multiplyTo(y, r);\n  this.reduce(r);\n}\nMontgomery.prototype.convert = montConvert;\nMontgomery.prototype.revert = montRevert;\nMontgomery.prototype.reduce = montReduce;\nMontgomery.prototype.mulTo = montMulTo;\nMontgomery.prototype.sqrTo = montSqrTo;\nfunction bnModPow(e, m, callback) {\n  var i = e.bitLength(), k, r = nbv(1), z = new Montgomery(m);\n  if (i <= 0)\n    return r;\n  else if (i < 18)\n    k = 1;\n  else if (i < 48)\n    k = 3;\n  else if (i < 144)\n    k = 4;\n  else if (i < 768)\n    k = 5;\n  else\n    k = 6;\n  var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;\n  g[1] = z.convert(this);\n  if (k > 1) {\n    var g2 = nbi();\n    z.sqrTo(g[1], g2);\n    while (n <= km) {\n      g[n] = nbi();\n      z.mulTo(g2, g[n - 2], g[n]);\n      n += 2;\n    }\n  }\n  var j = e.t - 1, w, is1 = true, r2 = nbi(), t;\n  i = nbits(e[j]) - 1;\n  while (j >= 0) {\n    if (i >= k1)\n      w = e[j] >> i - k1 & km;\n    else {\n      w = (e[j] & (1 << i + 1) - 1) << k1 - i;\n      if (j > 0)\n        w |= e[j - 1] >> this.DB + i - k1;\n    }\n    n = k;\n    while ((w & 1) == 0) {\n      w >>= 1;\n      --n;\n    }\n    if ((i -= n) < 0) {\n      i += this.DB;\n      --j;\n    }\n    if (is1) {\n      g[w].copyTo(r);\n      is1 = false;\n    } else {\n      while (n > 1) {\n        z.sqrTo(r, r2);\n        z.sqrTo(r2, r);\n        n -= 2;\n      }\n      if (n > 0)\n        z.sqrTo(r, r2);\n      else {\n        t = r;\n        r = r2;\n        r2 = t;\n      }\n      z.mulTo(r2, g[w], r);\n    }\n    while (j >= 0 && (e[j] & 1 << i) == 0) {\n      z.sqrTo(r, r2);\n      t = r;\n      r = r2;\n      r2 = t;\n      if (--i < 0) {\n        i = this.DB - 1;\n        --j;\n      }\n    }\n  }\n  var result = z.revert(r);\n  callback(null, result);\n  return result;\n}\nBigInteger.prototype.copyTo = bnpCopyTo;\nBigInteger.prototype.fromInt = bnpFromInt;\nBigInteger.prototype.fromString = bnpFromString;\nBigInteger.prototype.clamp = bnpClamp;\nBigInteger.prototype.dlShiftTo = bnpDLShiftTo;\nBigInteger.prototype.drShiftTo = bnpDRShiftTo;\nBigInteger.prototype.lShiftTo = bnpLShiftTo;\nBigInteger.prototype.rShiftTo = bnpRShiftTo;\nBigInteger.prototype.subTo = bnpSubTo;\nBigInteger.prototype.multiplyTo = bnpMultiplyTo;\nBigInteger.prototype.squareTo = bnpSquareTo;\nBigInteger.prototype.divRemTo = bnpDivRemTo;\nBigInteger.prototype.invDigit = bnpInvDigit;\nBigInteger.prototype.addTo = bnpAddTo;\nBigInteger.prototype.toString = bnToString;\nBigInteger.prototype.negate = bnNegate;\nBigInteger.prototype.abs = bnAbs;\nBigInteger.prototype.compareTo = bnCompareTo;\nBigInteger.prototype.bitLength = bnBitLength;\nBigInteger.prototype.mod = bnMod;\nBigInteger.prototype.equals = bnEquals;\nBigInteger.prototype.add = bnAdd;\nBigInteger.prototype.subtract = bnSubtract;\nBigInteger.prototype.multiply = bnMultiply;\nBigInteger.prototype.divide = bnDivide;\nBigInteger.prototype.modPow = bnModPow;\nBigInteger.ZERO = nbv(0);\nBigInteger.ONE = nbv(1);\n\n// node_modules/amazon-cognito-identity-js/es/AuthenticationHelper.js\nfunction randomBytes(nBytes) {\n  return import_buffer.Buffer.from(new WordArray().random(nBytes).toString(), \"hex\");\n}\nvar HEX_MSB_REGEX = /^[89a-f]/i;\nvar initN = \"FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D670C354E4ABC9804F1746C08CA18217C32905E462E36CE3BE39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9DE2BCBF6955817183995497CEA956AE515D2261898FA051015728E5A8AAAC42DAD33170D04507A33A85521ABDF1CBA64ECFB850458DBEF0A8AEA71575D060C7DB3970F85A6E1E4C7ABF5AE8CDB0933D71E8C94E04A25619DCEE3D2261AD2EE6BF12FFA06D98A0864D87602733EC86A64521F2B18177B200CBBE117577A615D6C770988C0BAD946E208E24FA074E5AB3143DB5BFCE0FD108E4B82D120A93AD2CAFFFFFFFFFFFFFFFF\";\nvar newPasswordRequiredChallengeUserAttributePrefix = \"userAttributes.\";\nvar AuthenticationHelper = function() {\n  function AuthenticationHelper2(PoolName) {\n    this.N = new BigInteger_default(initN, 16);\n    this.g = new BigInteger_default(\"2\", 16);\n    this.k = new BigInteger_default(this.hexHash(\"\" + this.padHex(this.N) + this.padHex(this.g)), 16);\n    this.smallAValue = this.generateRandomSmallA();\n    this.getLargeAValue(function() {\n    });\n    this.infoBits = import_buffer.Buffer.from(\"Caldera Derived Key\", \"utf8\");\n    this.poolName = PoolName;\n  }\n  var _proto = AuthenticationHelper2.prototype;\n  _proto.getSmallAValue = function getSmallAValue() {\n    return this.smallAValue;\n  };\n  _proto.getLargeAValue = function getLargeAValue(callback) {\n    var _this = this;\n    if (this.largeAValue) {\n      callback(null, this.largeAValue);\n    } else {\n      this.calculateA(this.smallAValue, function(err, largeAValue) {\n        if (err) {\n          callback(err, null);\n        }\n        _this.largeAValue = largeAValue;\n        callback(null, _this.largeAValue);\n      });\n    }\n  };\n  _proto.generateRandomSmallA = function generateRandomSmallA() {\n    var hexRandom = randomBytes(128).toString(\"hex\");\n    var randomBigInt = new BigInteger_default(hexRandom, 16);\n    return randomBigInt;\n  };\n  _proto.generateRandomString = function generateRandomString() {\n    return randomBytes(40).toString(\"base64\");\n  };\n  _proto.getRandomPassword = function getRandomPassword() {\n    return this.randomPassword;\n  };\n  _proto.getSaltDevices = function getSaltDevices() {\n    return this.SaltToHashDevices;\n  };\n  _proto.getVerifierDevices = function getVerifierDevices() {\n    return this.verifierDevices;\n  };\n  _proto.generateHashDevice = function generateHashDevice(deviceGroupKey, username, callback) {\n    var _this2 = this;\n    this.randomPassword = this.generateRandomString();\n    var combinedString = \"\" + deviceGroupKey + username + \":\" + this.randomPassword;\n    var hashedString = this.hash(combinedString);\n    var hexRandom = randomBytes(16).toString(\"hex\");\n    this.SaltToHashDevices = this.padHex(new BigInteger_default(hexRandom, 16));\n    this.g.modPow(new BigInteger_default(this.hexHash(this.SaltToHashDevices + hashedString), 16), this.N, function(err, verifierDevicesNotPadded) {\n      if (err) {\n        callback(err, null);\n      }\n      _this2.verifierDevices = _this2.padHex(verifierDevicesNotPadded);\n      callback(null, null);\n    });\n  };\n  _proto.calculateA = function calculateA(a, callback) {\n    var _this3 = this;\n    this.g.modPow(a, this.N, function(err, A) {\n      if (err) {\n        callback(err, null);\n      }\n      if (A.mod(_this3.N).equals(BigInteger_default.ZERO)) {\n        callback(new Error(\"Illegal paramater. A mod N cannot be 0.\"), null);\n      }\n      callback(null, A);\n    });\n  };\n  _proto.calculateU = function calculateU(A, B) {\n    this.UHexHash = this.hexHash(this.padHex(A) + this.padHex(B));\n    var finalU = new BigInteger_default(this.UHexHash, 16);\n    return finalU;\n  };\n  _proto.hash = function hash(buf) {\n    var awsCryptoHash = new import_sha256_js.Sha256();\n    awsCryptoHash.update(buf);\n    var resultFromAWSCrypto = awsCryptoHash.digestSync();\n    var hashHex = import_buffer.Buffer.from(resultFromAWSCrypto).toString(\"hex\");\n    return new Array(64 - hashHex.length).join(\"0\") + hashHex;\n  };\n  _proto.hexHash = function hexHash(hexStr) {\n    return this.hash(import_buffer.Buffer.from(hexStr, \"hex\"));\n  };\n  _proto.computehkdf = function computehkdf(ikm, salt) {\n    var infoBitsBuffer = import_buffer.Buffer.concat([this.infoBits, import_buffer.Buffer.from(String.fromCharCode(1), \"utf8\")]);\n    var awsCryptoHash = new import_sha256_js.Sha256(salt);\n    awsCryptoHash.update(ikm);\n    var resultFromAWSCryptoPrk = awsCryptoHash.digestSync();\n    var awsCryptoHashHmac = new import_sha256_js.Sha256(resultFromAWSCryptoPrk);\n    awsCryptoHashHmac.update(infoBitsBuffer);\n    var resultFromAWSCryptoHmac = awsCryptoHashHmac.digestSync();\n    var hashHexFromAWSCrypto = resultFromAWSCryptoHmac;\n    var currentHex = hashHexFromAWSCrypto.slice(0, 16);\n    return currentHex;\n  };\n  _proto.getPasswordAuthenticationKey = function getPasswordAuthenticationKey(username, password, serverBValue, salt, callback) {\n    var _this4 = this;\n    if (serverBValue.mod(this.N).equals(BigInteger_default.ZERO)) {\n      throw new Error(\"B cannot be zero.\");\n    }\n    this.UValue = this.calculateU(this.largeAValue, serverBValue);\n    if (this.UValue.equals(BigInteger_default.ZERO)) {\n      throw new Error(\"U cannot be zero.\");\n    }\n    var usernamePassword = \"\" + this.poolName + username + \":\" + password;\n    var usernamePasswordHash = this.hash(usernamePassword);\n    var xValue = new BigInteger_default(this.hexHash(this.padHex(salt) + usernamePasswordHash), 16);\n    this.calculateS(xValue, serverBValue, function(err, sValue) {\n      if (err) {\n        callback(err, null);\n      }\n      var hkdf = _this4.computehkdf(import_buffer.Buffer.from(_this4.padHex(sValue), \"hex\"), import_buffer.Buffer.from(_this4.padHex(_this4.UValue), \"hex\"));\n      callback(null, hkdf);\n    });\n  };\n  _proto.calculateS = function calculateS(xValue, serverBValue, callback) {\n    var _this5 = this;\n    this.g.modPow(xValue, this.N, function(err, gModPowXN) {\n      if (err) {\n        callback(err, null);\n      }\n      var intValue2 = serverBValue.subtract(_this5.k.multiply(gModPowXN));\n      intValue2.modPow(_this5.smallAValue.add(_this5.UValue.multiply(xValue)), _this5.N, function(err2, result) {\n        if (err2) {\n          callback(err2, null);\n        }\n        callback(null, result.mod(_this5.N));\n      });\n    });\n  };\n  _proto.getNewPasswordRequiredChallengeUserAttributePrefix = function getNewPasswordRequiredChallengeUserAttributePrefix() {\n    return newPasswordRequiredChallengeUserAttributePrefix;\n  };\n  _proto.padHex = function padHex(bigInt) {\n    if (!(bigInt instanceof BigInteger_default)) {\n      throw new Error(\"Not a BigInteger\");\n    }\n    var isNegative = bigInt.compareTo(BigInteger_default.ZERO) < 0;\n    var hexStr = bigInt.abs().toString(16);\n    hexStr = hexStr.length % 2 !== 0 ? \"0\" + hexStr : hexStr;\n    hexStr = HEX_MSB_REGEX.test(hexStr) ? \"00\" + hexStr : hexStr;\n    if (isNegative) {\n      var invertedNibbles = hexStr.split(\"\").map(function(x) {\n        var invertedNibble = ~parseInt(x, 16) & 15;\n        return \"0123456789ABCDEF\".charAt(invertedNibble);\n      }).join(\"\");\n      var flippedBitsBI = new BigInteger_default(invertedNibbles, 16).add(BigInteger_default.ONE);\n      hexStr = flippedBitsBI.toString(16);\n      if (hexStr.toUpperCase().startsWith(\"FF8\")) {\n        hexStr = hexStr.substring(2);\n      }\n    }\n    return hexStr;\n  };\n  return AuthenticationHelper2;\n}();\n\n// node_modules/amazon-cognito-identity-js/es/CognitoAccessToken.js\nvar import_dist11 = __toESM(require_dist());\n\n// node_modules/amazon-cognito-identity-js/es/CognitoJwtToken.js\nvar import_dist10 = __toESM(require_dist());\nvar import_buffer2 = __toESM(require_buffer_polyfill());\nvar CognitoJwtToken = function() {\n  function CognitoJwtToken2(token) {\n    this.jwtToken = token || \"\";\n    this.payload = this.decodePayload();\n  }\n  var _proto = CognitoJwtToken2.prototype;\n  _proto.getJwtToken = function getJwtToken() {\n    return this.jwtToken;\n  };\n  _proto.getExpiration = function getExpiration() {\n    return this.payload.exp;\n  };\n  _proto.getIssuedAt = function getIssuedAt() {\n    return this.payload.iat;\n  };\n  _proto.decodePayload = function decodePayload() {\n    var payload = this.jwtToken.split(\".\")[1];\n    try {\n      return JSON.parse(import_buffer2.Buffer.from(payload, \"base64\").toString(\"utf8\"));\n    } catch (err) {\n      return {};\n    }\n  };\n  return CognitoJwtToken2;\n}();\n\n// node_modules/amazon-cognito-identity-js/es/CognitoAccessToken.js\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf4(o2, p2) {\n    o2.__proto__ = p2;\n    return o2;\n  };\n  return _setPrototypeOf(o, p);\n}\nvar CognitoAccessToken = function(_CognitoJwtToken) {\n  _inheritsLoose(CognitoAccessToken2, _CognitoJwtToken);\n  function CognitoAccessToken2(_temp) {\n    var _ref = _temp === void 0 ? {} : _temp, AccessToken = _ref.AccessToken;\n    return _CognitoJwtToken.call(this, AccessToken || \"\") || this;\n  }\n  return CognitoAccessToken2;\n}(CognitoJwtToken);\n\n// node_modules/amazon-cognito-identity-js/es/CognitoIdToken.js\nvar import_dist12 = __toESM(require_dist());\nfunction _inheritsLoose2(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  _setPrototypeOf2(subClass, superClass);\n}\nfunction _setPrototypeOf2(o, p) {\n  _setPrototypeOf2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf4(o2, p2) {\n    o2.__proto__ = p2;\n    return o2;\n  };\n  return _setPrototypeOf2(o, p);\n}\nvar CognitoIdToken = function(_CognitoJwtToken) {\n  _inheritsLoose2(CognitoIdToken2, _CognitoJwtToken);\n  function CognitoIdToken2(_temp) {\n    var _ref = _temp === void 0 ? {} : _temp, IdToken = _ref.IdToken;\n    return _CognitoJwtToken.call(this, IdToken || \"\") || this;\n  }\n  return CognitoIdToken2;\n}(CognitoJwtToken);\n\n// node_modules/amazon-cognito-identity-js/es/CognitoRefreshToken.js\nvar import_dist13 = __toESM(require_dist());\nvar CognitoRefreshToken = function() {\n  function CognitoRefreshToken2(_temp) {\n    var _ref = _temp === void 0 ? {} : _temp, RefreshToken = _ref.RefreshToken;\n    this.token = RefreshToken || \"\";\n  }\n  var _proto = CognitoRefreshToken2.prototype;\n  _proto.getToken = function getToken() {\n    return this.token;\n  };\n  return CognitoRefreshToken2;\n}();\n\n// node_modules/amazon-cognito-identity-js/es/CognitoUser.js\nvar import_dist20 = __toESM(require_dist());\nvar import_buffer3 = __toESM(require_buffer_polyfill());\nvar import_sha256_js2 = __toESM(require_build2());\n\n// node_modules/amazon-cognito-identity-js/es/Platform/index.js\nvar import_dist15 = __toESM(require_dist());\n\n// node_modules/amazon-cognito-identity-js/es/Platform/version.js\nvar import_dist14 = __toESM(require_dist());\nvar version = \"5.0.4\";\n\n// node_modules/amazon-cognito-identity-js/es/Platform/index.js\nvar BASE_USER_AGENT = \"aws-amplify/\" + version;\nvar Platform = {\n  userAgent: BASE_USER_AGENT,\n  isReactNative: typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\"\n};\nvar getUserAgent = function getUserAgent2() {\n  return Platform.userAgent;\n};\n\n// node_modules/amazon-cognito-identity-js/es/CognitoUserSession.js\nvar import_dist16 = __toESM(require_dist());\nvar CognitoUserSession = function() {\n  function CognitoUserSession2(_temp) {\n    var _ref = _temp === void 0 ? {} : _temp, IdToken = _ref.IdToken, RefreshToken = _ref.RefreshToken, AccessToken = _ref.AccessToken, ClockDrift = _ref.ClockDrift;\n    if (AccessToken == null || IdToken == null) {\n      throw new Error(\"Id token and Access Token must be present.\");\n    }\n    this.idToken = IdToken;\n    this.refreshToken = RefreshToken;\n    this.accessToken = AccessToken;\n    this.clockDrift = ClockDrift === void 0 ? this.calculateClockDrift() : ClockDrift;\n  }\n  var _proto = CognitoUserSession2.prototype;\n  _proto.getIdToken = function getIdToken() {\n    return this.idToken;\n  };\n  _proto.getRefreshToken = function getRefreshToken() {\n    return this.refreshToken;\n  };\n  _proto.getAccessToken = function getAccessToken() {\n    return this.accessToken;\n  };\n  _proto.getClockDrift = function getClockDrift() {\n    return this.clockDrift;\n  };\n  _proto.calculateClockDrift = function calculateClockDrift() {\n    var now = Math.floor(/* @__PURE__ */ new Date() / 1e3);\n    var iat = Math.min(this.accessToken.getIssuedAt(), this.idToken.getIssuedAt());\n    return now - iat;\n  };\n  _proto.isValid = function isValid() {\n    var now = Math.floor(/* @__PURE__ */ new Date() / 1e3);\n    var adjusted = now - this.clockDrift;\n    return adjusted < this.accessToken.getExpiration() && adjusted < this.idToken.getExpiration();\n  };\n  return CognitoUserSession2;\n}();\n\n// node_modules/amazon-cognito-identity-js/es/DateHelper.js\nvar import_dist17 = __toESM(require_dist());\nvar monthNames = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\nvar weekNames = [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"];\nvar DateHelper = function() {\n  function DateHelper2() {\n  }\n  var _proto = DateHelper2.prototype;\n  _proto.getNowString = function getNowString() {\n    var now = /* @__PURE__ */ new Date();\n    var weekDay = weekNames[now.getUTCDay()];\n    var month = monthNames[now.getUTCMonth()];\n    var day = now.getUTCDate();\n    var hours = now.getUTCHours();\n    if (hours < 10) {\n      hours = \"0\" + hours;\n    }\n    var minutes = now.getUTCMinutes();\n    if (minutes < 10) {\n      minutes = \"0\" + minutes;\n    }\n    var seconds = now.getUTCSeconds();\n    if (seconds < 10) {\n      seconds = \"0\" + seconds;\n    }\n    var year = now.getUTCFullYear();\n    var dateNow = weekDay + \" \" + month + \" \" + day + \" \" + hours + \":\" + minutes + \":\" + seconds + \" UTC \" + year;\n    return dateNow;\n  };\n  return DateHelper2;\n}();\n\n// node_modules/amazon-cognito-identity-js/es/CognitoUserAttribute.js\nvar import_dist18 = __toESM(require_dist());\nvar CognitoUserAttribute = function() {\n  function CognitoUserAttribute2(_temp) {\n    var _ref = _temp === void 0 ? {} : _temp, Name = _ref.Name, Value = _ref.Value;\n    this.Name = Name || \"\";\n    this.Value = Value || \"\";\n  }\n  var _proto = CognitoUserAttribute2.prototype;\n  _proto.getValue = function getValue() {\n    return this.Value;\n  };\n  _proto.setValue = function setValue(value) {\n    this.Value = value;\n    return this;\n  };\n  _proto.getName = function getName() {\n    return this.Name;\n  };\n  _proto.setName = function setName(name) {\n    this.Name = name;\n    return this;\n  };\n  _proto.toString = function toString() {\n    return JSON.stringify(this);\n  };\n  _proto.toJSON = function toJSON() {\n    return {\n      Name: this.Name,\n      Value: this.Value\n    };\n  };\n  return CognitoUserAttribute2;\n}();\n\n// node_modules/amazon-cognito-identity-js/es/StorageHelper.js\nvar import_dist19 = __toESM(require_dist());\nvar dataMemory = {};\nvar MemoryStorage = function() {\n  function MemoryStorage2() {\n  }\n  MemoryStorage2.setItem = function setItem(key, value) {\n    dataMemory[key] = value;\n    return dataMemory[key];\n  };\n  MemoryStorage2.getItem = function getItem(key) {\n    return Object.prototype.hasOwnProperty.call(dataMemory, key) ? dataMemory[key] : void 0;\n  };\n  MemoryStorage2.removeItem = function removeItem(key) {\n    return delete dataMemory[key];\n  };\n  MemoryStorage2.clear = function clear() {\n    dataMemory = {};\n    return dataMemory;\n  };\n  return MemoryStorage2;\n}();\nvar StorageHelper = function() {\n  function StorageHelper2() {\n    try {\n      this.storageWindow = window.localStorage;\n      this.storageWindow.setItem(\"aws.cognito.test-ls\", 1);\n      this.storageWindow.removeItem(\"aws.cognito.test-ls\");\n    } catch (exception) {\n      this.storageWindow = MemoryStorage;\n    }\n  }\n  var _proto = StorageHelper2.prototype;\n  _proto.getStorage = function getStorage() {\n    return this.storageWindow;\n  };\n  return StorageHelper2;\n}();\n\n// node_modules/amazon-cognito-identity-js/es/CognitoUser.js\nvar isNavigatorAvailable = typeof navigator !== \"undefined\";\nvar userAgent = isNavigatorAvailable ? Platform.isReactNative ? \"react-native\" : navigator.userAgent : \"nodejs\";\nvar CognitoUser = function() {\n  function CognitoUser2(data) {\n    if (data == null || data.Username == null || data.Pool == null) {\n      throw new Error(\"Username and Pool information are required.\");\n    }\n    this.username = data.Username || \"\";\n    this.pool = data.Pool;\n    this.Session = null;\n    this.client = data.Pool.client;\n    this.signInUserSession = null;\n    this.authenticationFlowType = \"USER_SRP_AUTH\";\n    this.storage = data.Storage || new StorageHelper().getStorage();\n    this.keyPrefix = \"CognitoIdentityServiceProvider.\" + this.pool.getClientId();\n    this.userDataKey = this.keyPrefix + \".\" + this.username + \".userData\";\n  }\n  var _proto = CognitoUser2.prototype;\n  _proto.setSignInUserSession = function setSignInUserSession(signInUserSession) {\n    this.clearCachedUserData();\n    this.signInUserSession = signInUserSession;\n    this.cacheTokens();\n  };\n  _proto.getSignInUserSession = function getSignInUserSession() {\n    return this.signInUserSession;\n  };\n  _proto.getUsername = function getUsername() {\n    return this.username;\n  };\n  _proto.getAuthenticationFlowType = function getAuthenticationFlowType() {\n    return this.authenticationFlowType;\n  };\n  _proto.setAuthenticationFlowType = function setAuthenticationFlowType(authenticationFlowType) {\n    this.authenticationFlowType = authenticationFlowType;\n  };\n  _proto.initiateAuth = function initiateAuth(authDetails, callback) {\n    var _this = this;\n    var authParameters = authDetails.getAuthParameters();\n    authParameters.USERNAME = this.username;\n    var clientMetaData = Object.keys(authDetails.getValidationData()).length !== 0 ? authDetails.getValidationData() : authDetails.getClientMetadata();\n    var jsonReq = {\n      AuthFlow: \"CUSTOM_AUTH\",\n      ClientId: this.pool.getClientId(),\n      AuthParameters: authParameters,\n      ClientMetadata: clientMetaData\n    };\n    if (this.getUserContextData()) {\n      jsonReq.UserContextData = this.getUserContextData();\n    }\n    this.client.request(\"InitiateAuth\", jsonReq, function(err, data) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      var challengeName = data.ChallengeName;\n      var challengeParameters = data.ChallengeParameters;\n      if (challengeName === \"CUSTOM_CHALLENGE\") {\n        _this.Session = data.Session;\n        return callback.customChallenge(challengeParameters);\n      }\n      _this.signInUserSession = _this.getCognitoUserSession(data.AuthenticationResult);\n      _this.cacheTokens();\n      return callback.onSuccess(_this.signInUserSession);\n    });\n  };\n  _proto.authenticateUser = function authenticateUser(authDetails, callback) {\n    if (this.authenticationFlowType === \"USER_PASSWORD_AUTH\") {\n      return this.authenticateUserPlainUsernamePassword(authDetails, callback);\n    } else if (this.authenticationFlowType === \"USER_SRP_AUTH\" || this.authenticationFlowType === \"CUSTOM_AUTH\") {\n      return this.authenticateUserDefaultAuth(authDetails, callback);\n    }\n    return callback.onFailure(new Error(\"Authentication flow type is invalid.\"));\n  };\n  _proto.authenticateUserDefaultAuth = function authenticateUserDefaultAuth(authDetails, callback) {\n    var _this2 = this;\n    var authenticationHelper = new AuthenticationHelper(this.pool.getUserPoolName());\n    var dateHelper = new DateHelper();\n    var serverBValue;\n    var salt;\n    var authParameters = {};\n    if (this.deviceKey != null) {\n      authParameters.DEVICE_KEY = this.deviceKey;\n    }\n    authParameters.USERNAME = this.username;\n    authenticationHelper.getLargeAValue(function(errOnAValue, aValue) {\n      if (errOnAValue) {\n        callback.onFailure(errOnAValue);\n      }\n      authParameters.SRP_A = aValue.toString(16);\n      if (_this2.authenticationFlowType === \"CUSTOM_AUTH\") {\n        authParameters.CHALLENGE_NAME = \"SRP_A\";\n      }\n      var clientMetaData = Object.keys(authDetails.getValidationData()).length !== 0 ? authDetails.getValidationData() : authDetails.getClientMetadata();\n      var jsonReq = {\n        AuthFlow: _this2.authenticationFlowType,\n        ClientId: _this2.pool.getClientId(),\n        AuthParameters: authParameters,\n        ClientMetadata: clientMetaData\n      };\n      if (_this2.getUserContextData(_this2.username)) {\n        jsonReq.UserContextData = _this2.getUserContextData(_this2.username);\n      }\n      _this2.client.request(\"InitiateAuth\", jsonReq, function(err, data) {\n        if (err) {\n          return callback.onFailure(err);\n        }\n        var challengeParameters = data.ChallengeParameters;\n        _this2.username = challengeParameters.USER_ID_FOR_SRP;\n        _this2.userDataKey = _this2.keyPrefix + \".\" + _this2.username + \".userData\";\n        serverBValue = new BigInteger_default(challengeParameters.SRP_B, 16);\n        salt = new BigInteger_default(challengeParameters.SALT, 16);\n        _this2.getCachedDeviceKeyAndPassword();\n        authenticationHelper.getPasswordAuthenticationKey(_this2.username, authDetails.getPassword(), serverBValue, salt, function(errOnHkdf, hkdf) {\n          if (errOnHkdf) {\n            callback.onFailure(errOnHkdf);\n          }\n          var dateNow = dateHelper.getNowString();\n          var concatBuffer = import_buffer3.Buffer.concat([import_buffer3.Buffer.from(_this2.pool.getUserPoolName(), \"utf8\"), import_buffer3.Buffer.from(_this2.username, \"utf8\"), import_buffer3.Buffer.from(challengeParameters.SECRET_BLOCK, \"base64\"), import_buffer3.Buffer.from(dateNow, \"utf8\")]);\n          var awsCryptoHash = new import_sha256_js2.Sha256(hkdf);\n          awsCryptoHash.update(concatBuffer);\n          var resultFromAWSCrypto = awsCryptoHash.digestSync();\n          var signatureString = import_buffer3.Buffer.from(resultFromAWSCrypto).toString(\"base64\");\n          var challengeResponses = {};\n          challengeResponses.USERNAME = _this2.username;\n          challengeResponses.PASSWORD_CLAIM_SECRET_BLOCK = challengeParameters.SECRET_BLOCK;\n          challengeResponses.TIMESTAMP = dateNow;\n          challengeResponses.PASSWORD_CLAIM_SIGNATURE = signatureString;\n          if (_this2.deviceKey != null) {\n            challengeResponses.DEVICE_KEY = _this2.deviceKey;\n          }\n          var respondToAuthChallenge = function respondToAuthChallenge2(challenge, challengeCallback) {\n            return _this2.client.request(\"RespondToAuthChallenge\", challenge, function(errChallenge, dataChallenge) {\n              if (errChallenge && errChallenge.code === \"ResourceNotFoundException\" && errChallenge.message.toLowerCase().indexOf(\"device\") !== -1) {\n                challengeResponses.DEVICE_KEY = null;\n                _this2.deviceKey = null;\n                _this2.randomPassword = null;\n                _this2.deviceGroupKey = null;\n                _this2.clearCachedDeviceKeyAndPassword();\n                return respondToAuthChallenge2(challenge, challengeCallback);\n              }\n              return challengeCallback(errChallenge, dataChallenge);\n            });\n          };\n          var jsonReqResp = {\n            ChallengeName: \"PASSWORD_VERIFIER\",\n            ClientId: _this2.pool.getClientId(),\n            ChallengeResponses: challengeResponses,\n            Session: data.Session,\n            ClientMetadata: clientMetaData\n          };\n          if (_this2.getUserContextData()) {\n            jsonReqResp.UserContextData = _this2.getUserContextData();\n          }\n          respondToAuthChallenge(jsonReqResp, function(errAuthenticate, dataAuthenticate) {\n            if (errAuthenticate) {\n              return callback.onFailure(errAuthenticate);\n            }\n            return _this2.authenticateUserInternal(dataAuthenticate, authenticationHelper, callback);\n          });\n          return void 0;\n        });\n        return void 0;\n      });\n    });\n  };\n  _proto.authenticateUserPlainUsernamePassword = function authenticateUserPlainUsernamePassword(authDetails, callback) {\n    var _this3 = this;\n    var authParameters = {};\n    authParameters.USERNAME = this.username;\n    authParameters.PASSWORD = authDetails.getPassword();\n    if (!authParameters.PASSWORD) {\n      callback.onFailure(new Error(\"PASSWORD parameter is required\"));\n      return;\n    }\n    var authenticationHelper = new AuthenticationHelper(this.pool.getUserPoolName());\n    this.getCachedDeviceKeyAndPassword();\n    if (this.deviceKey != null) {\n      authParameters.DEVICE_KEY = this.deviceKey;\n    }\n    var clientMetaData = Object.keys(authDetails.getValidationData()).length !== 0 ? authDetails.getValidationData() : authDetails.getClientMetadata();\n    var jsonReq = {\n      AuthFlow: \"USER_PASSWORD_AUTH\",\n      ClientId: this.pool.getClientId(),\n      AuthParameters: authParameters,\n      ClientMetadata: clientMetaData\n    };\n    if (this.getUserContextData(this.username)) {\n      jsonReq.UserContextData = this.getUserContextData(this.username);\n    }\n    this.client.request(\"InitiateAuth\", jsonReq, function(err, authResult) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      return _this3.authenticateUserInternal(authResult, authenticationHelper, callback);\n    });\n  };\n  _proto.authenticateUserInternal = function authenticateUserInternal(dataAuthenticate, authenticationHelper, callback) {\n    var _this4 = this;\n    var challengeName = dataAuthenticate.ChallengeName;\n    var challengeParameters = dataAuthenticate.ChallengeParameters;\n    if (challengeName === \"SMS_MFA\") {\n      this.Session = dataAuthenticate.Session;\n      return callback.mfaRequired(challengeName, challengeParameters);\n    }\n    if (challengeName === \"SELECT_MFA_TYPE\") {\n      this.Session = dataAuthenticate.Session;\n      return callback.selectMFAType(challengeName, challengeParameters);\n    }\n    if (challengeName === \"MFA_SETUP\") {\n      this.Session = dataAuthenticate.Session;\n      return callback.mfaSetup(challengeName, challengeParameters);\n    }\n    if (challengeName === \"SOFTWARE_TOKEN_MFA\") {\n      this.Session = dataAuthenticate.Session;\n      return callback.totpRequired(challengeName, challengeParameters);\n    }\n    if (challengeName === \"CUSTOM_CHALLENGE\") {\n      this.Session = dataAuthenticate.Session;\n      return callback.customChallenge(challengeParameters);\n    }\n    if (challengeName === \"NEW_PASSWORD_REQUIRED\") {\n      this.Session = dataAuthenticate.Session;\n      var userAttributes = null;\n      var rawRequiredAttributes = null;\n      var requiredAttributes = [];\n      var userAttributesPrefix = authenticationHelper.getNewPasswordRequiredChallengeUserAttributePrefix();\n      if (challengeParameters) {\n        userAttributes = JSON.parse(dataAuthenticate.ChallengeParameters.userAttributes);\n        rawRequiredAttributes = JSON.parse(dataAuthenticate.ChallengeParameters.requiredAttributes);\n      }\n      if (rawRequiredAttributes) {\n        for (var i = 0; i < rawRequiredAttributes.length; i++) {\n          requiredAttributes[i] = rawRequiredAttributes[i].substr(userAttributesPrefix.length);\n        }\n      }\n      return callback.newPasswordRequired(userAttributes, requiredAttributes);\n    }\n    if (challengeName === \"DEVICE_SRP_AUTH\") {\n      this.Session = dataAuthenticate.Session;\n      this.getDeviceResponse(callback);\n      return void 0;\n    }\n    this.signInUserSession = this.getCognitoUserSession(dataAuthenticate.AuthenticationResult);\n    this.challengeName = challengeName;\n    this.cacheTokens();\n    var newDeviceMetadata = dataAuthenticate.AuthenticationResult.NewDeviceMetadata;\n    if (newDeviceMetadata == null) {\n      return callback.onSuccess(this.signInUserSession);\n    }\n    authenticationHelper.generateHashDevice(dataAuthenticate.AuthenticationResult.NewDeviceMetadata.DeviceGroupKey, dataAuthenticate.AuthenticationResult.NewDeviceMetadata.DeviceKey, function(errGenHash) {\n      if (errGenHash) {\n        return callback.onFailure(errGenHash);\n      }\n      var deviceSecretVerifierConfig = {\n        Salt: import_buffer3.Buffer.from(authenticationHelper.getSaltDevices(), \"hex\").toString(\"base64\"),\n        PasswordVerifier: import_buffer3.Buffer.from(authenticationHelper.getVerifierDevices(), \"hex\").toString(\"base64\")\n      };\n      _this4.verifierDevices = deviceSecretVerifierConfig.PasswordVerifier;\n      _this4.deviceGroupKey = newDeviceMetadata.DeviceGroupKey;\n      _this4.randomPassword = authenticationHelper.getRandomPassword();\n      _this4.client.request(\"ConfirmDevice\", {\n        DeviceKey: newDeviceMetadata.DeviceKey,\n        AccessToken: _this4.signInUserSession.getAccessToken().getJwtToken(),\n        DeviceSecretVerifierConfig: deviceSecretVerifierConfig,\n        DeviceName: userAgent\n      }, function(errConfirm, dataConfirm) {\n        if (errConfirm) {\n          return callback.onFailure(errConfirm);\n        }\n        _this4.deviceKey = dataAuthenticate.AuthenticationResult.NewDeviceMetadata.DeviceKey;\n        _this4.cacheDeviceKeyAndPassword();\n        if (dataConfirm.UserConfirmationNecessary === true) {\n          return callback.onSuccess(_this4.signInUserSession, dataConfirm.UserConfirmationNecessary);\n        }\n        return callback.onSuccess(_this4.signInUserSession);\n      });\n      return void 0;\n    });\n    return void 0;\n  };\n  _proto.completeNewPasswordChallenge = function completeNewPasswordChallenge(newPassword, requiredAttributeData, callback, clientMetadata) {\n    var _this5 = this;\n    if (!newPassword) {\n      return callback.onFailure(new Error(\"New password is required.\"));\n    }\n    var authenticationHelper = new AuthenticationHelper(this.pool.getUserPoolName());\n    var userAttributesPrefix = authenticationHelper.getNewPasswordRequiredChallengeUserAttributePrefix();\n    var finalUserAttributes = {};\n    if (requiredAttributeData) {\n      Object.keys(requiredAttributeData).forEach(function(key) {\n        finalUserAttributes[userAttributesPrefix + key] = requiredAttributeData[key];\n      });\n    }\n    finalUserAttributes.NEW_PASSWORD = newPassword;\n    finalUserAttributes.USERNAME = this.username;\n    var jsonReq = {\n      ChallengeName: \"NEW_PASSWORD_REQUIRED\",\n      ClientId: this.pool.getClientId(),\n      ChallengeResponses: finalUserAttributes,\n      Session: this.Session,\n      ClientMetadata: clientMetadata\n    };\n    if (this.getUserContextData()) {\n      jsonReq.UserContextData = this.getUserContextData();\n    }\n    this.client.request(\"RespondToAuthChallenge\", jsonReq, function(errAuthenticate, dataAuthenticate) {\n      if (errAuthenticate) {\n        return callback.onFailure(errAuthenticate);\n      }\n      return _this5.authenticateUserInternal(dataAuthenticate, authenticationHelper, callback);\n    });\n    return void 0;\n  };\n  _proto.getDeviceResponse = function getDeviceResponse(callback, clientMetadata) {\n    var _this6 = this;\n    var authenticationHelper = new AuthenticationHelper(this.deviceGroupKey);\n    var dateHelper = new DateHelper();\n    var authParameters = {};\n    authParameters.USERNAME = this.username;\n    authParameters.DEVICE_KEY = this.deviceKey;\n    authenticationHelper.getLargeAValue(function(errAValue, aValue) {\n      if (errAValue) {\n        callback.onFailure(errAValue);\n      }\n      authParameters.SRP_A = aValue.toString(16);\n      var jsonReq = {\n        ChallengeName: \"DEVICE_SRP_AUTH\",\n        ClientId: _this6.pool.getClientId(),\n        ChallengeResponses: authParameters,\n        ClientMetadata: clientMetadata,\n        Session: _this6.Session\n      };\n      if (_this6.getUserContextData()) {\n        jsonReq.UserContextData = _this6.getUserContextData();\n      }\n      _this6.client.request(\"RespondToAuthChallenge\", jsonReq, function(err, data) {\n        if (err) {\n          return callback.onFailure(err);\n        }\n        var challengeParameters = data.ChallengeParameters;\n        var serverBValue = new BigInteger_default(challengeParameters.SRP_B, 16);\n        var salt = new BigInteger_default(challengeParameters.SALT, 16);\n        authenticationHelper.getPasswordAuthenticationKey(_this6.deviceKey, _this6.randomPassword, serverBValue, salt, function(errHkdf, hkdf) {\n          if (errHkdf) {\n            return callback.onFailure(errHkdf);\n          }\n          var dateNow = dateHelper.getNowString();\n          var concatBuffer = import_buffer3.Buffer.concat([import_buffer3.Buffer.from(_this6.deviceGroupKey, \"utf8\"), import_buffer3.Buffer.from(_this6.deviceKey, \"utf8\"), import_buffer3.Buffer.from(challengeParameters.SECRET_BLOCK, \"base64\"), import_buffer3.Buffer.from(dateNow, \"utf8\")]);\n          var awsCryptoHash = new import_sha256_js2.Sha256(hkdf);\n          awsCryptoHash.update(concatBuffer);\n          var resultFromAWSCrypto = awsCryptoHash.digestSync();\n          var signatureString = import_buffer3.Buffer.from(resultFromAWSCrypto).toString(\"base64\");\n          var challengeResponses = {};\n          challengeResponses.USERNAME = _this6.username;\n          challengeResponses.PASSWORD_CLAIM_SECRET_BLOCK = challengeParameters.SECRET_BLOCK;\n          challengeResponses.TIMESTAMP = dateNow;\n          challengeResponses.PASSWORD_CLAIM_SIGNATURE = signatureString;\n          challengeResponses.DEVICE_KEY = _this6.deviceKey;\n          var jsonReqResp = {\n            ChallengeName: \"DEVICE_PASSWORD_VERIFIER\",\n            ClientId: _this6.pool.getClientId(),\n            ChallengeResponses: challengeResponses,\n            Session: data.Session\n          };\n          if (_this6.getUserContextData()) {\n            jsonReqResp.UserContextData = _this6.getUserContextData();\n          }\n          _this6.client.request(\"RespondToAuthChallenge\", jsonReqResp, function(errAuthenticate, dataAuthenticate) {\n            if (errAuthenticate) {\n              return callback.onFailure(errAuthenticate);\n            }\n            _this6.signInUserSession = _this6.getCognitoUserSession(dataAuthenticate.AuthenticationResult);\n            _this6.cacheTokens();\n            return callback.onSuccess(_this6.signInUserSession);\n          });\n          return void 0;\n        });\n        return void 0;\n      });\n    });\n  };\n  _proto.confirmRegistration = function confirmRegistration(confirmationCode, forceAliasCreation, callback, clientMetadata) {\n    var jsonReq = {\n      ClientId: this.pool.getClientId(),\n      ConfirmationCode: confirmationCode,\n      Username: this.username,\n      ForceAliasCreation: forceAliasCreation,\n      ClientMetadata: clientMetadata\n    };\n    if (this.getUserContextData()) {\n      jsonReq.UserContextData = this.getUserContextData();\n    }\n    this.client.request(\"ConfirmSignUp\", jsonReq, function(err) {\n      if (err) {\n        return callback(err, null);\n      }\n      return callback(null, \"SUCCESS\");\n    });\n  };\n  _proto.sendCustomChallengeAnswer = function sendCustomChallengeAnswer(answerChallenge, callback, clientMetadata) {\n    var _this7 = this;\n    var challengeResponses = {};\n    challengeResponses.USERNAME = this.username;\n    challengeResponses.ANSWER = answerChallenge;\n    var authenticationHelper = new AuthenticationHelper(this.pool.getUserPoolName());\n    this.getCachedDeviceKeyAndPassword();\n    if (this.deviceKey != null) {\n      challengeResponses.DEVICE_KEY = this.deviceKey;\n    }\n    var jsonReq = {\n      ChallengeName: \"CUSTOM_CHALLENGE\",\n      ChallengeResponses: challengeResponses,\n      ClientId: this.pool.getClientId(),\n      Session: this.Session,\n      ClientMetadata: clientMetadata\n    };\n    if (this.getUserContextData()) {\n      jsonReq.UserContextData = this.getUserContextData();\n    }\n    this.client.request(\"RespondToAuthChallenge\", jsonReq, function(err, data) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      return _this7.authenticateUserInternal(data, authenticationHelper, callback);\n    });\n  };\n  _proto.sendMFACode = function sendMFACode(confirmationCode, callback, mfaType, clientMetadata) {\n    var _this8 = this;\n    var challengeResponses = {};\n    challengeResponses.USERNAME = this.username;\n    challengeResponses.SMS_MFA_CODE = confirmationCode;\n    var mfaTypeSelection = mfaType || \"SMS_MFA\";\n    if (mfaTypeSelection === \"SOFTWARE_TOKEN_MFA\") {\n      challengeResponses.SOFTWARE_TOKEN_MFA_CODE = confirmationCode;\n    }\n    if (this.deviceKey != null) {\n      challengeResponses.DEVICE_KEY = this.deviceKey;\n    }\n    var jsonReq = {\n      ChallengeName: mfaTypeSelection,\n      ChallengeResponses: challengeResponses,\n      ClientId: this.pool.getClientId(),\n      Session: this.Session,\n      ClientMetadata: clientMetadata\n    };\n    if (this.getUserContextData()) {\n      jsonReq.UserContextData = this.getUserContextData();\n    }\n    this.client.request(\"RespondToAuthChallenge\", jsonReq, function(err, dataAuthenticate) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      var challengeName = dataAuthenticate.ChallengeName;\n      if (challengeName === \"DEVICE_SRP_AUTH\") {\n        _this8.getDeviceResponse(callback);\n        return void 0;\n      }\n      _this8.signInUserSession = _this8.getCognitoUserSession(dataAuthenticate.AuthenticationResult);\n      _this8.cacheTokens();\n      if (dataAuthenticate.AuthenticationResult.NewDeviceMetadata == null) {\n        return callback.onSuccess(_this8.signInUserSession);\n      }\n      var authenticationHelper = new AuthenticationHelper(_this8.pool.getUserPoolName());\n      authenticationHelper.generateHashDevice(dataAuthenticate.AuthenticationResult.NewDeviceMetadata.DeviceGroupKey, dataAuthenticate.AuthenticationResult.NewDeviceMetadata.DeviceKey, function(errGenHash) {\n        if (errGenHash) {\n          return callback.onFailure(errGenHash);\n        }\n        var deviceSecretVerifierConfig = {\n          Salt: import_buffer3.Buffer.from(authenticationHelper.getSaltDevices(), \"hex\").toString(\"base64\"),\n          PasswordVerifier: import_buffer3.Buffer.from(authenticationHelper.getVerifierDevices(), \"hex\").toString(\"base64\")\n        };\n        _this8.verifierDevices = deviceSecretVerifierConfig.PasswordVerifier;\n        _this8.deviceGroupKey = dataAuthenticate.AuthenticationResult.NewDeviceMetadata.DeviceGroupKey;\n        _this8.randomPassword = authenticationHelper.getRandomPassword();\n        _this8.client.request(\"ConfirmDevice\", {\n          DeviceKey: dataAuthenticate.AuthenticationResult.NewDeviceMetadata.DeviceKey,\n          AccessToken: _this8.signInUserSession.getAccessToken().getJwtToken(),\n          DeviceSecretVerifierConfig: deviceSecretVerifierConfig,\n          DeviceName: userAgent\n        }, function(errConfirm, dataConfirm) {\n          if (errConfirm) {\n            return callback.onFailure(errConfirm);\n          }\n          _this8.deviceKey = dataAuthenticate.AuthenticationResult.NewDeviceMetadata.DeviceKey;\n          _this8.cacheDeviceKeyAndPassword();\n          if (dataConfirm.UserConfirmationNecessary === true) {\n            return callback.onSuccess(_this8.signInUserSession, dataConfirm.UserConfirmationNecessary);\n          }\n          return callback.onSuccess(_this8.signInUserSession);\n        });\n        return void 0;\n      });\n      return void 0;\n    });\n  };\n  _proto.changePassword = function changePassword(oldUserPassword, newUserPassword, callback, clientMetadata) {\n    if (!(this.signInUserSession != null && this.signInUserSession.isValid())) {\n      return callback(new Error(\"User is not authenticated\"), null);\n    }\n    this.client.request(\"ChangePassword\", {\n      PreviousPassword: oldUserPassword,\n      ProposedPassword: newUserPassword,\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\n      ClientMetadata: clientMetadata\n    }, function(err) {\n      if (err) {\n        return callback(err, null);\n      }\n      return callback(null, \"SUCCESS\");\n    });\n    return void 0;\n  };\n  _proto.enableMFA = function enableMFA(callback) {\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback(new Error(\"User is not authenticated\"), null);\n    }\n    var mfaOptions = [];\n    var mfaEnabled = {\n      DeliveryMedium: \"SMS\",\n      AttributeName: \"phone_number\"\n    };\n    mfaOptions.push(mfaEnabled);\n    this.client.request(\"SetUserSettings\", {\n      MFAOptions: mfaOptions,\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\n    }, function(err) {\n      if (err) {\n        return callback(err, null);\n      }\n      return callback(null, \"SUCCESS\");\n    });\n    return void 0;\n  };\n  _proto.setUserMfaPreference = function setUserMfaPreference(smsMfaSettings, softwareTokenMfaSettings, callback) {\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback(new Error(\"User is not authenticated\"), null);\n    }\n    this.client.request(\"SetUserMFAPreference\", {\n      SMSMfaSettings: smsMfaSettings,\n      SoftwareTokenMfaSettings: softwareTokenMfaSettings,\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\n    }, function(err) {\n      if (err) {\n        return callback(err, null);\n      }\n      return callback(null, \"SUCCESS\");\n    });\n    return void 0;\n  };\n  _proto.disableMFA = function disableMFA(callback) {\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback(new Error(\"User is not authenticated\"), null);\n    }\n    var mfaOptions = [];\n    this.client.request(\"SetUserSettings\", {\n      MFAOptions: mfaOptions,\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\n    }, function(err) {\n      if (err) {\n        return callback(err, null);\n      }\n      return callback(null, \"SUCCESS\");\n    });\n    return void 0;\n  };\n  _proto.deleteUser = function deleteUser(callback, clientMetadata) {\n    var _this9 = this;\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback(new Error(\"User is not authenticated\"), null);\n    }\n    this.client.request(\"DeleteUser\", {\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\n      ClientMetadata: clientMetadata\n    }, function(err) {\n      if (err) {\n        return callback(err, null);\n      }\n      _this9.clearCachedUser();\n      return callback(null, \"SUCCESS\");\n    });\n    return void 0;\n  };\n  _proto.updateAttributes = function updateAttributes(attributes, callback, clientMetadata) {\n    var _this10 = this;\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback(new Error(\"User is not authenticated\"), null);\n    }\n    this.client.request(\"UpdateUserAttributes\", {\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\n      UserAttributes: attributes,\n      ClientMetadata: clientMetadata\n    }, function(err, result) {\n      if (err) {\n        return callback(err, null);\n      }\n      return _this10.getUserData(function() {\n        return callback(null, \"SUCCESS\", result);\n      }, {\n        bypassCache: true\n      });\n    });\n    return void 0;\n  };\n  _proto.getUserAttributes = function getUserAttributes(callback) {\n    if (!(this.signInUserSession != null && this.signInUserSession.isValid())) {\n      return callback(new Error(\"User is not authenticated\"), null);\n    }\n    this.client.request(\"GetUser\", {\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\n    }, function(err, userData) {\n      if (err) {\n        return callback(err, null);\n      }\n      var attributeList = [];\n      for (var i = 0; i < userData.UserAttributes.length; i++) {\n        var attribute = {\n          Name: userData.UserAttributes[i].Name,\n          Value: userData.UserAttributes[i].Value\n        };\n        var userAttribute = new CognitoUserAttribute(attribute);\n        attributeList.push(userAttribute);\n      }\n      return callback(null, attributeList);\n    });\n    return void 0;\n  };\n  _proto.getMFAOptions = function getMFAOptions(callback) {\n    if (!(this.signInUserSession != null && this.signInUserSession.isValid())) {\n      return callback(new Error(\"User is not authenticated\"), null);\n    }\n    this.client.request(\"GetUser\", {\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\n    }, function(err, userData) {\n      if (err) {\n        return callback(err, null);\n      }\n      return callback(null, userData.MFAOptions);\n    });\n    return void 0;\n  };\n  _proto.createGetUserRequest = function createGetUserRequest() {\n    return this.client.promisifyRequest(\"GetUser\", {\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\n    });\n  };\n  _proto.refreshSessionIfPossible = function refreshSessionIfPossible(options) {\n    var _this11 = this;\n    if (options === void 0) {\n      options = {};\n    }\n    return new Promise(function(resolve) {\n      var refresh = _this11.signInUserSession.getRefreshToken();\n      if (refresh && refresh.getToken()) {\n        _this11.refreshSession(refresh, resolve, options.clientMetadata);\n      } else {\n        resolve();\n      }\n    });\n  };\n  _proto.getUserData = function getUserData(callback, params) {\n    var _this12 = this;\n    if (!(this.signInUserSession != null && this.signInUserSession.isValid())) {\n      this.clearCachedUserData();\n      return callback(new Error(\"User is not authenticated\"), null);\n    }\n    var userData = this.getUserDataFromCache();\n    if (!userData) {\n      this.fetchUserData().then(function(data) {\n        callback(null, data);\n      })[\"catch\"](callback);\n      return;\n    }\n    if (this.isFetchUserDataAndTokenRequired(params)) {\n      this.fetchUserData().then(function(data) {\n        return _this12.refreshSessionIfPossible(params).then(function() {\n          return data;\n        });\n      }).then(function(data) {\n        return callback(null, data);\n      })[\"catch\"](callback);\n      return;\n    }\n    try {\n      callback(null, JSON.parse(userData));\n      return;\n    } catch (err) {\n      this.clearCachedUserData();\n      callback(err, null);\n      return;\n    }\n  };\n  _proto.getUserDataFromCache = function getUserDataFromCache() {\n    var userData = this.storage.getItem(this.userDataKey);\n    return userData;\n  };\n  _proto.isFetchUserDataAndTokenRequired = function isFetchUserDataAndTokenRequired(params) {\n    var _ref = params || {}, _ref$bypassCache = _ref.bypassCache, bypassCache = _ref$bypassCache === void 0 ? false : _ref$bypassCache;\n    return bypassCache;\n  };\n  _proto.fetchUserData = function fetchUserData() {\n    var _this13 = this;\n    return this.createGetUserRequest().then(function(data) {\n      _this13.cacheUserData(data);\n      return data;\n    });\n  };\n  _proto.deleteAttributes = function deleteAttributes(attributeList, callback) {\n    var _this14 = this;\n    if (!(this.signInUserSession != null && this.signInUserSession.isValid())) {\n      return callback(new Error(\"User is not authenticated\"), null);\n    }\n    this.client.request(\"DeleteUserAttributes\", {\n      UserAttributeNames: attributeList,\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\n    }, function(err) {\n      if (err) {\n        return callback(err, null);\n      }\n      return _this14.getUserData(function() {\n        return callback(null, \"SUCCESS\");\n      }, {\n        bypassCache: true\n      });\n    });\n    return void 0;\n  };\n  _proto.resendConfirmationCode = function resendConfirmationCode(callback, clientMetadata) {\n    var jsonReq = {\n      ClientId: this.pool.getClientId(),\n      Username: this.username,\n      ClientMetadata: clientMetadata\n    };\n    this.client.request(\"ResendConfirmationCode\", jsonReq, function(err, result) {\n      if (err) {\n        return callback(err, null);\n      }\n      return callback(null, result);\n    });\n  };\n  _proto.getSession = function getSession(callback, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    if (this.username == null) {\n      return callback(new Error(\"Username is null. Cannot retrieve a new session\"), null);\n    }\n    if (this.signInUserSession != null && this.signInUserSession.isValid()) {\n      return callback(null, this.signInUserSession);\n    }\n    var keyPrefix = \"CognitoIdentityServiceProvider.\" + this.pool.getClientId() + \".\" + this.username;\n    var idTokenKey = keyPrefix + \".idToken\";\n    var accessTokenKey = keyPrefix + \".accessToken\";\n    var refreshTokenKey = keyPrefix + \".refreshToken\";\n    var clockDriftKey = keyPrefix + \".clockDrift\";\n    if (this.storage.getItem(idTokenKey)) {\n      var idToken = new CognitoIdToken({\n        IdToken: this.storage.getItem(idTokenKey)\n      });\n      var accessToken = new CognitoAccessToken({\n        AccessToken: this.storage.getItem(accessTokenKey)\n      });\n      var refreshToken = new CognitoRefreshToken({\n        RefreshToken: this.storage.getItem(refreshTokenKey)\n      });\n      var clockDrift = parseInt(this.storage.getItem(clockDriftKey), 0) || 0;\n      var sessionData = {\n        IdToken: idToken,\n        AccessToken: accessToken,\n        RefreshToken: refreshToken,\n        ClockDrift: clockDrift\n      };\n      var cachedSession = new CognitoUserSession(sessionData);\n      if (cachedSession.isValid()) {\n        this.signInUserSession = cachedSession;\n        return callback(null, this.signInUserSession);\n      }\n      if (!refreshToken.getToken()) {\n        return callback(new Error(\"Cannot retrieve a new session. Please authenticate.\"), null);\n      }\n      this.refreshSession(refreshToken, callback, options.clientMetadata);\n    } else {\n      callback(new Error(\"Local storage is missing an ID Token, Please authenticate\"), null);\n    }\n    return void 0;\n  };\n  _proto.refreshSession = function refreshSession(refreshToken, callback, clientMetadata) {\n    var _this15 = this;\n    var wrappedCallback = this.pool.wrapRefreshSessionCallback ? this.pool.wrapRefreshSessionCallback(callback) : callback;\n    var authParameters = {};\n    authParameters.REFRESH_TOKEN = refreshToken.getToken();\n    var keyPrefix = \"CognitoIdentityServiceProvider.\" + this.pool.getClientId();\n    var lastUserKey = keyPrefix + \".LastAuthUser\";\n    if (this.storage.getItem(lastUserKey)) {\n      this.username = this.storage.getItem(lastUserKey);\n      var deviceKeyKey = keyPrefix + \".\" + this.username + \".deviceKey\";\n      this.deviceKey = this.storage.getItem(deviceKeyKey);\n      authParameters.DEVICE_KEY = this.deviceKey;\n    }\n    var jsonReq = {\n      ClientId: this.pool.getClientId(),\n      AuthFlow: \"REFRESH_TOKEN_AUTH\",\n      AuthParameters: authParameters,\n      ClientMetadata: clientMetadata\n    };\n    if (this.getUserContextData()) {\n      jsonReq.UserContextData = this.getUserContextData();\n    }\n    this.client.request(\"InitiateAuth\", jsonReq, function(err, authResult) {\n      if (err) {\n        if (err.code === \"NotAuthorizedException\") {\n          _this15.clearCachedUser();\n        }\n        return wrappedCallback(err, null);\n      }\n      if (authResult) {\n        var authenticationResult = authResult.AuthenticationResult;\n        if (!Object.prototype.hasOwnProperty.call(authenticationResult, \"RefreshToken\")) {\n          authenticationResult.RefreshToken = refreshToken.getToken();\n        }\n        _this15.signInUserSession = _this15.getCognitoUserSession(authenticationResult);\n        _this15.cacheTokens();\n        return wrappedCallback(null, _this15.signInUserSession);\n      }\n      return void 0;\n    });\n  };\n  _proto.cacheTokens = function cacheTokens() {\n    var keyPrefix = \"CognitoIdentityServiceProvider.\" + this.pool.getClientId();\n    var idTokenKey = keyPrefix + \".\" + this.username + \".idToken\";\n    var accessTokenKey = keyPrefix + \".\" + this.username + \".accessToken\";\n    var refreshTokenKey = keyPrefix + \".\" + this.username + \".refreshToken\";\n    var clockDriftKey = keyPrefix + \".\" + this.username + \".clockDrift\";\n    var lastUserKey = keyPrefix + \".LastAuthUser\";\n    this.storage.setItem(idTokenKey, this.signInUserSession.getIdToken().getJwtToken());\n    this.storage.setItem(accessTokenKey, this.signInUserSession.getAccessToken().getJwtToken());\n    this.storage.setItem(refreshTokenKey, this.signInUserSession.getRefreshToken().getToken());\n    this.storage.setItem(clockDriftKey, \"\" + this.signInUserSession.getClockDrift());\n    this.storage.setItem(lastUserKey, this.username);\n  };\n  _proto.cacheUserData = function cacheUserData(userData) {\n    this.storage.setItem(this.userDataKey, JSON.stringify(userData));\n  };\n  _proto.clearCachedUserData = function clearCachedUserData() {\n    this.storage.removeItem(this.userDataKey);\n  };\n  _proto.clearCachedUser = function clearCachedUser() {\n    this.clearCachedTokens();\n    this.clearCachedUserData();\n  };\n  _proto.cacheDeviceKeyAndPassword = function cacheDeviceKeyAndPassword() {\n    var keyPrefix = \"CognitoIdentityServiceProvider.\" + this.pool.getClientId() + \".\" + this.username;\n    var deviceKeyKey = keyPrefix + \".deviceKey\";\n    var randomPasswordKey = keyPrefix + \".randomPasswordKey\";\n    var deviceGroupKeyKey = keyPrefix + \".deviceGroupKey\";\n    this.storage.setItem(deviceKeyKey, this.deviceKey);\n    this.storage.setItem(randomPasswordKey, this.randomPassword);\n    this.storage.setItem(deviceGroupKeyKey, this.deviceGroupKey);\n  };\n  _proto.getCachedDeviceKeyAndPassword = function getCachedDeviceKeyAndPassword() {\n    var keyPrefix = \"CognitoIdentityServiceProvider.\" + this.pool.getClientId() + \".\" + this.username;\n    var deviceKeyKey = keyPrefix + \".deviceKey\";\n    var randomPasswordKey = keyPrefix + \".randomPasswordKey\";\n    var deviceGroupKeyKey = keyPrefix + \".deviceGroupKey\";\n    if (this.storage.getItem(deviceKeyKey)) {\n      this.deviceKey = this.storage.getItem(deviceKeyKey);\n      this.randomPassword = this.storage.getItem(randomPasswordKey);\n      this.deviceGroupKey = this.storage.getItem(deviceGroupKeyKey);\n    }\n  };\n  _proto.clearCachedDeviceKeyAndPassword = function clearCachedDeviceKeyAndPassword() {\n    var keyPrefix = \"CognitoIdentityServiceProvider.\" + this.pool.getClientId() + \".\" + this.username;\n    var deviceKeyKey = keyPrefix + \".deviceKey\";\n    var randomPasswordKey = keyPrefix + \".randomPasswordKey\";\n    var deviceGroupKeyKey = keyPrefix + \".deviceGroupKey\";\n    this.storage.removeItem(deviceKeyKey);\n    this.storage.removeItem(randomPasswordKey);\n    this.storage.removeItem(deviceGroupKeyKey);\n  };\n  _proto.clearCachedTokens = function clearCachedTokens() {\n    var keyPrefix = \"CognitoIdentityServiceProvider.\" + this.pool.getClientId();\n    var idTokenKey = keyPrefix + \".\" + this.username + \".idToken\";\n    var accessTokenKey = keyPrefix + \".\" + this.username + \".accessToken\";\n    var refreshTokenKey = keyPrefix + \".\" + this.username + \".refreshToken\";\n    var lastUserKey = keyPrefix + \".LastAuthUser\";\n    var clockDriftKey = keyPrefix + \".\" + this.username + \".clockDrift\";\n    this.storage.removeItem(idTokenKey);\n    this.storage.removeItem(accessTokenKey);\n    this.storage.removeItem(refreshTokenKey);\n    this.storage.removeItem(lastUserKey);\n    this.storage.removeItem(clockDriftKey);\n  };\n  _proto.getCognitoUserSession = function getCognitoUserSession(authResult) {\n    var idToken = new CognitoIdToken(authResult);\n    var accessToken = new CognitoAccessToken(authResult);\n    var refreshToken = new CognitoRefreshToken(authResult);\n    var sessionData = {\n      IdToken: idToken,\n      AccessToken: accessToken,\n      RefreshToken: refreshToken\n    };\n    return new CognitoUserSession(sessionData);\n  };\n  _proto.forgotPassword = function forgotPassword(callback, clientMetadata) {\n    var jsonReq = {\n      ClientId: this.pool.getClientId(),\n      Username: this.username,\n      ClientMetadata: clientMetadata\n    };\n    if (this.getUserContextData()) {\n      jsonReq.UserContextData = this.getUserContextData();\n    }\n    this.client.request(\"ForgotPassword\", jsonReq, function(err, data) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      if (typeof callback.inputVerificationCode === \"function\") {\n        return callback.inputVerificationCode(data);\n      }\n      return callback.onSuccess(data);\n    });\n  };\n  _proto.confirmPassword = function confirmPassword(confirmationCode, newPassword, callback, clientMetadata) {\n    var jsonReq = {\n      ClientId: this.pool.getClientId(),\n      Username: this.username,\n      ConfirmationCode: confirmationCode,\n      Password: newPassword,\n      ClientMetadata: clientMetadata\n    };\n    if (this.getUserContextData()) {\n      jsonReq.UserContextData = this.getUserContextData();\n    }\n    this.client.request(\"ConfirmForgotPassword\", jsonReq, function(err) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      return callback.onSuccess(\"SUCCESS\");\n    });\n  };\n  _proto.getAttributeVerificationCode = function getAttributeVerificationCode(attributeName, callback, clientMetadata) {\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback.onFailure(new Error(\"User is not authenticated\"));\n    }\n    this.client.request(\"GetUserAttributeVerificationCode\", {\n      AttributeName: attributeName,\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\n      ClientMetadata: clientMetadata\n    }, function(err, data) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      if (typeof callback.inputVerificationCode === \"function\") {\n        return callback.inputVerificationCode(data);\n      }\n      return callback.onSuccess(\"SUCCESS\");\n    });\n    return void 0;\n  };\n  _proto.verifyAttribute = function verifyAttribute(attributeName, confirmationCode, callback) {\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback.onFailure(new Error(\"User is not authenticated\"));\n    }\n    this.client.request(\"VerifyUserAttribute\", {\n      AttributeName: attributeName,\n      Code: confirmationCode,\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\n    }, function(err) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      return callback.onSuccess(\"SUCCESS\");\n    });\n    return void 0;\n  };\n  _proto.getDevice = function getDevice(callback) {\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback.onFailure(new Error(\"User is not authenticated\"));\n    }\n    this.client.request(\"GetDevice\", {\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\n      DeviceKey: this.deviceKey\n    }, function(err, data) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      return callback.onSuccess(data);\n    });\n    return void 0;\n  };\n  _proto.forgetSpecificDevice = function forgetSpecificDevice(deviceKey, callback) {\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback.onFailure(new Error(\"User is not authenticated\"));\n    }\n    this.client.request(\"ForgetDevice\", {\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\n      DeviceKey: deviceKey\n    }, function(err) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      return callback.onSuccess(\"SUCCESS\");\n    });\n    return void 0;\n  };\n  _proto.forgetDevice = function forgetDevice(callback) {\n    var _this16 = this;\n    this.forgetSpecificDevice(this.deviceKey, {\n      onFailure: callback.onFailure,\n      onSuccess: function onSuccess(result) {\n        _this16.deviceKey = null;\n        _this16.deviceGroupKey = null;\n        _this16.randomPassword = null;\n        _this16.clearCachedDeviceKeyAndPassword();\n        return callback.onSuccess(result);\n      }\n    });\n  };\n  _proto.setDeviceStatusRemembered = function setDeviceStatusRemembered(callback) {\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback.onFailure(new Error(\"User is not authenticated\"));\n    }\n    this.client.request(\"UpdateDeviceStatus\", {\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\n      DeviceKey: this.deviceKey,\n      DeviceRememberedStatus: \"remembered\"\n    }, function(err) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      return callback.onSuccess(\"SUCCESS\");\n    });\n    return void 0;\n  };\n  _proto.setDeviceStatusNotRemembered = function setDeviceStatusNotRemembered(callback) {\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback.onFailure(new Error(\"User is not authenticated\"));\n    }\n    this.client.request(\"UpdateDeviceStatus\", {\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\n      DeviceKey: this.deviceKey,\n      DeviceRememberedStatus: \"not_remembered\"\n    }, function(err) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      return callback.onSuccess(\"SUCCESS\");\n    });\n    return void 0;\n  };\n  _proto.listDevices = function listDevices(limit, paginationToken, callback) {\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback.onFailure(new Error(\"User is not authenticated\"));\n    }\n    var requestParams = {\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\n      Limit: limit\n    };\n    if (paginationToken) {\n      requestParams.PaginationToken = paginationToken;\n    }\n    this.client.request(\"ListDevices\", requestParams, function(err, data) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      return callback.onSuccess(data);\n    });\n    return void 0;\n  };\n  _proto.globalSignOut = function globalSignOut(callback) {\n    var _this17 = this;\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback.onFailure(new Error(\"User is not authenticated\"));\n    }\n    this.client.request(\"GlobalSignOut\", {\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\n    }, function(err) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      _this17.clearCachedUser();\n      return callback.onSuccess(\"SUCCESS\");\n    });\n    return void 0;\n  };\n  _proto.signOut = function signOut(revokeTokenCallback) {\n    var _this18 = this;\n    if (!revokeTokenCallback || typeof revokeTokenCallback !== \"function\") {\n      this.cleanClientData();\n      return;\n    }\n    this.getSession(function(error, _session) {\n      if (error) {\n        return revokeTokenCallback(error);\n      }\n      _this18.revokeTokens(function(err) {\n        _this18.cleanClientData();\n        revokeTokenCallback(err);\n      });\n    });\n  };\n  _proto.revokeTokens = function revokeTokens(revokeTokenCallback) {\n    if (revokeTokenCallback === void 0) {\n      revokeTokenCallback = function revokeTokenCallback2() {\n      };\n    }\n    if (typeof revokeTokenCallback !== \"function\") {\n      throw new Error(\"Invalid revokeTokenCallback. It should be a function.\");\n    }\n    var tokensToBeRevoked = [];\n    if (!this.signInUserSession) {\n      var error = new Error(\"User is not authenticated\");\n      return revokeTokenCallback(error);\n    }\n    if (!this.signInUserSession.getAccessToken()) {\n      var _error = new Error(\"No Access token available\");\n      return revokeTokenCallback(_error);\n    }\n    var refreshToken = this.signInUserSession.getRefreshToken().getToken();\n    var accessToken = this.signInUserSession.getAccessToken();\n    if (this.isSessionRevocable(accessToken)) {\n      if (refreshToken) {\n        return this.revokeToken({\n          token: refreshToken,\n          callback: revokeTokenCallback\n        });\n      }\n    }\n    revokeTokenCallback();\n  };\n  _proto.isSessionRevocable = function isSessionRevocable(token) {\n    if (token && typeof token.decodePayload === \"function\") {\n      try {\n        var _token$decodePayload = token.decodePayload(), origin_jti = _token$decodePayload.origin_jti;\n        return !!origin_jti;\n      } catch (err) {\n      }\n    }\n    return false;\n  };\n  _proto.cleanClientData = function cleanClientData() {\n    this.signInUserSession = null;\n    this.clearCachedUser();\n  };\n  _proto.revokeToken = function revokeToken(_ref2) {\n    var token = _ref2.token, callback = _ref2.callback;\n    this.client.requestWithRetry(\"RevokeToken\", {\n      Token: token,\n      ClientId: this.pool.getClientId()\n    }, function(err) {\n      if (err) {\n        return callback(err);\n      }\n      callback();\n    });\n  };\n  _proto.sendMFASelectionAnswer = function sendMFASelectionAnswer(answerChallenge, callback) {\n    var _this19 = this;\n    var challengeResponses = {};\n    challengeResponses.USERNAME = this.username;\n    challengeResponses.ANSWER = answerChallenge;\n    var jsonReq = {\n      ChallengeName: \"SELECT_MFA_TYPE\",\n      ChallengeResponses: challengeResponses,\n      ClientId: this.pool.getClientId(),\n      Session: this.Session\n    };\n    if (this.getUserContextData()) {\n      jsonReq.UserContextData = this.getUserContextData();\n    }\n    this.client.request(\"RespondToAuthChallenge\", jsonReq, function(err, data) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      _this19.Session = data.Session;\n      if (answerChallenge === \"SMS_MFA\") {\n        return callback.mfaRequired(data.ChallengeName, data.ChallengeParameters);\n      }\n      if (answerChallenge === \"SOFTWARE_TOKEN_MFA\") {\n        return callback.totpRequired(data.ChallengeName, data.ChallengeParameters);\n      }\n      return void 0;\n    });\n  };\n  _proto.getUserContextData = function getUserContextData() {\n    var pool = this.pool;\n    return pool.getUserContextData(this.username);\n  };\n  _proto.associateSoftwareToken = function associateSoftwareToken(callback) {\n    var _this20 = this;\n    if (!(this.signInUserSession != null && this.signInUserSession.isValid())) {\n      this.client.request(\"AssociateSoftwareToken\", {\n        Session: this.Session\n      }, function(err, data) {\n        if (err) {\n          return callback.onFailure(err);\n        }\n        _this20.Session = data.Session;\n        return callback.associateSecretCode(data.SecretCode);\n      });\n    } else {\n      this.client.request(\"AssociateSoftwareToken\", {\n        AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\n      }, function(err, data) {\n        if (err) {\n          return callback.onFailure(err);\n        }\n        return callback.associateSecretCode(data.SecretCode);\n      });\n    }\n  };\n  _proto.verifySoftwareToken = function verifySoftwareToken(totpCode, friendlyDeviceName, callback) {\n    var _this21 = this;\n    if (!(this.signInUserSession != null && this.signInUserSession.isValid())) {\n      this.client.request(\"VerifySoftwareToken\", {\n        Session: this.Session,\n        UserCode: totpCode,\n        FriendlyDeviceName: friendlyDeviceName\n      }, function(err, data) {\n        if (err) {\n          return callback.onFailure(err);\n        }\n        _this21.Session = data.Session;\n        var challengeResponses = {};\n        challengeResponses.USERNAME = _this21.username;\n        var jsonReq = {\n          ChallengeName: \"MFA_SETUP\",\n          ClientId: _this21.pool.getClientId(),\n          ChallengeResponses: challengeResponses,\n          Session: _this21.Session\n        };\n        if (_this21.getUserContextData()) {\n          jsonReq.UserContextData = _this21.getUserContextData();\n        }\n        _this21.client.request(\"RespondToAuthChallenge\", jsonReq, function(errRespond, dataRespond) {\n          if (errRespond) {\n            return callback.onFailure(errRespond);\n          }\n          _this21.signInUserSession = _this21.getCognitoUserSession(dataRespond.AuthenticationResult);\n          _this21.cacheTokens();\n          return callback.onSuccess(_this21.signInUserSession);\n        });\n        return void 0;\n      });\n    } else {\n      this.client.request(\"VerifySoftwareToken\", {\n        AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\n        UserCode: totpCode,\n        FriendlyDeviceName: friendlyDeviceName\n      }, function(err, data) {\n        if (err) {\n          return callback.onFailure(err);\n        }\n        return callback.onSuccess(data);\n      });\n    }\n  };\n  return CognitoUser2;\n}();\n\n// node_modules/amazon-cognito-identity-js/es/CognitoUserPool.js\nvar import_dist25 = __toESM(require_dist());\n\n// node_modules/amazon-cognito-identity-js/es/Client.js\nvar import_dist24 = __toESM(require_dist());\nvar import_isomorphic_unfetch = __toESM(require_browser());\n\n// node_modules/amazon-cognito-identity-js/es/UserAgent.js\nvar import_dist23 = __toESM(require_dist());\n\n// node_modules/amazon-cognito-identity-js/es/Platform/constants.js\nvar import_dist22 = __toESM(require_dist());\n\n// node_modules/amazon-cognito-identity-js/es/UserAgent.js\nfunction UserAgent() {\n}\nUserAgent.prototype.userAgent = getUserAgent();\nvar appendToCognitoUserAgent = function appendToCognitoUserAgent2(content) {\n  if (!content) {\n    return;\n  }\n  if (UserAgent.prototype.userAgent && !UserAgent.prototype.userAgent.includes(content)) {\n    UserAgent.prototype.userAgent = UserAgent.prototype.userAgent.concat(\" \", content);\n  }\n  if (!UserAgent.prototype.userAgent || UserAgent.prototype.userAgent === \"\") {\n    UserAgent.prototype.userAgent = content;\n  }\n};\nvar getAmplifyUserAgent = function getAmplifyUserAgent2(action) {\n  var uaCategoryAction = UserAgent.category ? \" \" + UserAgent.category : \"\";\n  var uaFramework = UserAgent.framework ? \" framework/\" + UserAgent.framework : \"\";\n  var userAgent2 = \"\" + UserAgent.prototype.userAgent + uaCategoryAction + uaFramework;\n  return userAgent2;\n};\n\n// node_modules/amazon-cognito-identity-js/es/Client.js\nfunction _inheritsLoose3(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  _setPrototypeOf3(subClass, superClass);\n}\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? /* @__PURE__ */ new Map() : void 0;\n  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {\n    if (Class2 === null || !_isNativeFunction(Class2))\n      return Class2;\n    if (typeof Class2 !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class2))\n        return _cache.get(Class2);\n      _cache.set(Class2, Wrapper);\n    }\n    function Wrapper() {\n      return _construct(Class2, arguments, _getPrototypeOf(this).constructor);\n    }\n    Wrapper.prototype = Object.create(Class2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } });\n    return _setPrototypeOf3(Wrapper, Class2);\n  };\n  return _wrapNativeSuper(Class);\n}\nfunction _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct()) {\n    _construct = Reflect.construct.bind();\n  } else {\n    _construct = function _construct2(Parent2, args2, Class2) {\n      var a = [null];\n      a.push.apply(a, args2);\n      var Constructor = Function.bind.apply(Parent2, a);\n      var instance = new Constructor();\n      if (Class2)\n        _setPrototypeOf3(instance, Class2.prototype);\n      return instance;\n    };\n  }\n  return _construct.apply(null, arguments);\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct)\n    return false;\n  if (Reflect.construct.sham)\n    return false;\n  if (typeof Proxy === \"function\")\n    return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {\n    }));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nfunction _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\nfunction _setPrototypeOf3(o, p) {\n  _setPrototypeOf3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf4(o2, p2) {\n    o2.__proto__ = p2;\n    return o2;\n  };\n  return _setPrototypeOf3(o, p);\n}\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {\n    return o2.__proto__ || Object.getPrototypeOf(o2);\n  };\n  return _getPrototypeOf(o);\n}\nvar CognitoError = function(_Error) {\n  _inheritsLoose3(CognitoError2, _Error);\n  function CognitoError2(message, code, name, statusCode) {\n    var _this;\n    _this = _Error.call(this, message) || this;\n    _this.code = code;\n    _this.name = name;\n    _this.statusCode = statusCode;\n    return _this;\n  }\n  return CognitoError2;\n}(_wrapNativeSuper(Error));\nvar Client = function() {\n  function Client2(region, endpoint, fetchOptions) {\n    this.endpoint = endpoint || \"https://cognito-idp.\" + region + \".amazonaws.com/\";\n    var _ref = fetchOptions || {}, credentials = _ref.credentials;\n    this.fetchOptions = credentials ? {\n      credentials\n    } : {};\n  }\n  var _proto = Client2.prototype;\n  _proto.promisifyRequest = function promisifyRequest(operation, params) {\n    var _this2 = this;\n    return new Promise(function(resolve, reject) {\n      _this2.request(operation, params, function(err, data) {\n        if (err) {\n          reject(new CognitoError(err.message, err.code, err.name, err.statusCode));\n        } else {\n          resolve(data);\n        }\n      });\n    });\n  };\n  _proto.requestWithRetry = function requestWithRetry(operation, params, callback) {\n    var _this3 = this;\n    var MAX_DELAY_IN_MILLIS = 5 * 1e3;\n    jitteredExponentialRetry(function(p) {\n      return new Promise(function(res, rej) {\n        _this3.request(operation, p, function(error, result) {\n          if (error) {\n            rej(error);\n          } else {\n            res(result);\n          }\n        });\n      });\n    }, [params], MAX_DELAY_IN_MILLIS).then(function(result) {\n      return callback(null, result);\n    })[\"catch\"](function(error) {\n      return callback(error);\n    });\n  };\n  _proto.request = function request(operation, params, callback) {\n    var headers = {\n      \"Content-Type\": \"application/x-amz-json-1.1\",\n      \"X-Amz-Target\": \"AWSCognitoIdentityProviderService.\" + operation,\n      \"X-Amz-User-Agent\": getAmplifyUserAgent(),\n      \"Cache-Control\": \"no-store\"\n    };\n    var options = Object.assign({}, this.fetchOptions, {\n      headers,\n      method: \"POST\",\n      mode: \"cors\",\n      body: JSON.stringify(params)\n    });\n    var response;\n    var responseJsonData;\n    fetch(this.endpoint, options).then(function(resp) {\n      response = resp;\n      return resp;\n    }, function(err) {\n      if (err instanceof TypeError) {\n        throw new Error(\"Network error\");\n      }\n      throw err;\n    }).then(function(resp) {\n      return resp.json()[\"catch\"](function() {\n        return {};\n      });\n    }).then(function(data) {\n      if (response.ok)\n        return callback(null, data);\n      responseJsonData = data;\n      var code = (data.__type || data.code).split(\"#\").pop();\n      var error = new Error(data.message || data.Message || null);\n      error.name = code;\n      error.code = code;\n      return callback(error);\n    })[\"catch\"](function(err) {\n      if (response && response.headers && response.headers.get(\"x-amzn-errortype\")) {\n        try {\n          var code = response.headers.get(\"x-amzn-errortype\").split(\":\")[0];\n          var error = new Error(response.status ? response.status.toString() : null);\n          error.code = code;\n          error.name = code;\n          error.statusCode = response.status;\n          return callback(error);\n        } catch (ex) {\n          return callback(err);\n        }\n      } else if (err instanceof Error && err.message === \"Network error\") {\n        err.code = \"NetworkError\";\n      }\n      return callback(err);\n    });\n  };\n  return Client2;\n}();\nvar logger = {\n  debug: function debug() {\n  }\n};\nvar NonRetryableError = function(_Error2) {\n  _inheritsLoose3(NonRetryableError2, _Error2);\n  function NonRetryableError2(message) {\n    var _this4;\n    _this4 = _Error2.call(this, message) || this;\n    _this4.nonRetryable = true;\n    return _this4;\n  }\n  return NonRetryableError2;\n}(_wrapNativeSuper(Error));\nvar isNonRetryableError = function isNonRetryableError2(obj) {\n  var key = \"nonRetryable\";\n  return obj && obj[key];\n};\nfunction retry(functionToRetry, args, delayFn, attempt) {\n  if (attempt === void 0) {\n    attempt = 1;\n  }\n  if (typeof functionToRetry !== \"function\") {\n    throw Error(\"functionToRetry must be a function\");\n  }\n  logger.debug(functionToRetry.name + \" attempt #\" + attempt + \" with args: \" + JSON.stringify(args));\n  return functionToRetry.apply(void 0, args)[\"catch\"](function(err) {\n    logger.debug(\"error on \" + functionToRetry.name, err);\n    if (isNonRetryableError(err)) {\n      logger.debug(functionToRetry.name + \" non retryable error\", err);\n      throw err;\n    }\n    var retryIn = delayFn(attempt, args, err);\n    logger.debug(functionToRetry.name + \" retrying in \" + retryIn + \" ms\");\n    if (retryIn !== false) {\n      return new Promise(function(res) {\n        return setTimeout(res, retryIn);\n      }).then(function() {\n        return retry(functionToRetry, args, delayFn, attempt + 1);\n      });\n    } else {\n      throw err;\n    }\n  });\n}\nfunction jitteredBackoff(maxDelayMs) {\n  var BASE_TIME_MS = 100;\n  var JITTER_FACTOR = 100;\n  return function(attempt) {\n    var delay = Math.pow(2, attempt) * BASE_TIME_MS + JITTER_FACTOR * Math.random();\n    return delay > maxDelayMs ? false : delay;\n  };\n}\nvar MAX_DELAY_MS = 5 * 60 * 1e3;\nfunction jitteredExponentialRetry(functionToRetry, args, maxDelayMs) {\n  if (maxDelayMs === void 0) {\n    maxDelayMs = MAX_DELAY_MS;\n  }\n  return retry(functionToRetry, args, jitteredBackoff(maxDelayMs));\n}\n\n// node_modules/amazon-cognito-identity-js/es/CognitoUserPool.js\nvar USER_POOL_ID_MAX_LENGTH = 55;\nvar CognitoUserPool = function() {\n  function CognitoUserPool2(data, wrapRefreshSessionCallback) {\n    var _ref = data || {}, UserPoolId = _ref.UserPoolId, ClientId = _ref.ClientId, endpoint = _ref.endpoint, fetchOptions = _ref.fetchOptions, AdvancedSecurityDataCollectionFlag = _ref.AdvancedSecurityDataCollectionFlag;\n    if (!UserPoolId || !ClientId) {\n      throw new Error(\"Both UserPoolId and ClientId are required.\");\n    }\n    if (UserPoolId.length > USER_POOL_ID_MAX_LENGTH || !/^[\\w-]+_[0-9a-zA-Z]+$/.test(UserPoolId)) {\n      throw new Error(\"Invalid UserPoolId format.\");\n    }\n    var region = UserPoolId.split(\"_\")[0];\n    this.userPoolId = UserPoolId;\n    this.clientId = ClientId;\n    this.client = new Client(region, endpoint, fetchOptions);\n    this.advancedSecurityDataCollectionFlag = AdvancedSecurityDataCollectionFlag !== false;\n    this.storage = data.Storage || new StorageHelper().getStorage();\n    if (wrapRefreshSessionCallback) {\n      this.wrapRefreshSessionCallback = wrapRefreshSessionCallback;\n    }\n  }\n  var _proto = CognitoUserPool2.prototype;\n  _proto.getUserPoolId = function getUserPoolId() {\n    return this.userPoolId;\n  };\n  _proto.getUserPoolName = function getUserPoolName() {\n    return this.getUserPoolId().split(\"_\")[1];\n  };\n  _proto.getClientId = function getClientId() {\n    return this.clientId;\n  };\n  _proto.signUp = function signUp(username, password, userAttributes, validationData, callback, clientMetadata) {\n    var _this = this;\n    var jsonReq = {\n      ClientId: this.clientId,\n      Username: username,\n      Password: password,\n      UserAttributes: userAttributes,\n      ValidationData: validationData,\n      ClientMetadata: clientMetadata\n    };\n    if (this.getUserContextData(username)) {\n      jsonReq.UserContextData = this.getUserContextData(username);\n    }\n    this.client.request(\"SignUp\", jsonReq, function(err, data) {\n      if (err) {\n        return callback(err, null);\n      }\n      var cognitoUser = {\n        Username: username,\n        Pool: _this,\n        Storage: _this.storage\n      };\n      var returnData = {\n        user: new CognitoUser(cognitoUser),\n        userConfirmed: data.UserConfirmed,\n        userSub: data.UserSub,\n        codeDeliveryDetails: data.CodeDeliveryDetails\n      };\n      return callback(null, returnData);\n    });\n  };\n  _proto.getCurrentUser = function getCurrentUser() {\n    var lastUserKey = \"CognitoIdentityServiceProvider.\" + this.clientId + \".LastAuthUser\";\n    var lastAuthUser = this.storage.getItem(lastUserKey);\n    if (lastAuthUser) {\n      var cognitoUser = {\n        Username: lastAuthUser,\n        Pool: this,\n        Storage: this.storage\n      };\n      return new CognitoUser(cognitoUser);\n    }\n    return null;\n  };\n  _proto.getUserContextData = function getUserContextData(username) {\n    if (typeof AmazonCognitoAdvancedSecurityData === \"undefined\") {\n      return void 0;\n    }\n    var amazonCognitoAdvancedSecurityDataConst = AmazonCognitoAdvancedSecurityData;\n    if (this.advancedSecurityDataCollectionFlag) {\n      var advancedSecurityData = amazonCognitoAdvancedSecurityDataConst.getData(username, this.userPoolId, this.clientId);\n      if (advancedSecurityData) {\n        var userContextData = {\n          EncodedData: advancedSecurityData\n        };\n        return userContextData;\n      }\n    }\n    return {};\n  };\n  return CognitoUserPool2;\n}();\n\n// node_modules/amazon-cognito-identity-js/es/CookieStorage.js\nvar import_dist26 = __toESM(require_dist());\nvar Cookies = __toESM(require_js_cookie());\nvar CookieStorage = function() {\n  function CookieStorage2(data) {\n    if (data === void 0) {\n      data = {};\n    }\n    if (data.domain) {\n      this.domain = data.domain;\n    }\n    if (data.path) {\n      this.path = data.path;\n    } else {\n      this.path = \"/\";\n    }\n    if (Object.prototype.hasOwnProperty.call(data, \"expires\")) {\n      this.expires = data.expires;\n    } else {\n      this.expires = 365;\n    }\n    if (Object.prototype.hasOwnProperty.call(data, \"secure\")) {\n      this.secure = data.secure;\n    } else {\n      this.secure = true;\n    }\n    if (Object.prototype.hasOwnProperty.call(data, \"sameSite\")) {\n      if (![\"strict\", \"lax\", \"none\"].includes(data.sameSite)) {\n        throw new Error('The sameSite value of cookieStorage must be \"lax\", \"strict\" or \"none\".');\n      }\n      if (data.sameSite === \"none\" && !this.secure) {\n        throw new Error(\"sameSite = None requires the Secure attribute in latest browser versions.\");\n      }\n      this.sameSite = data.sameSite;\n    } else {\n      this.sameSite = null;\n    }\n  }\n  var _proto = CookieStorage2.prototype;\n  _proto.setItem = function setItem(key, value) {\n    var options = {\n      path: this.path,\n      expires: this.expires,\n      domain: this.domain,\n      secure: this.secure\n    };\n    if (this.sameSite) {\n      options.sameSite = this.sameSite;\n    }\n    Cookies.set(key, value, options);\n    return Cookies.get(key);\n  };\n  _proto.getItem = function getItem(key) {\n    return Cookies.get(key);\n  };\n  _proto.removeItem = function removeItem(key) {\n    var options = {\n      path: this.path,\n      expires: this.expires,\n      domain: this.domain,\n      secure: this.secure\n    };\n    if (this.sameSite) {\n      options.sameSite = this.sameSite;\n    }\n    return Cookies.remove(key, options);\n  };\n  _proto.clear = function clear() {\n    var cookies = Cookies.get();\n    var numKeys = Object.keys(cookies).length;\n    for (var index = 0; index < numKeys; ++index) {\n      this.removeItem(Object.keys(cookies)[index]);\n    }\n    return {};\n  };\n  return CookieStorage2;\n}();\nexport {\n  AuthenticationDetails,\n  AuthenticationHelper,\n  CognitoAccessToken,\n  CognitoIdToken,\n  CognitoRefreshToken,\n  CognitoUser,\n  CognitoUserAttribute,\n  CognitoUserPool,\n  CognitoUserSession,\n  CookieStorage,\n  DateHelper,\n  WordArray,\n  appendToCognitoUserAgent\n};\n/*! Bundled license information:\n\ntslib/tslib.es6.js:\n  (*! *****************************************************************************\n  Copyright (c) Microsoft Corporation.\n  \n  Permission to use, copy, modify, and/or distribute this software for any\n  purpose with or without fee is hereby granted.\n  \n  THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n  PERFORMANCE OF THIS SOFTWARE.\n  ***************************************************************************** *)\n\njs-cookie/src/js.cookie.js:\n  (*!\n   * JavaScript Cookie v2.2.1\n   * https://github.com/js-cookie/js-cookie\n   *\n   * Copyright 2006, 2015 Klaus Hartl & Fagner Brack\n   * Released under the MIT license\n   *)\n\namazon-cognito-identity-js/es/AuthenticationDetails.js:\n  (*!\n   * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n   * SPDX-License-Identifier: Apache-2.0\n   *)\n\namazon-cognito-identity-js/es/AuthenticationHelper.js:\n  (*!\n   * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n   * SPDX-License-Identifier: Apache-2.0\n   *)\n\namazon-cognito-identity-js/es/CognitoJwtToken.js:\n  (*!\n   * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n   * SPDX-License-Identifier: Apache-2.0\n   *)\n\namazon-cognito-identity-js/es/CognitoAccessToken.js:\n  (*!\n   * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n   * SPDX-License-Identifier: Apache-2.0\n   *)\n\namazon-cognito-identity-js/es/CognitoIdToken.js:\n  (*!\n   * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n   * SPDX-License-Identifier: Apache-2.0\n   *)\n\namazon-cognito-identity-js/es/CognitoRefreshToken.js:\n  (*!\n   * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n   * SPDX-License-Identifier: Apache-2.0\n   *)\n\namazon-cognito-identity-js/es/Platform/index.js:\n  (*!\n   * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n   * SPDX-License-Identifier: Apache-2.0\n   *)\n\namazon-cognito-identity-js/es/CognitoUserSession.js:\n  (*!\n   * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n   * SPDX-License-Identifier: Apache-2.0\n   *)\n\namazon-cognito-identity-js/es/DateHelper.js:\n  (*!\n   * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n   * SPDX-License-Identifier: Apache-2.0\n   *)\n\namazon-cognito-identity-js/es/CognitoUserAttribute.js:\n  (*!\n   * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n   * SPDX-License-Identifier: Apache-2.0\n   *)\n\namazon-cognito-identity-js/es/StorageHelper.js:\n  (*!\n   * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n   * SPDX-License-Identifier: Apache-2.0\n   *)\n\namazon-cognito-identity-js/es/CognitoUser.js:\n  (*!\n   * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n   * SPDX-License-Identifier: Apache-2.0\n   *)\n\namazon-cognito-identity-js/es/CognitoUserPool.js:\n  (*!\n   * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n   * SPDX-License-Identifier: Apache-2.0\n   *)\n\namazon-cognito-identity-js/es/index.js:\n  (*!\n   * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n   * SPDX-License-Identifier: Apache-2.0\n   *)\n*/\n//# sourceMappingURL=amazon-cognito-identity-js.js.map\n",
      "start": 1703289449947,
      "end": 1703289449955,
      "sourcemaps": null
    },
    {
      "name": "vite:react-babel",
      "start": 1703289449955,
      "end": 1703289449955,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1703289449955,
      "end": 1703289449955,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1703289449955,
      "end": 1703289449955,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1703289449955,
      "end": 1703289449955,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1703289449955,
      "end": 1703289449955,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1703289449955,
      "end": 1703289449955,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1703289449955,
      "end": 1703289449955,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1703289449955,
      "end": 1703289449955,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1703289449955,
      "end": 1703289449955,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1703289449955,
      "end": 1703289449955,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1703289449955,
      "end": 1703289449955,
      "order": "normal"
    },
    {
      "name": "vite:client-inject",
      "start": 1703289449955,
      "end": 1703289449955,
      "order": "normal"
    },
    {
      "name": "vite:import-analysis",
      "result": "\"use strict\";\n(() => {\n  var __create = Object.create;\n  var __defProp = Object.defineProperty;\n  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n  var __getOwnPropNames = Object.getOwnPropertyNames;\n  var __getProtoOf = Object.getPrototypeOf;\n  var __hasOwnProp = Object.prototype.hasOwnProperty;\n  var __esm = (fn, res) => function __init() {\n    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;\n  };\n  var __commonJS = (cb, mod) => function __require() {\n    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n  };\n  var __copyProps = (to, from, except, desc) => {\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n      for (let key of __getOwnPropNames(from))\n        if (!__hasOwnProp.call(to, key) && key !== except)\n          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n    }\n    return to;\n  };\n  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n    // If the importer is in node compatibility mode or this is not an ESM\n    // file that has been converted to a CommonJS file using a Babel-\n    // compatible transform (i.e. \"__esModule\" has not been set), then set\n    // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n    isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n    mod\n  ));\n\n  // node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js\n  var require_base64_js = __commonJS({\n    \"node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js\"(exports) {\n      \"use strict\";\n      init_dist();\n      exports.byteLength = byteLength;\n      exports.toByteArray = toByteArray;\n      exports.fromByteArray = fromByteArray;\n      var lookup = [];\n      var revLookup = [];\n      var Arr = typeof Uint8Array !== \"undefined\" ? Uint8Array : Array;\n      var code = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n      for (i = 0, len = code.length; i < len; ++i) {\n        lookup[i] = code[i];\n        revLookup[code.charCodeAt(i)] = i;\n      }\n      var i;\n      var len;\n      revLookup[\"-\".charCodeAt(0)] = 62;\n      revLookup[\"_\".charCodeAt(0)] = 63;\n      function getLens(b64) {\n        var len2 = b64.length;\n        if (len2 % 4 > 0) {\n          throw new Error(\"Invalid string. Length must be a multiple of 4\");\n        }\n        var validLen = b64.indexOf(\"=\");\n        if (validLen === -1)\n          validLen = len2;\n        var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;\n        return [validLen, placeHoldersLen];\n      }\n      function byteLength(b64) {\n        var lens = getLens(b64);\n        var validLen = lens[0];\n        var placeHoldersLen = lens[1];\n        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n      }\n      function _byteLength(b64, validLen, placeHoldersLen) {\n        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n      }\n      function toByteArray(b64) {\n        var tmp;\n        var lens = getLens(b64);\n        var validLen = lens[0];\n        var placeHoldersLen = lens[1];\n        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n        var curByte = 0;\n        var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;\n        var i2;\n        for (i2 = 0; i2 < len2; i2 += 4) {\n          tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];\n          arr[curByte++] = tmp >> 16 & 255;\n          arr[curByte++] = tmp >> 8 & 255;\n          arr[curByte++] = tmp & 255;\n        }\n        if (placeHoldersLen === 2) {\n          tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;\n          arr[curByte++] = tmp & 255;\n        }\n        if (placeHoldersLen === 1) {\n          tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;\n          arr[curByte++] = tmp >> 8 & 255;\n          arr[curByte++] = tmp & 255;\n        }\n        return arr;\n      }\n      function tripletToBase64(num) {\n        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];\n      }\n      function encodeChunk(uint8, start, end) {\n        var tmp;\n        var output = [];\n        for (var i2 = start; i2 < end; i2 += 3) {\n          tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);\n          output.push(tripletToBase64(tmp));\n        }\n        return output.join(\"\");\n      }\n      function fromByteArray(uint8) {\n        var tmp;\n        var len2 = uint8.length;\n        var extraBytes = len2 % 3;\n        var parts = [];\n        var maxChunkLength = 16383;\n        for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {\n          parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));\n        }\n        if (extraBytes === 1) {\n          tmp = uint8[len2 - 1];\n          parts.push(\n            lookup[tmp >> 2] + lookup[tmp << 4 & 63] + \"==\"\n          );\n        } else if (extraBytes === 2) {\n          tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];\n          parts.push(\n            lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + \"=\"\n          );\n        }\n        return parts.join(\"\");\n      }\n    }\n  });\n\n  // node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js\n  var require_ieee754 = __commonJS({\n    \"node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js\"(exports) {\n      init_dist();\n      exports.read = function(buffer, offset, isLE, mLen, nBytes) {\n        var e, m;\n        var eLen = nBytes * 8 - mLen - 1;\n        var eMax = (1 << eLen) - 1;\n        var eBias = eMax >> 1;\n        var nBits = -7;\n        var i = isLE ? nBytes - 1 : 0;\n        var d = isLE ? -1 : 1;\n        var s2 = buffer[offset + i];\n        i += d;\n        e = s2 & (1 << -nBits) - 1;\n        s2 >>= -nBits;\n        nBits += eLen;\n        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {\n        }\n        m = e & (1 << -nBits) - 1;\n        e >>= -nBits;\n        nBits += mLen;\n        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {\n        }\n        if (e === 0) {\n          e = 1 - eBias;\n        } else if (e === eMax) {\n          return m ? NaN : (s2 ? -1 : 1) * Infinity;\n        } else {\n          m = m + Math.pow(2, mLen);\n          e = e - eBias;\n        }\n        return (s2 ? -1 : 1) * m * Math.pow(2, e - mLen);\n      };\n      exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {\n        var e, m, c;\n        var eLen = nBytes * 8 - mLen - 1;\n        var eMax = (1 << eLen) - 1;\n        var eBias = eMax >> 1;\n        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n        var i = isLE ? 0 : nBytes - 1;\n        var d = isLE ? 1 : -1;\n        var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n        value = Math.abs(value);\n        if (isNaN(value) || value === Infinity) {\n          m = isNaN(value) ? 1 : 0;\n          e = eMax;\n        } else {\n          e = Math.floor(Math.log(value) / Math.LN2);\n          if (value * (c = Math.pow(2, -e)) < 1) {\n            e--;\n            c *= 2;\n          }\n          if (e + eBias >= 1) {\n            value += rt / c;\n          } else {\n            value += rt * Math.pow(2, 1 - eBias);\n          }\n          if (value * c >= 2) {\n            e++;\n            c /= 2;\n          }\n          if (e + eBias >= eMax) {\n            m = 0;\n            e = eMax;\n          } else if (e + eBias >= 1) {\n            m = (value * c - 1) * Math.pow(2, mLen);\n            e = e + eBias;\n          } else {\n            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n            e = 0;\n          }\n        }\n        for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {\n        }\n        e = e << mLen | m;\n        eLen += mLen;\n        for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {\n        }\n        buffer[offset + i - d] |= s2 * 128;\n      };\n    }\n  });\n\n  // node_modules/.pnpm/buffer@6.0.3_patch_hash=zkkuxompt5d553skpnegwi5wuy/node_modules/buffer/index.js\n  var require_buffer = __commonJS({\n    \"node_modules/.pnpm/buffer@6.0.3_patch_hash=zkkuxompt5d553skpnegwi5wuy/node_modules/buffer/index.js\"(exports) {\n      \"use strict\";\n      init_dist();\n      var base64 = require_base64_js();\n      var ieee754 = require_ieee754();\n      var customInspectSymbol = typeof Symbol === \"function\" && typeof Symbol[\"for\"] === \"function\" ? Symbol[\"for\"](\"nodejs.util.inspect.custom\") : null;\n      exports.Buffer = Buffer2;\n      exports.SlowBuffer = SlowBuffer;\n      exports.INSPECT_MAX_BYTES = 50;\n      var K_MAX_LENGTH = 2147483647;\n      exports.kMaxLength = K_MAX_LENGTH;\n      var { Uint8Array: GlobalUint8Array, ArrayBuffer: GlobalArrayBuffer, SharedArrayBuffer: GlobalSharedArrayBuffer } = globalThis;\n      Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();\n      if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== \"undefined\" && typeof console.error === \"function\") {\n        console.error(\n          \"This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.\"\n        );\n      }\n      function typedArraySupport() {\n        try {\n          const arr = new GlobalUint8Array(1);\n          const proto = { foo: function() {\n            return 42;\n          } };\n          Object.setPrototypeOf(proto, GlobalUint8Array.prototype);\n          Object.setPrototypeOf(arr, proto);\n          return arr.foo() === 42;\n        } catch (e) {\n          return false;\n        }\n      }\n      Object.defineProperty(Buffer2.prototype, \"parent\", {\n        enumerable: true,\n        get: function() {\n          if (!Buffer2.isBuffer(this))\n            return void 0;\n          return this.buffer;\n        }\n      });\n      Object.defineProperty(Buffer2.prototype, \"offset\", {\n        enumerable: true,\n        get: function() {\n          if (!Buffer2.isBuffer(this))\n            return void 0;\n          return this.byteOffset;\n        }\n      });\n      function createBuffer(length) {\n        if (length > K_MAX_LENGTH) {\n          throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"');\n        }\n        const buf = new GlobalUint8Array(length);\n        Object.setPrototypeOf(buf, Buffer2.prototype);\n        return buf;\n      }\n      function Buffer2(arg, encodingOrOffset, length) {\n        if (typeof arg === \"number\") {\n          if (typeof encodingOrOffset === \"string\") {\n            throw new TypeError(\n              'The \"string\" argument must be of type string. Received type number'\n            );\n          }\n          return allocUnsafe(arg);\n        }\n        return from(arg, encodingOrOffset, length);\n      }\n      Buffer2.poolSize = 8192;\n      function from(value, encodingOrOffset, length) {\n        if (typeof value === \"string\") {\n          return fromString(value, encodingOrOffset);\n        }\n        if (GlobalArrayBuffer.isView(value)) {\n          return fromArrayView(value);\n        }\n        if (value == null) {\n          throw new TypeError(\n            \"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value\n          );\n        }\n        if (isInstance(value, GlobalArrayBuffer) || value && isInstance(value.buffer, GlobalArrayBuffer)) {\n          return fromArrayBuffer(value, encodingOrOffset, length);\n        }\n        if (typeof GlobalSharedArrayBuffer !== \"undefined\" && (isInstance(value, GlobalSharedArrayBuffer) || value && isInstance(value.buffer, GlobalSharedArrayBuffer))) {\n          return fromArrayBuffer(value, encodingOrOffset, length);\n        }\n        if (typeof value === \"number\") {\n          throw new TypeError(\n            'The \"value\" argument must not be of type number. Received type number'\n          );\n        }\n        const valueOf = value.valueOf && value.valueOf();\n        if (valueOf != null && valueOf !== value) {\n          return Buffer2.from(valueOf, encodingOrOffset, length);\n        }\n        const b = fromObject(value);\n        if (b)\n          return b;\n        if (typeof Symbol !== \"undefined\" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === \"function\") {\n          return Buffer2.from(value[Symbol.toPrimitive](\"string\"), encodingOrOffset, length);\n        }\n        throw new TypeError(\n          \"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value\n        );\n      }\n      Buffer2.from = function(value, encodingOrOffset, length) {\n        return from(value, encodingOrOffset, length);\n      };\n      Object.setPrototypeOf(Buffer2.prototype, GlobalUint8Array.prototype);\n      Object.setPrototypeOf(Buffer2, GlobalUint8Array);\n      function assertSize(size) {\n        if (typeof size !== \"number\") {\n          throw new TypeError('\"size\" argument must be of type number');\n        } else if (size < 0) {\n          throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"');\n        }\n      }\n      function alloc(size, fill, encoding) {\n        assertSize(size);\n        if (size <= 0) {\n          return createBuffer(size);\n        }\n        if (fill !== void 0) {\n          return typeof encoding === \"string\" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);\n        }\n        return createBuffer(size);\n      }\n      Buffer2.alloc = function(size, fill, encoding) {\n        return alloc(size, fill, encoding);\n      };\n      function allocUnsafe(size) {\n        assertSize(size);\n        return createBuffer(size < 0 ? 0 : checked(size) | 0);\n      }\n      Buffer2.allocUnsafe = function(size) {\n        return allocUnsafe(size);\n      };\n      Buffer2.allocUnsafeSlow = function(size) {\n        return allocUnsafe(size);\n      };\n      function fromString(string, encoding) {\n        if (typeof encoding !== \"string\" || encoding === \"\") {\n          encoding = \"utf8\";\n        }\n        if (!Buffer2.isEncoding(encoding)) {\n          throw new TypeError(\"Unknown encoding: \" + encoding);\n        }\n        const length = byteLength(string, encoding) | 0;\n        let buf = createBuffer(length);\n        const actual = buf.write(string, encoding);\n        if (actual !== length) {\n          buf = buf.slice(0, actual);\n        }\n        return buf;\n      }\n      function fromArrayLike(array) {\n        const length = array.length < 0 ? 0 : checked(array.length) | 0;\n        const buf = createBuffer(length);\n        for (let i = 0; i < length; i += 1) {\n          buf[i] = array[i] & 255;\n        }\n        return buf;\n      }\n      function fromArrayView(arrayView) {\n        if (isInstance(arrayView, GlobalUint8Array)) {\n          const copy = new GlobalUint8Array(arrayView);\n          return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);\n        }\n        return fromArrayLike(arrayView);\n      }\n      function fromArrayBuffer(array, byteOffset, length) {\n        if (byteOffset < 0 || array.byteLength < byteOffset) {\n          throw new RangeError('\"offset\" is outside of buffer bounds');\n        }\n        if (array.byteLength < byteOffset + (length || 0)) {\n          throw new RangeError('\"length\" is outside of buffer bounds');\n        }\n        let buf;\n        if (byteOffset === void 0 && length === void 0) {\n          buf = new GlobalUint8Array(array);\n        } else if (length === void 0) {\n          buf = new GlobalUint8Array(array, byteOffset);\n        } else {\n          buf = new GlobalUint8Array(array, byteOffset, length);\n        }\n        Object.setPrototypeOf(buf, Buffer2.prototype);\n        return buf;\n      }\n      function fromObject(obj) {\n        if (Buffer2.isBuffer(obj)) {\n          const len = checked(obj.length) | 0;\n          const buf = createBuffer(len);\n          if (buf.length === 0) {\n            return buf;\n          }\n          obj.copy(buf, 0, 0, len);\n          return buf;\n        }\n        if (obj.length !== void 0) {\n          if (typeof obj.length !== \"number\" || numberIsNaN(obj.length)) {\n            return createBuffer(0);\n          }\n          return fromArrayLike(obj);\n        }\n        if (obj.type === \"Buffer\" && Array.isArray(obj.data)) {\n          return fromArrayLike(obj.data);\n        }\n      }\n      function checked(length) {\n        if (length >= K_MAX_LENGTH) {\n          throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\" + K_MAX_LENGTH.toString(16) + \" bytes\");\n        }\n        return length | 0;\n      }\n      function SlowBuffer(length) {\n        if (+length != length) {\n          length = 0;\n        }\n        return Buffer2.alloc(+length);\n      }\n      Buffer2.isBuffer = function isBuffer(b) {\n        return b != null && b._isBuffer === true && b !== Buffer2.prototype;\n      };\n      Buffer2.compare = function compare(a, b) {\n        if (isInstance(a, GlobalUint8Array))\n          a = Buffer2.from(a, a.offset, a.byteLength);\n        if (isInstance(b, GlobalUint8Array))\n          b = Buffer2.from(b, b.offset, b.byteLength);\n        if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {\n          throw new TypeError(\n            'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n          );\n        }\n        if (a === b)\n          return 0;\n        let x = a.length;\n        let y = b.length;\n        for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n          if (a[i] !== b[i]) {\n            x = a[i];\n            y = b[i];\n            break;\n          }\n        }\n        if (x < y)\n          return -1;\n        if (y < x)\n          return 1;\n        return 0;\n      };\n      Buffer2.isEncoding = function isEncoding(encoding) {\n        switch (String(encoding).toLowerCase()) {\n          case \"hex\":\n          case \"utf8\":\n          case \"utf-8\":\n          case \"ascii\":\n          case \"latin1\":\n          case \"binary\":\n          case \"base64\":\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return true;\n          default:\n            return false;\n        }\n      };\n      Buffer2.concat = function concat(list, length) {\n        if (!Array.isArray(list)) {\n          throw new TypeError('\"list\" argument must be an Array of Buffers');\n        }\n        if (list.length === 0) {\n          return Buffer2.alloc(0);\n        }\n        let i;\n        if (length === void 0) {\n          length = 0;\n          for (i = 0; i < list.length; ++i) {\n            length += list[i].length;\n          }\n        }\n        const buffer = Buffer2.allocUnsafe(length);\n        let pos = 0;\n        for (i = 0; i < list.length; ++i) {\n          let buf = list[i];\n          if (isInstance(buf, GlobalUint8Array)) {\n            if (pos + buf.length > buffer.length) {\n              if (!Buffer2.isBuffer(buf))\n                buf = Buffer2.from(buf);\n              buf.copy(buffer, pos);\n            } else {\n              GlobalUint8Array.prototype.set.call(\n                buffer,\n                buf,\n                pos\n              );\n            }\n          } else if (!Buffer2.isBuffer(buf)) {\n            throw new TypeError('\"list\" argument must be an Array of Buffers');\n          } else {\n            buf.copy(buffer, pos);\n          }\n          pos += buf.length;\n        }\n        return buffer;\n      };\n      function byteLength(string, encoding) {\n        if (Buffer2.isBuffer(string)) {\n          return string.length;\n        }\n        if (GlobalArrayBuffer.isView(string) || isInstance(string, GlobalArrayBuffer)) {\n          return string.byteLength;\n        }\n        if (typeof string !== \"string\") {\n          throw new TypeError(\n            'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string\n          );\n        }\n        const len = string.length;\n        const mustMatch = arguments.length > 2 && arguments[2] === true;\n        if (!mustMatch && len === 0)\n          return 0;\n        let loweredCase = false;\n        for (; ; ) {\n          switch (encoding) {\n            case \"ascii\":\n            case \"latin1\":\n            case \"binary\":\n              return len;\n            case \"utf8\":\n            case \"utf-8\":\n              return utf8ToBytes(string).length;\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n              return len * 2;\n            case \"hex\":\n              return len >>> 1;\n            case \"base64\":\n              return base64ToBytes(string).length;\n            default:\n              if (loweredCase) {\n                return mustMatch ? -1 : utf8ToBytes(string).length;\n              }\n              encoding = (\"\" + encoding).toLowerCase();\n              loweredCase = true;\n          }\n        }\n      }\n      Buffer2.byteLength = byteLength;\n      function slowToString(encoding, start, end) {\n        let loweredCase = false;\n        if (start === void 0 || start < 0) {\n          start = 0;\n        }\n        if (start > this.length) {\n          return \"\";\n        }\n        if (end === void 0 || end > this.length) {\n          end = this.length;\n        }\n        if (end <= 0) {\n          return \"\";\n        }\n        end >>>= 0;\n        start >>>= 0;\n        if (end <= start) {\n          return \"\";\n        }\n        if (!encoding)\n          encoding = \"utf8\";\n        while (true) {\n          switch (encoding) {\n            case \"hex\":\n              return hexSlice(this, start, end);\n            case \"utf8\":\n            case \"utf-8\":\n              return utf8Slice(this, start, end);\n            case \"ascii\":\n              return asciiSlice(this, start, end);\n            case \"latin1\":\n            case \"binary\":\n              return latin1Slice(this, start, end);\n            case \"base64\":\n              return base64Slice(this, start, end);\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n              return utf16leSlice(this, start, end);\n            default:\n              if (loweredCase)\n                throw new TypeError(\"Unknown encoding: \" + encoding);\n              encoding = (encoding + \"\").toLowerCase();\n              loweredCase = true;\n          }\n        }\n      }\n      Buffer2.prototype._isBuffer = true;\n      function swap(b, n, m) {\n        const i = b[n];\n        b[n] = b[m];\n        b[m] = i;\n      }\n      Buffer2.prototype.swap16 = function swap16() {\n        const len = this.length;\n        if (len % 2 !== 0) {\n          throw new RangeError(\"Buffer size must be a multiple of 16-bits\");\n        }\n        for (let i = 0; i < len; i += 2) {\n          swap(this, i, i + 1);\n        }\n        return this;\n      };\n      Buffer2.prototype.swap32 = function swap32() {\n        const len = this.length;\n        if (len % 4 !== 0) {\n          throw new RangeError(\"Buffer size must be a multiple of 32-bits\");\n        }\n        for (let i = 0; i < len; i += 4) {\n          swap(this, i, i + 3);\n          swap(this, i + 1, i + 2);\n        }\n        return this;\n      };\n      Buffer2.prototype.swap64 = function swap64() {\n        const len = this.length;\n        if (len % 8 !== 0) {\n          throw new RangeError(\"Buffer size must be a multiple of 64-bits\");\n        }\n        for (let i = 0; i < len; i += 8) {\n          swap(this, i, i + 7);\n          swap(this, i + 1, i + 6);\n          swap(this, i + 2, i + 5);\n          swap(this, i + 3, i + 4);\n        }\n        return this;\n      };\n      Buffer2.prototype.toString = function toString() {\n        const length = this.length;\n        if (length === 0)\n          return \"\";\n        if (arguments.length === 0)\n          return utf8Slice(this, 0, length);\n        return slowToString.apply(this, arguments);\n      };\n      Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;\n      Buffer2.prototype.equals = function equals(b) {\n        if (!Buffer2.isBuffer(b))\n          throw new TypeError(\"Argument must be a Buffer\");\n        if (this === b)\n          return true;\n        return Buffer2.compare(this, b) === 0;\n      };\n      Buffer2.prototype.inspect = function inspect() {\n        let str = \"\";\n        const max = exports.INSPECT_MAX_BYTES;\n        str = this.toString(\"hex\", 0, max).replace(/(.{2})/g, \"$1 \").trim();\n        if (this.length > max)\n          str += \" ... \";\n        return \"<Buffer \" + str + \">\";\n      };\n      if (customInspectSymbol) {\n        Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;\n      }\n      Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n        if (isInstance(target, GlobalUint8Array)) {\n          target = Buffer2.from(target, target.offset, target.byteLength);\n        }\n        if (!Buffer2.isBuffer(target)) {\n          throw new TypeError(\n            'The \"target\" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target\n          );\n        }\n        if (start === void 0) {\n          start = 0;\n        }\n        if (end === void 0) {\n          end = target ? target.length : 0;\n        }\n        if (thisStart === void 0) {\n          thisStart = 0;\n        }\n        if (thisEnd === void 0) {\n          thisEnd = this.length;\n        }\n        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n          throw new RangeError(\"out of range index\");\n        }\n        if (thisStart >= thisEnd && start >= end) {\n          return 0;\n        }\n        if (thisStart >= thisEnd) {\n          return -1;\n        }\n        if (start >= end) {\n          return 1;\n        }\n        start >>>= 0;\n        end >>>= 0;\n        thisStart >>>= 0;\n        thisEnd >>>= 0;\n        if (this === target)\n          return 0;\n        let x = thisEnd - thisStart;\n        let y = end - start;\n        const len = Math.min(x, y);\n        const thisCopy = this.slice(thisStart, thisEnd);\n        const targetCopy = target.slice(start, end);\n        for (let i = 0; i < len; ++i) {\n          if (thisCopy[i] !== targetCopy[i]) {\n            x = thisCopy[i];\n            y = targetCopy[i];\n            break;\n          }\n        }\n        if (x < y)\n          return -1;\n        if (y < x)\n          return 1;\n        return 0;\n      };\n      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n        if (buffer.length === 0)\n          return -1;\n        if (typeof byteOffset === \"string\") {\n          encoding = byteOffset;\n          byteOffset = 0;\n        } else if (byteOffset > 2147483647) {\n          byteOffset = 2147483647;\n        } else if (byteOffset < -2147483648) {\n          byteOffset = -2147483648;\n        }\n        byteOffset = +byteOffset;\n        if (numberIsNaN(byteOffset)) {\n          byteOffset = dir ? 0 : buffer.length - 1;\n        }\n        if (byteOffset < 0)\n          byteOffset = buffer.length + byteOffset;\n        if (byteOffset >= buffer.length) {\n          if (dir)\n            return -1;\n          else\n            byteOffset = buffer.length - 1;\n        } else if (byteOffset < 0) {\n          if (dir)\n            byteOffset = 0;\n          else\n            return -1;\n        }\n        if (typeof val === \"string\") {\n          val = Buffer2.from(val, encoding);\n        }\n        if (Buffer2.isBuffer(val)) {\n          if (val.length === 0) {\n            return -1;\n          }\n          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n        } else if (typeof val === \"number\") {\n          val = val & 255;\n          if (typeof GlobalUint8Array.prototype.indexOf === \"function\") {\n            if (dir) {\n              return GlobalUint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n            } else {\n              return GlobalUint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n            }\n          }\n          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);\n        }\n        throw new TypeError(\"val must be string, number or Buffer\");\n      }\n      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n        let indexSize = 1;\n        let arrLength = arr.length;\n        let valLength = val.length;\n        if (encoding !== void 0) {\n          encoding = String(encoding).toLowerCase();\n          if (encoding === \"ucs2\" || encoding === \"ucs-2\" || encoding === \"utf16le\" || encoding === \"utf-16le\") {\n            if (arr.length < 2 || val.length < 2) {\n              return -1;\n            }\n            indexSize = 2;\n            arrLength /= 2;\n            valLength /= 2;\n            byteOffset /= 2;\n          }\n        }\n        function read(buf, i2) {\n          if (indexSize === 1) {\n            return buf[i2];\n          } else {\n            return buf.readUInt16BE(i2 * indexSize);\n          }\n        }\n        let i;\n        if (dir) {\n          let foundIndex = -1;\n          for (i = byteOffset; i < arrLength; i++) {\n            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n              if (foundIndex === -1)\n                foundIndex = i;\n              if (i - foundIndex + 1 === valLength)\n                return foundIndex * indexSize;\n            } else {\n              if (foundIndex !== -1)\n                i -= i - foundIndex;\n              foundIndex = -1;\n            }\n          }\n        } else {\n          if (byteOffset + valLength > arrLength)\n            byteOffset = arrLength - valLength;\n          for (i = byteOffset; i >= 0; i--) {\n            let found = true;\n            for (let j = 0; j < valLength; j++) {\n              if (read(arr, i + j) !== read(val, j)) {\n                found = false;\n                break;\n              }\n            }\n            if (found)\n              return i;\n          }\n        }\n        return -1;\n      }\n      Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {\n        return this.indexOf(val, byteOffset, encoding) !== -1;\n      };\n      Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n      };\n      Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n      };\n      function hexWrite(buf, string, offset, length) {\n        offset = Number(offset) || 0;\n        const remaining = buf.length - offset;\n        if (!length) {\n          length = remaining;\n        } else {\n          length = Number(length);\n          if (length > remaining) {\n            length = remaining;\n          }\n        }\n        const strLen = string.length;\n        if (length > strLen / 2) {\n          length = strLen / 2;\n        }\n        let i;\n        for (i = 0; i < length; ++i) {\n          const parsed = parseInt(string.substr(i * 2, 2), 16);\n          if (numberIsNaN(parsed))\n            return i;\n          buf[offset + i] = parsed;\n        }\n        return i;\n      }\n      function utf8Write(buf, string, offset, length) {\n        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n      }\n      function asciiWrite(buf, string, offset, length) {\n        return blitBuffer(asciiToBytes(string), buf, offset, length);\n      }\n      function base64Write(buf, string, offset, length) {\n        return blitBuffer(base64ToBytes(string), buf, offset, length);\n      }\n      function ucs2Write(buf, string, offset, length) {\n        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n      }\n      Buffer2.prototype.write = function write(string, offset, length, encoding) {\n        if (offset === void 0) {\n          encoding = \"utf8\";\n          length = this.length;\n          offset = 0;\n        } else if (length === void 0 && typeof offset === \"string\") {\n          encoding = offset;\n          length = this.length;\n          offset = 0;\n        } else if (isFinite(offset)) {\n          offset = offset >>> 0;\n          if (isFinite(length)) {\n            length = length >>> 0;\n            if (encoding === void 0)\n              encoding = \"utf8\";\n          } else {\n            encoding = length;\n            length = void 0;\n          }\n        } else {\n          throw new Error(\n            \"Buffer.write(string, encoding, offset[, length]) is no longer supported\"\n          );\n        }\n        const remaining = this.length - offset;\n        if (length === void 0 || length > remaining)\n          length = remaining;\n        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n          throw new RangeError(\"Attempt to write outside buffer bounds\");\n        }\n        if (!encoding)\n          encoding = \"utf8\";\n        let loweredCase = false;\n        for (; ; ) {\n          switch (encoding) {\n            case \"hex\":\n              return hexWrite(this, string, offset, length);\n            case \"utf8\":\n            case \"utf-8\":\n              return utf8Write(this, string, offset, length);\n            case \"ascii\":\n            case \"latin1\":\n            case \"binary\":\n              return asciiWrite(this, string, offset, length);\n            case \"base64\":\n              return base64Write(this, string, offset, length);\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n              return ucs2Write(this, string, offset, length);\n            default:\n              if (loweredCase)\n                throw new TypeError(\"Unknown encoding: \" + encoding);\n              encoding = (\"\" + encoding).toLowerCase();\n              loweredCase = true;\n          }\n        }\n      };\n      Buffer2.prototype.toJSON = function toJSON() {\n        return {\n          type: \"Buffer\",\n          data: Array.prototype.slice.call(this._arr || this, 0)\n        };\n      };\n      function base64Slice(buf, start, end) {\n        if (start === 0 && end === buf.length) {\n          return base64.fromByteArray(buf);\n        } else {\n          return base64.fromByteArray(buf.slice(start, end));\n        }\n      }\n      function utf8Slice(buf, start, end) {\n        end = Math.min(buf.length, end);\n        const res = [];\n        let i = start;\n        while (i < end) {\n          const firstByte = buf[i];\n          let codePoint = null;\n          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;\n          if (i + bytesPerSequence <= end) {\n            let secondByte, thirdByte, fourthByte, tempCodePoint;\n            switch (bytesPerSequence) {\n              case 1:\n                if (firstByte < 128) {\n                  codePoint = firstByte;\n                }\n                break;\n              case 2:\n                secondByte = buf[i + 1];\n                if ((secondByte & 192) === 128) {\n                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;\n                  if (tempCodePoint > 127) {\n                    codePoint = tempCodePoint;\n                  }\n                }\n                break;\n              case 3:\n                secondByte = buf[i + 1];\n                thirdByte = buf[i + 2];\n                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {\n                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;\n                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {\n                    codePoint = tempCodePoint;\n                  }\n                }\n                break;\n              case 4:\n                secondByte = buf[i + 1];\n                thirdByte = buf[i + 2];\n                fourthByte = buf[i + 3];\n                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {\n                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;\n                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {\n                    codePoint = tempCodePoint;\n                  }\n                }\n            }\n          }\n          if (codePoint === null) {\n            codePoint = 65533;\n            bytesPerSequence = 1;\n          } else if (codePoint > 65535) {\n            codePoint -= 65536;\n            res.push(codePoint >>> 10 & 1023 | 55296);\n            codePoint = 56320 | codePoint & 1023;\n          }\n          res.push(codePoint);\n          i += bytesPerSequence;\n        }\n        return decodeCodePointsArray(res);\n      }\n      var MAX_ARGUMENTS_LENGTH = 4096;\n      function decodeCodePointsArray(codePoints) {\n        const len = codePoints.length;\n        if (len <= MAX_ARGUMENTS_LENGTH) {\n          return String.fromCharCode.apply(String, codePoints);\n        }\n        let res = \"\";\n        let i = 0;\n        while (i < len) {\n          res += String.fromCharCode.apply(\n            String,\n            codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n          );\n        }\n        return res;\n      }\n      function asciiSlice(buf, start, end) {\n        let ret = \"\";\n        end = Math.min(buf.length, end);\n        for (let i = start; i < end; ++i) {\n          ret += String.fromCharCode(buf[i] & 127);\n        }\n        return ret;\n      }\n      function latin1Slice(buf, start, end) {\n        let ret = \"\";\n        end = Math.min(buf.length, end);\n        for (let i = start; i < end; ++i) {\n          ret += String.fromCharCode(buf[i]);\n        }\n        return ret;\n      }\n      function hexSlice(buf, start, end) {\n        const len = buf.length;\n        if (!start || start < 0)\n          start = 0;\n        if (!end || end < 0 || end > len)\n          end = len;\n        let out = \"\";\n        for (let i = start; i < end; ++i) {\n          out += hexSliceLookupTable[buf[i]];\n        }\n        return out;\n      }\n      function utf16leSlice(buf, start, end) {\n        const bytes = buf.slice(start, end);\n        let res = \"\";\n        for (let i = 0; i < bytes.length - 1; i += 2) {\n          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n        }\n        return res;\n      }\n      Buffer2.prototype.slice = function slice(start, end) {\n        const len = this.length;\n        start = ~~start;\n        end = end === void 0 ? len : ~~end;\n        if (start < 0) {\n          start += len;\n          if (start < 0)\n            start = 0;\n        } else if (start > len) {\n          start = len;\n        }\n        if (end < 0) {\n          end += len;\n          if (end < 0)\n            end = 0;\n        } else if (end > len) {\n          end = len;\n        }\n        if (end < start)\n          end = start;\n        const newBuf = this.subarray(start, end);\n        Object.setPrototypeOf(newBuf, Buffer2.prototype);\n        return newBuf;\n      };\n      function checkOffset(offset, ext, length) {\n        if (offset % 1 !== 0 || offset < 0)\n          throw new RangeError(\"offset is not uint\");\n        if (offset + ext > length)\n          throw new RangeError(\"Trying to access beyond buffer length\");\n      }\n      Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert)\n          checkOffset(offset, byteLength2, this.length);\n        let val = this[offset];\n        let mul = 1;\n        let i = 0;\n        while (++i < byteLength2 && (mul *= 256)) {\n          val += this[offset + i] * mul;\n        }\n        return val;\n      };\n      Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert) {\n          checkOffset(offset, byteLength2, this.length);\n        }\n        let val = this[offset + --byteLength2];\n        let mul = 1;\n        while (byteLength2 > 0 && (mul *= 256)) {\n          val += this[offset + --byteLength2] * mul;\n        }\n        return val;\n      };\n      Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 1, this.length);\n        return this[offset];\n      };\n      Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 2, this.length);\n        return this[offset] | this[offset + 1] << 8;\n      };\n      Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 2, this.length);\n        return this[offset] << 8 | this[offset + 1];\n      };\n      Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;\n      };\n      Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n      };\n      Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {\n        offset = offset >>> 0;\n        validateNumber(offset, \"offset\");\n        const first = this[offset];\n        const last = this[offset + 7];\n        if (first === void 0 || last === void 0) {\n          boundsError(offset, this.length - 8);\n        }\n        const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;\n        const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;\n        return BigInt(lo) + (BigInt(hi) << BigInt(32));\n      });\n      Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {\n        offset = offset >>> 0;\n        validateNumber(offset, \"offset\");\n        const first = this[offset];\n        const last = this[offset + 7];\n        if (first === void 0 || last === void 0) {\n          boundsError(offset, this.length - 8);\n        }\n        const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];\n        const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;\n        return (BigInt(hi) << BigInt(32)) + BigInt(lo);\n      });\n      Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert)\n          checkOffset(offset, byteLength2, this.length);\n        let val = this[offset];\n        let mul = 1;\n        let i = 0;\n        while (++i < byteLength2 && (mul *= 256)) {\n          val += this[offset + i] * mul;\n        }\n        mul *= 128;\n        if (val >= mul)\n          val -= Math.pow(2, 8 * byteLength2);\n        return val;\n      };\n      Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert)\n          checkOffset(offset, byteLength2, this.length);\n        let i = byteLength2;\n        let mul = 1;\n        let val = this[offset + --i];\n        while (i > 0 && (mul *= 256)) {\n          val += this[offset + --i] * mul;\n        }\n        mul *= 128;\n        if (val >= mul)\n          val -= Math.pow(2, 8 * byteLength2);\n        return val;\n      };\n      Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 1, this.length);\n        if (!(this[offset] & 128))\n          return this[offset];\n        return (255 - this[offset] + 1) * -1;\n      };\n      Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 2, this.length);\n        const val = this[offset] | this[offset + 1] << 8;\n        return val & 32768 ? val | 4294901760 : val;\n      };\n      Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 2, this.length);\n        const val = this[offset + 1] | this[offset] << 8;\n        return val & 32768 ? val | 4294901760 : val;\n      };\n      Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n      };\n      Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n      };\n      Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {\n        offset = offset >>> 0;\n        validateNumber(offset, \"offset\");\n        const first = this[offset];\n        const last = this[offset + 7];\n        if (first === void 0 || last === void 0) {\n          boundsError(offset, this.length - 8);\n        }\n        const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);\n        return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);\n      });\n      Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {\n        offset = offset >>> 0;\n        validateNumber(offset, \"offset\");\n        const first = this[offset];\n        const last = this[offset + 7];\n        if (first === void 0 || last === void 0) {\n          boundsError(offset, this.length - 8);\n        }\n        const val = (first << 24) + // Overflow\n        this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];\n        return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);\n      });\n      Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return ieee754.read(this, offset, true, 23, 4);\n      };\n      Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return ieee754.read(this, offset, false, 23, 4);\n      };\n      Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 8, this.length);\n        return ieee754.read(this, offset, true, 52, 8);\n      };\n      Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 8, this.length);\n        return ieee754.read(this, offset, false, 52, 8);\n      };\n      function checkInt(buf, value, offset, ext, max, min) {\n        if (!Buffer2.isBuffer(buf))\n          throw new TypeError('\"buffer\" argument must be a Buffer instance');\n        if (value > max || value < min)\n          throw new RangeError('\"value\" argument is out of bounds');\n        if (offset + ext > buf.length)\n          throw new RangeError(\"Index out of range\");\n      }\n      Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert) {\n          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;\n          checkInt(this, value, offset, byteLength2, maxBytes, 0);\n        }\n        let mul = 1;\n        let i = 0;\n        this[offset] = value & 255;\n        while (++i < byteLength2 && (mul *= 256)) {\n          this[offset + i] = value / mul & 255;\n        }\n        return offset + byteLength2;\n      };\n      Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert) {\n          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;\n          checkInt(this, value, offset, byteLength2, maxBytes, 0);\n        }\n        let i = byteLength2 - 1;\n        let mul = 1;\n        this[offset + i] = value & 255;\n        while (--i >= 0 && (mul *= 256)) {\n          this[offset + i] = value / mul & 255;\n        }\n        return offset + byteLength2;\n      };\n      Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 1, 255, 0);\n        this[offset] = value & 255;\n        return offset + 1;\n      };\n      Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 2, 65535, 0);\n        this[offset] = value & 255;\n        this[offset + 1] = value >>> 8;\n        return offset + 2;\n      };\n      Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 2, 65535, 0);\n        this[offset] = value >>> 8;\n        this[offset + 1] = value & 255;\n        return offset + 2;\n      };\n      Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 4, 4294967295, 0);\n        this[offset + 3] = value >>> 24;\n        this[offset + 2] = value >>> 16;\n        this[offset + 1] = value >>> 8;\n        this[offset] = value & 255;\n        return offset + 4;\n      };\n      Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 4, 4294967295, 0);\n        this[offset] = value >>> 24;\n        this[offset + 1] = value >>> 16;\n        this[offset + 2] = value >>> 8;\n        this[offset + 3] = value & 255;\n        return offset + 4;\n      };\n      function wrtBigUInt64LE(buf, value, offset, min, max) {\n        checkIntBI(value, min, max, buf, offset, 7);\n        let lo = Number(value & BigInt(4294967295));\n        buf[offset++] = lo;\n        lo = lo >> 8;\n        buf[offset++] = lo;\n        lo = lo >> 8;\n        buf[offset++] = lo;\n        lo = lo >> 8;\n        buf[offset++] = lo;\n        let hi = Number(value >> BigInt(32) & BigInt(4294967295));\n        buf[offset++] = hi;\n        hi = hi >> 8;\n        buf[offset++] = hi;\n        hi = hi >> 8;\n        buf[offset++] = hi;\n        hi = hi >> 8;\n        buf[offset++] = hi;\n        return offset;\n      }\n      function wrtBigUInt64BE(buf, value, offset, min, max) {\n        checkIntBI(value, min, max, buf, offset, 7);\n        let lo = Number(value & BigInt(4294967295));\n        buf[offset + 7] = lo;\n        lo = lo >> 8;\n        buf[offset + 6] = lo;\n        lo = lo >> 8;\n        buf[offset + 5] = lo;\n        lo = lo >> 8;\n        buf[offset + 4] = lo;\n        let hi = Number(value >> BigInt(32) & BigInt(4294967295));\n        buf[offset + 3] = hi;\n        hi = hi >> 8;\n        buf[offset + 2] = hi;\n        hi = hi >> 8;\n        buf[offset + 1] = hi;\n        hi = hi >> 8;\n        buf[offset] = hi;\n        return offset + 8;\n      }\n      Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {\n        return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n      });\n      Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {\n        return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n      });\n      Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          const limit = Math.pow(2, 8 * byteLength2 - 1);\n          checkInt(this, value, offset, byteLength2, limit - 1, -limit);\n        }\n        let i = 0;\n        let mul = 1;\n        let sub = 0;\n        this[offset] = value & 255;\n        while (++i < byteLength2 && (mul *= 256)) {\n          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n            sub = 1;\n          }\n          this[offset + i] = (value / mul >> 0) - sub & 255;\n        }\n        return offset + byteLength2;\n      };\n      Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          const limit = Math.pow(2, 8 * byteLength2 - 1);\n          checkInt(this, value, offset, byteLength2, limit - 1, -limit);\n        }\n        let i = byteLength2 - 1;\n        let mul = 1;\n        let sub = 0;\n        this[offset + i] = value & 255;\n        while (--i >= 0 && (mul *= 256)) {\n          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n            sub = 1;\n          }\n          this[offset + i] = (value / mul >> 0) - sub & 255;\n        }\n        return offset + byteLength2;\n      };\n      Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 1, 127, -128);\n        if (value < 0)\n          value = 255 + value + 1;\n        this[offset] = value & 255;\n        return offset + 1;\n      };\n      Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 2, 32767, -32768);\n        this[offset] = value & 255;\n        this[offset + 1] = value >>> 8;\n        return offset + 2;\n      };\n      Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 2, 32767, -32768);\n        this[offset] = value >>> 8;\n        this[offset + 1] = value & 255;\n        return offset + 2;\n      };\n      Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 4, 2147483647, -2147483648);\n        this[offset] = value & 255;\n        this[offset + 1] = value >>> 8;\n        this[offset + 2] = value >>> 16;\n        this[offset + 3] = value >>> 24;\n        return offset + 4;\n      };\n      Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 4, 2147483647, -2147483648);\n        if (value < 0)\n          value = 4294967295 + value + 1;\n        this[offset] = value >>> 24;\n        this[offset + 1] = value >>> 16;\n        this[offset + 2] = value >>> 8;\n        this[offset + 3] = value & 255;\n        return offset + 4;\n      };\n      Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {\n        return wrtBigUInt64LE(this, value, offset, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n      });\n      Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {\n        return wrtBigUInt64BE(this, value, offset, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n      });\n      function checkIEEE754(buf, value, offset, ext, max, min) {\n        if (offset + ext > buf.length)\n          throw new RangeError(\"Index out of range\");\n        if (offset < 0)\n          throw new RangeError(\"Index out of range\");\n      }\n      function writeFloat(buf, value, offset, littleEndian, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);\n        }\n        ieee754.write(buf, value, offset, littleEndian, 23, 4);\n        return offset + 4;\n      }\n      Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n        return writeFloat(this, value, offset, true, noAssert);\n      };\n      Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n        return writeFloat(this, value, offset, false, noAssert);\n      };\n      function writeDouble(buf, value, offset, littleEndian, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);\n        }\n        ieee754.write(buf, value, offset, littleEndian, 52, 8);\n        return offset + 8;\n      }\n      Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n        return writeDouble(this, value, offset, true, noAssert);\n      };\n      Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n        return writeDouble(this, value, offset, false, noAssert);\n      };\n      Buffer2.prototype.copy = function copy(target, targetStart, start, end) {\n        if (!Buffer2.isBuffer(target))\n          throw new TypeError(\"argument should be a Buffer\");\n        if (!start)\n          start = 0;\n        if (!end && end !== 0)\n          end = this.length;\n        if (targetStart >= target.length)\n          targetStart = target.length;\n        if (!targetStart)\n          targetStart = 0;\n        if (end > 0 && end < start)\n          end = start;\n        if (end === start)\n          return 0;\n        if (target.length === 0 || this.length === 0)\n          return 0;\n        if (targetStart < 0) {\n          throw new RangeError(\"targetStart out of bounds\");\n        }\n        if (start < 0 || start >= this.length)\n          throw new RangeError(\"Index out of range\");\n        if (end < 0)\n          throw new RangeError(\"sourceEnd out of bounds\");\n        if (end > this.length)\n          end = this.length;\n        if (target.length - targetStart < end - start) {\n          end = target.length - targetStart + start;\n        }\n        const len = end - start;\n        if (this === target && typeof GlobalUint8Array.prototype.copyWithin === \"function\") {\n          this.copyWithin(targetStart, start, end);\n        } else {\n          GlobalUint8Array.prototype.set.call(\n            target,\n            this.subarray(start, end),\n            targetStart\n          );\n        }\n        return len;\n      };\n      Buffer2.prototype.fill = function fill(val, start, end, encoding) {\n        if (typeof val === \"string\") {\n          if (typeof start === \"string\") {\n            encoding = start;\n            start = 0;\n            end = this.length;\n          } else if (typeof end === \"string\") {\n            encoding = end;\n            end = this.length;\n          }\n          if (encoding !== void 0 && typeof encoding !== \"string\") {\n            throw new TypeError(\"encoding must be a string\");\n          }\n          if (typeof encoding === \"string\" && !Buffer2.isEncoding(encoding)) {\n            throw new TypeError(\"Unknown encoding: \" + encoding);\n          }\n          if (val.length === 1) {\n            const code = val.charCodeAt(0);\n            if (encoding === \"utf8\" && code < 128 || encoding === \"latin1\") {\n              val = code;\n            }\n          }\n        } else if (typeof val === \"number\") {\n          val = val & 255;\n        } else if (typeof val === \"boolean\") {\n          val = Number(val);\n        }\n        if (start < 0 || this.length < start || this.length < end) {\n          throw new RangeError(\"Out of range index\");\n        }\n        if (end <= start) {\n          return this;\n        }\n        start = start >>> 0;\n        end = end === void 0 ? this.length : end >>> 0;\n        if (!val)\n          val = 0;\n        let i;\n        if (typeof val === \"number\") {\n          for (i = start; i < end; ++i) {\n            this[i] = val;\n          }\n        } else {\n          const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);\n          const len = bytes.length;\n          if (len === 0) {\n            throw new TypeError('The value \"' + val + '\" is invalid for argument \"value\"');\n          }\n          for (i = 0; i < end - start; ++i) {\n            this[i + start] = bytes[i % len];\n          }\n        }\n        return this;\n      };\n      var errors = {};\n      function E(sym, getMessage, Base) {\n        errors[sym] = class NodeError extends Base {\n          constructor() {\n            super();\n            Object.defineProperty(this, \"message\", {\n              value: getMessage.apply(this, arguments),\n              writable: true,\n              configurable: true\n            });\n            this.name = `${this.name} [${sym}]`;\n            this.stack;\n            delete this.name;\n          }\n          get code() {\n            return sym;\n          }\n          set code(value) {\n            Object.defineProperty(this, \"code\", {\n              configurable: true,\n              enumerable: true,\n              value,\n              writable: true\n            });\n          }\n          toString() {\n            return `${this.name} [${sym}]: ${this.message}`;\n          }\n        };\n      }\n      E(\n        \"ERR_BUFFER_OUT_OF_BOUNDS\",\n        function(name) {\n          if (name) {\n            return `${name} is outside of buffer bounds`;\n          }\n          return \"Attempt to access memory outside buffer bounds\";\n        },\n        RangeError\n      );\n      E(\n        \"ERR_INVALID_ARG_TYPE\",\n        function(name, actual) {\n          return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`;\n        },\n        TypeError\n      );\n      E(\n        \"ERR_OUT_OF_RANGE\",\n        function(str, range, input) {\n          let msg = `The value of \"${str}\" is out of range.`;\n          let received = input;\n          if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n            received = addNumericalSeparator(String(input));\n          } else if (typeof input === \"bigint\") {\n            received = String(input);\n            if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n              received = addNumericalSeparator(received);\n            }\n            received += \"n\";\n          }\n          msg += ` It must be ${range}. Received ${received}`;\n          return msg;\n        },\n        RangeError\n      );\n      function addNumericalSeparator(val) {\n        let res = \"\";\n        let i = val.length;\n        const start = val[0] === \"-\" ? 1 : 0;\n        for (; i >= start + 4; i -= 3) {\n          res = `_${val.slice(i - 3, i)}${res}`;\n        }\n        return `${val.slice(0, i)}${res}`;\n      }\n      function checkBounds(buf, offset, byteLength2) {\n        validateNumber(offset, \"offset\");\n        if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {\n          boundsError(offset, buf.length - (byteLength2 + 1));\n        }\n      }\n      function checkIntBI(value, min, max, buf, offset, byteLength2) {\n        if (value > max || value < min) {\n          const n = typeof min === \"bigint\" ? \"n\" : \"\";\n          let range;\n          if (byteLength2 > 3) {\n            if (min === 0 || min === BigInt(0)) {\n              range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;\n            } else {\n              range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;\n            }\n          } else {\n            range = `>= ${min}${n} and <= ${max}${n}`;\n          }\n          throw new errors.ERR_OUT_OF_RANGE(\"value\", range, value);\n        }\n        checkBounds(buf, offset, byteLength2);\n      }\n      function validateNumber(value, name) {\n        if (typeof value !== \"number\") {\n          throw new errors.ERR_INVALID_ARG_TYPE(name, \"number\", value);\n        }\n      }\n      function boundsError(value, length, type) {\n        if (Math.floor(value) !== value) {\n          validateNumber(value, type);\n          throw new errors.ERR_OUT_OF_RANGE(type || \"offset\", \"an integer\", value);\n        }\n        if (length < 0) {\n          throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();\n        }\n        throw new errors.ERR_OUT_OF_RANGE(\n          type || \"offset\",\n          `>= ${type ? 1 : 0} and <= ${length}`,\n          value\n        );\n      }\n      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;\n      function base64clean(str) {\n        str = str.split(\"=\")[0];\n        str = str.trim().replace(INVALID_BASE64_RE, \"\");\n        if (str.length < 2)\n          return \"\";\n        while (str.length % 4 !== 0) {\n          str = str + \"=\";\n        }\n        return str;\n      }\n      function utf8ToBytes(string, units) {\n        units = units || Infinity;\n        let codePoint;\n        const length = string.length;\n        let leadSurrogate = null;\n        const bytes = [];\n        for (let i = 0; i < length; ++i) {\n          codePoint = string.charCodeAt(i);\n          if (codePoint > 55295 && codePoint < 57344) {\n            if (!leadSurrogate) {\n              if (codePoint > 56319) {\n                if ((units -= 3) > -1)\n                  bytes.push(239, 191, 189);\n                continue;\n              } else if (i + 1 === length) {\n                if ((units -= 3) > -1)\n                  bytes.push(239, 191, 189);\n                continue;\n              }\n              leadSurrogate = codePoint;\n              continue;\n            }\n            if (codePoint < 56320) {\n              if ((units -= 3) > -1)\n                bytes.push(239, 191, 189);\n              leadSurrogate = codePoint;\n              continue;\n            }\n            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;\n          } else if (leadSurrogate) {\n            if ((units -= 3) > -1)\n              bytes.push(239, 191, 189);\n          }\n          leadSurrogate = null;\n          if (codePoint < 128) {\n            if ((units -= 1) < 0)\n              break;\n            bytes.push(codePoint);\n          } else if (codePoint < 2048) {\n            if ((units -= 2) < 0)\n              break;\n            bytes.push(\n              codePoint >> 6 | 192,\n              codePoint & 63 | 128\n            );\n          } else if (codePoint < 65536) {\n            if ((units -= 3) < 0)\n              break;\n            bytes.push(\n              codePoint >> 12 | 224,\n              codePoint >> 6 & 63 | 128,\n              codePoint & 63 | 128\n            );\n          } else if (codePoint < 1114112) {\n            if ((units -= 4) < 0)\n              break;\n            bytes.push(\n              codePoint >> 18 | 240,\n              codePoint >> 12 & 63 | 128,\n              codePoint >> 6 & 63 | 128,\n              codePoint & 63 | 128\n            );\n          } else {\n            throw new Error(\"Invalid code point\");\n          }\n        }\n        return bytes;\n      }\n      function asciiToBytes(str) {\n        const byteArray = [];\n        for (let i = 0; i < str.length; ++i) {\n          byteArray.push(str.charCodeAt(i) & 255);\n        }\n        return byteArray;\n      }\n      function utf16leToBytes(str, units) {\n        let c, hi, lo;\n        const byteArray = [];\n        for (let i = 0; i < str.length; ++i) {\n          if ((units -= 2) < 0)\n            break;\n          c = str.charCodeAt(i);\n          hi = c >> 8;\n          lo = c % 256;\n          byteArray.push(lo);\n          byteArray.push(hi);\n        }\n        return byteArray;\n      }\n      function base64ToBytes(str) {\n        return base64.toByteArray(base64clean(str));\n      }\n      function blitBuffer(src, dst, offset, length) {\n        let i;\n        for (i = 0; i < length; ++i) {\n          if (i + offset >= dst.length || i >= src.length)\n            break;\n          dst[i + offset] = src[i];\n        }\n        return i;\n      }\n      function isInstance(obj, type) {\n        return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;\n      }\n      function numberIsNaN(obj) {\n        return obj !== obj;\n      }\n      var hexSliceLookupTable = function() {\n        const alphabet = \"0123456789abcdef\";\n        const table = new Array(256);\n        for (let i = 0; i < 16; ++i) {\n          const i16 = i * 16;\n          for (let j = 0; j < 16; ++j) {\n            table[i16 + j] = alphabet[i] + alphabet[j];\n          }\n        }\n        return table;\n      }();\n      function defineBigIntMethod(fn) {\n        return typeof BigInt === \"undefined\" ? BufferBigIntNotDefined : fn;\n      }\n      function BufferBigIntNotDefined() {\n        throw new Error(\"BigInt not supported\");\n      }\n    }\n  });\n\n  // node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js\n  var require_browser = __commonJS({\n    \"node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js\"(exports, module) {\n      init_dist();\n      var process = module.exports = {};\n      var cachedSetTimeout;\n      var cachedClearTimeout;\n      function defaultSetTimout() {\n        throw new Error(\"setTimeout has not been defined\");\n      }\n      function defaultClearTimeout() {\n        throw new Error(\"clearTimeout has not been defined\");\n      }\n      (function() {\n        try {\n          if (typeof setTimeout === \"function\") {\n            cachedSetTimeout = setTimeout;\n          } else {\n            cachedSetTimeout = defaultSetTimout;\n          }\n        } catch (e) {\n          cachedSetTimeout = defaultSetTimout;\n        }\n        try {\n          if (typeof clearTimeout === \"function\") {\n            cachedClearTimeout = clearTimeout;\n          } else {\n            cachedClearTimeout = defaultClearTimeout;\n          }\n        } catch (e) {\n          cachedClearTimeout = defaultClearTimeout;\n        }\n      })();\n      function runTimeout(fun) {\n        if (cachedSetTimeout === setTimeout) {\n          return setTimeout(fun, 0);\n        }\n        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n          cachedSetTimeout = setTimeout;\n          return setTimeout(fun, 0);\n        }\n        try {\n          return cachedSetTimeout(fun, 0);\n        } catch (e) {\n          try {\n            return cachedSetTimeout.call(null, fun, 0);\n          } catch (e2) {\n            return cachedSetTimeout.call(this, fun, 0);\n          }\n        }\n      }\n      function runClearTimeout(marker) {\n        if (cachedClearTimeout === clearTimeout) {\n          return clearTimeout(marker);\n        }\n        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n          cachedClearTimeout = clearTimeout;\n          return clearTimeout(marker);\n        }\n        try {\n          return cachedClearTimeout(marker);\n        } catch (e) {\n          try {\n            return cachedClearTimeout.call(null, marker);\n          } catch (e2) {\n            return cachedClearTimeout.call(this, marker);\n          }\n        }\n      }\n      var queue = [];\n      var draining = false;\n      var currentQueue;\n      var queueIndex = -1;\n      function cleanUpNextTick() {\n        if (!draining || !currentQueue) {\n          return;\n        }\n        draining = false;\n        if (currentQueue.length) {\n          queue = currentQueue.concat(queue);\n        } else {\n          queueIndex = -1;\n        }\n        if (queue.length) {\n          drainQueue();\n        }\n      }\n      function drainQueue() {\n        if (draining) {\n          return;\n        }\n        var timeout = runTimeout(cleanUpNextTick);\n        draining = true;\n        var len = queue.length;\n        while (len) {\n          currentQueue = queue;\n          queue = [];\n          while (++queueIndex < len) {\n            if (currentQueue) {\n              currentQueue[queueIndex].run();\n            }\n          }\n          queueIndex = -1;\n          len = queue.length;\n        }\n        currentQueue = null;\n        draining = false;\n        runClearTimeout(timeout);\n      }\n      process.nextTick = function(fun) {\n        var args = new Array(arguments.length - 1);\n        if (arguments.length > 1) {\n          for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n          }\n        }\n        queue.push(new Item(fun, args));\n        if (queue.length === 1 && !draining) {\n          runTimeout(drainQueue);\n        }\n      };\n      function Item(fun, array) {\n        this.fun = fun;\n        this.array = array;\n      }\n      Item.prototype.run = function() {\n        this.fun.apply(null, this.array);\n      };\n      process.title = \"browser\";\n      process.browser = true;\n      process.env = {};\n      process.argv = [];\n      process.version = \"\";\n      process.versions = {};\n      function noop() {\n      }\n      process.on = noop;\n      process.addListener = noop;\n      process.once = noop;\n      process.off = noop;\n      process.removeListener = noop;\n      process.removeAllListeners = noop;\n      process.emit = noop;\n      process.prependListener = noop;\n      process.prependOnceListener = noop;\n      process.listeners = function(name) {\n        return [];\n      };\n      process.binding = function(name) {\n        throw new Error(\"process.binding is not supported\");\n      };\n      process.cwd = function() {\n        return \"/\";\n      };\n      process.chdir = function(dir) {\n        throw new Error(\"process.chdir is not supported\");\n      };\n      process.umask = function() {\n        return 0;\n      };\n    }\n  });\n\n  // shims/dist/index.js\n  var import_buffer_polyfill, import_process, o;\n  var init_dist = __esm({\n    \"shims/dist/index.js\"() {\n      \"use strict\";\n      import_buffer_polyfill = __toESM(require_buffer(), 1);\n      import_process = __toESM(require_browser(), 1);\n      o = globalThis || void 0 || self;\n    }\n  });\n\n  // shims/banner/index.cjs\n  var require_banner = __commonJS({\n    \"shims/banner/index.cjs\"() {\n      init_dist();\n      globalThis.Buffer = globalThis.Buffer || import_buffer_polyfill.Buffer;\n      globalThis.global = globalThis.global || o;\n      globalThis.process = globalThis.process || import_process.default;\n    }\n  });\n  require_banner();\n})();\n/*! Bundled license information:\n\nieee754/index.js:\n  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)\n\nbuffer/index.js:\n  (*!\n   * The buffer module from node.js, for the browser.\n   *\n   * @author   Feross Aboukhadijeh <https://feross.org>\n   * @license  MIT\n   *)\n*/\n\nimport {\n  require_crypto_browserify\n} from \"/node_modules/.vite/deps/chunk-OYHNC6W5.js?v=733ce8d4\";\nimport {\n  __commonJS,\n  __esm,\n  __export,\n  __require,\n  __toCommonJS,\n  __toESM,\n  require_buffer_polyfill,\n  require_dist\n} from \"/node_modules/.vite/deps/chunk-VMXIV7NB.js?v=733ce8d4\";\n\n// node_modules/@aws-crypto/sha256-js/node_modules/tslib/tslib.es6.js\nvar tslib_es6_exports = {};\n__export(tslib_es6_exports, {\n  __assign: () => __assign,\n  __asyncDelegator: () => __asyncDelegator,\n  __asyncGenerator: () => __asyncGenerator,\n  __asyncValues: () => __asyncValues,\n  __await: () => __await,\n  __awaiter: () => __awaiter,\n  __classPrivateFieldGet: () => __classPrivateFieldGet,\n  __classPrivateFieldSet: () => __classPrivateFieldSet,\n  __createBinding: () => __createBinding,\n  __decorate: () => __decorate,\n  __exportStar: () => __exportStar,\n  __extends: () => __extends,\n  __generator: () => __generator,\n  __importDefault: () => __importDefault,\n  __importStar: () => __importStar,\n  __makeTemplateObject: () => __makeTemplateObject,\n  __metadata: () => __metadata,\n  __param: () => __param,\n  __read: () => __read,\n  __rest: () => __rest,\n  __spread: () => __spread,\n  __spreadArrays: () => __spreadArrays,\n  __values: () => __values\n});\nfunction __extends(d, b) {\n  extendStatics(d, b);\n  function __() {\n    this.constructor = d;\n  }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nfunction __rest(s, e) {\n  var t = {};\n  for (var p in s)\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n        t[p[i]] = s[p[i]];\n    }\n  return t;\n}\nfunction __decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n    r = Reflect.decorate(decorators, target, key, desc);\n  else\n    for (var i = decorators.length - 1; i >= 0; i--)\n      if (d = decorators[i])\n        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\nfunction __param(paramIndex, decorator) {\n  return function(target, key) {\n    decorator(target, key, paramIndex);\n  };\n}\nfunction __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\")\n    return Reflect.metadata(metadataKey, metadataValue);\n}\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function(resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function(resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\nfunction __generator(thisArg, body) {\n  var _ = { label: 0, sent: function() {\n    if (t[0] & 1)\n      throw t[1];\n    return t[1];\n  }, trys: [], ops: [] }, f, y, t, g;\n  return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n    return this;\n  }), g;\n  function verb(n) {\n    return function(v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f)\n      throw new TypeError(\"Generator is already executing.\");\n    while (_)\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n          return t;\n        if (y = 0, t)\n          op = [op[0] & 2, t.value];\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n          case 4:\n            _.label++;\n            return { value: op[1], done: false };\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n          case 7:\n            op = _.ops.pop();\n            _.trys.pop();\n            continue;\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n              _.ops.push(op);\n              break;\n            }\n            if (t[2])\n              _.ops.pop();\n            _.trys.pop();\n            continue;\n        }\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    if (op[0] & 5)\n      throw op[1];\n    return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\nfunction __createBinding(o, m, k, k2) {\n  if (k2 === void 0)\n    k2 = k;\n  o[k2] = m[k];\n}\nfunction __exportStar(m, exports) {\n  for (var p in m)\n    if (p !== \"default\" && !exports.hasOwnProperty(p))\n      exports[p] = m[p];\n}\nfunction __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m)\n    return m.call(o);\n  if (o && typeof o.length === \"number\")\n    return {\n      next: function() {\n        if (o && i >= o.length)\n          o = void 0;\n        return { value: o && o[i++], done: !o };\n      }\n    };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nfunction __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m)\n    return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)\n      ar.push(r.value);\n  } catch (error) {\n    e = { error };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"]))\n        m.call(i);\n    } finally {\n      if (e)\n        throw e.error;\n    }\n  }\n  return ar;\n}\nfunction __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n    ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\nfunction __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++)\n    s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++)\n    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n      r[k] = a[j];\n  return r;\n}\nfunction __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\nfunction __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator)\n    throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n    return this;\n  }, i;\n  function verb(n) {\n    if (g[n])\n      i[n] = function(v) {\n        return new Promise(function(a, b) {\n          q.push([n, v, a, b]) > 1 || resume(n, v);\n        });\n      };\n  }\n  function resume(n, v) {\n    try {\n      step(g[n](v));\n    } catch (e) {\n      settle(q[0][3], e);\n    }\n  }\n  function step(r) {\n    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n  }\n  function fulfill(value) {\n    resume(\"next\", value);\n  }\n  function reject(value) {\n    resume(\"throw\", value);\n  }\n  function settle(f, v) {\n    if (f(v), q.shift(), q.length)\n      resume(q[0][0], q[0][1]);\n  }\n}\nfunction __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function(e) {\n    throw e;\n  }), verb(\"return\"), i[Symbol.iterator] = function() {\n    return this;\n  }, i;\n  function verb(n, f) {\n    i[n] = o[n] ? function(v) {\n      return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v;\n    } : f;\n  }\n}\nfunction __asyncValues(o) {\n  if (!Symbol.asyncIterator)\n    throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n    return this;\n  }, i);\n  function verb(n) {\n    i[n] = o[n] && function(v) {\n      return new Promise(function(resolve, reject) {\n        v = o[n](v), settle(resolve, reject, v.done, v.value);\n      });\n    };\n  }\n  function settle(resolve, reject, d, v) {\n    Promise.resolve(v).then(function(v2) {\n      resolve({ value: v2, done: d });\n    }, reject);\n  }\n}\nfunction __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) {\n    Object.defineProperty(cooked, \"raw\", { value: raw });\n  } else {\n    cooked.raw = raw;\n  }\n  return cooked;\n}\nfunction __importStar(mod) {\n  if (mod && mod.__esModule)\n    return mod;\n  var result = {};\n  if (mod != null) {\n    for (var k in mod)\n      if (Object.hasOwnProperty.call(mod, k))\n        result[k] = mod[k];\n  }\n  result.default = mod;\n  return result;\n}\nfunction __importDefault(mod) {\n  return mod && mod.__esModule ? mod : { default: mod };\n}\nfunction __classPrivateFieldGet(receiver, privateMap) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to get private field on non-instance\");\n  }\n  return privateMap.get(receiver);\n}\nfunction __classPrivateFieldSet(receiver, privateMap, value) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to set private field on non-instance\");\n  }\n  privateMap.set(receiver, value);\n  return value;\n}\nvar import_dist4, extendStatics, __assign;\nvar init_tslib_es6 = __esm({\n  \"node_modules/@aws-crypto/sha256-js/node_modules/tslib/tslib.es6.js\"() {\n    import_dist4 = __toESM(require_dist());\n    extendStatics = function(d, b) {\n      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {\n        d2.__proto__ = b2;\n      } || function(d2, b2) {\n        for (var p in b2)\n          if (b2.hasOwnProperty(p))\n            d2[p] = b2[p];\n      };\n      return extendStatics(d, b);\n    };\n    __assign = function() {\n      __assign = Object.assign || function __assign2(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s)\n            if (Object.prototype.hasOwnProperty.call(s, p))\n              t[p] = s[p];\n        }\n        return t;\n      };\n      return __assign.apply(this, arguments);\n    };\n  }\n});\n\n// node_modules/@aws-crypto/sha256-js/build/constants.js\nvar require_constants = __commonJS({\n  \"node_modules/@aws-crypto/sha256-js/build/constants.js\"(exports) {\n    \"use strict\";\n    var import_dist28 = __toESM(require_dist());\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.MAX_HASHABLE_LENGTH = exports.INIT = exports.KEY = exports.DIGEST_LENGTH = exports.BLOCK_SIZE = void 0;\n    exports.BLOCK_SIZE = 64;\n    exports.DIGEST_LENGTH = 32;\n    exports.KEY = new Uint32Array([\n      1116352408,\n      1899447441,\n      3049323471,\n      3921009573,\n      961987163,\n      1508970993,\n      2453635748,\n      2870763221,\n      3624381080,\n      310598401,\n      607225278,\n      1426881987,\n      1925078388,\n      2162078206,\n      2614888103,\n      3248222580,\n      3835390401,\n      4022224774,\n      264347078,\n      604807628,\n      770255983,\n      1249150122,\n      1555081692,\n      1996064986,\n      2554220882,\n      2821834349,\n      2952996808,\n      3210313671,\n      3336571891,\n      3584528711,\n      113926993,\n      338241895,\n      666307205,\n      773529912,\n      1294757372,\n      1396182291,\n      1695183700,\n      1986661051,\n      2177026350,\n      2456956037,\n      2730485921,\n      2820302411,\n      3259730800,\n      3345764771,\n      3516065817,\n      3600352804,\n      4094571909,\n      275423344,\n      430227734,\n      506948616,\n      659060556,\n      883997877,\n      958139571,\n      1322822218,\n      1537002063,\n      1747873779,\n      1955562222,\n      2024104815,\n      2227730452,\n      2361852424,\n      2428436474,\n      2756734187,\n      3204031479,\n      3329325298\n    ]);\n    exports.INIT = [\n      1779033703,\n      3144134277,\n      1013904242,\n      2773480762,\n      1359893119,\n      2600822924,\n      528734635,\n      1541459225\n    ];\n    exports.MAX_HASHABLE_LENGTH = Math.pow(2, 53) - 1;\n  }\n});\n\n// node_modules/@aws-crypto/sha256-js/build/RawSha256.js\nvar require_RawSha256 = __commonJS({\n  \"node_modules/@aws-crypto/sha256-js/build/RawSha256.js\"(exports) {\n    \"use strict\";\n    var import_dist28 = __toESM(require_dist());\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.RawSha256 = void 0;\n    var constants_1 = require_constants();\n    var RawSha256 = (\n      /** @class */\n      function() {\n        function RawSha2562() {\n          this.state = Int32Array.from(constants_1.INIT);\n          this.temp = new Int32Array(64);\n          this.buffer = new Uint8Array(64);\n          this.bufferLength = 0;\n          this.bytesHashed = 0;\n          this.finished = false;\n        }\n        RawSha2562.prototype.update = function(data) {\n          if (this.finished) {\n            throw new Error(\"Attempted to update an already finished hash.\");\n          }\n          var position = 0;\n          var byteLength = data.byteLength;\n          this.bytesHashed += byteLength;\n          if (this.bytesHashed * 8 > constants_1.MAX_HASHABLE_LENGTH) {\n            throw new Error(\"Cannot hash more than 2^53 - 1 bits\");\n          }\n          while (byteLength > 0) {\n            this.buffer[this.bufferLength++] = data[position++];\n            byteLength--;\n            if (this.bufferLength === constants_1.BLOCK_SIZE) {\n              this.hashBuffer();\n              this.bufferLength = 0;\n            }\n          }\n        };\n        RawSha2562.prototype.digest = function() {\n          if (!this.finished) {\n            var bitsHashed = this.bytesHashed * 8;\n            var bufferView = new DataView(this.buffer.buffer, this.buffer.byteOffset, this.buffer.byteLength);\n            var undecoratedLength = this.bufferLength;\n            bufferView.setUint8(this.bufferLength++, 128);\n            if (undecoratedLength % constants_1.BLOCK_SIZE >= constants_1.BLOCK_SIZE - 8) {\n              for (var i = this.bufferLength; i < constants_1.BLOCK_SIZE; i++) {\n                bufferView.setUint8(i, 0);\n              }\n              this.hashBuffer();\n              this.bufferLength = 0;\n            }\n            for (var i = this.bufferLength; i < constants_1.BLOCK_SIZE - 8; i++) {\n              bufferView.setUint8(i, 0);\n            }\n            bufferView.setUint32(constants_1.BLOCK_SIZE - 8, Math.floor(bitsHashed / 4294967296), true);\n            bufferView.setUint32(constants_1.BLOCK_SIZE - 4, bitsHashed);\n            this.hashBuffer();\n            this.finished = true;\n          }\n          var out = new Uint8Array(constants_1.DIGEST_LENGTH);\n          for (var i = 0; i < 8; i++) {\n            out[i * 4] = this.state[i] >>> 24 & 255;\n            out[i * 4 + 1] = this.state[i] >>> 16 & 255;\n            out[i * 4 + 2] = this.state[i] >>> 8 & 255;\n            out[i * 4 + 3] = this.state[i] >>> 0 & 255;\n          }\n          return out;\n        };\n        RawSha2562.prototype.hashBuffer = function() {\n          var _a = this, buffer = _a.buffer, state = _a.state;\n          var state0 = state[0], state1 = state[1], state2 = state[2], state3 = state[3], state4 = state[4], state5 = state[5], state6 = state[6], state7 = state[7];\n          for (var i = 0; i < constants_1.BLOCK_SIZE; i++) {\n            if (i < 16) {\n              this.temp[i] = (buffer[i * 4] & 255) << 24 | (buffer[i * 4 + 1] & 255) << 16 | (buffer[i * 4 + 2] & 255) << 8 | buffer[i * 4 + 3] & 255;\n            } else {\n              var u = this.temp[i - 2];\n              var t1_1 = (u >>> 17 | u << 15) ^ (u >>> 19 | u << 13) ^ u >>> 10;\n              u = this.temp[i - 15];\n              var t2_1 = (u >>> 7 | u << 25) ^ (u >>> 18 | u << 14) ^ u >>> 3;\n              this.temp[i] = (t1_1 + this.temp[i - 7] | 0) + (t2_1 + this.temp[i - 16] | 0);\n            }\n            var t1 = (((state4 >>> 6 | state4 << 26) ^ (state4 >>> 11 | state4 << 21) ^ (state4 >>> 25 | state4 << 7)) + (state4 & state5 ^ ~state4 & state6) | 0) + (state7 + (constants_1.KEY[i] + this.temp[i] | 0) | 0) | 0;\n            var t2 = ((state0 >>> 2 | state0 << 30) ^ (state0 >>> 13 | state0 << 19) ^ (state0 >>> 22 | state0 << 10)) + (state0 & state1 ^ state0 & state2 ^ state1 & state2) | 0;\n            state7 = state6;\n            state6 = state5;\n            state5 = state4;\n            state4 = state3 + t1 | 0;\n            state3 = state2;\n            state2 = state1;\n            state1 = state0;\n            state0 = t1 + t2 | 0;\n          }\n          state[0] += state0;\n          state[1] += state1;\n          state[2] += state2;\n          state[3] += state3;\n          state[4] += state4;\n          state[5] += state5;\n          state[6] += state6;\n          state[7] += state7;\n        };\n        return RawSha2562;\n      }()\n    );\n    exports.RawSha256 = RawSha256;\n  }\n});\n\n// node_modules/@aws-sdk/util-utf8-browser/dist-es/pureJs.js\nvar import_dist5, fromUtf8, toUtf8;\nvar init_pureJs = __esm({\n  \"node_modules/@aws-sdk/util-utf8-browser/dist-es/pureJs.js\"() {\n    import_dist5 = __toESM(require_dist());\n    fromUtf8 = (input) => {\n      const bytes = [];\n      for (let i = 0, len = input.length; i < len; i++) {\n        const value = input.charCodeAt(i);\n        if (value < 128) {\n          bytes.push(value);\n        } else if (value < 2048) {\n          bytes.push(value >> 6 | 192, value & 63 | 128);\n        } else if (i + 1 < input.length && (value & 64512) === 55296 && (input.charCodeAt(i + 1) & 64512) === 56320) {\n          const surrogatePair = 65536 + ((value & 1023) << 10) + (input.charCodeAt(++i) & 1023);\n          bytes.push(surrogatePair >> 18 | 240, surrogatePair >> 12 & 63 | 128, surrogatePair >> 6 & 63 | 128, surrogatePair & 63 | 128);\n        } else {\n          bytes.push(value >> 12 | 224, value >> 6 & 63 | 128, value & 63 | 128);\n        }\n      }\n      return Uint8Array.from(bytes);\n    };\n    toUtf8 = (input) => {\n      let decoded = \"\";\n      for (let i = 0, len = input.length; i < len; i++) {\n        const byte = input[i];\n        if (byte < 128) {\n          decoded += String.fromCharCode(byte);\n        } else if (192 <= byte && byte < 224) {\n          const nextByte = input[++i];\n          decoded += String.fromCharCode((byte & 31) << 6 | nextByte & 63);\n        } else if (240 <= byte && byte < 365) {\n          const surrogatePair = [byte, input[++i], input[++i], input[++i]];\n          const encoded = \"%\" + surrogatePair.map((byteValue) => byteValue.toString(16)).join(\"%\");\n          decoded += decodeURIComponent(encoded);\n        } else {\n          decoded += String.fromCharCode((byte & 15) << 12 | (input[++i] & 63) << 6 | input[++i] & 63);\n        }\n      }\n      return decoded;\n    };\n  }\n});\n\n// node_modules/@aws-sdk/util-utf8-browser/dist-es/whatwgEncodingApi.js\nfunction fromUtf82(input) {\n  return new TextEncoder().encode(input);\n}\nfunction toUtf82(input) {\n  return new TextDecoder(\"utf-8\").decode(input);\n}\nvar import_dist6;\nvar init_whatwgEncodingApi = __esm({\n  \"node_modules/@aws-sdk/util-utf8-browser/dist-es/whatwgEncodingApi.js\"() {\n    import_dist6 = __toESM(require_dist());\n  }\n});\n\n// node_modules/@aws-sdk/util-utf8-browser/dist-es/index.js\nvar dist_es_exports = {};\n__export(dist_es_exports, {\n  fromUtf8: () => fromUtf83,\n  toUtf8: () => toUtf83\n});\nvar import_dist7, fromUtf83, toUtf83;\nvar init_dist_es = __esm({\n  \"node_modules/@aws-sdk/util-utf8-browser/dist-es/index.js\"() {\n    import_dist7 = __toESM(require_dist());\n    init_pureJs();\n    init_whatwgEncodingApi();\n    fromUtf83 = (input) => typeof TextEncoder === \"function\" ? fromUtf82(input) : fromUtf8(input);\n    toUtf83 = (input) => typeof TextDecoder === \"function\" ? toUtf82(input) : toUtf8(input);\n  }\n});\n\n// node_modules/@aws-crypto/util/build/convertToBuffer.js\nvar require_convertToBuffer = __commonJS({\n  \"node_modules/@aws-crypto/util/build/convertToBuffer.js\"(exports) {\n    \"use strict\";\n    var import_dist28 = __toESM(require_dist());\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.convertToBuffer = void 0;\n    var util_utf8_browser_1 = (init_dist_es(), __toCommonJS(dist_es_exports));\n    var fromUtf84 = typeof Buffer !== \"undefined\" && Buffer.from ? function(input) {\n      return Buffer.from(input, \"utf8\");\n    } : util_utf8_browser_1.fromUtf8;\n    function convertToBuffer(data) {\n      if (data instanceof Uint8Array)\n        return data;\n      if (typeof data === \"string\") {\n        return fromUtf84(data);\n      }\n      if (ArrayBuffer.isView(data)) {\n        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);\n      }\n      return new Uint8Array(data);\n    }\n    exports.convertToBuffer = convertToBuffer;\n  }\n});\n\n// node_modules/@aws-crypto/util/build/isEmptyData.js\nvar require_isEmptyData = __commonJS({\n  \"node_modules/@aws-crypto/util/build/isEmptyData.js\"(exports) {\n    \"use strict\";\n    var import_dist28 = __toESM(require_dist());\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.isEmptyData = void 0;\n    function isEmptyData(data) {\n      if (typeof data === \"string\") {\n        return data.length === 0;\n      }\n      return data.byteLength === 0;\n    }\n    exports.isEmptyData = isEmptyData;\n  }\n});\n\n// node_modules/@aws-crypto/util/build/numToUint8.js\nvar require_numToUint8 = __commonJS({\n  \"node_modules/@aws-crypto/util/build/numToUint8.js\"(exports) {\n    \"use strict\";\n    var import_dist28 = __toESM(require_dist());\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.numToUint8 = void 0;\n    function numToUint8(num) {\n      return new Uint8Array([\n        (num & 4278190080) >> 24,\n        (num & 16711680) >> 16,\n        (num & 65280) >> 8,\n        num & 255\n      ]);\n    }\n    exports.numToUint8 = numToUint8;\n  }\n});\n\n// node_modules/@aws-crypto/util/build/uint32ArrayFrom.js\nvar require_uint32ArrayFrom = __commonJS({\n  \"node_modules/@aws-crypto/util/build/uint32ArrayFrom.js\"(exports) {\n    \"use strict\";\n    var import_dist28 = __toESM(require_dist());\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.uint32ArrayFrom = void 0;\n    function uint32ArrayFrom(a_lookUpTable) {\n      if (!Array.from) {\n        var return_array = new Uint32Array(a_lookUpTable.length);\n        var a_index = 0;\n        while (a_index < a_lookUpTable.length) {\n          return_array[a_index] = a_lookUpTable[a_index];\n        }\n        return return_array;\n      }\n      return Uint32Array.from(a_lookUpTable);\n    }\n    exports.uint32ArrayFrom = uint32ArrayFrom;\n  }\n});\n\n// node_modules/@aws-crypto/util/build/index.js\nvar require_build = __commonJS({\n  \"node_modules/@aws-crypto/util/build/index.js\"(exports) {\n    \"use strict\";\n    var import_dist28 = __toESM(require_dist());\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.uint32ArrayFrom = exports.numToUint8 = exports.isEmptyData = exports.convertToBuffer = void 0;\n    var convertToBuffer_1 = require_convertToBuffer();\n    Object.defineProperty(exports, \"convertToBuffer\", { enumerable: true, get: function() {\n      return convertToBuffer_1.convertToBuffer;\n    } });\n    var isEmptyData_1 = require_isEmptyData();\n    Object.defineProperty(exports, \"isEmptyData\", { enumerable: true, get: function() {\n      return isEmptyData_1.isEmptyData;\n    } });\n    var numToUint8_1 = require_numToUint8();\n    Object.defineProperty(exports, \"numToUint8\", { enumerable: true, get: function() {\n      return numToUint8_1.numToUint8;\n    } });\n    var uint32ArrayFrom_1 = require_uint32ArrayFrom();\n    Object.defineProperty(exports, \"uint32ArrayFrom\", { enumerable: true, get: function() {\n      return uint32ArrayFrom_1.uint32ArrayFrom;\n    } });\n  }\n});\n\n// node_modules/@aws-crypto/sha256-js/build/jsSha256.js\nvar require_jsSha256 = __commonJS({\n  \"node_modules/@aws-crypto/sha256-js/build/jsSha256.js\"(exports) {\n    \"use strict\";\n    var import_dist28 = __toESM(require_dist());\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.Sha256 = void 0;\n    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));\n    var constants_1 = require_constants();\n    var RawSha256_1 = require_RawSha256();\n    var util_1 = require_build();\n    var Sha2563 = (\n      /** @class */\n      function() {\n        function Sha2564(secret) {\n          this.hash = new RawSha256_1.RawSha256();\n          if (secret) {\n            this.outer = new RawSha256_1.RawSha256();\n            var inner = bufferFromSecret(secret);\n            var outer = new Uint8Array(constants_1.BLOCK_SIZE);\n            outer.set(inner);\n            for (var i = 0; i < constants_1.BLOCK_SIZE; i++) {\n              inner[i] ^= 54;\n              outer[i] ^= 92;\n            }\n            this.hash.update(inner);\n            this.outer.update(outer);\n            for (var i = 0; i < inner.byteLength; i++) {\n              inner[i] = 0;\n            }\n          }\n        }\n        Sha2564.prototype.update = function(toHash) {\n          if ((0, util_1.isEmptyData)(toHash) || this.error) {\n            return;\n          }\n          try {\n            this.hash.update((0, util_1.convertToBuffer)(toHash));\n          } catch (e) {\n            this.error = e;\n          }\n        };\n        Sha2564.prototype.digestSync = function() {\n          if (this.error) {\n            throw this.error;\n          }\n          if (this.outer) {\n            if (!this.outer.finished) {\n              this.outer.update(this.hash.digest());\n            }\n            return this.outer.digest();\n          }\n          return this.hash.digest();\n        };\n        Sha2564.prototype.digest = function() {\n          return (0, tslib_1.__awaiter)(this, void 0, void 0, function() {\n            return (0, tslib_1.__generator)(this, function(_a) {\n              return [2, this.digestSync()];\n            });\n          });\n        };\n        return Sha2564;\n      }()\n    );\n    exports.Sha256 = Sha2563;\n    function bufferFromSecret(secret) {\n      var input = (0, util_1.convertToBuffer)(secret);\n      if (input.byteLength > constants_1.BLOCK_SIZE) {\n        var bufferHash = new RawSha256_1.RawSha256();\n        bufferHash.update(input);\n        input = bufferHash.digest();\n      }\n      var buffer = new Uint8Array(constants_1.BLOCK_SIZE);\n      buffer.set(input);\n      return buffer;\n    }\n  }\n});\n\n// node_modules/@aws-crypto/sha256-js/build/index.js\nvar require_build2 = __commonJS({\n  \"node_modules/@aws-crypto/sha256-js/build/index.js\"(exports) {\n    \"use strict\";\n    var import_dist28 = __toESM(require_dist());\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));\n    (0, tslib_1.__exportStar)(require_jsSha256(), exports);\n  }\n});\n\n// node_modules/unfetch/dist/unfetch.module.js\nvar unfetch_module_exports = {};\n__export(unfetch_module_exports, {\n  default: () => unfetch_module_default\n});\nfunction unfetch_module_default(e, n) {\n  return n = n || {}, new Promise(function(t, r) {\n    var s = new XMLHttpRequest(), o = [], u = [], i = {}, a = function() {\n      return { ok: 2 == (s.status / 100 | 0), statusText: s.statusText, status: s.status, url: s.responseURL, text: function() {\n        return Promise.resolve(s.responseText);\n      }, json: function() {\n        return Promise.resolve(s.responseText).then(JSON.parse);\n      }, blob: function() {\n        return Promise.resolve(new Blob([s.response]));\n      }, clone: a, headers: { keys: function() {\n        return o;\n      }, entries: function() {\n        return u;\n      }, get: function(e2) {\n        return i[e2.toLowerCase()];\n      }, has: function(e2) {\n        return e2.toLowerCase() in i;\n      } } };\n    };\n    for (var l in s.open(n.method || \"get\", e, true), s.onload = function() {\n      s.getAllResponseHeaders().replace(/^(.*?):[^\\S\\n]*([\\s\\S]*?)$/gm, function(e2, n2, t2) {\n        o.push(n2 = n2.toLowerCase()), u.push([n2, t2]), i[n2] = i[n2] ? i[n2] + \",\" + t2 : t2;\n      }), t(a());\n    }, s.onerror = r, s.withCredentials = \"include\" == n.credentials, n.headers)\n      s.setRequestHeader(l, n.headers[l]);\n    s.send(n.body || null);\n  });\n}\nvar import_dist21;\nvar init_unfetch_module = __esm({\n  \"node_modules/unfetch/dist/unfetch.module.js\"() {\n    import_dist21 = __toESM(require_dist());\n  }\n});\n\n// node_modules/isomorphic-unfetch/browser.js\nvar require_browser = __commonJS({\n  \"node_modules/isomorphic-unfetch/browser.js\"(exports, module) {\n    var import_dist28 = __toESM(require_dist());\n    module.exports = self.fetch || (self.fetch = (init_unfetch_module(), __toCommonJS(unfetch_module_exports)).default || (init_unfetch_module(), __toCommonJS(unfetch_module_exports)));\n  }\n});\n\n// node_modules/js-cookie/src/js.cookie.js\nvar require_js_cookie = __commonJS({\n  \"node_modules/js-cookie/src/js.cookie.js\"(exports, module) {\n    var import_dist28 = __toESM(require_dist());\n    (function(factory) {\n      var registeredInModuleLoader;\n      if (typeof define === \"function\" && define.amd) {\n        define(factory);\n        registeredInModuleLoader = true;\n      }\n      if (typeof exports === \"object\") {\n        module.exports = factory();\n        registeredInModuleLoader = true;\n      }\n      if (!registeredInModuleLoader) {\n        var OldCookies = window.Cookies;\n        var api = window.Cookies = factory();\n        api.noConflict = function() {\n          window.Cookies = OldCookies;\n          return api;\n        };\n      }\n    })(function() {\n      function extend() {\n        var i = 0;\n        var result = {};\n        for (; i < arguments.length; i++) {\n          var attributes = arguments[i];\n          for (var key in attributes) {\n            result[key] = attributes[key];\n          }\n        }\n        return result;\n      }\n      function decode(s) {\n        return s.replace(/(%[0-9A-Z]{2})+/g, decodeURIComponent);\n      }\n      function init(converter) {\n        function api() {\n        }\n        function set2(key, value, attributes) {\n          if (typeof document === \"undefined\") {\n            return;\n          }\n          attributes = extend({\n            path: \"/\"\n          }, api.defaults, attributes);\n          if (typeof attributes.expires === \"number\") {\n            attributes.expires = new Date(/* @__PURE__ */ new Date() * 1 + attributes.expires * 864e5);\n          }\n          attributes.expires = attributes.expires ? attributes.expires.toUTCString() : \"\";\n          try {\n            var result = JSON.stringify(value);\n            if (/^[\\{\\[]/.test(result)) {\n              value = result;\n            }\n          } catch (e) {\n          }\n          value = converter.write ? converter.write(value, key) : encodeURIComponent(String(value)).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);\n          key = encodeURIComponent(String(key)).replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent).replace(/[\\(\\)]/g, escape);\n          var stringifiedAttributes = \"\";\n          for (var attributeName in attributes) {\n            if (!attributes[attributeName]) {\n              continue;\n            }\n            stringifiedAttributes += \"; \" + attributeName;\n            if (attributes[attributeName] === true) {\n              continue;\n            }\n            stringifiedAttributes += \"=\" + attributes[attributeName].split(\";\")[0];\n          }\n          return document.cookie = key + \"=\" + value + stringifiedAttributes;\n        }\n        function get2(key, json) {\n          if (typeof document === \"undefined\") {\n            return;\n          }\n          var jar = {};\n          var cookies = document.cookie ? document.cookie.split(\"; \") : [];\n          var i = 0;\n          for (; i < cookies.length; i++) {\n            var parts = cookies[i].split(\"=\");\n            var cookie = parts.slice(1).join(\"=\");\n            if (!json && cookie.charAt(0) === '\"') {\n              cookie = cookie.slice(1, -1);\n            }\n            try {\n              var name = decode(parts[0]);\n              cookie = (converter.read || converter)(cookie, name) || decode(cookie);\n              if (json) {\n                try {\n                  cookie = JSON.parse(cookie);\n                } catch (e) {\n                }\n              }\n              jar[name] = cookie;\n              if (key === name) {\n                break;\n              }\n            } catch (e) {\n            }\n          }\n          return key ? jar[key] : jar;\n        }\n        api.set = set2;\n        api.get = function(key) {\n          return get2(\n            key,\n            false\n            /* read as raw */\n          );\n        };\n        api.getJSON = function(key) {\n          return get2(\n            key,\n            true\n            /* read as json */\n          );\n        };\n        api.remove = function(key, attributes) {\n          set2(key, \"\", extend(attributes, {\n            expires: -1\n          }));\n        };\n        api.defaults = {};\n        api.withConverter = init;\n        return api;\n      }\n      return init(function() {\n      });\n    });\n  }\n});\n\n// node_modules/amazon-cognito-identity-js/es/index.js\nvar import_dist27 = __toESM(require_dist());\n\n// node_modules/amazon-cognito-identity-js/es/AuthenticationDetails.js\nvar import_dist = __toESM(require_dist());\nvar AuthenticationDetails = function() {\n  function AuthenticationDetails2(data) {\n    var _ref = data || {}, ValidationData = _ref.ValidationData, Username = _ref.Username, Password = _ref.Password, AuthParameters = _ref.AuthParameters, ClientMetadata = _ref.ClientMetadata;\n    this.validationData = ValidationData || {};\n    this.authParameters = AuthParameters || {};\n    this.clientMetadata = ClientMetadata || {};\n    this.username = Username;\n    this.password = Password;\n  }\n  var _proto = AuthenticationDetails2.prototype;\n  _proto.getUsername = function getUsername() {\n    return this.username;\n  };\n  _proto.getPassword = function getPassword() {\n    return this.password;\n  };\n  _proto.getValidationData = function getValidationData() {\n    return this.validationData;\n  };\n  _proto.getAuthParameters = function getAuthParameters() {\n    return this.authParameters;\n  };\n  _proto.getClientMetadata = function getClientMetadata() {\n    return this.clientMetadata;\n  };\n  return AuthenticationDetails2;\n}();\n\n// node_modules/amazon-cognito-identity-js/es/AuthenticationHelper.js\nvar import_dist9 = __toESM(require_dist());\nvar import_buffer = __toESM(require_buffer_polyfill());\n\n// node_modules/amazon-cognito-identity-js/es/utils/WordArray.js\nvar import_dist3 = __toESM(require_dist());\n\n// node_modules/amazon-cognito-identity-js/es/utils/cryptoSecureRandomInt.js\nvar import_dist2 = __toESM(require_dist());\nvar crypto;\nif (typeof window !== \"undefined\" && window.crypto) {\n  crypto = window.crypto;\n}\nif (!crypto && typeof window !== \"undefined\" && window.msCrypto) {\n  crypto = window.msCrypto;\n}\nif (!crypto && typeof global !== \"undefined\" && global.crypto) {\n  crypto = global.crypto;\n}\nif (!crypto && typeof __require === \"function\") {\n  try {\n    crypto = require_crypto_browserify();\n  } catch (err) {\n  }\n}\nfunction cryptoSecureRandomInt() {\n  if (crypto) {\n    if (typeof crypto.getRandomValues === \"function\") {\n      try {\n        return crypto.getRandomValues(new Uint32Array(1))[0];\n      } catch (err) {\n      }\n    }\n    if (typeof crypto.randomBytes === \"function\") {\n      try {\n        return crypto.randomBytes(4).readInt32LE();\n      } catch (err) {\n      }\n    }\n  }\n  throw new Error(\"Native crypto module could not be used to get secure random number.\");\n}\n\n// node_modules/amazon-cognito-identity-js/es/utils/WordArray.js\nfunction hexStringify(wordArray) {\n  var words = wordArray.words;\n  var sigBytes = wordArray.sigBytes;\n  var hexChars = [];\n  for (var i = 0; i < sigBytes; i++) {\n    var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;\n    hexChars.push((bite >>> 4).toString(16));\n    hexChars.push((bite & 15).toString(16));\n  }\n  return hexChars.join(\"\");\n}\nvar WordArray = function() {\n  function WordArray2(words, sigBytes) {\n    words = this.words = words || [];\n    if (sigBytes != void 0) {\n      this.sigBytes = sigBytes;\n    } else {\n      this.sigBytes = words.length * 4;\n    }\n  }\n  var _proto = WordArray2.prototype;\n  _proto.random = function random(nBytes) {\n    var words = [];\n    for (var i = 0; i < nBytes; i += 4) {\n      words.push(cryptoSecureRandomInt());\n    }\n    return new WordArray2(words, nBytes);\n  };\n  _proto.toString = function toString() {\n    return hexStringify(this);\n  };\n  return WordArray2;\n}();\n\n// node_modules/amazon-cognito-identity-js/es/AuthenticationHelper.js\nvar import_sha256_js = __toESM(require_build2());\n\n// node_modules/amazon-cognito-identity-js/es/BigInteger.js\nvar import_dist8 = __toESM(require_dist());\nvar BigInteger_default = BigInteger;\nfunction BigInteger(a, b) {\n  if (a != null)\n    this.fromString(a, b);\n}\nfunction nbi() {\n  return new BigInteger(null);\n}\nvar dbits;\nvar canary = 244837814094590;\nvar j_lm = (canary & 16777215) == 15715070;\nfunction am1(i, x, w, j, c, n) {\n  while (--n >= 0) {\n    var v = x * this[i++] + w[j] + c;\n    c = Math.floor(v / 67108864);\n    w[j++] = v & 67108863;\n  }\n  return c;\n}\nfunction am2(i, x, w, j, c, n) {\n  var xl = x & 32767, xh = x >> 15;\n  while (--n >= 0) {\n    var l = this[i] & 32767;\n    var h = this[i++] >> 15;\n    var m = xh * l + h * xl;\n    l = xl * l + ((m & 32767) << 15) + w[j] + (c & 1073741823);\n    c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);\n    w[j++] = l & 1073741823;\n  }\n  return c;\n}\nfunction am3(i, x, w, j, c, n) {\n  var xl = x & 16383, xh = x >> 14;\n  while (--n >= 0) {\n    var l = this[i] & 16383;\n    var h = this[i++] >> 14;\n    var m = xh * l + h * xl;\n    l = xl * l + ((m & 16383) << 14) + w[j] + c;\n    c = (l >> 28) + (m >> 14) + xh * h;\n    w[j++] = l & 268435455;\n  }\n  return c;\n}\nvar inBrowser = typeof navigator !== \"undefined\";\nif (inBrowser && j_lm && navigator.appName == \"Microsoft Internet Explorer\") {\n  BigInteger.prototype.am = am2;\n  dbits = 30;\n} else if (inBrowser && j_lm && navigator.appName != \"Netscape\") {\n  BigInteger.prototype.am = am1;\n  dbits = 26;\n} else {\n  BigInteger.prototype.am = am3;\n  dbits = 28;\n}\nBigInteger.prototype.DB = dbits;\nBigInteger.prototype.DM = (1 << dbits) - 1;\nBigInteger.prototype.DV = 1 << dbits;\nvar BI_FP = 52;\nBigInteger.prototype.FV = Math.pow(2, BI_FP);\nBigInteger.prototype.F1 = BI_FP - dbits;\nBigInteger.prototype.F2 = 2 * dbits - BI_FP;\nvar BI_RM = \"0123456789abcdefghijklmnopqrstuvwxyz\";\nvar BI_RC = new Array();\nvar rr;\nvar vv;\nrr = \"0\".charCodeAt(0);\nfor (vv = 0; vv <= 9; ++vv)\n  BI_RC[rr++] = vv;\nrr = \"a\".charCodeAt(0);\nfor (vv = 10; vv < 36; ++vv)\n  BI_RC[rr++] = vv;\nrr = \"A\".charCodeAt(0);\nfor (vv = 10; vv < 36; ++vv)\n  BI_RC[rr++] = vv;\nfunction int2char(n) {\n  return BI_RM.charAt(n);\n}\nfunction intAt(s, i) {\n  var c = BI_RC[s.charCodeAt(i)];\n  return c == null ? -1 : c;\n}\nfunction bnpCopyTo(r) {\n  for (var i = this.t - 1; i >= 0; --i)\n    r[i] = this[i];\n  r.t = this.t;\n  r.s = this.s;\n}\nfunction bnpFromInt(x) {\n  this.t = 1;\n  this.s = x < 0 ? -1 : 0;\n  if (x > 0)\n    this[0] = x;\n  else if (x < -1)\n    this[0] = x + this.DV;\n  else\n    this.t = 0;\n}\nfunction nbv(i) {\n  var r = nbi();\n  r.fromInt(i);\n  return r;\n}\nfunction bnpFromString(s, b) {\n  var k;\n  if (b == 16)\n    k = 4;\n  else if (b == 8)\n    k = 3;\n  else if (b == 2)\n    k = 1;\n  else if (b == 32)\n    k = 5;\n  else if (b == 4)\n    k = 2;\n  else\n    throw new Error(\"Only radix 2, 4, 8, 16, 32 are supported\");\n  this.t = 0;\n  this.s = 0;\n  var i = s.length, mi = false, sh = 0;\n  while (--i >= 0) {\n    var x = intAt(s, i);\n    if (x < 0) {\n      if (s.charAt(i) == \"-\")\n        mi = true;\n      continue;\n    }\n    mi = false;\n    if (sh == 0)\n      this[this.t++] = x;\n    else if (sh + k > this.DB) {\n      this[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;\n      this[this.t++] = x >> this.DB - sh;\n    } else\n      this[this.t - 1] |= x << sh;\n    sh += k;\n    if (sh >= this.DB)\n      sh -= this.DB;\n  }\n  this.clamp();\n  if (mi)\n    BigInteger.ZERO.subTo(this, this);\n}\nfunction bnpClamp() {\n  var c = this.s & this.DM;\n  while (this.t > 0 && this[this.t - 1] == c)\n    --this.t;\n}\nfunction bnToString(b) {\n  if (this.s < 0)\n    return \"-\" + this.negate().toString(b);\n  var k;\n  if (b == 16)\n    k = 4;\n  else if (b == 8)\n    k = 3;\n  else if (b == 2)\n    k = 1;\n  else if (b == 32)\n    k = 5;\n  else if (b == 4)\n    k = 2;\n  else\n    throw new Error(\"Only radix 2, 4, 8, 16, 32 are supported\");\n  var km = (1 << k) - 1, d, m = false, r = \"\", i = this.t;\n  var p = this.DB - i * this.DB % k;\n  if (i-- > 0) {\n    if (p < this.DB && (d = this[i] >> p) > 0) {\n      m = true;\n      r = int2char(d);\n    }\n    while (i >= 0) {\n      if (p < k) {\n        d = (this[i] & (1 << p) - 1) << k - p;\n        d |= this[--i] >> (p += this.DB - k);\n      } else {\n        d = this[i] >> (p -= k) & km;\n        if (p <= 0) {\n          p += this.DB;\n          --i;\n        }\n      }\n      if (d > 0)\n        m = true;\n      if (m)\n        r += int2char(d);\n    }\n  }\n  return m ? r : \"0\";\n}\nfunction bnNegate() {\n  var r = nbi();\n  BigInteger.ZERO.subTo(this, r);\n  return r;\n}\nfunction bnAbs() {\n  return this.s < 0 ? this.negate() : this;\n}\nfunction bnCompareTo(a) {\n  var r = this.s - a.s;\n  if (r != 0)\n    return r;\n  var i = this.t;\n  r = i - a.t;\n  if (r != 0)\n    return this.s < 0 ? -r : r;\n  while (--i >= 0)\n    if ((r = this[i] - a[i]) != 0)\n      return r;\n  return 0;\n}\nfunction nbits(x) {\n  var r = 1, t;\n  if ((t = x >>> 16) != 0) {\n    x = t;\n    r += 16;\n  }\n  if ((t = x >> 8) != 0) {\n    x = t;\n    r += 8;\n  }\n  if ((t = x >> 4) != 0) {\n    x = t;\n    r += 4;\n  }\n  if ((t = x >> 2) != 0) {\n    x = t;\n    r += 2;\n  }\n  if ((t = x >> 1) != 0) {\n    x = t;\n    r += 1;\n  }\n  return r;\n}\nfunction bnBitLength() {\n  if (this.t <= 0)\n    return 0;\n  return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ this.s & this.DM);\n}\nfunction bnpDLShiftTo(n, r) {\n  var i;\n  for (i = this.t - 1; i >= 0; --i)\n    r[i + n] = this[i];\n  for (i = n - 1; i >= 0; --i)\n    r[i] = 0;\n  r.t = this.t + n;\n  r.s = this.s;\n}\nfunction bnpDRShiftTo(n, r) {\n  for (var i = n; i < this.t; ++i)\n    r[i - n] = this[i];\n  r.t = Math.max(this.t - n, 0);\n  r.s = this.s;\n}\nfunction bnpLShiftTo(n, r) {\n  var bs = n % this.DB;\n  var cbs = this.DB - bs;\n  var bm = (1 << cbs) - 1;\n  var ds = Math.floor(n / this.DB), c = this.s << bs & this.DM, i;\n  for (i = this.t - 1; i >= 0; --i) {\n    r[i + ds + 1] = this[i] >> cbs | c;\n    c = (this[i] & bm) << bs;\n  }\n  for (i = ds - 1; i >= 0; --i)\n    r[i] = 0;\n  r[ds] = c;\n  r.t = this.t + ds + 1;\n  r.s = this.s;\n  r.clamp();\n}\nfunction bnpRShiftTo(n, r) {\n  r.s = this.s;\n  var ds = Math.floor(n / this.DB);\n  if (ds >= this.t) {\n    r.t = 0;\n    return;\n  }\n  var bs = n % this.DB;\n  var cbs = this.DB - bs;\n  var bm = (1 << bs) - 1;\n  r[0] = this[ds] >> bs;\n  for (var i = ds + 1; i < this.t; ++i) {\n    r[i - ds - 1] |= (this[i] & bm) << cbs;\n    r[i - ds] = this[i] >> bs;\n  }\n  if (bs > 0)\n    r[this.t - ds - 1] |= (this.s & bm) << cbs;\n  r.t = this.t - ds;\n  r.clamp();\n}\nfunction bnpSubTo(a, r) {\n  var i = 0, c = 0, m = Math.min(a.t, this.t);\n  while (i < m) {\n    c += this[i] - a[i];\n    r[i++] = c & this.DM;\n    c >>= this.DB;\n  }\n  if (a.t < this.t) {\n    c -= a.s;\n    while (i < this.t) {\n      c += this[i];\n      r[i++] = c & this.DM;\n      c >>= this.DB;\n    }\n    c += this.s;\n  } else {\n    c += this.s;\n    while (i < a.t) {\n      c -= a[i];\n      r[i++] = c & this.DM;\n      c >>= this.DB;\n    }\n    c -= a.s;\n  }\n  r.s = c < 0 ? -1 : 0;\n  if (c < -1)\n    r[i++] = this.DV + c;\n  else if (c > 0)\n    r[i++] = c;\n  r.t = i;\n  r.clamp();\n}\nfunction bnpMultiplyTo(a, r) {\n  var x = this.abs(), y = a.abs();\n  var i = x.t;\n  r.t = i + y.t;\n  while (--i >= 0)\n    r[i] = 0;\n  for (i = 0; i < y.t; ++i)\n    r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);\n  r.s = 0;\n  r.clamp();\n  if (this.s != a.s)\n    BigInteger.ZERO.subTo(r, r);\n}\nfunction bnpSquareTo(r) {\n  var x = this.abs();\n  var i = r.t = 2 * x.t;\n  while (--i >= 0)\n    r[i] = 0;\n  for (i = 0; i < x.t - 1; ++i) {\n    var c = x.am(i, x[i], r, 2 * i, 0, 1);\n    if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {\n      r[i + x.t] -= x.DV;\n      r[i + x.t + 1] = 1;\n    }\n  }\n  if (r.t > 0)\n    r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);\n  r.s = 0;\n  r.clamp();\n}\nfunction bnpDivRemTo(m, q, r) {\n  var pm = m.abs();\n  if (pm.t <= 0)\n    return;\n  var pt = this.abs();\n  if (pt.t < pm.t) {\n    if (q != null)\n      q.fromInt(0);\n    if (r != null)\n      this.copyTo(r);\n    return;\n  }\n  if (r == null)\n    r = nbi();\n  var y = nbi(), ts = this.s, ms = m.s;\n  var nsh = this.DB - nbits(pm[pm.t - 1]);\n  if (nsh > 0) {\n    pm.lShiftTo(nsh, y);\n    pt.lShiftTo(nsh, r);\n  } else {\n    pm.copyTo(y);\n    pt.copyTo(r);\n  }\n  var ys = y.t;\n  var y0 = y[ys - 1];\n  if (y0 == 0)\n    return;\n  var yt = y0 * (1 << this.F1) + (ys > 1 ? y[ys - 2] >> this.F2 : 0);\n  var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;\n  var i = r.t, j = i - ys, t = q == null ? nbi() : q;\n  y.dlShiftTo(j, t);\n  if (r.compareTo(t) >= 0) {\n    r[r.t++] = 1;\n    r.subTo(t, r);\n  }\n  BigInteger.ONE.dlShiftTo(ys, t);\n  t.subTo(y, y);\n  while (y.t < ys)\n    y[y.t++] = 0;\n  while (--j >= 0) {\n    var qd = r[--i] == y0 ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);\n    if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) {\n      y.dlShiftTo(j, t);\n      r.subTo(t, r);\n      while (r[i] < --qd)\n        r.subTo(t, r);\n    }\n  }\n  if (q != null) {\n    r.drShiftTo(ys, q);\n    if (ts != ms)\n      BigInteger.ZERO.subTo(q, q);\n  }\n  r.t = ys;\n  r.clamp();\n  if (nsh > 0)\n    r.rShiftTo(nsh, r);\n  if (ts < 0)\n    BigInteger.ZERO.subTo(r, r);\n}\nfunction bnMod(a) {\n  var r = nbi();\n  this.abs().divRemTo(a, null, r);\n  if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0)\n    a.subTo(r, r);\n  return r;\n}\nfunction bnpInvDigit() {\n  if (this.t < 1)\n    return 0;\n  var x = this[0];\n  if ((x & 1) == 0)\n    return 0;\n  var y = x & 3;\n  y = y * (2 - (x & 15) * y) & 15;\n  y = y * (2 - (x & 255) * y) & 255;\n  y = y * (2 - ((x & 65535) * y & 65535)) & 65535;\n  y = y * (2 - x * y % this.DV) % this.DV;\n  return y > 0 ? this.DV - y : -y;\n}\nfunction bnEquals(a) {\n  return this.compareTo(a) == 0;\n}\nfunction bnpAddTo(a, r) {\n  var i = 0, c = 0, m = Math.min(a.t, this.t);\n  while (i < m) {\n    c += this[i] + a[i];\n    r[i++] = c & this.DM;\n    c >>= this.DB;\n  }\n  if (a.t < this.t) {\n    c += a.s;\n    while (i < this.t) {\n      c += this[i];\n      r[i++] = c & this.DM;\n      c >>= this.DB;\n    }\n    c += this.s;\n  } else {\n    c += this.s;\n    while (i < a.t) {\n      c += a[i];\n      r[i++] = c & this.DM;\n      c >>= this.DB;\n    }\n    c += a.s;\n  }\n  r.s = c < 0 ? -1 : 0;\n  if (c > 0)\n    r[i++] = c;\n  else if (c < -1)\n    r[i++] = this.DV + c;\n  r.t = i;\n  r.clamp();\n}\nfunction bnAdd(a) {\n  var r = nbi();\n  this.addTo(a, r);\n  return r;\n}\nfunction bnSubtract(a) {\n  var r = nbi();\n  this.subTo(a, r);\n  return r;\n}\nfunction bnMultiply(a) {\n  var r = nbi();\n  this.multiplyTo(a, r);\n  return r;\n}\nfunction bnDivide(a) {\n  var r = nbi();\n  this.divRemTo(a, r, null);\n  return r;\n}\nfunction Montgomery(m) {\n  this.m = m;\n  this.mp = m.invDigit();\n  this.mpl = this.mp & 32767;\n  this.mph = this.mp >> 15;\n  this.um = (1 << m.DB - 15) - 1;\n  this.mt2 = 2 * m.t;\n}\nfunction montConvert(x) {\n  var r = nbi();\n  x.abs().dlShiftTo(this.m.t, r);\n  r.divRemTo(this.m, null, r);\n  if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0)\n    this.m.subTo(r, r);\n  return r;\n}\nfunction montRevert(x) {\n  var r = nbi();\n  x.copyTo(r);\n  this.reduce(r);\n  return r;\n}\nfunction montReduce(x) {\n  while (x.t <= this.mt2)\n    x[x.t++] = 0;\n  for (var i = 0; i < this.m.t; ++i) {\n    var j = x[i] & 32767;\n    var u0 = j * this.mpl + ((j * this.mph + (x[i] >> 15) * this.mpl & this.um) << 15) & x.DM;\n    j = i + this.m.t;\n    x[j] += this.m.am(0, u0, x, i, 0, this.m.t);\n    while (x[j] >= x.DV) {\n      x[j] -= x.DV;\n      x[++j]++;\n    }\n  }\n  x.clamp();\n  x.drShiftTo(this.m.t, x);\n  if (x.compareTo(this.m) >= 0)\n    x.subTo(this.m, x);\n}\nfunction montSqrTo(x, r) {\n  x.squareTo(r);\n  this.reduce(r);\n}\nfunction montMulTo(x, y, r) {\n  x.multiplyTo(y, r);\n  this.reduce(r);\n}\nMontgomery.prototype.convert = montConvert;\nMontgomery.prototype.revert = montRevert;\nMontgomery.prototype.reduce = montReduce;\nMontgomery.prototype.mulTo = montMulTo;\nMontgomery.prototype.sqrTo = montSqrTo;\nfunction bnModPow(e, m, callback) {\n  var i = e.bitLength(), k, r = nbv(1), z = new Montgomery(m);\n  if (i <= 0)\n    return r;\n  else if (i < 18)\n    k = 1;\n  else if (i < 48)\n    k = 3;\n  else if (i < 144)\n    k = 4;\n  else if (i < 768)\n    k = 5;\n  else\n    k = 6;\n  var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;\n  g[1] = z.convert(this);\n  if (k > 1) {\n    var g2 = nbi();\n    z.sqrTo(g[1], g2);\n    while (n <= km) {\n      g[n] = nbi();\n      z.mulTo(g2, g[n - 2], g[n]);\n      n += 2;\n    }\n  }\n  var j = e.t - 1, w, is1 = true, r2 = nbi(), t;\n  i = nbits(e[j]) - 1;\n  while (j >= 0) {\n    if (i >= k1)\n      w = e[j] >> i - k1 & km;\n    else {\n      w = (e[j] & (1 << i + 1) - 1) << k1 - i;\n      if (j > 0)\n        w |= e[j - 1] >> this.DB + i - k1;\n    }\n    n = k;\n    while ((w & 1) == 0) {\n      w >>= 1;\n      --n;\n    }\n    if ((i -= n) < 0) {\n      i += this.DB;\n      --j;\n    }\n    if (is1) {\n      g[w].copyTo(r);\n      is1 = false;\n    } else {\n      while (n > 1) {\n        z.sqrTo(r, r2);\n        z.sqrTo(r2, r);\n        n -= 2;\n      }\n      if (n > 0)\n        z.sqrTo(r, r2);\n      else {\n        t = r;\n        r = r2;\n        r2 = t;\n      }\n      z.mulTo(r2, g[w], r);\n    }\n    while (j >= 0 && (e[j] & 1 << i) == 0) {\n      z.sqrTo(r, r2);\n      t = r;\n      r = r2;\n      r2 = t;\n      if (--i < 0) {\n        i = this.DB - 1;\n        --j;\n      }\n    }\n  }\n  var result = z.revert(r);\n  callback(null, result);\n  return result;\n}\nBigInteger.prototype.copyTo = bnpCopyTo;\nBigInteger.prototype.fromInt = bnpFromInt;\nBigInteger.prototype.fromString = bnpFromString;\nBigInteger.prototype.clamp = bnpClamp;\nBigInteger.prototype.dlShiftTo = bnpDLShiftTo;\nBigInteger.prototype.drShiftTo = bnpDRShiftTo;\nBigInteger.prototype.lShiftTo = bnpLShiftTo;\nBigInteger.prototype.rShiftTo = bnpRShiftTo;\nBigInteger.prototype.subTo = bnpSubTo;\nBigInteger.prototype.multiplyTo = bnpMultiplyTo;\nBigInteger.prototype.squareTo = bnpSquareTo;\nBigInteger.prototype.divRemTo = bnpDivRemTo;\nBigInteger.prototype.invDigit = bnpInvDigit;\nBigInteger.prototype.addTo = bnpAddTo;\nBigInteger.prototype.toString = bnToString;\nBigInteger.prototype.negate = bnNegate;\nBigInteger.prototype.abs = bnAbs;\nBigInteger.prototype.compareTo = bnCompareTo;\nBigInteger.prototype.bitLength = bnBitLength;\nBigInteger.prototype.mod = bnMod;\nBigInteger.prototype.equals = bnEquals;\nBigInteger.prototype.add = bnAdd;\nBigInteger.prototype.subtract = bnSubtract;\nBigInteger.prototype.multiply = bnMultiply;\nBigInteger.prototype.divide = bnDivide;\nBigInteger.prototype.modPow = bnModPow;\nBigInteger.ZERO = nbv(0);\nBigInteger.ONE = nbv(1);\n\n// node_modules/amazon-cognito-identity-js/es/AuthenticationHelper.js\nfunction randomBytes(nBytes) {\n  return import_buffer.Buffer.from(new WordArray().random(nBytes).toString(), \"hex\");\n}\nvar HEX_MSB_REGEX = /^[89a-f]/i;\nvar initN = \"FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D670C354E4ABC9804F1746C08CA18217C32905E462E36CE3BE39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9DE2BCBF6955817183995497CEA956AE515D2261898FA051015728E5A8AAAC42DAD33170D04507A33A85521ABDF1CBA64ECFB850458DBEF0A8AEA71575D060C7DB3970F85A6E1E4C7ABF5AE8CDB0933D71E8C94E04A25619DCEE3D2261AD2EE6BF12FFA06D98A0864D87602733EC86A64521F2B18177B200CBBE117577A615D6C770988C0BAD946E208E24FA074E5AB3143DB5BFCE0FD108E4B82D120A93AD2CAFFFFFFFFFFFFFFFF\";\nvar newPasswordRequiredChallengeUserAttributePrefix = \"userAttributes.\";\nvar AuthenticationHelper = function() {\n  function AuthenticationHelper2(PoolName) {\n    this.N = new BigInteger_default(initN, 16);\n    this.g = new BigInteger_default(\"2\", 16);\n    this.k = new BigInteger_default(this.hexHash(\"\" + this.padHex(this.N) + this.padHex(this.g)), 16);\n    this.smallAValue = this.generateRandomSmallA();\n    this.getLargeAValue(function() {\n    });\n    this.infoBits = import_buffer.Buffer.from(\"Caldera Derived Key\", \"utf8\");\n    this.poolName = PoolName;\n  }\n  var _proto = AuthenticationHelper2.prototype;\n  _proto.getSmallAValue = function getSmallAValue() {\n    return this.smallAValue;\n  };\n  _proto.getLargeAValue = function getLargeAValue(callback) {\n    var _this = this;\n    if (this.largeAValue) {\n      callback(null, this.largeAValue);\n    } else {\n      this.calculateA(this.smallAValue, function(err, largeAValue) {\n        if (err) {\n          callback(err, null);\n        }\n        _this.largeAValue = largeAValue;\n        callback(null, _this.largeAValue);\n      });\n    }\n  };\n  _proto.generateRandomSmallA = function generateRandomSmallA() {\n    var hexRandom = randomBytes(128).toString(\"hex\");\n    var randomBigInt = new BigInteger_default(hexRandom, 16);\n    return randomBigInt;\n  };\n  _proto.generateRandomString = function generateRandomString() {\n    return randomBytes(40).toString(\"base64\");\n  };\n  _proto.getRandomPassword = function getRandomPassword() {\n    return this.randomPassword;\n  };\n  _proto.getSaltDevices = function getSaltDevices() {\n    return this.SaltToHashDevices;\n  };\n  _proto.getVerifierDevices = function getVerifierDevices() {\n    return this.verifierDevices;\n  };\n  _proto.generateHashDevice = function generateHashDevice(deviceGroupKey, username, callback) {\n    var _this2 = this;\n    this.randomPassword = this.generateRandomString();\n    var combinedString = \"\" + deviceGroupKey + username + \":\" + this.randomPassword;\n    var hashedString = this.hash(combinedString);\n    var hexRandom = randomBytes(16).toString(\"hex\");\n    this.SaltToHashDevices = this.padHex(new BigInteger_default(hexRandom, 16));\n    this.g.modPow(new BigInteger_default(this.hexHash(this.SaltToHashDevices + hashedString), 16), this.N, function(err, verifierDevicesNotPadded) {\n      if (err) {\n        callback(err, null);\n      }\n      _this2.verifierDevices = _this2.padHex(verifierDevicesNotPadded);\n      callback(null, null);\n    });\n  };\n  _proto.calculateA = function calculateA(a, callback) {\n    var _this3 = this;\n    this.g.modPow(a, this.N, function(err, A) {\n      if (err) {\n        callback(err, null);\n      }\n      if (A.mod(_this3.N).equals(BigInteger_default.ZERO)) {\n        callback(new Error(\"Illegal paramater. A mod N cannot be 0.\"), null);\n      }\n      callback(null, A);\n    });\n  };\n  _proto.calculateU = function calculateU(A, B) {\n    this.UHexHash = this.hexHash(this.padHex(A) + this.padHex(B));\n    var finalU = new BigInteger_default(this.UHexHash, 16);\n    return finalU;\n  };\n  _proto.hash = function hash(buf) {\n    var awsCryptoHash = new import_sha256_js.Sha256();\n    awsCryptoHash.update(buf);\n    var resultFromAWSCrypto = awsCryptoHash.digestSync();\n    var hashHex = import_buffer.Buffer.from(resultFromAWSCrypto).toString(\"hex\");\n    return new Array(64 - hashHex.length).join(\"0\") + hashHex;\n  };\n  _proto.hexHash = function hexHash(hexStr) {\n    return this.hash(import_buffer.Buffer.from(hexStr, \"hex\"));\n  };\n  _proto.computehkdf = function computehkdf(ikm, salt) {\n    var infoBitsBuffer = import_buffer.Buffer.concat([this.infoBits, import_buffer.Buffer.from(String.fromCharCode(1), \"utf8\")]);\n    var awsCryptoHash = new import_sha256_js.Sha256(salt);\n    awsCryptoHash.update(ikm);\n    var resultFromAWSCryptoPrk = awsCryptoHash.digestSync();\n    var awsCryptoHashHmac = new import_sha256_js.Sha256(resultFromAWSCryptoPrk);\n    awsCryptoHashHmac.update(infoBitsBuffer);\n    var resultFromAWSCryptoHmac = awsCryptoHashHmac.digestSync();\n    var hashHexFromAWSCrypto = resultFromAWSCryptoHmac;\n    var currentHex = hashHexFromAWSCrypto.slice(0, 16);\n    return currentHex;\n  };\n  _proto.getPasswordAuthenticationKey = function getPasswordAuthenticationKey(username, password, serverBValue, salt, callback) {\n    var _this4 = this;\n    if (serverBValue.mod(this.N).equals(BigInteger_default.ZERO)) {\n      throw new Error(\"B cannot be zero.\");\n    }\n    this.UValue = this.calculateU(this.largeAValue, serverBValue);\n    if (this.UValue.equals(BigInteger_default.ZERO)) {\n      throw new Error(\"U cannot be zero.\");\n    }\n    var usernamePassword = \"\" + this.poolName + username + \":\" + password;\n    var usernamePasswordHash = this.hash(usernamePassword);\n    var xValue = new BigInteger_default(this.hexHash(this.padHex(salt) + usernamePasswordHash), 16);\n    this.calculateS(xValue, serverBValue, function(err, sValue) {\n      if (err) {\n        callback(err, null);\n      }\n      var hkdf = _this4.computehkdf(import_buffer.Buffer.from(_this4.padHex(sValue), \"hex\"), import_buffer.Buffer.from(_this4.padHex(_this4.UValue), \"hex\"));\n      callback(null, hkdf);\n    });\n  };\n  _proto.calculateS = function calculateS(xValue, serverBValue, callback) {\n    var _this5 = this;\n    this.g.modPow(xValue, this.N, function(err, gModPowXN) {\n      if (err) {\n        callback(err, null);\n      }\n      var intValue2 = serverBValue.subtract(_this5.k.multiply(gModPowXN));\n      intValue2.modPow(_this5.smallAValue.add(_this5.UValue.multiply(xValue)), _this5.N, function(err2, result) {\n        if (err2) {\n          callback(err2, null);\n        }\n        callback(null, result.mod(_this5.N));\n      });\n    });\n  };\n  _proto.getNewPasswordRequiredChallengeUserAttributePrefix = function getNewPasswordRequiredChallengeUserAttributePrefix() {\n    return newPasswordRequiredChallengeUserAttributePrefix;\n  };\n  _proto.padHex = function padHex(bigInt) {\n    if (!(bigInt instanceof BigInteger_default)) {\n      throw new Error(\"Not a BigInteger\");\n    }\n    var isNegative = bigInt.compareTo(BigInteger_default.ZERO) < 0;\n    var hexStr = bigInt.abs().toString(16);\n    hexStr = hexStr.length % 2 !== 0 ? \"0\" + hexStr : hexStr;\n    hexStr = HEX_MSB_REGEX.test(hexStr) ? \"00\" + hexStr : hexStr;\n    if (isNegative) {\n      var invertedNibbles = hexStr.split(\"\").map(function(x) {\n        var invertedNibble = ~parseInt(x, 16) & 15;\n        return \"0123456789ABCDEF\".charAt(invertedNibble);\n      }).join(\"\");\n      var flippedBitsBI = new BigInteger_default(invertedNibbles, 16).add(BigInteger_default.ONE);\n      hexStr = flippedBitsBI.toString(16);\n      if (hexStr.toUpperCase().startsWith(\"FF8\")) {\n        hexStr = hexStr.substring(2);\n      }\n    }\n    return hexStr;\n  };\n  return AuthenticationHelper2;\n}();\n\n// node_modules/amazon-cognito-identity-js/es/CognitoAccessToken.js\nvar import_dist11 = __toESM(require_dist());\n\n// node_modules/amazon-cognito-identity-js/es/CognitoJwtToken.js\nvar import_dist10 = __toESM(require_dist());\nvar import_buffer2 = __toESM(require_buffer_polyfill());\nvar CognitoJwtToken = function() {\n  function CognitoJwtToken2(token) {\n    this.jwtToken = token || \"\";\n    this.payload = this.decodePayload();\n  }\n  var _proto = CognitoJwtToken2.prototype;\n  _proto.getJwtToken = function getJwtToken() {\n    return this.jwtToken;\n  };\n  _proto.getExpiration = function getExpiration() {\n    return this.payload.exp;\n  };\n  _proto.getIssuedAt = function getIssuedAt() {\n    return this.payload.iat;\n  };\n  _proto.decodePayload = function decodePayload() {\n    var payload = this.jwtToken.split(\".\")[1];\n    try {\n      return JSON.parse(import_buffer2.Buffer.from(payload, \"base64\").toString(\"utf8\"));\n    } catch (err) {\n      return {};\n    }\n  };\n  return CognitoJwtToken2;\n}();\n\n// node_modules/amazon-cognito-identity-js/es/CognitoAccessToken.js\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf4(o2, p2) {\n    o2.__proto__ = p2;\n    return o2;\n  };\n  return _setPrototypeOf(o, p);\n}\nvar CognitoAccessToken = function(_CognitoJwtToken) {\n  _inheritsLoose(CognitoAccessToken2, _CognitoJwtToken);\n  function CognitoAccessToken2(_temp) {\n    var _ref = _temp === void 0 ? {} : _temp, AccessToken = _ref.AccessToken;\n    return _CognitoJwtToken.call(this, AccessToken || \"\") || this;\n  }\n  return CognitoAccessToken2;\n}(CognitoJwtToken);\n\n// node_modules/amazon-cognito-identity-js/es/CognitoIdToken.js\nvar import_dist12 = __toESM(require_dist());\nfunction _inheritsLoose2(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  _setPrototypeOf2(subClass, superClass);\n}\nfunction _setPrototypeOf2(o, p) {\n  _setPrototypeOf2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf4(o2, p2) {\n    o2.__proto__ = p2;\n    return o2;\n  };\n  return _setPrototypeOf2(o, p);\n}\nvar CognitoIdToken = function(_CognitoJwtToken) {\n  _inheritsLoose2(CognitoIdToken2, _CognitoJwtToken);\n  function CognitoIdToken2(_temp) {\n    var _ref = _temp === void 0 ? {} : _temp, IdToken = _ref.IdToken;\n    return _CognitoJwtToken.call(this, IdToken || \"\") || this;\n  }\n  return CognitoIdToken2;\n}(CognitoJwtToken);\n\n// node_modules/amazon-cognito-identity-js/es/CognitoRefreshToken.js\nvar import_dist13 = __toESM(require_dist());\nvar CognitoRefreshToken = function() {\n  function CognitoRefreshToken2(_temp) {\n    var _ref = _temp === void 0 ? {} : _temp, RefreshToken = _ref.RefreshToken;\n    this.token = RefreshToken || \"\";\n  }\n  var _proto = CognitoRefreshToken2.prototype;\n  _proto.getToken = function getToken() {\n    return this.token;\n  };\n  return CognitoRefreshToken2;\n}();\n\n// node_modules/amazon-cognito-identity-js/es/CognitoUser.js\nvar import_dist20 = __toESM(require_dist());\nvar import_buffer3 = __toESM(require_buffer_polyfill());\nvar import_sha256_js2 = __toESM(require_build2());\n\n// node_modules/amazon-cognito-identity-js/es/Platform/index.js\nvar import_dist15 = __toESM(require_dist());\n\n// node_modules/amazon-cognito-identity-js/es/Platform/version.js\nvar import_dist14 = __toESM(require_dist());\nvar version = \"5.0.4\";\n\n// node_modules/amazon-cognito-identity-js/es/Platform/index.js\nvar BASE_USER_AGENT = \"aws-amplify/\" + version;\nvar Platform = {\n  userAgent: BASE_USER_AGENT,\n  isReactNative: typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\"\n};\nvar getUserAgent = function getUserAgent2() {\n  return Platform.userAgent;\n};\n\n// node_modules/amazon-cognito-identity-js/es/CognitoUserSession.js\nvar import_dist16 = __toESM(require_dist());\nvar CognitoUserSession = function() {\n  function CognitoUserSession2(_temp) {\n    var _ref = _temp === void 0 ? {} : _temp, IdToken = _ref.IdToken, RefreshToken = _ref.RefreshToken, AccessToken = _ref.AccessToken, ClockDrift = _ref.ClockDrift;\n    if (AccessToken == null || IdToken == null) {\n      throw new Error(\"Id token and Access Token must be present.\");\n    }\n    this.idToken = IdToken;\n    this.refreshToken = RefreshToken;\n    this.accessToken = AccessToken;\n    this.clockDrift = ClockDrift === void 0 ? this.calculateClockDrift() : ClockDrift;\n  }\n  var _proto = CognitoUserSession2.prototype;\n  _proto.getIdToken = function getIdToken() {\n    return this.idToken;\n  };\n  _proto.getRefreshToken = function getRefreshToken() {\n    return this.refreshToken;\n  };\n  _proto.getAccessToken = function getAccessToken() {\n    return this.accessToken;\n  };\n  _proto.getClockDrift = function getClockDrift() {\n    return this.clockDrift;\n  };\n  _proto.calculateClockDrift = function calculateClockDrift() {\n    var now = Math.floor(/* @__PURE__ */ new Date() / 1e3);\n    var iat = Math.min(this.accessToken.getIssuedAt(), this.idToken.getIssuedAt());\n    return now - iat;\n  };\n  _proto.isValid = function isValid() {\n    var now = Math.floor(/* @__PURE__ */ new Date() / 1e3);\n    var adjusted = now - this.clockDrift;\n    return adjusted < this.accessToken.getExpiration() && adjusted < this.idToken.getExpiration();\n  };\n  return CognitoUserSession2;\n}();\n\n// node_modules/amazon-cognito-identity-js/es/DateHelper.js\nvar import_dist17 = __toESM(require_dist());\nvar monthNames = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\nvar weekNames = [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"];\nvar DateHelper = function() {\n  function DateHelper2() {\n  }\n  var _proto = DateHelper2.prototype;\n  _proto.getNowString = function getNowString() {\n    var now = /* @__PURE__ */ new Date();\n    var weekDay = weekNames[now.getUTCDay()];\n    var month = monthNames[now.getUTCMonth()];\n    var day = now.getUTCDate();\n    var hours = now.getUTCHours();\n    if (hours < 10) {\n      hours = \"0\" + hours;\n    }\n    var minutes = now.getUTCMinutes();\n    if (minutes < 10) {\n      minutes = \"0\" + minutes;\n    }\n    var seconds = now.getUTCSeconds();\n    if (seconds < 10) {\n      seconds = \"0\" + seconds;\n    }\n    var year = now.getUTCFullYear();\n    var dateNow = weekDay + \" \" + month + \" \" + day + \" \" + hours + \":\" + minutes + \":\" + seconds + \" UTC \" + year;\n    return dateNow;\n  };\n  return DateHelper2;\n}();\n\n// node_modules/amazon-cognito-identity-js/es/CognitoUserAttribute.js\nvar import_dist18 = __toESM(require_dist());\nvar CognitoUserAttribute = function() {\n  function CognitoUserAttribute2(_temp) {\n    var _ref = _temp === void 0 ? {} : _temp, Name = _ref.Name, Value = _ref.Value;\n    this.Name = Name || \"\";\n    this.Value = Value || \"\";\n  }\n  var _proto = CognitoUserAttribute2.prototype;\n  _proto.getValue = function getValue() {\n    return this.Value;\n  };\n  _proto.setValue = function setValue(value) {\n    this.Value = value;\n    return this;\n  };\n  _proto.getName = function getName() {\n    return this.Name;\n  };\n  _proto.setName = function setName(name) {\n    this.Name = name;\n    return this;\n  };\n  _proto.toString = function toString() {\n    return JSON.stringify(this);\n  };\n  _proto.toJSON = function toJSON() {\n    return {\n      Name: this.Name,\n      Value: this.Value\n    };\n  };\n  return CognitoUserAttribute2;\n}();\n\n// node_modules/amazon-cognito-identity-js/es/StorageHelper.js\nvar import_dist19 = __toESM(require_dist());\nvar dataMemory = {};\nvar MemoryStorage = function() {\n  function MemoryStorage2() {\n  }\n  MemoryStorage2.setItem = function setItem(key, value) {\n    dataMemory[key] = value;\n    return dataMemory[key];\n  };\n  MemoryStorage2.getItem = function getItem(key) {\n    return Object.prototype.hasOwnProperty.call(dataMemory, key) ? dataMemory[key] : void 0;\n  };\n  MemoryStorage2.removeItem = function removeItem(key) {\n    return delete dataMemory[key];\n  };\n  MemoryStorage2.clear = function clear() {\n    dataMemory = {};\n    return dataMemory;\n  };\n  return MemoryStorage2;\n}();\nvar StorageHelper = function() {\n  function StorageHelper2() {\n    try {\n      this.storageWindow = window.localStorage;\n      this.storageWindow.setItem(\"aws.cognito.test-ls\", 1);\n      this.storageWindow.removeItem(\"aws.cognito.test-ls\");\n    } catch (exception) {\n      this.storageWindow = MemoryStorage;\n    }\n  }\n  var _proto = StorageHelper2.prototype;\n  _proto.getStorage = function getStorage() {\n    return this.storageWindow;\n  };\n  return StorageHelper2;\n}();\n\n// node_modules/amazon-cognito-identity-js/es/CognitoUser.js\nvar isNavigatorAvailable = typeof navigator !== \"undefined\";\nvar userAgent = isNavigatorAvailable ? Platform.isReactNative ? \"react-native\" : navigator.userAgent : \"nodejs\";\nvar CognitoUser = function() {\n  function CognitoUser2(data) {\n    if (data == null || data.Username == null || data.Pool == null) {\n      throw new Error(\"Username and Pool information are required.\");\n    }\n    this.username = data.Username || \"\";\n    this.pool = data.Pool;\n    this.Session = null;\n    this.client = data.Pool.client;\n    this.signInUserSession = null;\n    this.authenticationFlowType = \"USER_SRP_AUTH\";\n    this.storage = data.Storage || new StorageHelper().getStorage();\n    this.keyPrefix = \"CognitoIdentityServiceProvider.\" + this.pool.getClientId();\n    this.userDataKey = this.keyPrefix + \".\" + this.username + \".userData\";\n  }\n  var _proto = CognitoUser2.prototype;\n  _proto.setSignInUserSession = function setSignInUserSession(signInUserSession) {\n    this.clearCachedUserData();\n    this.signInUserSession = signInUserSession;\n    this.cacheTokens();\n  };\n  _proto.getSignInUserSession = function getSignInUserSession() {\n    return this.signInUserSession;\n  };\n  _proto.getUsername = function getUsername() {\n    return this.username;\n  };\n  _proto.getAuthenticationFlowType = function getAuthenticationFlowType() {\n    return this.authenticationFlowType;\n  };\n  _proto.setAuthenticationFlowType = function setAuthenticationFlowType(authenticationFlowType) {\n    this.authenticationFlowType = authenticationFlowType;\n  };\n  _proto.initiateAuth = function initiateAuth(authDetails, callback) {\n    var _this = this;\n    var authParameters = authDetails.getAuthParameters();\n    authParameters.USERNAME = this.username;\n    var clientMetaData = Object.keys(authDetails.getValidationData()).length !== 0 ? authDetails.getValidationData() : authDetails.getClientMetadata();\n    var jsonReq = {\n      AuthFlow: \"CUSTOM_AUTH\",\n      ClientId: this.pool.getClientId(),\n      AuthParameters: authParameters,\n      ClientMetadata: clientMetaData\n    };\n    if (this.getUserContextData()) {\n      jsonReq.UserContextData = this.getUserContextData();\n    }\n    this.client.request(\"InitiateAuth\", jsonReq, function(err, data) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      var challengeName = data.ChallengeName;\n      var challengeParameters = data.ChallengeParameters;\n      if (challengeName === \"CUSTOM_CHALLENGE\") {\n        _this.Session = data.Session;\n        return callback.customChallenge(challengeParameters);\n      }\n      _this.signInUserSession = _this.getCognitoUserSession(data.AuthenticationResult);\n      _this.cacheTokens();\n      return callback.onSuccess(_this.signInUserSession);\n    });\n  };\n  _proto.authenticateUser = function authenticateUser(authDetails, callback) {\n    if (this.authenticationFlowType === \"USER_PASSWORD_AUTH\") {\n      return this.authenticateUserPlainUsernamePassword(authDetails, callback);\n    } else if (this.authenticationFlowType === \"USER_SRP_AUTH\" || this.authenticationFlowType === \"CUSTOM_AUTH\") {\n      return this.authenticateUserDefaultAuth(authDetails, callback);\n    }\n    return callback.onFailure(new Error(\"Authentication flow type is invalid.\"));\n  };\n  _proto.authenticateUserDefaultAuth = function authenticateUserDefaultAuth(authDetails, callback) {\n    var _this2 = this;\n    var authenticationHelper = new AuthenticationHelper(this.pool.getUserPoolName());\n    var dateHelper = new DateHelper();\n    var serverBValue;\n    var salt;\n    var authParameters = {};\n    if (this.deviceKey != null) {\n      authParameters.DEVICE_KEY = this.deviceKey;\n    }\n    authParameters.USERNAME = this.username;\n    authenticationHelper.getLargeAValue(function(errOnAValue, aValue) {\n      if (errOnAValue) {\n        callback.onFailure(errOnAValue);\n      }\n      authParameters.SRP_A = aValue.toString(16);\n      if (_this2.authenticationFlowType === \"CUSTOM_AUTH\") {\n        authParameters.CHALLENGE_NAME = \"SRP_A\";\n      }\n      var clientMetaData = Object.keys(authDetails.getValidationData()).length !== 0 ? authDetails.getValidationData() : authDetails.getClientMetadata();\n      var jsonReq = {\n        AuthFlow: _this2.authenticationFlowType,\n        ClientId: _this2.pool.getClientId(),\n        AuthParameters: authParameters,\n        ClientMetadata: clientMetaData\n      };\n      if (_this2.getUserContextData(_this2.username)) {\n        jsonReq.UserContextData = _this2.getUserContextData(_this2.username);\n      }\n      _this2.client.request(\"InitiateAuth\", jsonReq, function(err, data) {\n        if (err) {\n          return callback.onFailure(err);\n        }\n        var challengeParameters = data.ChallengeParameters;\n        _this2.username = challengeParameters.USER_ID_FOR_SRP;\n        _this2.userDataKey = _this2.keyPrefix + \".\" + _this2.username + \".userData\";\n        serverBValue = new BigInteger_default(challengeParameters.SRP_B, 16);\n        salt = new BigInteger_default(challengeParameters.SALT, 16);\n        _this2.getCachedDeviceKeyAndPassword();\n        authenticationHelper.getPasswordAuthenticationKey(_this2.username, authDetails.getPassword(), serverBValue, salt, function(errOnHkdf, hkdf) {\n          if (errOnHkdf) {\n            callback.onFailure(errOnHkdf);\n          }\n          var dateNow = dateHelper.getNowString();\n          var concatBuffer = import_buffer3.Buffer.concat([import_buffer3.Buffer.from(_this2.pool.getUserPoolName(), \"utf8\"), import_buffer3.Buffer.from(_this2.username, \"utf8\"), import_buffer3.Buffer.from(challengeParameters.SECRET_BLOCK, \"base64\"), import_buffer3.Buffer.from(dateNow, \"utf8\")]);\n          var awsCryptoHash = new import_sha256_js2.Sha256(hkdf);\n          awsCryptoHash.update(concatBuffer);\n          var resultFromAWSCrypto = awsCryptoHash.digestSync();\n          var signatureString = import_buffer3.Buffer.from(resultFromAWSCrypto).toString(\"base64\");\n          var challengeResponses = {};\n          challengeResponses.USERNAME = _this2.username;\n          challengeResponses.PASSWORD_CLAIM_SECRET_BLOCK = challengeParameters.SECRET_BLOCK;\n          challengeResponses.TIMESTAMP = dateNow;\n          challengeResponses.PASSWORD_CLAIM_SIGNATURE = signatureString;\n          if (_this2.deviceKey != null) {\n            challengeResponses.DEVICE_KEY = _this2.deviceKey;\n          }\n          var respondToAuthChallenge = function respondToAuthChallenge2(challenge, challengeCallback) {\n            return _this2.client.request(\"RespondToAuthChallenge\", challenge, function(errChallenge, dataChallenge) {\n              if (errChallenge && errChallenge.code === \"ResourceNotFoundException\" && errChallenge.message.toLowerCase().indexOf(\"device\") !== -1) {\n                challengeResponses.DEVICE_KEY = null;\n                _this2.deviceKey = null;\n                _this2.randomPassword = null;\n                _this2.deviceGroupKey = null;\n                _this2.clearCachedDeviceKeyAndPassword();\n                return respondToAuthChallenge2(challenge, challengeCallback);\n              }\n              return challengeCallback(errChallenge, dataChallenge);\n            });\n          };\n          var jsonReqResp = {\n            ChallengeName: \"PASSWORD_VERIFIER\",\n            ClientId: _this2.pool.getClientId(),\n            ChallengeResponses: challengeResponses,\n            Session: data.Session,\n            ClientMetadata: clientMetaData\n          };\n          if (_this2.getUserContextData()) {\n            jsonReqResp.UserContextData = _this2.getUserContextData();\n          }\n          respondToAuthChallenge(jsonReqResp, function(errAuthenticate, dataAuthenticate) {\n            if (errAuthenticate) {\n              return callback.onFailure(errAuthenticate);\n            }\n            return _this2.authenticateUserInternal(dataAuthenticate, authenticationHelper, callback);\n          });\n          return void 0;\n        });\n        return void 0;\n      });\n    });\n  };\n  _proto.authenticateUserPlainUsernamePassword = function authenticateUserPlainUsernamePassword(authDetails, callback) {\n    var _this3 = this;\n    var authParameters = {};\n    authParameters.USERNAME = this.username;\n    authParameters.PASSWORD = authDetails.getPassword();\n    if (!authParameters.PASSWORD) {\n      callback.onFailure(new Error(\"PASSWORD parameter is required\"));\n      return;\n    }\n    var authenticationHelper = new AuthenticationHelper(this.pool.getUserPoolName());\n    this.getCachedDeviceKeyAndPassword();\n    if (this.deviceKey != null) {\n      authParameters.DEVICE_KEY = this.deviceKey;\n    }\n    var clientMetaData = Object.keys(authDetails.getValidationData()).length !== 0 ? authDetails.getValidationData() : authDetails.getClientMetadata();\n    var jsonReq = {\n      AuthFlow: \"USER_PASSWORD_AUTH\",\n      ClientId: this.pool.getClientId(),\n      AuthParameters: authParameters,\n      ClientMetadata: clientMetaData\n    };\n    if (this.getUserContextData(this.username)) {\n      jsonReq.UserContextData = this.getUserContextData(this.username);\n    }\n    this.client.request(\"InitiateAuth\", jsonReq, function(err, authResult) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      return _this3.authenticateUserInternal(authResult, authenticationHelper, callback);\n    });\n  };\n  _proto.authenticateUserInternal = function authenticateUserInternal(dataAuthenticate, authenticationHelper, callback) {\n    var _this4 = this;\n    var challengeName = dataAuthenticate.ChallengeName;\n    var challengeParameters = dataAuthenticate.ChallengeParameters;\n    if (challengeName === \"SMS_MFA\") {\n      this.Session = dataAuthenticate.Session;\n      return callback.mfaRequired(challengeName, challengeParameters);\n    }\n    if (challengeName === \"SELECT_MFA_TYPE\") {\n      this.Session = dataAuthenticate.Session;\n      return callback.selectMFAType(challengeName, challengeParameters);\n    }\n    if (challengeName === \"MFA_SETUP\") {\n      this.Session = dataAuthenticate.Session;\n      return callback.mfaSetup(challengeName, challengeParameters);\n    }\n    if (challengeName === \"SOFTWARE_TOKEN_MFA\") {\n      this.Session = dataAuthenticate.Session;\n      return callback.totpRequired(challengeName, challengeParameters);\n    }\n    if (challengeName === \"CUSTOM_CHALLENGE\") {\n      this.Session = dataAuthenticate.Session;\n      return callback.customChallenge(challengeParameters);\n    }\n    if (challengeName === \"NEW_PASSWORD_REQUIRED\") {\n      this.Session = dataAuthenticate.Session;\n      var userAttributes = null;\n      var rawRequiredAttributes = null;\n      var requiredAttributes = [];\n      var userAttributesPrefix = authenticationHelper.getNewPasswordRequiredChallengeUserAttributePrefix();\n      if (challengeParameters) {\n        userAttributes = JSON.parse(dataAuthenticate.ChallengeParameters.userAttributes);\n        rawRequiredAttributes = JSON.parse(dataAuthenticate.ChallengeParameters.requiredAttributes);\n      }\n      if (rawRequiredAttributes) {\n        for (var i = 0; i < rawRequiredAttributes.length; i++) {\n          requiredAttributes[i] = rawRequiredAttributes[i].substr(userAttributesPrefix.length);\n        }\n      }\n      return callback.newPasswordRequired(userAttributes, requiredAttributes);\n    }\n    if (challengeName === \"DEVICE_SRP_AUTH\") {\n      this.Session = dataAuthenticate.Session;\n      this.getDeviceResponse(callback);\n      return void 0;\n    }\n    this.signInUserSession = this.getCognitoUserSession(dataAuthenticate.AuthenticationResult);\n    this.challengeName = challengeName;\n    this.cacheTokens();\n    var newDeviceMetadata = dataAuthenticate.AuthenticationResult.NewDeviceMetadata;\n    if (newDeviceMetadata == null) {\n      return callback.onSuccess(this.signInUserSession);\n    }\n    authenticationHelper.generateHashDevice(dataAuthenticate.AuthenticationResult.NewDeviceMetadata.DeviceGroupKey, dataAuthenticate.AuthenticationResult.NewDeviceMetadata.DeviceKey, function(errGenHash) {\n      if (errGenHash) {\n        return callback.onFailure(errGenHash);\n      }\n      var deviceSecretVerifierConfig = {\n        Salt: import_buffer3.Buffer.from(authenticationHelper.getSaltDevices(), \"hex\").toString(\"base64\"),\n        PasswordVerifier: import_buffer3.Buffer.from(authenticationHelper.getVerifierDevices(), \"hex\").toString(\"base64\")\n      };\n      _this4.verifierDevices = deviceSecretVerifierConfig.PasswordVerifier;\n      _this4.deviceGroupKey = newDeviceMetadata.DeviceGroupKey;\n      _this4.randomPassword = authenticationHelper.getRandomPassword();\n      _this4.client.request(\"ConfirmDevice\", {\n        DeviceKey: newDeviceMetadata.DeviceKey,\n        AccessToken: _this4.signInUserSession.getAccessToken().getJwtToken(),\n        DeviceSecretVerifierConfig: deviceSecretVerifierConfig,\n        DeviceName: userAgent\n      }, function(errConfirm, dataConfirm) {\n        if (errConfirm) {\n          return callback.onFailure(errConfirm);\n        }\n        _this4.deviceKey = dataAuthenticate.AuthenticationResult.NewDeviceMetadata.DeviceKey;\n        _this4.cacheDeviceKeyAndPassword();\n        if (dataConfirm.UserConfirmationNecessary === true) {\n          return callback.onSuccess(_this4.signInUserSession, dataConfirm.UserConfirmationNecessary);\n        }\n        return callback.onSuccess(_this4.signInUserSession);\n      });\n      return void 0;\n    });\n    return void 0;\n  };\n  _proto.completeNewPasswordChallenge = function completeNewPasswordChallenge(newPassword, requiredAttributeData, callback, clientMetadata) {\n    var _this5 = this;\n    if (!newPassword) {\n      return callback.onFailure(new Error(\"New password is required.\"));\n    }\n    var authenticationHelper = new AuthenticationHelper(this.pool.getUserPoolName());\n    var userAttributesPrefix = authenticationHelper.getNewPasswordRequiredChallengeUserAttributePrefix();\n    var finalUserAttributes = {};\n    if (requiredAttributeData) {\n      Object.keys(requiredAttributeData).forEach(function(key) {\n        finalUserAttributes[userAttributesPrefix + key] = requiredAttributeData[key];\n      });\n    }\n    finalUserAttributes.NEW_PASSWORD = newPassword;\n    finalUserAttributes.USERNAME = this.username;\n    var jsonReq = {\n      ChallengeName: \"NEW_PASSWORD_REQUIRED\",\n      ClientId: this.pool.getClientId(),\n      ChallengeResponses: finalUserAttributes,\n      Session: this.Session,\n      ClientMetadata: clientMetadata\n    };\n    if (this.getUserContextData()) {\n      jsonReq.UserContextData = this.getUserContextData();\n    }\n    this.client.request(\"RespondToAuthChallenge\", jsonReq, function(errAuthenticate, dataAuthenticate) {\n      if (errAuthenticate) {\n        return callback.onFailure(errAuthenticate);\n      }\n      return _this5.authenticateUserInternal(dataAuthenticate, authenticationHelper, callback);\n    });\n    return void 0;\n  };\n  _proto.getDeviceResponse = function getDeviceResponse(callback, clientMetadata) {\n    var _this6 = this;\n    var authenticationHelper = new AuthenticationHelper(this.deviceGroupKey);\n    var dateHelper = new DateHelper();\n    var authParameters = {};\n    authParameters.USERNAME = this.username;\n    authParameters.DEVICE_KEY = this.deviceKey;\n    authenticationHelper.getLargeAValue(function(errAValue, aValue) {\n      if (errAValue) {\n        callback.onFailure(errAValue);\n      }\n      authParameters.SRP_A = aValue.toString(16);\n      var jsonReq = {\n        ChallengeName: \"DEVICE_SRP_AUTH\",\n        ClientId: _this6.pool.getClientId(),\n        ChallengeResponses: authParameters,\n        ClientMetadata: clientMetadata,\n        Session: _this6.Session\n      };\n      if (_this6.getUserContextData()) {\n        jsonReq.UserContextData = _this6.getUserContextData();\n      }\n      _this6.client.request(\"RespondToAuthChallenge\", jsonReq, function(err, data) {\n        if (err) {\n          return callback.onFailure(err);\n        }\n        var challengeParameters = data.ChallengeParameters;\n        var serverBValue = new BigInteger_default(challengeParameters.SRP_B, 16);\n        var salt = new BigInteger_default(challengeParameters.SALT, 16);\n        authenticationHelper.getPasswordAuthenticationKey(_this6.deviceKey, _this6.randomPassword, serverBValue, salt, function(errHkdf, hkdf) {\n          if (errHkdf) {\n            return callback.onFailure(errHkdf);\n          }\n          var dateNow = dateHelper.getNowString();\n          var concatBuffer = import_buffer3.Buffer.concat([import_buffer3.Buffer.from(_this6.deviceGroupKey, \"utf8\"), import_buffer3.Buffer.from(_this6.deviceKey, \"utf8\"), import_buffer3.Buffer.from(challengeParameters.SECRET_BLOCK, \"base64\"), import_buffer3.Buffer.from(dateNow, \"utf8\")]);\n          var awsCryptoHash = new import_sha256_js2.Sha256(hkdf);\n          awsCryptoHash.update(concatBuffer);\n          var resultFromAWSCrypto = awsCryptoHash.digestSync();\n          var signatureString = import_buffer3.Buffer.from(resultFromAWSCrypto).toString(\"base64\");\n          var challengeResponses = {};\n          challengeResponses.USERNAME = _this6.username;\n          challengeResponses.PASSWORD_CLAIM_SECRET_BLOCK = challengeParameters.SECRET_BLOCK;\n          challengeResponses.TIMESTAMP = dateNow;\n          challengeResponses.PASSWORD_CLAIM_SIGNATURE = signatureString;\n          challengeResponses.DEVICE_KEY = _this6.deviceKey;\n          var jsonReqResp = {\n            ChallengeName: \"DEVICE_PASSWORD_VERIFIER\",\n            ClientId: _this6.pool.getClientId(),\n            ChallengeResponses: challengeResponses,\n            Session: data.Session\n          };\n          if (_this6.getUserContextData()) {\n            jsonReqResp.UserContextData = _this6.getUserContextData();\n          }\n          _this6.client.request(\"RespondToAuthChallenge\", jsonReqResp, function(errAuthenticate, dataAuthenticate) {\n            if (errAuthenticate) {\n              return callback.onFailure(errAuthenticate);\n            }\n            _this6.signInUserSession = _this6.getCognitoUserSession(dataAuthenticate.AuthenticationResult);\n            _this6.cacheTokens();\n            return callback.onSuccess(_this6.signInUserSession);\n          });\n          return void 0;\n        });\n        return void 0;\n      });\n    });\n  };\n  _proto.confirmRegistration = function confirmRegistration(confirmationCode, forceAliasCreation, callback, clientMetadata) {\n    var jsonReq = {\n      ClientId: this.pool.getClientId(),\n      ConfirmationCode: confirmationCode,\n      Username: this.username,\n      ForceAliasCreation: forceAliasCreation,\n      ClientMetadata: clientMetadata\n    };\n    if (this.getUserContextData()) {\n      jsonReq.UserContextData = this.getUserContextData();\n    }\n    this.client.request(\"ConfirmSignUp\", jsonReq, function(err) {\n      if (err) {\n        return callback(err, null);\n      }\n      return callback(null, \"SUCCESS\");\n    });\n  };\n  _proto.sendCustomChallengeAnswer = function sendCustomChallengeAnswer(answerChallenge, callback, clientMetadata) {\n    var _this7 = this;\n    var challengeResponses = {};\n    challengeResponses.USERNAME = this.username;\n    challengeResponses.ANSWER = answerChallenge;\n    var authenticationHelper = new AuthenticationHelper(this.pool.getUserPoolName());\n    this.getCachedDeviceKeyAndPassword();\n    if (this.deviceKey != null) {\n      challengeResponses.DEVICE_KEY = this.deviceKey;\n    }\n    var jsonReq = {\n      ChallengeName: \"CUSTOM_CHALLENGE\",\n      ChallengeResponses: challengeResponses,\n      ClientId: this.pool.getClientId(),\n      Session: this.Session,\n      ClientMetadata: clientMetadata\n    };\n    if (this.getUserContextData()) {\n      jsonReq.UserContextData = this.getUserContextData();\n    }\n    this.client.request(\"RespondToAuthChallenge\", jsonReq, function(err, data) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      return _this7.authenticateUserInternal(data, authenticationHelper, callback);\n    });\n  };\n  _proto.sendMFACode = function sendMFACode(confirmationCode, callback, mfaType, clientMetadata) {\n    var _this8 = this;\n    var challengeResponses = {};\n    challengeResponses.USERNAME = this.username;\n    challengeResponses.SMS_MFA_CODE = confirmationCode;\n    var mfaTypeSelection = mfaType || \"SMS_MFA\";\n    if (mfaTypeSelection === \"SOFTWARE_TOKEN_MFA\") {\n      challengeResponses.SOFTWARE_TOKEN_MFA_CODE = confirmationCode;\n    }\n    if (this.deviceKey != null) {\n      challengeResponses.DEVICE_KEY = this.deviceKey;\n    }\n    var jsonReq = {\n      ChallengeName: mfaTypeSelection,\n      ChallengeResponses: challengeResponses,\n      ClientId: this.pool.getClientId(),\n      Session: this.Session,\n      ClientMetadata: clientMetadata\n    };\n    if (this.getUserContextData()) {\n      jsonReq.UserContextData = this.getUserContextData();\n    }\n    this.client.request(\"RespondToAuthChallenge\", jsonReq, function(err, dataAuthenticate) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      var challengeName = dataAuthenticate.ChallengeName;\n      if (challengeName === \"DEVICE_SRP_AUTH\") {\n        _this8.getDeviceResponse(callback);\n        return void 0;\n      }\n      _this8.signInUserSession = _this8.getCognitoUserSession(dataAuthenticate.AuthenticationResult);\n      _this8.cacheTokens();\n      if (dataAuthenticate.AuthenticationResult.NewDeviceMetadata == null) {\n        return callback.onSuccess(_this8.signInUserSession);\n      }\n      var authenticationHelper = new AuthenticationHelper(_this8.pool.getUserPoolName());\n      authenticationHelper.generateHashDevice(dataAuthenticate.AuthenticationResult.NewDeviceMetadata.DeviceGroupKey, dataAuthenticate.AuthenticationResult.NewDeviceMetadata.DeviceKey, function(errGenHash) {\n        if (errGenHash) {\n          return callback.onFailure(errGenHash);\n        }\n        var deviceSecretVerifierConfig = {\n          Salt: import_buffer3.Buffer.from(authenticationHelper.getSaltDevices(), \"hex\").toString(\"base64\"),\n          PasswordVerifier: import_buffer3.Buffer.from(authenticationHelper.getVerifierDevices(), \"hex\").toString(\"base64\")\n        };\n        _this8.verifierDevices = deviceSecretVerifierConfig.PasswordVerifier;\n        _this8.deviceGroupKey = dataAuthenticate.AuthenticationResult.NewDeviceMetadata.DeviceGroupKey;\n        _this8.randomPassword = authenticationHelper.getRandomPassword();\n        _this8.client.request(\"ConfirmDevice\", {\n          DeviceKey: dataAuthenticate.AuthenticationResult.NewDeviceMetadata.DeviceKey,\n          AccessToken: _this8.signInUserSession.getAccessToken().getJwtToken(),\n          DeviceSecretVerifierConfig: deviceSecretVerifierConfig,\n          DeviceName: userAgent\n        }, function(errConfirm, dataConfirm) {\n          if (errConfirm) {\n            return callback.onFailure(errConfirm);\n          }\n          _this8.deviceKey = dataAuthenticate.AuthenticationResult.NewDeviceMetadata.DeviceKey;\n          _this8.cacheDeviceKeyAndPassword();\n          if (dataConfirm.UserConfirmationNecessary === true) {\n            return callback.onSuccess(_this8.signInUserSession, dataConfirm.UserConfirmationNecessary);\n          }\n          return callback.onSuccess(_this8.signInUserSession);\n        });\n        return void 0;\n      });\n      return void 0;\n    });\n  };\n  _proto.changePassword = function changePassword(oldUserPassword, newUserPassword, callback, clientMetadata) {\n    if (!(this.signInUserSession != null && this.signInUserSession.isValid())) {\n      return callback(new Error(\"User is not authenticated\"), null);\n    }\n    this.client.request(\"ChangePassword\", {\n      PreviousPassword: oldUserPassword,\n      ProposedPassword: newUserPassword,\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\n      ClientMetadata: clientMetadata\n    }, function(err) {\n      if (err) {\n        return callback(err, null);\n      }\n      return callback(null, \"SUCCESS\");\n    });\n    return void 0;\n  };\n  _proto.enableMFA = function enableMFA(callback) {\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback(new Error(\"User is not authenticated\"), null);\n    }\n    var mfaOptions = [];\n    var mfaEnabled = {\n      DeliveryMedium: \"SMS\",\n      AttributeName: \"phone_number\"\n    };\n    mfaOptions.push(mfaEnabled);\n    this.client.request(\"SetUserSettings\", {\n      MFAOptions: mfaOptions,\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\n    }, function(err) {\n      if (err) {\n        return callback(err, null);\n      }\n      return callback(null, \"SUCCESS\");\n    });\n    return void 0;\n  };\n  _proto.setUserMfaPreference = function setUserMfaPreference(smsMfaSettings, softwareTokenMfaSettings, callback) {\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback(new Error(\"User is not authenticated\"), null);\n    }\n    this.client.request(\"SetUserMFAPreference\", {\n      SMSMfaSettings: smsMfaSettings,\n      SoftwareTokenMfaSettings: softwareTokenMfaSettings,\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\n    }, function(err) {\n      if (err) {\n        return callback(err, null);\n      }\n      return callback(null, \"SUCCESS\");\n    });\n    return void 0;\n  };\n  _proto.disableMFA = function disableMFA(callback) {\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback(new Error(\"User is not authenticated\"), null);\n    }\n    var mfaOptions = [];\n    this.client.request(\"SetUserSettings\", {\n      MFAOptions: mfaOptions,\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\n    }, function(err) {\n      if (err) {\n        return callback(err, null);\n      }\n      return callback(null, \"SUCCESS\");\n    });\n    return void 0;\n  };\n  _proto.deleteUser = function deleteUser(callback, clientMetadata) {\n    var _this9 = this;\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback(new Error(\"User is not authenticated\"), null);\n    }\n    this.client.request(\"DeleteUser\", {\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\n      ClientMetadata: clientMetadata\n    }, function(err) {\n      if (err) {\n        return callback(err, null);\n      }\n      _this9.clearCachedUser();\n      return callback(null, \"SUCCESS\");\n    });\n    return void 0;\n  };\n  _proto.updateAttributes = function updateAttributes(attributes, callback, clientMetadata) {\n    var _this10 = this;\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback(new Error(\"User is not authenticated\"), null);\n    }\n    this.client.request(\"UpdateUserAttributes\", {\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\n      UserAttributes: attributes,\n      ClientMetadata: clientMetadata\n    }, function(err, result) {\n      if (err) {\n        return callback(err, null);\n      }\n      return _this10.getUserData(function() {\n        return callback(null, \"SUCCESS\", result);\n      }, {\n        bypassCache: true\n      });\n    });\n    return void 0;\n  };\n  _proto.getUserAttributes = function getUserAttributes(callback) {\n    if (!(this.signInUserSession != null && this.signInUserSession.isValid())) {\n      return callback(new Error(\"User is not authenticated\"), null);\n    }\n    this.client.request(\"GetUser\", {\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\n    }, function(err, userData) {\n      if (err) {\n        return callback(err, null);\n      }\n      var attributeList = [];\n      for (var i = 0; i < userData.UserAttributes.length; i++) {\n        var attribute = {\n          Name: userData.UserAttributes[i].Name,\n          Value: userData.UserAttributes[i].Value\n        };\n        var userAttribute = new CognitoUserAttribute(attribute);\n        attributeList.push(userAttribute);\n      }\n      return callback(null, attributeList);\n    });\n    return void 0;\n  };\n  _proto.getMFAOptions = function getMFAOptions(callback) {\n    if (!(this.signInUserSession != null && this.signInUserSession.isValid())) {\n      return callback(new Error(\"User is not authenticated\"), null);\n    }\n    this.client.request(\"GetUser\", {\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\n    }, function(err, userData) {\n      if (err) {\n        return callback(err, null);\n      }\n      return callback(null, userData.MFAOptions);\n    });\n    return void 0;\n  };\n  _proto.createGetUserRequest = function createGetUserRequest() {\n    return this.client.promisifyRequest(\"GetUser\", {\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\n    });\n  };\n  _proto.refreshSessionIfPossible = function refreshSessionIfPossible(options) {\n    var _this11 = this;\n    if (options === void 0) {\n      options = {};\n    }\n    return new Promise(function(resolve) {\n      var refresh = _this11.signInUserSession.getRefreshToken();\n      if (refresh && refresh.getToken()) {\n        _this11.refreshSession(refresh, resolve, options.clientMetadata);\n      } else {\n        resolve();\n      }\n    });\n  };\n  _proto.getUserData = function getUserData(callback, params) {\n    var _this12 = this;\n    if (!(this.signInUserSession != null && this.signInUserSession.isValid())) {\n      this.clearCachedUserData();\n      return callback(new Error(\"User is not authenticated\"), null);\n    }\n    var userData = this.getUserDataFromCache();\n    if (!userData) {\n      this.fetchUserData().then(function(data) {\n        callback(null, data);\n      })[\"catch\"](callback);\n      return;\n    }\n    if (this.isFetchUserDataAndTokenRequired(params)) {\n      this.fetchUserData().then(function(data) {\n        return _this12.refreshSessionIfPossible(params).then(function() {\n          return data;\n        });\n      }).then(function(data) {\n        return callback(null, data);\n      })[\"catch\"](callback);\n      return;\n    }\n    try {\n      callback(null, JSON.parse(userData));\n      return;\n    } catch (err) {\n      this.clearCachedUserData();\n      callback(err, null);\n      return;\n    }\n  };\n  _proto.getUserDataFromCache = function getUserDataFromCache() {\n    var userData = this.storage.getItem(this.userDataKey);\n    return userData;\n  };\n  _proto.isFetchUserDataAndTokenRequired = function isFetchUserDataAndTokenRequired(params) {\n    var _ref = params || {}, _ref$bypassCache = _ref.bypassCache, bypassCache = _ref$bypassCache === void 0 ? false : _ref$bypassCache;\n    return bypassCache;\n  };\n  _proto.fetchUserData = function fetchUserData() {\n    var _this13 = this;\n    return this.createGetUserRequest().then(function(data) {\n      _this13.cacheUserData(data);\n      return data;\n    });\n  };\n  _proto.deleteAttributes = function deleteAttributes(attributeList, callback) {\n    var _this14 = this;\n    if (!(this.signInUserSession != null && this.signInUserSession.isValid())) {\n      return callback(new Error(\"User is not authenticated\"), null);\n    }\n    this.client.request(\"DeleteUserAttributes\", {\n      UserAttributeNames: attributeList,\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\n    }, function(err) {\n      if (err) {\n        return callback(err, null);\n      }\n      return _this14.getUserData(function() {\n        return callback(null, \"SUCCESS\");\n      }, {\n        bypassCache: true\n      });\n    });\n    return void 0;\n  };\n  _proto.resendConfirmationCode = function resendConfirmationCode(callback, clientMetadata) {\n    var jsonReq = {\n      ClientId: this.pool.getClientId(),\n      Username: this.username,\n      ClientMetadata: clientMetadata\n    };\n    this.client.request(\"ResendConfirmationCode\", jsonReq, function(err, result) {\n      if (err) {\n        return callback(err, null);\n      }\n      return callback(null, result);\n    });\n  };\n  _proto.getSession = function getSession(callback, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    if (this.username == null) {\n      return callback(new Error(\"Username is null. Cannot retrieve a new session\"), null);\n    }\n    if (this.signInUserSession != null && this.signInUserSession.isValid()) {\n      return callback(null, this.signInUserSession);\n    }\n    var keyPrefix = \"CognitoIdentityServiceProvider.\" + this.pool.getClientId() + \".\" + this.username;\n    var idTokenKey = keyPrefix + \".idToken\";\n    var accessTokenKey = keyPrefix + \".accessToken\";\n    var refreshTokenKey = keyPrefix + \".refreshToken\";\n    var clockDriftKey = keyPrefix + \".clockDrift\";\n    if (this.storage.getItem(idTokenKey)) {\n      var idToken = new CognitoIdToken({\n        IdToken: this.storage.getItem(idTokenKey)\n      });\n      var accessToken = new CognitoAccessToken({\n        AccessToken: this.storage.getItem(accessTokenKey)\n      });\n      var refreshToken = new CognitoRefreshToken({\n        RefreshToken: this.storage.getItem(refreshTokenKey)\n      });\n      var clockDrift = parseInt(this.storage.getItem(clockDriftKey), 0) || 0;\n      var sessionData = {\n        IdToken: idToken,\n        AccessToken: accessToken,\n        RefreshToken: refreshToken,\n        ClockDrift: clockDrift\n      };\n      var cachedSession = new CognitoUserSession(sessionData);\n      if (cachedSession.isValid()) {\n        this.signInUserSession = cachedSession;\n        return callback(null, this.signInUserSession);\n      }\n      if (!refreshToken.getToken()) {\n        return callback(new Error(\"Cannot retrieve a new session. Please authenticate.\"), null);\n      }\n      this.refreshSession(refreshToken, callback, options.clientMetadata);\n    } else {\n      callback(new Error(\"Local storage is missing an ID Token, Please authenticate\"), null);\n    }\n    return void 0;\n  };\n  _proto.refreshSession = function refreshSession(refreshToken, callback, clientMetadata) {\n    var _this15 = this;\n    var wrappedCallback = this.pool.wrapRefreshSessionCallback ? this.pool.wrapRefreshSessionCallback(callback) : callback;\n    var authParameters = {};\n    authParameters.REFRESH_TOKEN = refreshToken.getToken();\n    var keyPrefix = \"CognitoIdentityServiceProvider.\" + this.pool.getClientId();\n    var lastUserKey = keyPrefix + \".LastAuthUser\";\n    if (this.storage.getItem(lastUserKey)) {\n      this.username = this.storage.getItem(lastUserKey);\n      var deviceKeyKey = keyPrefix + \".\" + this.username + \".deviceKey\";\n      this.deviceKey = this.storage.getItem(deviceKeyKey);\n      authParameters.DEVICE_KEY = this.deviceKey;\n    }\n    var jsonReq = {\n      ClientId: this.pool.getClientId(),\n      AuthFlow: \"REFRESH_TOKEN_AUTH\",\n      AuthParameters: authParameters,\n      ClientMetadata: clientMetadata\n    };\n    if (this.getUserContextData()) {\n      jsonReq.UserContextData = this.getUserContextData();\n    }\n    this.client.request(\"InitiateAuth\", jsonReq, function(err, authResult) {\n      if (err) {\n        if (err.code === \"NotAuthorizedException\") {\n          _this15.clearCachedUser();\n        }\n        return wrappedCallback(err, null);\n      }\n      if (authResult) {\n        var authenticationResult = authResult.AuthenticationResult;\n        if (!Object.prototype.hasOwnProperty.call(authenticationResult, \"RefreshToken\")) {\n          authenticationResult.RefreshToken = refreshToken.getToken();\n        }\n        _this15.signInUserSession = _this15.getCognitoUserSession(authenticationResult);\n        _this15.cacheTokens();\n        return wrappedCallback(null, _this15.signInUserSession);\n      }\n      return void 0;\n    });\n  };\n  _proto.cacheTokens = function cacheTokens() {\n    var keyPrefix = \"CognitoIdentityServiceProvider.\" + this.pool.getClientId();\n    var idTokenKey = keyPrefix + \".\" + this.username + \".idToken\";\n    var accessTokenKey = keyPrefix + \".\" + this.username + \".accessToken\";\n    var refreshTokenKey = keyPrefix + \".\" + this.username + \".refreshToken\";\n    var clockDriftKey = keyPrefix + \".\" + this.username + \".clockDrift\";\n    var lastUserKey = keyPrefix + \".LastAuthUser\";\n    this.storage.setItem(idTokenKey, this.signInUserSession.getIdToken().getJwtToken());\n    this.storage.setItem(accessTokenKey, this.signInUserSession.getAccessToken().getJwtToken());\n    this.storage.setItem(refreshTokenKey, this.signInUserSession.getRefreshToken().getToken());\n    this.storage.setItem(clockDriftKey, \"\" + this.signInUserSession.getClockDrift());\n    this.storage.setItem(lastUserKey, this.username);\n  };\n  _proto.cacheUserData = function cacheUserData(userData) {\n    this.storage.setItem(this.userDataKey, JSON.stringify(userData));\n  };\n  _proto.clearCachedUserData = function clearCachedUserData() {\n    this.storage.removeItem(this.userDataKey);\n  };\n  _proto.clearCachedUser = function clearCachedUser() {\n    this.clearCachedTokens();\n    this.clearCachedUserData();\n  };\n  _proto.cacheDeviceKeyAndPassword = function cacheDeviceKeyAndPassword() {\n    var keyPrefix = \"CognitoIdentityServiceProvider.\" + this.pool.getClientId() + \".\" + this.username;\n    var deviceKeyKey = keyPrefix + \".deviceKey\";\n    var randomPasswordKey = keyPrefix + \".randomPasswordKey\";\n    var deviceGroupKeyKey = keyPrefix + \".deviceGroupKey\";\n    this.storage.setItem(deviceKeyKey, this.deviceKey);\n    this.storage.setItem(randomPasswordKey, this.randomPassword);\n    this.storage.setItem(deviceGroupKeyKey, this.deviceGroupKey);\n  };\n  _proto.getCachedDeviceKeyAndPassword = function getCachedDeviceKeyAndPassword() {\n    var keyPrefix = \"CognitoIdentityServiceProvider.\" + this.pool.getClientId() + \".\" + this.username;\n    var deviceKeyKey = keyPrefix + \".deviceKey\";\n    var randomPasswordKey = keyPrefix + \".randomPasswordKey\";\n    var deviceGroupKeyKey = keyPrefix + \".deviceGroupKey\";\n    if (this.storage.getItem(deviceKeyKey)) {\n      this.deviceKey = this.storage.getItem(deviceKeyKey);\n      this.randomPassword = this.storage.getItem(randomPasswordKey);\n      this.deviceGroupKey = this.storage.getItem(deviceGroupKeyKey);\n    }\n  };\n  _proto.clearCachedDeviceKeyAndPassword = function clearCachedDeviceKeyAndPassword() {\n    var keyPrefix = \"CognitoIdentityServiceProvider.\" + this.pool.getClientId() + \".\" + this.username;\n    var deviceKeyKey = keyPrefix + \".deviceKey\";\n    var randomPasswordKey = keyPrefix + \".randomPasswordKey\";\n    var deviceGroupKeyKey = keyPrefix + \".deviceGroupKey\";\n    this.storage.removeItem(deviceKeyKey);\n    this.storage.removeItem(randomPasswordKey);\n    this.storage.removeItem(deviceGroupKeyKey);\n  };\n  _proto.clearCachedTokens = function clearCachedTokens() {\n    var keyPrefix = \"CognitoIdentityServiceProvider.\" + this.pool.getClientId();\n    var idTokenKey = keyPrefix + \".\" + this.username + \".idToken\";\n    var accessTokenKey = keyPrefix + \".\" + this.username + \".accessToken\";\n    var refreshTokenKey = keyPrefix + \".\" + this.username + \".refreshToken\";\n    var lastUserKey = keyPrefix + \".LastAuthUser\";\n    var clockDriftKey = keyPrefix + \".\" + this.username + \".clockDrift\";\n    this.storage.removeItem(idTokenKey);\n    this.storage.removeItem(accessTokenKey);\n    this.storage.removeItem(refreshTokenKey);\n    this.storage.removeItem(lastUserKey);\n    this.storage.removeItem(clockDriftKey);\n  };\n  _proto.getCognitoUserSession = function getCognitoUserSession(authResult) {\n    var idToken = new CognitoIdToken(authResult);\n    var accessToken = new CognitoAccessToken(authResult);\n    var refreshToken = new CognitoRefreshToken(authResult);\n    var sessionData = {\n      IdToken: idToken,\n      AccessToken: accessToken,\n      RefreshToken: refreshToken\n    };\n    return new CognitoUserSession(sessionData);\n  };\n  _proto.forgotPassword = function forgotPassword(callback, clientMetadata) {\n    var jsonReq = {\n      ClientId: this.pool.getClientId(),\n      Username: this.username,\n      ClientMetadata: clientMetadata\n    };\n    if (this.getUserContextData()) {\n      jsonReq.UserContextData = this.getUserContextData();\n    }\n    this.client.request(\"ForgotPassword\", jsonReq, function(err, data) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      if (typeof callback.inputVerificationCode === \"function\") {\n        return callback.inputVerificationCode(data);\n      }\n      return callback.onSuccess(data);\n    });\n  };\n  _proto.confirmPassword = function confirmPassword(confirmationCode, newPassword, callback, clientMetadata) {\n    var jsonReq = {\n      ClientId: this.pool.getClientId(),\n      Username: this.username,\n      ConfirmationCode: confirmationCode,\n      Password: newPassword,\n      ClientMetadata: clientMetadata\n    };\n    if (this.getUserContextData()) {\n      jsonReq.UserContextData = this.getUserContextData();\n    }\n    this.client.request(\"ConfirmForgotPassword\", jsonReq, function(err) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      return callback.onSuccess(\"SUCCESS\");\n    });\n  };\n  _proto.getAttributeVerificationCode = function getAttributeVerificationCode(attributeName, callback, clientMetadata) {\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback.onFailure(new Error(\"User is not authenticated\"));\n    }\n    this.client.request(\"GetUserAttributeVerificationCode\", {\n      AttributeName: attributeName,\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\n      ClientMetadata: clientMetadata\n    }, function(err, data) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      if (typeof callback.inputVerificationCode === \"function\") {\n        return callback.inputVerificationCode(data);\n      }\n      return callback.onSuccess(\"SUCCESS\");\n    });\n    return void 0;\n  };\n  _proto.verifyAttribute = function verifyAttribute(attributeName, confirmationCode, callback) {\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback.onFailure(new Error(\"User is not authenticated\"));\n    }\n    this.client.request(\"VerifyUserAttribute\", {\n      AttributeName: attributeName,\n      Code: confirmationCode,\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\n    }, function(err) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      return callback.onSuccess(\"SUCCESS\");\n    });\n    return void 0;\n  };\n  _proto.getDevice = function getDevice(callback) {\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback.onFailure(new Error(\"User is not authenticated\"));\n    }\n    this.client.request(\"GetDevice\", {\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\n      DeviceKey: this.deviceKey\n    }, function(err, data) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      return callback.onSuccess(data);\n    });\n    return void 0;\n  };\n  _proto.forgetSpecificDevice = function forgetSpecificDevice(deviceKey, callback) {\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback.onFailure(new Error(\"User is not authenticated\"));\n    }\n    this.client.request(\"ForgetDevice\", {\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\n      DeviceKey: deviceKey\n    }, function(err) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      return callback.onSuccess(\"SUCCESS\");\n    });\n    return void 0;\n  };\n  _proto.forgetDevice = function forgetDevice(callback) {\n    var _this16 = this;\n    this.forgetSpecificDevice(this.deviceKey, {\n      onFailure: callback.onFailure,\n      onSuccess: function onSuccess(result) {\n        _this16.deviceKey = null;\n        _this16.deviceGroupKey = null;\n        _this16.randomPassword = null;\n        _this16.clearCachedDeviceKeyAndPassword();\n        return callback.onSuccess(result);\n      }\n    });\n  };\n  _proto.setDeviceStatusRemembered = function setDeviceStatusRemembered(callback) {\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback.onFailure(new Error(\"User is not authenticated\"));\n    }\n    this.client.request(\"UpdateDeviceStatus\", {\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\n      DeviceKey: this.deviceKey,\n      DeviceRememberedStatus: \"remembered\"\n    }, function(err) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      return callback.onSuccess(\"SUCCESS\");\n    });\n    return void 0;\n  };\n  _proto.setDeviceStatusNotRemembered = function setDeviceStatusNotRemembered(callback) {\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback.onFailure(new Error(\"User is not authenticated\"));\n    }\n    this.client.request(\"UpdateDeviceStatus\", {\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\n      DeviceKey: this.deviceKey,\n      DeviceRememberedStatus: \"not_remembered\"\n    }, function(err) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      return callback.onSuccess(\"SUCCESS\");\n    });\n    return void 0;\n  };\n  _proto.listDevices = function listDevices(limit, paginationToken, callback) {\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback.onFailure(new Error(\"User is not authenticated\"));\n    }\n    var requestParams = {\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\n      Limit: limit\n    };\n    if (paginationToken) {\n      requestParams.PaginationToken = paginationToken;\n    }\n    this.client.request(\"ListDevices\", requestParams, function(err, data) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      return callback.onSuccess(data);\n    });\n    return void 0;\n  };\n  _proto.globalSignOut = function globalSignOut(callback) {\n    var _this17 = this;\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback.onFailure(new Error(\"User is not authenticated\"));\n    }\n    this.client.request(\"GlobalSignOut\", {\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\n    }, function(err) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      _this17.clearCachedUser();\n      return callback.onSuccess(\"SUCCESS\");\n    });\n    return void 0;\n  };\n  _proto.signOut = function signOut(revokeTokenCallback) {\n    var _this18 = this;\n    if (!revokeTokenCallback || typeof revokeTokenCallback !== \"function\") {\n      this.cleanClientData();\n      return;\n    }\n    this.getSession(function(error, _session) {\n      if (error) {\n        return revokeTokenCallback(error);\n      }\n      _this18.revokeTokens(function(err) {\n        _this18.cleanClientData();\n        revokeTokenCallback(err);\n      });\n    });\n  };\n  _proto.revokeTokens = function revokeTokens(revokeTokenCallback) {\n    if (revokeTokenCallback === void 0) {\n      revokeTokenCallback = function revokeTokenCallback2() {\n      };\n    }\n    if (typeof revokeTokenCallback !== \"function\") {\n      throw new Error(\"Invalid revokeTokenCallback. It should be a function.\");\n    }\n    var tokensToBeRevoked = [];\n    if (!this.signInUserSession) {\n      var error = new Error(\"User is not authenticated\");\n      return revokeTokenCallback(error);\n    }\n    if (!this.signInUserSession.getAccessToken()) {\n      var _error = new Error(\"No Access token available\");\n      return revokeTokenCallback(_error);\n    }\n    var refreshToken = this.signInUserSession.getRefreshToken().getToken();\n    var accessToken = this.signInUserSession.getAccessToken();\n    if (this.isSessionRevocable(accessToken)) {\n      if (refreshToken) {\n        return this.revokeToken({\n          token: refreshToken,\n          callback: revokeTokenCallback\n        });\n      }\n    }\n    revokeTokenCallback();\n  };\n  _proto.isSessionRevocable = function isSessionRevocable(token) {\n    if (token && typeof token.decodePayload === \"function\") {\n      try {\n        var _token$decodePayload = token.decodePayload(), origin_jti = _token$decodePayload.origin_jti;\n        return !!origin_jti;\n      } catch (err) {\n      }\n    }\n    return false;\n  };\n  _proto.cleanClientData = function cleanClientData() {\n    this.signInUserSession = null;\n    this.clearCachedUser();\n  };\n  _proto.revokeToken = function revokeToken(_ref2) {\n    var token = _ref2.token, callback = _ref2.callback;\n    this.client.requestWithRetry(\"RevokeToken\", {\n      Token: token,\n      ClientId: this.pool.getClientId()\n    }, function(err) {\n      if (err) {\n        return callback(err);\n      }\n      callback();\n    });\n  };\n  _proto.sendMFASelectionAnswer = function sendMFASelectionAnswer(answerChallenge, callback) {\n    var _this19 = this;\n    var challengeResponses = {};\n    challengeResponses.USERNAME = this.username;\n    challengeResponses.ANSWER = answerChallenge;\n    var jsonReq = {\n      ChallengeName: \"SELECT_MFA_TYPE\",\n      ChallengeResponses: challengeResponses,\n      ClientId: this.pool.getClientId(),\n      Session: this.Session\n    };\n    if (this.getUserContextData()) {\n      jsonReq.UserContextData = this.getUserContextData();\n    }\n    this.client.request(\"RespondToAuthChallenge\", jsonReq, function(err, data) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      _this19.Session = data.Session;\n      if (answerChallenge === \"SMS_MFA\") {\n        return callback.mfaRequired(data.ChallengeName, data.ChallengeParameters);\n      }\n      if (answerChallenge === \"SOFTWARE_TOKEN_MFA\") {\n        return callback.totpRequired(data.ChallengeName, data.ChallengeParameters);\n      }\n      return void 0;\n    });\n  };\n  _proto.getUserContextData = function getUserContextData() {\n    var pool = this.pool;\n    return pool.getUserContextData(this.username);\n  };\n  _proto.associateSoftwareToken = function associateSoftwareToken(callback) {\n    var _this20 = this;\n    if (!(this.signInUserSession != null && this.signInUserSession.isValid())) {\n      this.client.request(\"AssociateSoftwareToken\", {\n        Session: this.Session\n      }, function(err, data) {\n        if (err) {\n          return callback.onFailure(err);\n        }\n        _this20.Session = data.Session;\n        return callback.associateSecretCode(data.SecretCode);\n      });\n    } else {\n      this.client.request(\"AssociateSoftwareToken\", {\n        AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\n      }, function(err, data) {\n        if (err) {\n          return callback.onFailure(err);\n        }\n        return callback.associateSecretCode(data.SecretCode);\n      });\n    }\n  };\n  _proto.verifySoftwareToken = function verifySoftwareToken(totpCode, friendlyDeviceName, callback) {\n    var _this21 = this;\n    if (!(this.signInUserSession != null && this.signInUserSession.isValid())) {\n      this.client.request(\"VerifySoftwareToken\", {\n        Session: this.Session,\n        UserCode: totpCode,\n        FriendlyDeviceName: friendlyDeviceName\n      }, function(err, data) {\n        if (err) {\n          return callback.onFailure(err);\n        }\n        _this21.Session = data.Session;\n        var challengeResponses = {};\n        challengeResponses.USERNAME = _this21.username;\n        var jsonReq = {\n          ChallengeName: \"MFA_SETUP\",\n          ClientId: _this21.pool.getClientId(),\n          ChallengeResponses: challengeResponses,\n          Session: _this21.Session\n        };\n        if (_this21.getUserContextData()) {\n          jsonReq.UserContextData = _this21.getUserContextData();\n        }\n        _this21.client.request(\"RespondToAuthChallenge\", jsonReq, function(errRespond, dataRespond) {\n          if (errRespond) {\n            return callback.onFailure(errRespond);\n          }\n          _this21.signInUserSession = _this21.getCognitoUserSession(dataRespond.AuthenticationResult);\n          _this21.cacheTokens();\n          return callback.onSuccess(_this21.signInUserSession);\n        });\n        return void 0;\n      });\n    } else {\n      this.client.request(\"VerifySoftwareToken\", {\n        AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\n        UserCode: totpCode,\n        FriendlyDeviceName: friendlyDeviceName\n      }, function(err, data) {\n        if (err) {\n          return callback.onFailure(err);\n        }\n        return callback.onSuccess(data);\n      });\n    }\n  };\n  return CognitoUser2;\n}();\n\n// node_modules/amazon-cognito-identity-js/es/CognitoUserPool.js\nvar import_dist25 = __toESM(require_dist());\n\n// node_modules/amazon-cognito-identity-js/es/Client.js\nvar import_dist24 = __toESM(require_dist());\nvar import_isomorphic_unfetch = __toESM(require_browser());\n\n// node_modules/amazon-cognito-identity-js/es/UserAgent.js\nvar import_dist23 = __toESM(require_dist());\n\n// node_modules/amazon-cognito-identity-js/es/Platform/constants.js\nvar import_dist22 = __toESM(require_dist());\n\n// node_modules/amazon-cognito-identity-js/es/UserAgent.js\nfunction UserAgent() {\n}\nUserAgent.prototype.userAgent = getUserAgent();\nvar appendToCognitoUserAgent = function appendToCognitoUserAgent2(content) {\n  if (!content) {\n    return;\n  }\n  if (UserAgent.prototype.userAgent && !UserAgent.prototype.userAgent.includes(content)) {\n    UserAgent.prototype.userAgent = UserAgent.prototype.userAgent.concat(\" \", content);\n  }\n  if (!UserAgent.prototype.userAgent || UserAgent.prototype.userAgent === \"\") {\n    UserAgent.prototype.userAgent = content;\n  }\n};\nvar getAmplifyUserAgent = function getAmplifyUserAgent2(action) {\n  var uaCategoryAction = UserAgent.category ? \" \" + UserAgent.category : \"\";\n  var uaFramework = UserAgent.framework ? \" framework/\" + UserAgent.framework : \"\";\n  var userAgent2 = \"\" + UserAgent.prototype.userAgent + uaCategoryAction + uaFramework;\n  return userAgent2;\n};\n\n// node_modules/amazon-cognito-identity-js/es/Client.js\nfunction _inheritsLoose3(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  _setPrototypeOf3(subClass, superClass);\n}\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? /* @__PURE__ */ new Map() : void 0;\n  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {\n    if (Class2 === null || !_isNativeFunction(Class2))\n      return Class2;\n    if (typeof Class2 !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class2))\n        return _cache.get(Class2);\n      _cache.set(Class2, Wrapper);\n    }\n    function Wrapper() {\n      return _construct(Class2, arguments, _getPrototypeOf(this).constructor);\n    }\n    Wrapper.prototype = Object.create(Class2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } });\n    return _setPrototypeOf3(Wrapper, Class2);\n  };\n  return _wrapNativeSuper(Class);\n}\nfunction _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct()) {\n    _construct = Reflect.construct.bind();\n  } else {\n    _construct = function _construct2(Parent2, args2, Class2) {\n      var a = [null];\n      a.push.apply(a, args2);\n      var Constructor = Function.bind.apply(Parent2, a);\n      var instance = new Constructor();\n      if (Class2)\n        _setPrototypeOf3(instance, Class2.prototype);\n      return instance;\n    };\n  }\n  return _construct.apply(null, arguments);\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct)\n    return false;\n  if (Reflect.construct.sham)\n    return false;\n  if (typeof Proxy === \"function\")\n    return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {\n    }));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nfunction _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\nfunction _setPrototypeOf3(o, p) {\n  _setPrototypeOf3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf4(o2, p2) {\n    o2.__proto__ = p2;\n    return o2;\n  };\n  return _setPrototypeOf3(o, p);\n}\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {\n    return o2.__proto__ || Object.getPrototypeOf(o2);\n  };\n  return _getPrototypeOf(o);\n}\nvar CognitoError = function(_Error) {\n  _inheritsLoose3(CognitoError2, _Error);\n  function CognitoError2(message, code, name, statusCode) {\n    var _this;\n    _this = _Error.call(this, message) || this;\n    _this.code = code;\n    _this.name = name;\n    _this.statusCode = statusCode;\n    return _this;\n  }\n  return CognitoError2;\n}(_wrapNativeSuper(Error));\nvar Client = function() {\n  function Client2(region, endpoint, fetchOptions) {\n    this.endpoint = endpoint || \"https://cognito-idp.\" + region + \".amazonaws.com/\";\n    var _ref = fetchOptions || {}, credentials = _ref.credentials;\n    this.fetchOptions = credentials ? {\n      credentials\n    } : {};\n  }\n  var _proto = Client2.prototype;\n  _proto.promisifyRequest = function promisifyRequest(operation, params) {\n    var _this2 = this;\n    return new Promise(function(resolve, reject) {\n      _this2.request(operation, params, function(err, data) {\n        if (err) {\n          reject(new CognitoError(err.message, err.code, err.name, err.statusCode));\n        } else {\n          resolve(data);\n        }\n      });\n    });\n  };\n  _proto.requestWithRetry = function requestWithRetry(operation, params, callback) {\n    var _this3 = this;\n    var MAX_DELAY_IN_MILLIS = 5 * 1e3;\n    jitteredExponentialRetry(function(p) {\n      return new Promise(function(res, rej) {\n        _this3.request(operation, p, function(error, result) {\n          if (error) {\n            rej(error);\n          } else {\n            res(result);\n          }\n        });\n      });\n    }, [params], MAX_DELAY_IN_MILLIS).then(function(result) {\n      return callback(null, result);\n    })[\"catch\"](function(error) {\n      return callback(error);\n    });\n  };\n  _proto.request = function request(operation, params, callback) {\n    var headers = {\n      \"Content-Type\": \"application/x-amz-json-1.1\",\n      \"X-Amz-Target\": \"AWSCognitoIdentityProviderService.\" + operation,\n      \"X-Amz-User-Agent\": getAmplifyUserAgent(),\n      \"Cache-Control\": \"no-store\"\n    };\n    var options = Object.assign({}, this.fetchOptions, {\n      headers,\n      method: \"POST\",\n      mode: \"cors\",\n      body: JSON.stringify(params)\n    });\n    var response;\n    var responseJsonData;\n    fetch(this.endpoint, options).then(function(resp) {\n      response = resp;\n      return resp;\n    }, function(err) {\n      if (err instanceof TypeError) {\n        throw new Error(\"Network error\");\n      }\n      throw err;\n    }).then(function(resp) {\n      return resp.json()[\"catch\"](function() {\n        return {};\n      });\n    }).then(function(data) {\n      if (response.ok)\n        return callback(null, data);\n      responseJsonData = data;\n      var code = (data.__type || data.code).split(\"#\").pop();\n      var error = new Error(data.message || data.Message || null);\n      error.name = code;\n      error.code = code;\n      return callback(error);\n    })[\"catch\"](function(err) {\n      if (response && response.headers && response.headers.get(\"x-amzn-errortype\")) {\n        try {\n          var code = response.headers.get(\"x-amzn-errortype\").split(\":\")[0];\n          var error = new Error(response.status ? response.status.toString() : null);\n          error.code = code;\n          error.name = code;\n          error.statusCode = response.status;\n          return callback(error);\n        } catch (ex) {\n          return callback(err);\n        }\n      } else if (err instanceof Error && err.message === \"Network error\") {\n        err.code = \"NetworkError\";\n      }\n      return callback(err);\n    });\n  };\n  return Client2;\n}();\nvar logger = {\n  debug: function debug() {\n  }\n};\nvar NonRetryableError = function(_Error2) {\n  _inheritsLoose3(NonRetryableError2, _Error2);\n  function NonRetryableError2(message) {\n    var _this4;\n    _this4 = _Error2.call(this, message) || this;\n    _this4.nonRetryable = true;\n    return _this4;\n  }\n  return NonRetryableError2;\n}(_wrapNativeSuper(Error));\nvar isNonRetryableError = function isNonRetryableError2(obj) {\n  var key = \"nonRetryable\";\n  return obj && obj[key];\n};\nfunction retry(functionToRetry, args, delayFn, attempt) {\n  if (attempt === void 0) {\n    attempt = 1;\n  }\n  if (typeof functionToRetry !== \"function\") {\n    throw Error(\"functionToRetry must be a function\");\n  }\n  logger.debug(functionToRetry.name + \" attempt #\" + attempt + \" with args: \" + JSON.stringify(args));\n  return functionToRetry.apply(void 0, args)[\"catch\"](function(err) {\n    logger.debug(\"error on \" + functionToRetry.name, err);\n    if (isNonRetryableError(err)) {\n      logger.debug(functionToRetry.name + \" non retryable error\", err);\n      throw err;\n    }\n    var retryIn = delayFn(attempt, args, err);\n    logger.debug(functionToRetry.name + \" retrying in \" + retryIn + \" ms\");\n    if (retryIn !== false) {\n      return new Promise(function(res) {\n        return setTimeout(res, retryIn);\n      }).then(function() {\n        return retry(functionToRetry, args, delayFn, attempt + 1);\n      });\n    } else {\n      throw err;\n    }\n  });\n}\nfunction jitteredBackoff(maxDelayMs) {\n  var BASE_TIME_MS = 100;\n  var JITTER_FACTOR = 100;\n  return function(attempt) {\n    var delay = Math.pow(2, attempt) * BASE_TIME_MS + JITTER_FACTOR * Math.random();\n    return delay > maxDelayMs ? false : delay;\n  };\n}\nvar MAX_DELAY_MS = 5 * 60 * 1e3;\nfunction jitteredExponentialRetry(functionToRetry, args, maxDelayMs) {\n  if (maxDelayMs === void 0) {\n    maxDelayMs = MAX_DELAY_MS;\n  }\n  return retry(functionToRetry, args, jitteredBackoff(maxDelayMs));\n}\n\n// node_modules/amazon-cognito-identity-js/es/CognitoUserPool.js\nvar USER_POOL_ID_MAX_LENGTH = 55;\nvar CognitoUserPool = function() {\n  function CognitoUserPool2(data, wrapRefreshSessionCallback) {\n    var _ref = data || {}, UserPoolId = _ref.UserPoolId, ClientId = _ref.ClientId, endpoint = _ref.endpoint, fetchOptions = _ref.fetchOptions, AdvancedSecurityDataCollectionFlag = _ref.AdvancedSecurityDataCollectionFlag;\n    if (!UserPoolId || !ClientId) {\n      throw new Error(\"Both UserPoolId and ClientId are required.\");\n    }\n    if (UserPoolId.length > USER_POOL_ID_MAX_LENGTH || !/^[\\w-]+_[0-9a-zA-Z]+$/.test(UserPoolId)) {\n      throw new Error(\"Invalid UserPoolId format.\");\n    }\n    var region = UserPoolId.split(\"_\")[0];\n    this.userPoolId = UserPoolId;\n    this.clientId = ClientId;\n    this.client = new Client(region, endpoint, fetchOptions);\n    this.advancedSecurityDataCollectionFlag = AdvancedSecurityDataCollectionFlag !== false;\n    this.storage = data.Storage || new StorageHelper().getStorage();\n    if (wrapRefreshSessionCallback) {\n      this.wrapRefreshSessionCallback = wrapRefreshSessionCallback;\n    }\n  }\n  var _proto = CognitoUserPool2.prototype;\n  _proto.getUserPoolId = function getUserPoolId() {\n    return this.userPoolId;\n  };\n  _proto.getUserPoolName = function getUserPoolName() {\n    return this.getUserPoolId().split(\"_\")[1];\n  };\n  _proto.getClientId = function getClientId() {\n    return this.clientId;\n  };\n  _proto.signUp = function signUp(username, password, userAttributes, validationData, callback, clientMetadata) {\n    var _this = this;\n    var jsonReq = {\n      ClientId: this.clientId,\n      Username: username,\n      Password: password,\n      UserAttributes: userAttributes,\n      ValidationData: validationData,\n      ClientMetadata: clientMetadata\n    };\n    if (this.getUserContextData(username)) {\n      jsonReq.UserContextData = this.getUserContextData(username);\n    }\n    this.client.request(\"SignUp\", jsonReq, function(err, data) {\n      if (err) {\n        return callback(err, null);\n      }\n      var cognitoUser = {\n        Username: username,\n        Pool: _this,\n        Storage: _this.storage\n      };\n      var returnData = {\n        user: new CognitoUser(cognitoUser),\n        userConfirmed: data.UserConfirmed,\n        userSub: data.UserSub,\n        codeDeliveryDetails: data.CodeDeliveryDetails\n      };\n      return callback(null, returnData);\n    });\n  };\n  _proto.getCurrentUser = function getCurrentUser() {\n    var lastUserKey = \"CognitoIdentityServiceProvider.\" + this.clientId + \".LastAuthUser\";\n    var lastAuthUser = this.storage.getItem(lastUserKey);\n    if (lastAuthUser) {\n      var cognitoUser = {\n        Username: lastAuthUser,\n        Pool: this,\n        Storage: this.storage\n      };\n      return new CognitoUser(cognitoUser);\n    }\n    return null;\n  };\n  _proto.getUserContextData = function getUserContextData(username) {\n    if (typeof AmazonCognitoAdvancedSecurityData === \"undefined\") {\n      return void 0;\n    }\n    var amazonCognitoAdvancedSecurityDataConst = AmazonCognitoAdvancedSecurityData;\n    if (this.advancedSecurityDataCollectionFlag) {\n      var advancedSecurityData = amazonCognitoAdvancedSecurityDataConst.getData(username, this.userPoolId, this.clientId);\n      if (advancedSecurityData) {\n        var userContextData = {\n          EncodedData: advancedSecurityData\n        };\n        return userContextData;\n      }\n    }\n    return {};\n  };\n  return CognitoUserPool2;\n}();\n\n// node_modules/amazon-cognito-identity-js/es/CookieStorage.js\nvar import_dist26 = __toESM(require_dist());\nvar Cookies = __toESM(require_js_cookie());\nvar CookieStorage = function() {\n  function CookieStorage2(data) {\n    if (data === void 0) {\n      data = {};\n    }\n    if (data.domain) {\n      this.domain = data.domain;\n    }\n    if (data.path) {\n      this.path = data.path;\n    } else {\n      this.path = \"/\";\n    }\n    if (Object.prototype.hasOwnProperty.call(data, \"expires\")) {\n      this.expires = data.expires;\n    } else {\n      this.expires = 365;\n    }\n    if (Object.prototype.hasOwnProperty.call(data, \"secure\")) {\n      this.secure = data.secure;\n    } else {\n      this.secure = true;\n    }\n    if (Object.prototype.hasOwnProperty.call(data, \"sameSite\")) {\n      if (![\"strict\", \"lax\", \"none\"].includes(data.sameSite)) {\n        throw new Error('The sameSite value of cookieStorage must be \"lax\", \"strict\" or \"none\".');\n      }\n      if (data.sameSite === \"none\" && !this.secure) {\n        throw new Error(\"sameSite = None requires the Secure attribute in latest browser versions.\");\n      }\n      this.sameSite = data.sameSite;\n    } else {\n      this.sameSite = null;\n    }\n  }\n  var _proto = CookieStorage2.prototype;\n  _proto.setItem = function setItem(key, value) {\n    var options = {\n      path: this.path,\n      expires: this.expires,\n      domain: this.domain,\n      secure: this.secure\n    };\n    if (this.sameSite) {\n      options.sameSite = this.sameSite;\n    }\n    Cookies.set(key, value, options);\n    return Cookies.get(key);\n  };\n  _proto.getItem = function getItem(key) {\n    return Cookies.get(key);\n  };\n  _proto.removeItem = function removeItem(key) {\n    var options = {\n      path: this.path,\n      expires: this.expires,\n      domain: this.domain,\n      secure: this.secure\n    };\n    if (this.sameSite) {\n      options.sameSite = this.sameSite;\n    }\n    return Cookies.remove(key, options);\n  };\n  _proto.clear = function clear() {\n    var cookies = Cookies.get();\n    var numKeys = Object.keys(cookies).length;\n    for (var index = 0; index < numKeys; ++index) {\n      this.removeItem(Object.keys(cookies)[index]);\n    }\n    return {};\n  };\n  return CookieStorage2;\n}();\nexport {\n  AuthenticationDetails,\n  AuthenticationHelper,\n  CognitoAccessToken,\n  CognitoIdToken,\n  CognitoRefreshToken,\n  CognitoUser,\n  CognitoUserAttribute,\n  CognitoUserPool,\n  CognitoUserSession,\n  CookieStorage,\n  DateHelper,\n  WordArray,\n  appendToCognitoUserAgent\n};\n/*! Bundled license information:\n\ntslib/tslib.es6.js:\n  (*! *****************************************************************************\n  Copyright (c) Microsoft Corporation.\n  \n  Permission to use, copy, modify, and/or distribute this software for any\n  purpose with or without fee is hereby granted.\n  \n  THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n  PERFORMANCE OF THIS SOFTWARE.\n  ***************************************************************************** *)\n\njs-cookie/src/js.cookie.js:\n  (*!\n   * JavaScript Cookie v2.2.1\n   * https://github.com/js-cookie/js-cookie\n   *\n   * Copyright 2006, 2015 Klaus Hartl & Fagner Brack\n   * Released under the MIT license\n   *)\n\namazon-cognito-identity-js/es/AuthenticationDetails.js:\n  (*!\n   * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n   * SPDX-License-Identifier: Apache-2.0\n   *)\n\namazon-cognito-identity-js/es/AuthenticationHelper.js:\n  (*!\n   * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n   * SPDX-License-Identifier: Apache-2.0\n   *)\n\namazon-cognito-identity-js/es/CognitoJwtToken.js:\n  (*!\n   * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n   * SPDX-License-Identifier: Apache-2.0\n   *)\n\namazon-cognito-identity-js/es/CognitoAccessToken.js:\n  (*!\n   * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n   * SPDX-License-Identifier: Apache-2.0\n   *)\n\namazon-cognito-identity-js/es/CognitoIdToken.js:\n  (*!\n   * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n   * SPDX-License-Identifier: Apache-2.0\n   *)\n\namazon-cognito-identity-js/es/CognitoRefreshToken.js:\n  (*!\n   * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n   * SPDX-License-Identifier: Apache-2.0\n   *)\n\namazon-cognito-identity-js/es/Platform/index.js:\n  (*!\n   * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n   * SPDX-License-Identifier: Apache-2.0\n   *)\n\namazon-cognito-identity-js/es/CognitoUserSession.js:\n  (*!\n   * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n   * SPDX-License-Identifier: Apache-2.0\n   *)\n\namazon-cognito-identity-js/es/DateHelper.js:\n  (*!\n   * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n   * SPDX-License-Identifier: Apache-2.0\n   *)\n\namazon-cognito-identity-js/es/CognitoUserAttribute.js:\n  (*!\n   * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n   * SPDX-License-Identifier: Apache-2.0\n   *)\n\namazon-cognito-identity-js/es/StorageHelper.js:\n  (*!\n   * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n   * SPDX-License-Identifier: Apache-2.0\n   *)\n\namazon-cognito-identity-js/es/CognitoUser.js:\n  (*!\n   * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n   * SPDX-License-Identifier: Apache-2.0\n   *)\n\namazon-cognito-identity-js/es/CognitoUserPool.js:\n  (*!\n   * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n   * SPDX-License-Identifier: Apache-2.0\n   *)\n\namazon-cognito-identity-js/es/index.js:\n  (*!\n   * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n   * SPDX-License-Identifier: Apache-2.0\n   *)\n*/\n//# sourceMappingURL=amazon-cognito-identity-js.js.map\n",
      "start": 1703289449955,
      "end": 1703289449957,
      "order": "normal",
      "sourcemaps": null
    }
  ]
}
