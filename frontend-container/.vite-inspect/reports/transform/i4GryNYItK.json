{
  "resolvedId": "/home/zepor/ssweb/frontend-container/node_modules/.vite/deps/jsvectormap.js?v=733ce8d4",
  "transforms": [
    {
      "name": "vite:optimized-deps",
      "result": "\"use strict\";\n(() => {\n  var __create = Object.create;\n  var __defProp = Object.defineProperty;\n  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n  var __getOwnPropNames = Object.getOwnPropertyNames;\n  var __getProtoOf = Object.getPrototypeOf;\n  var __hasOwnProp = Object.prototype.hasOwnProperty;\n  var __esm = (fn, res) => function __init() {\n    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;\n  };\n  var __commonJS = (cb, mod) => function __require() {\n    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n  };\n  var __copyProps = (to, from, except, desc) => {\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n      for (let key of __getOwnPropNames(from))\n        if (!__hasOwnProp.call(to, key) && key !== except)\n          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n    }\n    return to;\n  };\n  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n    // If the importer is in node compatibility mode or this is not an ESM\n    // file that has been converted to a CommonJS file using a Babel-\n    // compatible transform (i.e. \"__esModule\" has not been set), then set\n    // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n    isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n    mod\n  ));\n\n  // node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js\n  var require_base64_js = __commonJS({\n    \"node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js\"(exports) {\n      \"use strict\";\n      init_dist();\n      exports.byteLength = byteLength;\n      exports.toByteArray = toByteArray;\n      exports.fromByteArray = fromByteArray;\n      var lookup = [];\n      var revLookup = [];\n      var Arr = typeof Uint8Array !== \"undefined\" ? Uint8Array : Array;\n      var code = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n      for (i = 0, len = code.length; i < len; ++i) {\n        lookup[i] = code[i];\n        revLookup[code.charCodeAt(i)] = i;\n      }\n      var i;\n      var len;\n      revLookup[\"-\".charCodeAt(0)] = 62;\n      revLookup[\"_\".charCodeAt(0)] = 63;\n      function getLens(b64) {\n        var len2 = b64.length;\n        if (len2 % 4 > 0) {\n          throw new Error(\"Invalid string. Length must be a multiple of 4\");\n        }\n        var validLen = b64.indexOf(\"=\");\n        if (validLen === -1)\n          validLen = len2;\n        var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;\n        return [validLen, placeHoldersLen];\n      }\n      function byteLength(b64) {\n        var lens = getLens(b64);\n        var validLen = lens[0];\n        var placeHoldersLen = lens[1];\n        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n      }\n      function _byteLength(b64, validLen, placeHoldersLen) {\n        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n      }\n      function toByteArray(b64) {\n        var tmp;\n        var lens = getLens(b64);\n        var validLen = lens[0];\n        var placeHoldersLen = lens[1];\n        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n        var curByte = 0;\n        var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;\n        var i2;\n        for (i2 = 0; i2 < len2; i2 += 4) {\n          tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];\n          arr[curByte++] = tmp >> 16 & 255;\n          arr[curByte++] = tmp >> 8 & 255;\n          arr[curByte++] = tmp & 255;\n        }\n        if (placeHoldersLen === 2) {\n          tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;\n          arr[curByte++] = tmp & 255;\n        }\n        if (placeHoldersLen === 1) {\n          tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;\n          arr[curByte++] = tmp >> 8 & 255;\n          arr[curByte++] = tmp & 255;\n        }\n        return arr;\n      }\n      function tripletToBase64(num) {\n        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];\n      }\n      function encodeChunk(uint8, start, end) {\n        var tmp;\n        var output = [];\n        for (var i2 = start; i2 < end; i2 += 3) {\n          tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);\n          output.push(tripletToBase64(tmp));\n        }\n        return output.join(\"\");\n      }\n      function fromByteArray(uint8) {\n        var tmp;\n        var len2 = uint8.length;\n        var extraBytes = len2 % 3;\n        var parts = [];\n        var maxChunkLength = 16383;\n        for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {\n          parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));\n        }\n        if (extraBytes === 1) {\n          tmp = uint8[len2 - 1];\n          parts.push(\n            lookup[tmp >> 2] + lookup[tmp << 4 & 63] + \"==\"\n          );\n        } else if (extraBytes === 2) {\n          tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];\n          parts.push(\n            lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + \"=\"\n          );\n        }\n        return parts.join(\"\");\n      }\n    }\n  });\n\n  // node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js\n  var require_ieee754 = __commonJS({\n    \"node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js\"(exports) {\n      init_dist();\n      exports.read = function(buffer, offset, isLE, mLen, nBytes) {\n        var e, m;\n        var eLen = nBytes * 8 - mLen - 1;\n        var eMax = (1 << eLen) - 1;\n        var eBias = eMax >> 1;\n        var nBits = -7;\n        var i = isLE ? nBytes - 1 : 0;\n        var d = isLE ? -1 : 1;\n        var s2 = buffer[offset + i];\n        i += d;\n        e = s2 & (1 << -nBits) - 1;\n        s2 >>= -nBits;\n        nBits += eLen;\n        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {\n        }\n        m = e & (1 << -nBits) - 1;\n        e >>= -nBits;\n        nBits += mLen;\n        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {\n        }\n        if (e === 0) {\n          e = 1 - eBias;\n        } else if (e === eMax) {\n          return m ? NaN : (s2 ? -1 : 1) * Infinity;\n        } else {\n          m = m + Math.pow(2, mLen);\n          e = e - eBias;\n        }\n        return (s2 ? -1 : 1) * m * Math.pow(2, e - mLen);\n      };\n      exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {\n        var e, m, c;\n        var eLen = nBytes * 8 - mLen - 1;\n        var eMax = (1 << eLen) - 1;\n        var eBias = eMax >> 1;\n        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n        var i = isLE ? 0 : nBytes - 1;\n        var d = isLE ? 1 : -1;\n        var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n        value = Math.abs(value);\n        if (isNaN(value) || value === Infinity) {\n          m = isNaN(value) ? 1 : 0;\n          e = eMax;\n        } else {\n          e = Math.floor(Math.log(value) / Math.LN2);\n          if (value * (c = Math.pow(2, -e)) < 1) {\n            e--;\n            c *= 2;\n          }\n          if (e + eBias >= 1) {\n            value += rt / c;\n          } else {\n            value += rt * Math.pow(2, 1 - eBias);\n          }\n          if (value * c >= 2) {\n            e++;\n            c /= 2;\n          }\n          if (e + eBias >= eMax) {\n            m = 0;\n            e = eMax;\n          } else if (e + eBias >= 1) {\n            m = (value * c - 1) * Math.pow(2, mLen);\n            e = e + eBias;\n          } else {\n            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n            e = 0;\n          }\n        }\n        for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {\n        }\n        e = e << mLen | m;\n        eLen += mLen;\n        for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {\n        }\n        buffer[offset + i - d] |= s2 * 128;\n      };\n    }\n  });\n\n  // node_modules/.pnpm/buffer@6.0.3_patch_hash=zkkuxompt5d553skpnegwi5wuy/node_modules/buffer/index.js\n  var require_buffer = __commonJS({\n    \"node_modules/.pnpm/buffer@6.0.3_patch_hash=zkkuxompt5d553skpnegwi5wuy/node_modules/buffer/index.js\"(exports) {\n      \"use strict\";\n      init_dist();\n      var base64 = require_base64_js();\n      var ieee754 = require_ieee754();\n      var customInspectSymbol = typeof Symbol === \"function\" && typeof Symbol[\"for\"] === \"function\" ? Symbol[\"for\"](\"nodejs.util.inspect.custom\") : null;\n      exports.Buffer = Buffer2;\n      exports.SlowBuffer = SlowBuffer;\n      exports.INSPECT_MAX_BYTES = 50;\n      var K_MAX_LENGTH = 2147483647;\n      exports.kMaxLength = K_MAX_LENGTH;\n      var { Uint8Array: GlobalUint8Array, ArrayBuffer: GlobalArrayBuffer, SharedArrayBuffer: GlobalSharedArrayBuffer } = globalThis;\n      Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();\n      if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== \"undefined\" && typeof console.error === \"function\") {\n        console.error(\n          \"This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.\"\n        );\n      }\n      function typedArraySupport() {\n        try {\n          const arr = new GlobalUint8Array(1);\n          const proto = { foo: function() {\n            return 42;\n          } };\n          Object.setPrototypeOf(proto, GlobalUint8Array.prototype);\n          Object.setPrototypeOf(arr, proto);\n          return arr.foo() === 42;\n        } catch (e) {\n          return false;\n        }\n      }\n      Object.defineProperty(Buffer2.prototype, \"parent\", {\n        enumerable: true,\n        get: function() {\n          if (!Buffer2.isBuffer(this))\n            return void 0;\n          return this.buffer;\n        }\n      });\n      Object.defineProperty(Buffer2.prototype, \"offset\", {\n        enumerable: true,\n        get: function() {\n          if (!Buffer2.isBuffer(this))\n            return void 0;\n          return this.byteOffset;\n        }\n      });\n      function createBuffer(length) {\n        if (length > K_MAX_LENGTH) {\n          throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"');\n        }\n        const buf = new GlobalUint8Array(length);\n        Object.setPrototypeOf(buf, Buffer2.prototype);\n        return buf;\n      }\n      function Buffer2(arg, encodingOrOffset, length) {\n        if (typeof arg === \"number\") {\n          if (typeof encodingOrOffset === \"string\") {\n            throw new TypeError(\n              'The \"string\" argument must be of type string. Received type number'\n            );\n          }\n          return allocUnsafe(arg);\n        }\n        return from(arg, encodingOrOffset, length);\n      }\n      Buffer2.poolSize = 8192;\n      function from(value, encodingOrOffset, length) {\n        if (typeof value === \"string\") {\n          return fromString(value, encodingOrOffset);\n        }\n        if (GlobalArrayBuffer.isView(value)) {\n          return fromArrayView(value);\n        }\n        if (value == null) {\n          throw new TypeError(\n            \"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value\n          );\n        }\n        if (isInstance(value, GlobalArrayBuffer) || value && isInstance(value.buffer, GlobalArrayBuffer)) {\n          return fromArrayBuffer(value, encodingOrOffset, length);\n        }\n        if (typeof GlobalSharedArrayBuffer !== \"undefined\" && (isInstance(value, GlobalSharedArrayBuffer) || value && isInstance(value.buffer, GlobalSharedArrayBuffer))) {\n          return fromArrayBuffer(value, encodingOrOffset, length);\n        }\n        if (typeof value === \"number\") {\n          throw new TypeError(\n            'The \"value\" argument must not be of type number. Received type number'\n          );\n        }\n        const valueOf = value.valueOf && value.valueOf();\n        if (valueOf != null && valueOf !== value) {\n          return Buffer2.from(valueOf, encodingOrOffset, length);\n        }\n        const b = fromObject(value);\n        if (b)\n          return b;\n        if (typeof Symbol !== \"undefined\" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === \"function\") {\n          return Buffer2.from(value[Symbol.toPrimitive](\"string\"), encodingOrOffset, length);\n        }\n        throw new TypeError(\n          \"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value\n        );\n      }\n      Buffer2.from = function(value, encodingOrOffset, length) {\n        return from(value, encodingOrOffset, length);\n      };\n      Object.setPrototypeOf(Buffer2.prototype, GlobalUint8Array.prototype);\n      Object.setPrototypeOf(Buffer2, GlobalUint8Array);\n      function assertSize(size) {\n        if (typeof size !== \"number\") {\n          throw new TypeError('\"size\" argument must be of type number');\n        } else if (size < 0) {\n          throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"');\n        }\n      }\n      function alloc(size, fill, encoding) {\n        assertSize(size);\n        if (size <= 0) {\n          return createBuffer(size);\n        }\n        if (fill !== void 0) {\n          return typeof encoding === \"string\" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);\n        }\n        return createBuffer(size);\n      }\n      Buffer2.alloc = function(size, fill, encoding) {\n        return alloc(size, fill, encoding);\n      };\n      function allocUnsafe(size) {\n        assertSize(size);\n        return createBuffer(size < 0 ? 0 : checked(size) | 0);\n      }\n      Buffer2.allocUnsafe = function(size) {\n        return allocUnsafe(size);\n      };\n      Buffer2.allocUnsafeSlow = function(size) {\n        return allocUnsafe(size);\n      };\n      function fromString(string, encoding) {\n        if (typeof encoding !== \"string\" || encoding === \"\") {\n          encoding = \"utf8\";\n        }\n        if (!Buffer2.isEncoding(encoding)) {\n          throw new TypeError(\"Unknown encoding: \" + encoding);\n        }\n        const length = byteLength(string, encoding) | 0;\n        let buf = createBuffer(length);\n        const actual = buf.write(string, encoding);\n        if (actual !== length) {\n          buf = buf.slice(0, actual);\n        }\n        return buf;\n      }\n      function fromArrayLike(array) {\n        const length = array.length < 0 ? 0 : checked(array.length) | 0;\n        const buf = createBuffer(length);\n        for (let i = 0; i < length; i += 1) {\n          buf[i] = array[i] & 255;\n        }\n        return buf;\n      }\n      function fromArrayView(arrayView) {\n        if (isInstance(arrayView, GlobalUint8Array)) {\n          const copy = new GlobalUint8Array(arrayView);\n          return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);\n        }\n        return fromArrayLike(arrayView);\n      }\n      function fromArrayBuffer(array, byteOffset, length) {\n        if (byteOffset < 0 || array.byteLength < byteOffset) {\n          throw new RangeError('\"offset\" is outside of buffer bounds');\n        }\n        if (array.byteLength < byteOffset + (length || 0)) {\n          throw new RangeError('\"length\" is outside of buffer bounds');\n        }\n        let buf;\n        if (byteOffset === void 0 && length === void 0) {\n          buf = new GlobalUint8Array(array);\n        } else if (length === void 0) {\n          buf = new GlobalUint8Array(array, byteOffset);\n        } else {\n          buf = new GlobalUint8Array(array, byteOffset, length);\n        }\n        Object.setPrototypeOf(buf, Buffer2.prototype);\n        return buf;\n      }\n      function fromObject(obj) {\n        if (Buffer2.isBuffer(obj)) {\n          const len = checked(obj.length) | 0;\n          const buf = createBuffer(len);\n          if (buf.length === 0) {\n            return buf;\n          }\n          obj.copy(buf, 0, 0, len);\n          return buf;\n        }\n        if (obj.length !== void 0) {\n          if (typeof obj.length !== \"number\" || numberIsNaN(obj.length)) {\n            return createBuffer(0);\n          }\n          return fromArrayLike(obj);\n        }\n        if (obj.type === \"Buffer\" && Array.isArray(obj.data)) {\n          return fromArrayLike(obj.data);\n        }\n      }\n      function checked(length) {\n        if (length >= K_MAX_LENGTH) {\n          throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\" + K_MAX_LENGTH.toString(16) + \" bytes\");\n        }\n        return length | 0;\n      }\n      function SlowBuffer(length) {\n        if (+length != length) {\n          length = 0;\n        }\n        return Buffer2.alloc(+length);\n      }\n      Buffer2.isBuffer = function isBuffer(b) {\n        return b != null && b._isBuffer === true && b !== Buffer2.prototype;\n      };\n      Buffer2.compare = function compare(a, b) {\n        if (isInstance(a, GlobalUint8Array))\n          a = Buffer2.from(a, a.offset, a.byteLength);\n        if (isInstance(b, GlobalUint8Array))\n          b = Buffer2.from(b, b.offset, b.byteLength);\n        if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {\n          throw new TypeError(\n            'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n          );\n        }\n        if (a === b)\n          return 0;\n        let x = a.length;\n        let y = b.length;\n        for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n          if (a[i] !== b[i]) {\n            x = a[i];\n            y = b[i];\n            break;\n          }\n        }\n        if (x < y)\n          return -1;\n        if (y < x)\n          return 1;\n        return 0;\n      };\n      Buffer2.isEncoding = function isEncoding(encoding) {\n        switch (String(encoding).toLowerCase()) {\n          case \"hex\":\n          case \"utf8\":\n          case \"utf-8\":\n          case \"ascii\":\n          case \"latin1\":\n          case \"binary\":\n          case \"base64\":\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return true;\n          default:\n            return false;\n        }\n      };\n      Buffer2.concat = function concat(list, length) {\n        if (!Array.isArray(list)) {\n          throw new TypeError('\"list\" argument must be an Array of Buffers');\n        }\n        if (list.length === 0) {\n          return Buffer2.alloc(0);\n        }\n        let i;\n        if (length === void 0) {\n          length = 0;\n          for (i = 0; i < list.length; ++i) {\n            length += list[i].length;\n          }\n        }\n        const buffer = Buffer2.allocUnsafe(length);\n        let pos = 0;\n        for (i = 0; i < list.length; ++i) {\n          let buf = list[i];\n          if (isInstance(buf, GlobalUint8Array)) {\n            if (pos + buf.length > buffer.length) {\n              if (!Buffer2.isBuffer(buf))\n                buf = Buffer2.from(buf);\n              buf.copy(buffer, pos);\n            } else {\n              GlobalUint8Array.prototype.set.call(\n                buffer,\n                buf,\n                pos\n              );\n            }\n          } else if (!Buffer2.isBuffer(buf)) {\n            throw new TypeError('\"list\" argument must be an Array of Buffers');\n          } else {\n            buf.copy(buffer, pos);\n          }\n          pos += buf.length;\n        }\n        return buffer;\n      };\n      function byteLength(string, encoding) {\n        if (Buffer2.isBuffer(string)) {\n          return string.length;\n        }\n        if (GlobalArrayBuffer.isView(string) || isInstance(string, GlobalArrayBuffer)) {\n          return string.byteLength;\n        }\n        if (typeof string !== \"string\") {\n          throw new TypeError(\n            'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string\n          );\n        }\n        const len = string.length;\n        const mustMatch = arguments.length > 2 && arguments[2] === true;\n        if (!mustMatch && len === 0)\n          return 0;\n        let loweredCase = false;\n        for (; ; ) {\n          switch (encoding) {\n            case \"ascii\":\n            case \"latin1\":\n            case \"binary\":\n              return len;\n            case \"utf8\":\n            case \"utf-8\":\n              return utf8ToBytes(string).length;\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n              return len * 2;\n            case \"hex\":\n              return len >>> 1;\n            case \"base64\":\n              return base64ToBytes(string).length;\n            default:\n              if (loweredCase) {\n                return mustMatch ? -1 : utf8ToBytes(string).length;\n              }\n              encoding = (\"\" + encoding).toLowerCase();\n              loweredCase = true;\n          }\n        }\n      }\n      Buffer2.byteLength = byteLength;\n      function slowToString(encoding, start, end) {\n        let loweredCase = false;\n        if (start === void 0 || start < 0) {\n          start = 0;\n        }\n        if (start > this.length) {\n          return \"\";\n        }\n        if (end === void 0 || end > this.length) {\n          end = this.length;\n        }\n        if (end <= 0) {\n          return \"\";\n        }\n        end >>>= 0;\n        start >>>= 0;\n        if (end <= start) {\n          return \"\";\n        }\n        if (!encoding)\n          encoding = \"utf8\";\n        while (true) {\n          switch (encoding) {\n            case \"hex\":\n              return hexSlice(this, start, end);\n            case \"utf8\":\n            case \"utf-8\":\n              return utf8Slice(this, start, end);\n            case \"ascii\":\n              return asciiSlice(this, start, end);\n            case \"latin1\":\n            case \"binary\":\n              return latin1Slice(this, start, end);\n            case \"base64\":\n              return base64Slice(this, start, end);\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n              return utf16leSlice(this, start, end);\n            default:\n              if (loweredCase)\n                throw new TypeError(\"Unknown encoding: \" + encoding);\n              encoding = (encoding + \"\").toLowerCase();\n              loweredCase = true;\n          }\n        }\n      }\n      Buffer2.prototype._isBuffer = true;\n      function swap(b, n, m) {\n        const i = b[n];\n        b[n] = b[m];\n        b[m] = i;\n      }\n      Buffer2.prototype.swap16 = function swap16() {\n        const len = this.length;\n        if (len % 2 !== 0) {\n          throw new RangeError(\"Buffer size must be a multiple of 16-bits\");\n        }\n        for (let i = 0; i < len; i += 2) {\n          swap(this, i, i + 1);\n        }\n        return this;\n      };\n      Buffer2.prototype.swap32 = function swap32() {\n        const len = this.length;\n        if (len % 4 !== 0) {\n          throw new RangeError(\"Buffer size must be a multiple of 32-bits\");\n        }\n        for (let i = 0; i < len; i += 4) {\n          swap(this, i, i + 3);\n          swap(this, i + 1, i + 2);\n        }\n        return this;\n      };\n      Buffer2.prototype.swap64 = function swap64() {\n        const len = this.length;\n        if (len % 8 !== 0) {\n          throw new RangeError(\"Buffer size must be a multiple of 64-bits\");\n        }\n        for (let i = 0; i < len; i += 8) {\n          swap(this, i, i + 7);\n          swap(this, i + 1, i + 6);\n          swap(this, i + 2, i + 5);\n          swap(this, i + 3, i + 4);\n        }\n        return this;\n      };\n      Buffer2.prototype.toString = function toString() {\n        const length = this.length;\n        if (length === 0)\n          return \"\";\n        if (arguments.length === 0)\n          return utf8Slice(this, 0, length);\n        return slowToString.apply(this, arguments);\n      };\n      Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;\n      Buffer2.prototype.equals = function equals(b) {\n        if (!Buffer2.isBuffer(b))\n          throw new TypeError(\"Argument must be a Buffer\");\n        if (this === b)\n          return true;\n        return Buffer2.compare(this, b) === 0;\n      };\n      Buffer2.prototype.inspect = function inspect() {\n        let str = \"\";\n        const max = exports.INSPECT_MAX_BYTES;\n        str = this.toString(\"hex\", 0, max).replace(/(.{2})/g, \"$1 \").trim();\n        if (this.length > max)\n          str += \" ... \";\n        return \"<Buffer \" + str + \">\";\n      };\n      if (customInspectSymbol) {\n        Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;\n      }\n      Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n        if (isInstance(target, GlobalUint8Array)) {\n          target = Buffer2.from(target, target.offset, target.byteLength);\n        }\n        if (!Buffer2.isBuffer(target)) {\n          throw new TypeError(\n            'The \"target\" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target\n          );\n        }\n        if (start === void 0) {\n          start = 0;\n        }\n        if (end === void 0) {\n          end = target ? target.length : 0;\n        }\n        if (thisStart === void 0) {\n          thisStart = 0;\n        }\n        if (thisEnd === void 0) {\n          thisEnd = this.length;\n        }\n        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n          throw new RangeError(\"out of range index\");\n        }\n        if (thisStart >= thisEnd && start >= end) {\n          return 0;\n        }\n        if (thisStart >= thisEnd) {\n          return -1;\n        }\n        if (start >= end) {\n          return 1;\n        }\n        start >>>= 0;\n        end >>>= 0;\n        thisStart >>>= 0;\n        thisEnd >>>= 0;\n        if (this === target)\n          return 0;\n        let x = thisEnd - thisStart;\n        let y = end - start;\n        const len = Math.min(x, y);\n        const thisCopy = this.slice(thisStart, thisEnd);\n        const targetCopy = target.slice(start, end);\n        for (let i = 0; i < len; ++i) {\n          if (thisCopy[i] !== targetCopy[i]) {\n            x = thisCopy[i];\n            y = targetCopy[i];\n            break;\n          }\n        }\n        if (x < y)\n          return -1;\n        if (y < x)\n          return 1;\n        return 0;\n      };\n      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n        if (buffer.length === 0)\n          return -1;\n        if (typeof byteOffset === \"string\") {\n          encoding = byteOffset;\n          byteOffset = 0;\n        } else if (byteOffset > 2147483647) {\n          byteOffset = 2147483647;\n        } else if (byteOffset < -2147483648) {\n          byteOffset = -2147483648;\n        }\n        byteOffset = +byteOffset;\n        if (numberIsNaN(byteOffset)) {\n          byteOffset = dir ? 0 : buffer.length - 1;\n        }\n        if (byteOffset < 0)\n          byteOffset = buffer.length + byteOffset;\n        if (byteOffset >= buffer.length) {\n          if (dir)\n            return -1;\n          else\n            byteOffset = buffer.length - 1;\n        } else if (byteOffset < 0) {\n          if (dir)\n            byteOffset = 0;\n          else\n            return -1;\n        }\n        if (typeof val === \"string\") {\n          val = Buffer2.from(val, encoding);\n        }\n        if (Buffer2.isBuffer(val)) {\n          if (val.length === 0) {\n            return -1;\n          }\n          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n        } else if (typeof val === \"number\") {\n          val = val & 255;\n          if (typeof GlobalUint8Array.prototype.indexOf === \"function\") {\n            if (dir) {\n              return GlobalUint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n            } else {\n              return GlobalUint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n            }\n          }\n          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);\n        }\n        throw new TypeError(\"val must be string, number or Buffer\");\n      }\n      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n        let indexSize = 1;\n        let arrLength = arr.length;\n        let valLength = val.length;\n        if (encoding !== void 0) {\n          encoding = String(encoding).toLowerCase();\n          if (encoding === \"ucs2\" || encoding === \"ucs-2\" || encoding === \"utf16le\" || encoding === \"utf-16le\") {\n            if (arr.length < 2 || val.length < 2) {\n              return -1;\n            }\n            indexSize = 2;\n            arrLength /= 2;\n            valLength /= 2;\n            byteOffset /= 2;\n          }\n        }\n        function read(buf, i2) {\n          if (indexSize === 1) {\n            return buf[i2];\n          } else {\n            return buf.readUInt16BE(i2 * indexSize);\n          }\n        }\n        let i;\n        if (dir) {\n          let foundIndex = -1;\n          for (i = byteOffset; i < arrLength; i++) {\n            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n              if (foundIndex === -1)\n                foundIndex = i;\n              if (i - foundIndex + 1 === valLength)\n                return foundIndex * indexSize;\n            } else {\n              if (foundIndex !== -1)\n                i -= i - foundIndex;\n              foundIndex = -1;\n            }\n          }\n        } else {\n          if (byteOffset + valLength > arrLength)\n            byteOffset = arrLength - valLength;\n          for (i = byteOffset; i >= 0; i--) {\n            let found = true;\n            for (let j = 0; j < valLength; j++) {\n              if (read(arr, i + j) !== read(val, j)) {\n                found = false;\n                break;\n              }\n            }\n            if (found)\n              return i;\n          }\n        }\n        return -1;\n      }\n      Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {\n        return this.indexOf(val, byteOffset, encoding) !== -1;\n      };\n      Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n      };\n      Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n      };\n      function hexWrite(buf, string, offset, length) {\n        offset = Number(offset) || 0;\n        const remaining = buf.length - offset;\n        if (!length) {\n          length = remaining;\n        } else {\n          length = Number(length);\n          if (length > remaining) {\n            length = remaining;\n          }\n        }\n        const strLen = string.length;\n        if (length > strLen / 2) {\n          length = strLen / 2;\n        }\n        let i;\n        for (i = 0; i < length; ++i) {\n          const parsed = parseInt(string.substr(i * 2, 2), 16);\n          if (numberIsNaN(parsed))\n            return i;\n          buf[offset + i] = parsed;\n        }\n        return i;\n      }\n      function utf8Write(buf, string, offset, length) {\n        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n      }\n      function asciiWrite(buf, string, offset, length) {\n        return blitBuffer(asciiToBytes(string), buf, offset, length);\n      }\n      function base64Write(buf, string, offset, length) {\n        return blitBuffer(base64ToBytes(string), buf, offset, length);\n      }\n      function ucs2Write(buf, string, offset, length) {\n        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n      }\n      Buffer2.prototype.write = function write(string, offset, length, encoding) {\n        if (offset === void 0) {\n          encoding = \"utf8\";\n          length = this.length;\n          offset = 0;\n        } else if (length === void 0 && typeof offset === \"string\") {\n          encoding = offset;\n          length = this.length;\n          offset = 0;\n        } else if (isFinite(offset)) {\n          offset = offset >>> 0;\n          if (isFinite(length)) {\n            length = length >>> 0;\n            if (encoding === void 0)\n              encoding = \"utf8\";\n          } else {\n            encoding = length;\n            length = void 0;\n          }\n        } else {\n          throw new Error(\n            \"Buffer.write(string, encoding, offset[, length]) is no longer supported\"\n          );\n        }\n        const remaining = this.length - offset;\n        if (length === void 0 || length > remaining)\n          length = remaining;\n        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n          throw new RangeError(\"Attempt to write outside buffer bounds\");\n        }\n        if (!encoding)\n          encoding = \"utf8\";\n        let loweredCase = false;\n        for (; ; ) {\n          switch (encoding) {\n            case \"hex\":\n              return hexWrite(this, string, offset, length);\n            case \"utf8\":\n            case \"utf-8\":\n              return utf8Write(this, string, offset, length);\n            case \"ascii\":\n            case \"latin1\":\n            case \"binary\":\n              return asciiWrite(this, string, offset, length);\n            case \"base64\":\n              return base64Write(this, string, offset, length);\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n              return ucs2Write(this, string, offset, length);\n            default:\n              if (loweredCase)\n                throw new TypeError(\"Unknown encoding: \" + encoding);\n              encoding = (\"\" + encoding).toLowerCase();\n              loweredCase = true;\n          }\n        }\n      };\n      Buffer2.prototype.toJSON = function toJSON() {\n        return {\n          type: \"Buffer\",\n          data: Array.prototype.slice.call(this._arr || this, 0)\n        };\n      };\n      function base64Slice(buf, start, end) {\n        if (start === 0 && end === buf.length) {\n          return base64.fromByteArray(buf);\n        } else {\n          return base64.fromByteArray(buf.slice(start, end));\n        }\n      }\n      function utf8Slice(buf, start, end) {\n        end = Math.min(buf.length, end);\n        const res = [];\n        let i = start;\n        while (i < end) {\n          const firstByte = buf[i];\n          let codePoint = null;\n          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;\n          if (i + bytesPerSequence <= end) {\n            let secondByte, thirdByte, fourthByte, tempCodePoint;\n            switch (bytesPerSequence) {\n              case 1:\n                if (firstByte < 128) {\n                  codePoint = firstByte;\n                }\n                break;\n              case 2:\n                secondByte = buf[i + 1];\n                if ((secondByte & 192) === 128) {\n                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;\n                  if (tempCodePoint > 127) {\n                    codePoint = tempCodePoint;\n                  }\n                }\n                break;\n              case 3:\n                secondByte = buf[i + 1];\n                thirdByte = buf[i + 2];\n                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {\n                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;\n                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {\n                    codePoint = tempCodePoint;\n                  }\n                }\n                break;\n              case 4:\n                secondByte = buf[i + 1];\n                thirdByte = buf[i + 2];\n                fourthByte = buf[i + 3];\n                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {\n                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;\n                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {\n                    codePoint = tempCodePoint;\n                  }\n                }\n            }\n          }\n          if (codePoint === null) {\n            codePoint = 65533;\n            bytesPerSequence = 1;\n          } else if (codePoint > 65535) {\n            codePoint -= 65536;\n            res.push(codePoint >>> 10 & 1023 | 55296);\n            codePoint = 56320 | codePoint & 1023;\n          }\n          res.push(codePoint);\n          i += bytesPerSequence;\n        }\n        return decodeCodePointsArray(res);\n      }\n      var MAX_ARGUMENTS_LENGTH = 4096;\n      function decodeCodePointsArray(codePoints) {\n        const len = codePoints.length;\n        if (len <= MAX_ARGUMENTS_LENGTH) {\n          return String.fromCharCode.apply(String, codePoints);\n        }\n        let res = \"\";\n        let i = 0;\n        while (i < len) {\n          res += String.fromCharCode.apply(\n            String,\n            codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n          );\n        }\n        return res;\n      }\n      function asciiSlice(buf, start, end) {\n        let ret = \"\";\n        end = Math.min(buf.length, end);\n        for (let i = start; i < end; ++i) {\n          ret += String.fromCharCode(buf[i] & 127);\n        }\n        return ret;\n      }\n      function latin1Slice(buf, start, end) {\n        let ret = \"\";\n        end = Math.min(buf.length, end);\n        for (let i = start; i < end; ++i) {\n          ret += String.fromCharCode(buf[i]);\n        }\n        return ret;\n      }\n      function hexSlice(buf, start, end) {\n        const len = buf.length;\n        if (!start || start < 0)\n          start = 0;\n        if (!end || end < 0 || end > len)\n          end = len;\n        let out = \"\";\n        for (let i = start; i < end; ++i) {\n          out += hexSliceLookupTable[buf[i]];\n        }\n        return out;\n      }\n      function utf16leSlice(buf, start, end) {\n        const bytes = buf.slice(start, end);\n        let res = \"\";\n        for (let i = 0; i < bytes.length - 1; i += 2) {\n          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n        }\n        return res;\n      }\n      Buffer2.prototype.slice = function slice(start, end) {\n        const len = this.length;\n        start = ~~start;\n        end = end === void 0 ? len : ~~end;\n        if (start < 0) {\n          start += len;\n          if (start < 0)\n            start = 0;\n        } else if (start > len) {\n          start = len;\n        }\n        if (end < 0) {\n          end += len;\n          if (end < 0)\n            end = 0;\n        } else if (end > len) {\n          end = len;\n        }\n        if (end < start)\n          end = start;\n        const newBuf = this.subarray(start, end);\n        Object.setPrototypeOf(newBuf, Buffer2.prototype);\n        return newBuf;\n      };\n      function checkOffset(offset, ext, length) {\n        if (offset % 1 !== 0 || offset < 0)\n          throw new RangeError(\"offset is not uint\");\n        if (offset + ext > length)\n          throw new RangeError(\"Trying to access beyond buffer length\");\n      }\n      Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert)\n          checkOffset(offset, byteLength2, this.length);\n        let val = this[offset];\n        let mul = 1;\n        let i = 0;\n        while (++i < byteLength2 && (mul *= 256)) {\n          val += this[offset + i] * mul;\n        }\n        return val;\n      };\n      Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert) {\n          checkOffset(offset, byteLength2, this.length);\n        }\n        let val = this[offset + --byteLength2];\n        let mul = 1;\n        while (byteLength2 > 0 && (mul *= 256)) {\n          val += this[offset + --byteLength2] * mul;\n        }\n        return val;\n      };\n      Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 1, this.length);\n        return this[offset];\n      };\n      Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 2, this.length);\n        return this[offset] | this[offset + 1] << 8;\n      };\n      Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 2, this.length);\n        return this[offset] << 8 | this[offset + 1];\n      };\n      Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;\n      };\n      Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n      };\n      Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {\n        offset = offset >>> 0;\n        validateNumber(offset, \"offset\");\n        const first = this[offset];\n        const last = this[offset + 7];\n        if (first === void 0 || last === void 0) {\n          boundsError(offset, this.length - 8);\n        }\n        const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;\n        const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;\n        return BigInt(lo) + (BigInt(hi) << BigInt(32));\n      });\n      Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {\n        offset = offset >>> 0;\n        validateNumber(offset, \"offset\");\n        const first = this[offset];\n        const last = this[offset + 7];\n        if (first === void 0 || last === void 0) {\n          boundsError(offset, this.length - 8);\n        }\n        const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];\n        const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;\n        return (BigInt(hi) << BigInt(32)) + BigInt(lo);\n      });\n      Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert)\n          checkOffset(offset, byteLength2, this.length);\n        let val = this[offset];\n        let mul = 1;\n        let i = 0;\n        while (++i < byteLength2 && (mul *= 256)) {\n          val += this[offset + i] * mul;\n        }\n        mul *= 128;\n        if (val >= mul)\n          val -= Math.pow(2, 8 * byteLength2);\n        return val;\n      };\n      Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert)\n          checkOffset(offset, byteLength2, this.length);\n        let i = byteLength2;\n        let mul = 1;\n        let val = this[offset + --i];\n        while (i > 0 && (mul *= 256)) {\n          val += this[offset + --i] * mul;\n        }\n        mul *= 128;\n        if (val >= mul)\n          val -= Math.pow(2, 8 * byteLength2);\n        return val;\n      };\n      Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 1, this.length);\n        if (!(this[offset] & 128))\n          return this[offset];\n        return (255 - this[offset] + 1) * -1;\n      };\n      Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 2, this.length);\n        const val = this[offset] | this[offset + 1] << 8;\n        return val & 32768 ? val | 4294901760 : val;\n      };\n      Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 2, this.length);\n        const val = this[offset + 1] | this[offset] << 8;\n        return val & 32768 ? val | 4294901760 : val;\n      };\n      Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n      };\n      Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n      };\n      Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {\n        offset = offset >>> 0;\n        validateNumber(offset, \"offset\");\n        const first = this[offset];\n        const last = this[offset + 7];\n        if (first === void 0 || last === void 0) {\n          boundsError(offset, this.length - 8);\n        }\n        const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);\n        return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);\n      });\n      Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {\n        offset = offset >>> 0;\n        validateNumber(offset, \"offset\");\n        const first = this[offset];\n        const last = this[offset + 7];\n        if (first === void 0 || last === void 0) {\n          boundsError(offset, this.length - 8);\n        }\n        const val = (first << 24) + // Overflow\n        this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];\n        return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);\n      });\n      Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return ieee754.read(this, offset, true, 23, 4);\n      };\n      Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return ieee754.read(this, offset, false, 23, 4);\n      };\n      Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 8, this.length);\n        return ieee754.read(this, offset, true, 52, 8);\n      };\n      Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 8, this.length);\n        return ieee754.read(this, offset, false, 52, 8);\n      };\n      function checkInt(buf, value, offset, ext, max, min) {\n        if (!Buffer2.isBuffer(buf))\n          throw new TypeError('\"buffer\" argument must be a Buffer instance');\n        if (value > max || value < min)\n          throw new RangeError('\"value\" argument is out of bounds');\n        if (offset + ext > buf.length)\n          throw new RangeError(\"Index out of range\");\n      }\n      Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert) {\n          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;\n          checkInt(this, value, offset, byteLength2, maxBytes, 0);\n        }\n        let mul = 1;\n        let i = 0;\n        this[offset] = value & 255;\n        while (++i < byteLength2 && (mul *= 256)) {\n          this[offset + i] = value / mul & 255;\n        }\n        return offset + byteLength2;\n      };\n      Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert) {\n          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;\n          checkInt(this, value, offset, byteLength2, maxBytes, 0);\n        }\n        let i = byteLength2 - 1;\n        let mul = 1;\n        this[offset + i] = value & 255;\n        while (--i >= 0 && (mul *= 256)) {\n          this[offset + i] = value / mul & 255;\n        }\n        return offset + byteLength2;\n      };\n      Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 1, 255, 0);\n        this[offset] = value & 255;\n        return offset + 1;\n      };\n      Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 2, 65535, 0);\n        this[offset] = value & 255;\n        this[offset + 1] = value >>> 8;\n        return offset + 2;\n      };\n      Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 2, 65535, 0);\n        this[offset] = value >>> 8;\n        this[offset + 1] = value & 255;\n        return offset + 2;\n      };\n      Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 4, 4294967295, 0);\n        this[offset + 3] = value >>> 24;\n        this[offset + 2] = value >>> 16;\n        this[offset + 1] = value >>> 8;\n        this[offset] = value & 255;\n        return offset + 4;\n      };\n      Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 4, 4294967295, 0);\n        this[offset] = value >>> 24;\n        this[offset + 1] = value >>> 16;\n        this[offset + 2] = value >>> 8;\n        this[offset + 3] = value & 255;\n        return offset + 4;\n      };\n      function wrtBigUInt64LE(buf, value, offset, min, max) {\n        checkIntBI(value, min, max, buf, offset, 7);\n        let lo = Number(value & BigInt(4294967295));\n        buf[offset++] = lo;\n        lo = lo >> 8;\n        buf[offset++] = lo;\n        lo = lo >> 8;\n        buf[offset++] = lo;\n        lo = lo >> 8;\n        buf[offset++] = lo;\n        let hi = Number(value >> BigInt(32) & BigInt(4294967295));\n        buf[offset++] = hi;\n        hi = hi >> 8;\n        buf[offset++] = hi;\n        hi = hi >> 8;\n        buf[offset++] = hi;\n        hi = hi >> 8;\n        buf[offset++] = hi;\n        return offset;\n      }\n      function wrtBigUInt64BE(buf, value, offset, min, max) {\n        checkIntBI(value, min, max, buf, offset, 7);\n        let lo = Number(value & BigInt(4294967295));\n        buf[offset + 7] = lo;\n        lo = lo >> 8;\n        buf[offset + 6] = lo;\n        lo = lo >> 8;\n        buf[offset + 5] = lo;\n        lo = lo >> 8;\n        buf[offset + 4] = lo;\n        let hi = Number(value >> BigInt(32) & BigInt(4294967295));\n        buf[offset + 3] = hi;\n        hi = hi >> 8;\n        buf[offset + 2] = hi;\n        hi = hi >> 8;\n        buf[offset + 1] = hi;\n        hi = hi >> 8;\n        buf[offset] = hi;\n        return offset + 8;\n      }\n      Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {\n        return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n      });\n      Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {\n        return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n      });\n      Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          const limit = Math.pow(2, 8 * byteLength2 - 1);\n          checkInt(this, value, offset, byteLength2, limit - 1, -limit);\n        }\n        let i = 0;\n        let mul = 1;\n        let sub = 0;\n        this[offset] = value & 255;\n        while (++i < byteLength2 && (mul *= 256)) {\n          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n            sub = 1;\n          }\n          this[offset + i] = (value / mul >> 0) - sub & 255;\n        }\n        return offset + byteLength2;\n      };\n      Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          const limit = Math.pow(2, 8 * byteLength2 - 1);\n          checkInt(this, value, offset, byteLength2, limit - 1, -limit);\n        }\n        let i = byteLength2 - 1;\n        let mul = 1;\n        let sub = 0;\n        this[offset + i] = value & 255;\n        while (--i >= 0 && (mul *= 256)) {\n          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n            sub = 1;\n          }\n          this[offset + i] = (value / mul >> 0) - sub & 255;\n        }\n        return offset + byteLength2;\n      };\n      Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 1, 127, -128);\n        if (value < 0)\n          value = 255 + value + 1;\n        this[offset] = value & 255;\n        return offset + 1;\n      };\n      Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 2, 32767, -32768);\n        this[offset] = value & 255;\n        this[offset + 1] = value >>> 8;\n        return offset + 2;\n      };\n      Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 2, 32767, -32768);\n        this[offset] = value >>> 8;\n        this[offset + 1] = value & 255;\n        return offset + 2;\n      };\n      Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 4, 2147483647, -2147483648);\n        this[offset] = value & 255;\n        this[offset + 1] = value >>> 8;\n        this[offset + 2] = value >>> 16;\n        this[offset + 3] = value >>> 24;\n        return offset + 4;\n      };\n      Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 4, 2147483647, -2147483648);\n        if (value < 0)\n          value = 4294967295 + value + 1;\n        this[offset] = value >>> 24;\n        this[offset + 1] = value >>> 16;\n        this[offset + 2] = value >>> 8;\n        this[offset + 3] = value & 255;\n        return offset + 4;\n      };\n      Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {\n        return wrtBigUInt64LE(this, value, offset, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n      });\n      Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {\n        return wrtBigUInt64BE(this, value, offset, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n      });\n      function checkIEEE754(buf, value, offset, ext, max, min) {\n        if (offset + ext > buf.length)\n          throw new RangeError(\"Index out of range\");\n        if (offset < 0)\n          throw new RangeError(\"Index out of range\");\n      }\n      function writeFloat(buf, value, offset, littleEndian, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);\n        }\n        ieee754.write(buf, value, offset, littleEndian, 23, 4);\n        return offset + 4;\n      }\n      Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n        return writeFloat(this, value, offset, true, noAssert);\n      };\n      Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n        return writeFloat(this, value, offset, false, noAssert);\n      };\n      function writeDouble(buf, value, offset, littleEndian, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);\n        }\n        ieee754.write(buf, value, offset, littleEndian, 52, 8);\n        return offset + 8;\n      }\n      Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n        return writeDouble(this, value, offset, true, noAssert);\n      };\n      Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n        return writeDouble(this, value, offset, false, noAssert);\n      };\n      Buffer2.prototype.copy = function copy(target, targetStart, start, end) {\n        if (!Buffer2.isBuffer(target))\n          throw new TypeError(\"argument should be a Buffer\");\n        if (!start)\n          start = 0;\n        if (!end && end !== 0)\n          end = this.length;\n        if (targetStart >= target.length)\n          targetStart = target.length;\n        if (!targetStart)\n          targetStart = 0;\n        if (end > 0 && end < start)\n          end = start;\n        if (end === start)\n          return 0;\n        if (target.length === 0 || this.length === 0)\n          return 0;\n        if (targetStart < 0) {\n          throw new RangeError(\"targetStart out of bounds\");\n        }\n        if (start < 0 || start >= this.length)\n          throw new RangeError(\"Index out of range\");\n        if (end < 0)\n          throw new RangeError(\"sourceEnd out of bounds\");\n        if (end > this.length)\n          end = this.length;\n        if (target.length - targetStart < end - start) {\n          end = target.length - targetStart + start;\n        }\n        const len = end - start;\n        if (this === target && typeof GlobalUint8Array.prototype.copyWithin === \"function\") {\n          this.copyWithin(targetStart, start, end);\n        } else {\n          GlobalUint8Array.prototype.set.call(\n            target,\n            this.subarray(start, end),\n            targetStart\n          );\n        }\n        return len;\n      };\n      Buffer2.prototype.fill = function fill(val, start, end, encoding) {\n        if (typeof val === \"string\") {\n          if (typeof start === \"string\") {\n            encoding = start;\n            start = 0;\n            end = this.length;\n          } else if (typeof end === \"string\") {\n            encoding = end;\n            end = this.length;\n          }\n          if (encoding !== void 0 && typeof encoding !== \"string\") {\n            throw new TypeError(\"encoding must be a string\");\n          }\n          if (typeof encoding === \"string\" && !Buffer2.isEncoding(encoding)) {\n            throw new TypeError(\"Unknown encoding: \" + encoding);\n          }\n          if (val.length === 1) {\n            const code = val.charCodeAt(0);\n            if (encoding === \"utf8\" && code < 128 || encoding === \"latin1\") {\n              val = code;\n            }\n          }\n        } else if (typeof val === \"number\") {\n          val = val & 255;\n        } else if (typeof val === \"boolean\") {\n          val = Number(val);\n        }\n        if (start < 0 || this.length < start || this.length < end) {\n          throw new RangeError(\"Out of range index\");\n        }\n        if (end <= start) {\n          return this;\n        }\n        start = start >>> 0;\n        end = end === void 0 ? this.length : end >>> 0;\n        if (!val)\n          val = 0;\n        let i;\n        if (typeof val === \"number\") {\n          for (i = start; i < end; ++i) {\n            this[i] = val;\n          }\n        } else {\n          const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);\n          const len = bytes.length;\n          if (len === 0) {\n            throw new TypeError('The value \"' + val + '\" is invalid for argument \"value\"');\n          }\n          for (i = 0; i < end - start; ++i) {\n            this[i + start] = bytes[i % len];\n          }\n        }\n        return this;\n      };\n      var errors = {};\n      function E(sym, getMessage, Base) {\n        errors[sym] = class NodeError extends Base {\n          constructor() {\n            super();\n            Object.defineProperty(this, \"message\", {\n              value: getMessage.apply(this, arguments),\n              writable: true,\n              configurable: true\n            });\n            this.name = `${this.name} [${sym}]`;\n            this.stack;\n            delete this.name;\n          }\n          get code() {\n            return sym;\n          }\n          set code(value) {\n            Object.defineProperty(this, \"code\", {\n              configurable: true,\n              enumerable: true,\n              value,\n              writable: true\n            });\n          }\n          toString() {\n            return `${this.name} [${sym}]: ${this.message}`;\n          }\n        };\n      }\n      E(\n        \"ERR_BUFFER_OUT_OF_BOUNDS\",\n        function(name) {\n          if (name) {\n            return `${name} is outside of buffer bounds`;\n          }\n          return \"Attempt to access memory outside buffer bounds\";\n        },\n        RangeError\n      );\n      E(\n        \"ERR_INVALID_ARG_TYPE\",\n        function(name, actual) {\n          return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`;\n        },\n        TypeError\n      );\n      E(\n        \"ERR_OUT_OF_RANGE\",\n        function(str, range, input) {\n          let msg = `The value of \"${str}\" is out of range.`;\n          let received = input;\n          if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n            received = addNumericalSeparator(String(input));\n          } else if (typeof input === \"bigint\") {\n            received = String(input);\n            if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n              received = addNumericalSeparator(received);\n            }\n            received += \"n\";\n          }\n          msg += ` It must be ${range}. Received ${received}`;\n          return msg;\n        },\n        RangeError\n      );\n      function addNumericalSeparator(val) {\n        let res = \"\";\n        let i = val.length;\n        const start = val[0] === \"-\" ? 1 : 0;\n        for (; i >= start + 4; i -= 3) {\n          res = `_${val.slice(i - 3, i)}${res}`;\n        }\n        return `${val.slice(0, i)}${res}`;\n      }\n      function checkBounds(buf, offset, byteLength2) {\n        validateNumber(offset, \"offset\");\n        if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {\n          boundsError(offset, buf.length - (byteLength2 + 1));\n        }\n      }\n      function checkIntBI(value, min, max, buf, offset, byteLength2) {\n        if (value > max || value < min) {\n          const n = typeof min === \"bigint\" ? \"n\" : \"\";\n          let range;\n          if (byteLength2 > 3) {\n            if (min === 0 || min === BigInt(0)) {\n              range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;\n            } else {\n              range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;\n            }\n          } else {\n            range = `>= ${min}${n} and <= ${max}${n}`;\n          }\n          throw new errors.ERR_OUT_OF_RANGE(\"value\", range, value);\n        }\n        checkBounds(buf, offset, byteLength2);\n      }\n      function validateNumber(value, name) {\n        if (typeof value !== \"number\") {\n          throw new errors.ERR_INVALID_ARG_TYPE(name, \"number\", value);\n        }\n      }\n      function boundsError(value, length, type) {\n        if (Math.floor(value) !== value) {\n          validateNumber(value, type);\n          throw new errors.ERR_OUT_OF_RANGE(type || \"offset\", \"an integer\", value);\n        }\n        if (length < 0) {\n          throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();\n        }\n        throw new errors.ERR_OUT_OF_RANGE(\n          type || \"offset\",\n          `>= ${type ? 1 : 0} and <= ${length}`,\n          value\n        );\n      }\n      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;\n      function base64clean(str) {\n        str = str.split(\"=\")[0];\n        str = str.trim().replace(INVALID_BASE64_RE, \"\");\n        if (str.length < 2)\n          return \"\";\n        while (str.length % 4 !== 0) {\n          str = str + \"=\";\n        }\n        return str;\n      }\n      function utf8ToBytes(string, units) {\n        units = units || Infinity;\n        let codePoint;\n        const length = string.length;\n        let leadSurrogate = null;\n        const bytes = [];\n        for (let i = 0; i < length; ++i) {\n          codePoint = string.charCodeAt(i);\n          if (codePoint > 55295 && codePoint < 57344) {\n            if (!leadSurrogate) {\n              if (codePoint > 56319) {\n                if ((units -= 3) > -1)\n                  bytes.push(239, 191, 189);\n                continue;\n              } else if (i + 1 === length) {\n                if ((units -= 3) > -1)\n                  bytes.push(239, 191, 189);\n                continue;\n              }\n              leadSurrogate = codePoint;\n              continue;\n            }\n            if (codePoint < 56320) {\n              if ((units -= 3) > -1)\n                bytes.push(239, 191, 189);\n              leadSurrogate = codePoint;\n              continue;\n            }\n            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;\n          } else if (leadSurrogate) {\n            if ((units -= 3) > -1)\n              bytes.push(239, 191, 189);\n          }\n          leadSurrogate = null;\n          if (codePoint < 128) {\n            if ((units -= 1) < 0)\n              break;\n            bytes.push(codePoint);\n          } else if (codePoint < 2048) {\n            if ((units -= 2) < 0)\n              break;\n            bytes.push(\n              codePoint >> 6 | 192,\n              codePoint & 63 | 128\n            );\n          } else if (codePoint < 65536) {\n            if ((units -= 3) < 0)\n              break;\n            bytes.push(\n              codePoint >> 12 | 224,\n              codePoint >> 6 & 63 | 128,\n              codePoint & 63 | 128\n            );\n          } else if (codePoint < 1114112) {\n            if ((units -= 4) < 0)\n              break;\n            bytes.push(\n              codePoint >> 18 | 240,\n              codePoint >> 12 & 63 | 128,\n              codePoint >> 6 & 63 | 128,\n              codePoint & 63 | 128\n            );\n          } else {\n            throw new Error(\"Invalid code point\");\n          }\n        }\n        return bytes;\n      }\n      function asciiToBytes(str) {\n        const byteArray = [];\n        for (let i = 0; i < str.length; ++i) {\n          byteArray.push(str.charCodeAt(i) & 255);\n        }\n        return byteArray;\n      }\n      function utf16leToBytes(str, units) {\n        let c, hi, lo;\n        const byteArray = [];\n        for (let i = 0; i < str.length; ++i) {\n          if ((units -= 2) < 0)\n            break;\n          c = str.charCodeAt(i);\n          hi = c >> 8;\n          lo = c % 256;\n          byteArray.push(lo);\n          byteArray.push(hi);\n        }\n        return byteArray;\n      }\n      function base64ToBytes(str) {\n        return base64.toByteArray(base64clean(str));\n      }\n      function blitBuffer(src, dst, offset, length) {\n        let i;\n        for (i = 0; i < length; ++i) {\n          if (i + offset >= dst.length || i >= src.length)\n            break;\n          dst[i + offset] = src[i];\n        }\n        return i;\n      }\n      function isInstance(obj, type) {\n        return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;\n      }\n      function numberIsNaN(obj) {\n        return obj !== obj;\n      }\n      var hexSliceLookupTable = function() {\n        const alphabet = \"0123456789abcdef\";\n        const table = new Array(256);\n        for (let i = 0; i < 16; ++i) {\n          const i16 = i * 16;\n          for (let j = 0; j < 16; ++j) {\n            table[i16 + j] = alphabet[i] + alphabet[j];\n          }\n        }\n        return table;\n      }();\n      function defineBigIntMethod(fn) {\n        return typeof BigInt === \"undefined\" ? BufferBigIntNotDefined : fn;\n      }\n      function BufferBigIntNotDefined() {\n        throw new Error(\"BigInt not supported\");\n      }\n    }\n  });\n\n  // node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js\n  var require_browser = __commonJS({\n    \"node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js\"(exports, module) {\n      init_dist();\n      var process = module.exports = {};\n      var cachedSetTimeout;\n      var cachedClearTimeout;\n      function defaultSetTimout() {\n        throw new Error(\"setTimeout has not been defined\");\n      }\n      function defaultClearTimeout() {\n        throw new Error(\"clearTimeout has not been defined\");\n      }\n      (function() {\n        try {\n          if (typeof setTimeout === \"function\") {\n            cachedSetTimeout = setTimeout;\n          } else {\n            cachedSetTimeout = defaultSetTimout;\n          }\n        } catch (e) {\n          cachedSetTimeout = defaultSetTimout;\n        }\n        try {\n          if (typeof clearTimeout === \"function\") {\n            cachedClearTimeout = clearTimeout;\n          } else {\n            cachedClearTimeout = defaultClearTimeout;\n          }\n        } catch (e) {\n          cachedClearTimeout = defaultClearTimeout;\n        }\n      })();\n      function runTimeout(fun) {\n        if (cachedSetTimeout === setTimeout) {\n          return setTimeout(fun, 0);\n        }\n        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n          cachedSetTimeout = setTimeout;\n          return setTimeout(fun, 0);\n        }\n        try {\n          return cachedSetTimeout(fun, 0);\n        } catch (e) {\n          try {\n            return cachedSetTimeout.call(null, fun, 0);\n          } catch (e2) {\n            return cachedSetTimeout.call(this, fun, 0);\n          }\n        }\n      }\n      function runClearTimeout(marker) {\n        if (cachedClearTimeout === clearTimeout) {\n          return clearTimeout(marker);\n        }\n        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n          cachedClearTimeout = clearTimeout;\n          return clearTimeout(marker);\n        }\n        try {\n          return cachedClearTimeout(marker);\n        } catch (e) {\n          try {\n            return cachedClearTimeout.call(null, marker);\n          } catch (e2) {\n            return cachedClearTimeout.call(this, marker);\n          }\n        }\n      }\n      var queue = [];\n      var draining = false;\n      var currentQueue;\n      var queueIndex = -1;\n      function cleanUpNextTick() {\n        if (!draining || !currentQueue) {\n          return;\n        }\n        draining = false;\n        if (currentQueue.length) {\n          queue = currentQueue.concat(queue);\n        } else {\n          queueIndex = -1;\n        }\n        if (queue.length) {\n          drainQueue();\n        }\n      }\n      function drainQueue() {\n        if (draining) {\n          return;\n        }\n        var timeout = runTimeout(cleanUpNextTick);\n        draining = true;\n        var len = queue.length;\n        while (len) {\n          currentQueue = queue;\n          queue = [];\n          while (++queueIndex < len) {\n            if (currentQueue) {\n              currentQueue[queueIndex].run();\n            }\n          }\n          queueIndex = -1;\n          len = queue.length;\n        }\n        currentQueue = null;\n        draining = false;\n        runClearTimeout(timeout);\n      }\n      process.nextTick = function(fun) {\n        var args = new Array(arguments.length - 1);\n        if (arguments.length > 1) {\n          for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n          }\n        }\n        queue.push(new Item(fun, args));\n        if (queue.length === 1 && !draining) {\n          runTimeout(drainQueue);\n        }\n      };\n      function Item(fun, array) {\n        this.fun = fun;\n        this.array = array;\n      }\n      Item.prototype.run = function() {\n        this.fun.apply(null, this.array);\n      };\n      process.title = \"browser\";\n      process.browser = true;\n      process.env = {};\n      process.argv = [];\n      process.version = \"\";\n      process.versions = {};\n      function noop() {\n      }\n      process.on = noop;\n      process.addListener = noop;\n      process.once = noop;\n      process.off = noop;\n      process.removeListener = noop;\n      process.removeAllListeners = noop;\n      process.emit = noop;\n      process.prependListener = noop;\n      process.prependOnceListener = noop;\n      process.listeners = function(name) {\n        return [];\n      };\n      process.binding = function(name) {\n        throw new Error(\"process.binding is not supported\");\n      };\n      process.cwd = function() {\n        return \"/\";\n      };\n      process.chdir = function(dir) {\n        throw new Error(\"process.chdir is not supported\");\n      };\n      process.umask = function() {\n        return 0;\n      };\n    }\n  });\n\n  // shims/dist/index.js\n  var import_buffer_polyfill, import_process, o;\n  var init_dist = __esm({\n    \"shims/dist/index.js\"() {\n      \"use strict\";\n      import_buffer_polyfill = __toESM(require_buffer(), 1);\n      import_process = __toESM(require_browser(), 1);\n      o = globalThis || void 0 || self;\n    }\n  });\n\n  // shims/banner/index.cjs\n  var require_banner = __commonJS({\n    \"shims/banner/index.cjs\"() {\n      init_dist();\n      globalThis.Buffer = globalThis.Buffer || import_buffer_polyfill.Buffer;\n      globalThis.global = globalThis.global || o;\n      globalThis.process = globalThis.process || import_process.default;\n    }\n  });\n  require_banner();\n})();\n/*! Bundled license information:\n\nieee754/index.js:\n  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)\n\nbuffer/index.js:\n  (*!\n   * The buffer module from node.js, for the browser.\n   *\n   * @author   Feross Aboukhadijeh <https://feross.org>\n   * @license  MIT\n   *)\n*/\n\nimport {\n  __commonJS,\n  __toESM,\n  require_dist\n} from \"./chunk-VMXIV7NB.js\";\n\n// node_modules/jsvectormap/dist/js/jsvectormap.min.js\nvar require_jsvectormap_min = __commonJS({\n  \"node_modules/jsvectormap/dist/js/jsvectormap.min.js\"(exports, module) {\n    var import_dist = __toESM(require_dist());\n    !function(t, e) {\n      \"object\" == typeof exports && \"undefined\" != typeof module ? module.exports = e() : \"function\" == typeof define && define.amd ? define(e) : (t = \"undefined\" != typeof globalThis ? globalThis : t || self).jsVectorMap = e();\n    }(exports, function() {\n      \"use strict\";\n      function t(t2, i2) {\n        t2.prototype = Object.create(i2.prototype), t2.prototype.constructor = t2, e(t2, i2);\n      }\n      function e(t2, i2) {\n        return e = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t3, e2) {\n          return t3.__proto__ = e2, t3;\n        }, e(t2, i2);\n      }\n      function i(t2) {\n        if (void 0 === t2)\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        return t2;\n      }\n      function s(t2) {\n        throw new TypeError('\"' + t2 + '\" is read-only');\n      }\n      function a(t2, e2) {\n        (null == e2 || e2 > t2.length) && (e2 = t2.length);\n        for (var i2 = 0, s2 = new Array(e2); i2 < e2; i2++)\n          s2[i2] = t2[i2];\n        return s2;\n      }\n      function n(t2, e2) {\n        var i2 = \"undefined\" != typeof Symbol && t2[Symbol.iterator] || t2[\"@@iterator\"];\n        if (i2)\n          return (i2 = i2.call(t2)).next.bind(i2);\n        if (Array.isArray(t2) || (i2 = function(t3, e3) {\n          if (t3) {\n            if (\"string\" == typeof t3)\n              return a(t3, e3);\n            var i3 = Object.prototype.toString.call(t3).slice(8, -1);\n            return \"Object\" === i3 && t3.constructor && (i3 = t3.constructor.name), \"Map\" === i3 || \"Set\" === i3 ? Array.from(t3) : \"Arguments\" === i3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i3) ? a(t3, e3) : void 0;\n          }\n        }(t2)) || e2 && t2 && \"number\" == typeof t2.length) {\n          i2 && (t2 = i2);\n          var s2 = 0;\n          return function() {\n            return s2 >= t2.length ? { done: true } : { done: false, value: t2[s2++] };\n          };\n        }\n        throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n      }\n      Element.prototype.matches || (Element.prototype.matches = Element.prototype.matchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector || Element.prototype.webkitMatchesSelector || function(t2) {\n        for (var e2 = (this.document || this.ownerDocument).querySelectorAll(t2), i2 = e2.length; s(\"i\") >= 0 && e2.item(i2) !== this; )\n          ;\n        return i2 > -1;\n      }), Object.assign || Object.defineProperty(Object, \"assign\", { enumerable: false, configurable: true, writable: true, value: function(t2) {\n        if (null == t2)\n          throw new TypeError(\"Cannot convert first argument to object\");\n        for (var e2 = Object(t2), i2 = 1; i2 < arguments.length; i2++) {\n          var s2 = arguments[i2];\n          if (null != s2) {\n            s2 = Object(s2);\n            for (var a2 = Object.keys(Object(s2)), n2 = 0, r2 = a2.length; n2 < r2; n2++) {\n              var o2 = a2[n2], h2 = Object.getOwnPropertyDescriptor(s2, o2);\n              void 0 !== h2 && h2.enumerable && (e2[o2] = s2[o2]);\n            }\n          }\n        }\n        return e2;\n      } });\n      var r = function(t2) {\n        return /* @__PURE__ */ function(t3) {\n          return !!t3 && \"object\" == typeof t3;\n        }(t2) && !function(t3) {\n          var e2 = Object.prototype.toString.call(t3);\n          return \"[object RegExp]\" === e2 || \"[object Date]\" === e2 || function(t4) {\n            return t4 instanceof Node;\n          }(t3) || function(t4) {\n            return t4.$$typeof === o;\n          }(t3);\n        }(t2);\n      };\n      var o = \"function\" == typeof Symbol && Symbol.for ? Symbol.for(\"react.element\") : 60103;\n      function h(t2, e2) {\n        return false !== e2.clone && e2.isMergeableObject(t2) ? d((i2 = t2, Array.isArray(i2) ? [] : {}), t2, e2) : t2;\n        var i2;\n      }\n      function l(t2, e2, i2) {\n        return t2.concat(e2).map(function(t3) {\n          return h(t3, i2);\n        });\n      }\n      function c(t2) {\n        return Object.keys(t2).concat(function(t3) {\n          return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(t3).filter(function(e2) {\n            return t3.propertyIsEnumerable(e2);\n          }) : [];\n        }(t2));\n      }\n      function u(t2, e2) {\n        try {\n          return e2 in t2;\n        } catch (t3) {\n          return false;\n        }\n      }\n      function p(t2, e2, i2) {\n        var s2 = {};\n        return i2.isMergeableObject(t2) && c(t2).forEach(function(e3) {\n          s2[e3] = h(t2[e3], i2);\n        }), c(e2).forEach(function(a2) {\n          (function(t3, e3) {\n            return u(t3, e3) && !(Object.hasOwnProperty.call(t3, e3) && Object.propertyIsEnumerable.call(t3, e3));\n          })(t2, a2) || (u(t2, a2) && i2.isMergeableObject(e2[a2]) ? s2[a2] = function(t3, e3) {\n            if (!e3.customMerge)\n              return d;\n            var i3 = e3.customMerge(t3);\n            return \"function\" == typeof i3 ? i3 : d;\n          }(a2, i2)(t2[a2], e2[a2], i2) : s2[a2] = h(e2[a2], i2));\n        }), s2;\n      }\n      var d = function(t2, e2, i2) {\n        (i2 = i2 || {}).arrayMerge = i2.arrayMerge || l, i2.isMergeableObject = i2.isMergeableObject || r, i2.cloneUnlessOtherwiseSpecified = h;\n        var s2 = Array.isArray(e2);\n        return s2 === Array.isArray(t2) ? s2 ? i2.arrayMerge(t2, e2, i2) : p(t2, e2, i2) : h(e2, i2);\n      }, f = function(t2) {\n        return \"object\" == typeof t2 && void 0 !== t2.nodeType ? t2 : \"string\" == typeof t2 ? document.querySelector(t2) : null;\n      }, m = function(t2, e2, i2, s2) {\n        void 0 === s2 && (s2 = false);\n        var a2 = document.createElement(t2);\n        return i2 && (a2[s2 ? \"innerHTML\" : \"textContent\"] = i2), e2 && (a2.className = e2), a2;\n      }, g = function(t2) {\n        t2.parentNode.removeChild(t2);\n      }, v = function(t2, e2, i2) {\n        return void 0 === i2 && (i2 = false), i2 ? d(t2, e2) : Object.assign(t2, e2);\n      }, _ = function(t2, e2) {\n        return t2.toLowerCase() + \":to:\" + e2.toLowerCase();\n      }, y = function(t2, e2) {\n        Object.assign(t2.prototype, e2);\n      }, b = {}, w = 1, S = { on: function(t2, e2, i2, s2) {\n        void 0 === s2 && (s2 = {});\n        var a2 = \"jvm:\" + e2 + \"::\" + w++;\n        b[a2] = { selector: t2, handler: i2 }, i2._uid = a2, t2.addEventListener(e2, i2, s2);\n      }, delegate: function(t2, e2, i2, s2) {\n        (e2 = e2.split(\" \")).forEach(function(e3) {\n          S.on(t2, e3, function(t3) {\n            var e4 = t3.target;\n            e4.matches(i2) && s2.call(e4, t3);\n          });\n        });\n      }, off: function(t2, e2, i2) {\n        var s2 = e2.split(\":\")[1];\n        t2.removeEventListener(s2, i2), delete b[i2._uid];\n      }, flush: function() {\n        Object.keys(b).forEach(function(t2) {\n          S.off(b[t2].selector, t2, b[t2].handler);\n        });\n      }, getEventRegistry: function() {\n        return b;\n      } };\n      var k = { onLoaded: \"map:loaded\", onViewportChange: \"viewport:changed\", onRegionClick: \"region:clicked\", onMarkerClick: \"marker:clicked\", onRegionSelected: \"region:selected\", onMarkerSelected: \"marker:selected\", onRegionTooltipShow: \"region.tooltip:show\", onMarkerTooltipShow: \"marker.tooltip:show\", onDestroyed: \"map:destroyed\" }, M = function(t2, e2, i2) {\n        var s2 = f(e2), a2 = -1 === s2.getAttribute(\"class\").indexOf(\"jvm-region\") ? \"marker\" : \"region\", n2 = \"region\" === a2, r2 = n2 ? s2.getAttribute(\"data-code\") : s2.getAttribute(\"data-index\"), o2 = n2 ? k.onRegionSelected : k.onMarkerSelected;\n        return i2 && (o2 = n2 ? k.onRegionTooltipShow : k.onMarkerTooltipShow), { type: a2, code: r2, event: o2, element: n2 ? t2.regions[r2].element : t2._markers[r2].element, tooltipText: n2 ? t2._mapData.paths[r2].name || \"\" : t2._markers[r2].config.name || \"\" };\n      };\n      var x = function() {\n        function t2() {\n        }\n        return t2.prototype.dispose = function() {\n          this._tooltip ? g(this._tooltip) : this.shape.remove();\n          for (var t3, e2 = n(Object.getOwnPropertyNames(this)); !(t3 = e2()).done; ) {\n            this[t3.value] = null;\n          }\n        }, t2;\n      }(), j = { getLabelText: function(t2, e2) {\n        if (e2) {\n          if (\"function\" == typeof e2.render) {\n            var i2 = [];\n            return this.config && this.config.marker && i2.push(this.config.marker), i2.push(t2), e2.render.apply(this, i2);\n          }\n          return t2;\n        }\n      }, getLabelOffsets: function(t2, e2) {\n        return \"function\" == typeof e2.offsets ? e2.offsets(t2) : Array.isArray(e2.offsets) ? e2.offsets[t2] : [0, 0];\n      }, setStyle: function(t2, e2) {\n        this.shape.setStyle(t2, e2);\n      }, remove: function() {\n        this.shape.remove(), this.label && this.label.remove();\n      }, hover: function(t2) {\n        this._setStatus(\"isHovered\", t2);\n      }, select: function(t2) {\n        this._setStatus(\"isSelected\", t2);\n      }, _setStatus: function(t2, e2) {\n        this.shape[t2] = e2, this.shape.updateStyle(), this[t2] = e2, this.label && (this.label[t2] = e2, this.label.updateStyle());\n      } }, C = function(e2) {\n        function i2(t2) {\n          var i3, s3 = t2.map, a2 = t2.code, n2 = t2.path, r2 = t2.style, o2 = t2.label, h2 = t2.labelStyle, l2 = t2.labelsGroup;\n          (i3 = e2.call(this) || this)._map = s3, i3.shape = i3._createRegion(n2, a2, r2);\n          var c2 = i3.getLabelText(a2, o2);\n          if (o2 && c2) {\n            var u2 = i3.shape.getBBox(), p2 = i3.getLabelOffsets(a2, o2);\n            i3.labelX = u2.x + u2.width / 2 + p2[0], i3.labelY = u2.y + u2.height / 2 + p2[1], i3.label = i3._map.canvas.createText({ text: c2, textAnchor: \"middle\", alignmentBaseline: \"central\", dataCode: a2, x: i3.labelX, y: i3.labelY }, h2, l2), i3.label.addClass(\"jvm-region jvm-element\");\n          }\n          return i3;\n        }\n        t(i2, e2);\n        var s2 = i2.prototype;\n        return s2._createRegion = function(t2, e3, i3) {\n          return (t2 = this._map.canvas.createPath({ d: t2, dataCode: e3 }, i3)).addClass(\"jvm-region jvm-element\"), t2;\n        }, s2.updateLabelPosition = function() {\n          this.label && this.label.set({ x: this.labelX * this._map.scale + this._map.transX * this._map.scale, y: this.labelY * this._map.scale + this._map.transY * this._map.scale });\n        }, i2;\n      }(x);\n      y(C, j);\n      var L = function(e2) {\n        function i2(t2) {\n          var i3, s2 = t2.index, a2 = t2.map, n2 = t2.style, r2 = t2.x1, o2 = t2.y1, h2 = t2.x2, l2 = t2.y2, c2 = t2.group, u2 = t2.config;\n          return (i3 = e2.call(this) || this).config = u2, i3.shape = a2.canvas.createLine({ x1: r2, y1: o2, x2: h2, y2: l2, dataIndex: s2 }, n2, c2), i3.shape.addClass(\"jvm-line\"), i3;\n        }\n        return t(i2, e2), i2.prototype.setStyle = function(t2, e3) {\n          this.shape.setStyle(t2, e3);\n        }, i2;\n      }(x);\n      var O = function(e2) {\n        function i2(t2) {\n          var i3, s3 = t2.index, a2 = t2.style, n2 = t2.label, r2 = t2.cx, o2 = t2.cy, h2 = t2.map, l2 = t2.group;\n          return (i3 = e2.call(this) || this)._map = h2, i3._isImage = !!a2.initial.image, i3.config = arguments[0], i3.shape = h2.canvas[i3._isImage ? \"createImage\" : \"createCircle\"]({ dataIndex: s3, cx: r2, cy: o2 }, a2, l2), i3.shape.addClass(\"jvm-marker jvm-element\"), i3._isImage && i3.updateLabelPosition(), n2 && i3._createLabel(i3.config), i3;\n        }\n        t(i2, e2);\n        var s2 = i2.prototype;\n        return s2.updateLabelPosition = function() {\n          this.label && this.label.set({ x: this._labelX * this._map.scale + this._offsets[0] + this._map.transX * this._map.scale + 5 + (this._isImage ? (this.shape.width || 0) / 2 : this.shape.node.r.baseVal.value), y: this._labelY * this._map.scale + this._map.transY * this._map.scale + this._offsets[1] });\n        }, s2._createLabel = function(t2) {\n          var e3 = t2.index, i3 = t2.map, s3 = t2.label, a2 = t2.labelsGroup, n2 = t2.cx, r2 = t2.cy, o2 = t2.marker, h2 = t2.isRecentlyCreated, l2 = this.getLabelText(e3, s3);\n          this._labelX = n2 / i3.scale - i3.transX, this._labelY = r2 / i3.scale - i3.transY, this._offsets = h2 && o2.offsets ? o2.offsets : this.getLabelOffsets(e3, s3), this.label = i3.canvas.createText({ text: l2, dataIndex: e3, x: this._labelX, y: this._labelY, dy: \"0.6ex\" }, i3.params.markerLabelStyle, a2), this.label.addClass(\"jvm-marker jvm-element\"), h2 && this.updateLabelPosition();\n        }, i2;\n      }(x);\n      y(O, j);\n      var A = function() {\n        function t2(t3) {\n          void 0 === t3 && (t3 = {}), this._options = t3, this._map = this._options.map, this._series = this._options.series, this._body = m(\"div\", \"jvm-legend\"), this._options.cssClass && this._body.setAttribute(\"class\", this._options.cssClass), t3.vertical ? this._map.legendVertical.appendChild(this._body) : this._map.legendHorizontal.appendChild(this._body), this.render();\n        }\n        return t2.prototype.render = function() {\n          var t3, e2 = this._series.scale.getTicks(), i2 = m(\"div\", \"jvm-legend-inner\");\n          if (this._body.innderHTML = \"\", this._options.title) {\n            var s2 = m(\"div\", \"jvm-legend-title\", this._options.title);\n            this._body.appendChild(s2);\n          }\n          this._body.appendChild(i2);\n          for (var a2 = 0; a2 < e2.length; a2++) {\n            var n2 = m(\"div\", \"jvm-legend-tick\"), r2 = m(\"div\", \"jvm-legend-tick-sample\");\n            switch (this._series.config.attribute) {\n              case \"fill\":\n                t3 = e2[a2].value, /\\.(jpg|gif|png)$/.test(t3) ? r2.style.background = \"url(\" + e2[a2].value + \")\" : r2.style.background = e2[a2].value;\n                break;\n              case \"stroke\":\n                r2.style.background = e2[a2].value;\n                break;\n              case \"image\":\n                r2.style.background = \"url(\" + (\"object\" == typeof e2[a2].value ? e2[a2].value.url : e2[a2].value) + \") no-repeat center center\", r2.style.backgroundSize = \"cover\";\n            }\n            n2.appendChild(r2);\n            var o2 = e2[a2].label;\n            this._options.labelRender && (o2 = this._options.labelRender(o2));\n            var h2 = m(\"div\", \"jvm-legend-tick-text\", o2);\n            n2.appendChild(h2), i2.appendChild(n2);\n          }\n        }, t2;\n      }(), X = function() {\n        function t2(t3) {\n          this._scale = t3;\n        }\n        var e2 = t2.prototype;\n        return e2.getValue = function(t3) {\n          return this._scale[t3];\n        }, e2.getTicks = function() {\n          var t3 = [];\n          for (var e3 in this._scale)\n            t3.push({ label: e3, value: this._scale[e3] });\n          return t3;\n        }, t2;\n      }(), Y = function() {\n        function t2(t3, e3, i2) {\n          void 0 === t3 && (t3 = {}), this._map = i2, this._elements = e3, this._values = t3.values || {}, this.config = t3, this.config.attribute = t3.attribute || \"fill\", t3.attributes && this.setAttributes(t3.attributes), \"object\" == typeof t3.scale && (this.scale = new X(t3.scale)), this.config.legend && (this.legend = new A(v({ map: this._map, series: this }, this.config.legend))), this.setValues(this._values);\n        }\n        var e2 = t2.prototype;\n        return e2.setValues = function(t3) {\n          var e3 = {};\n          for (var i2 in t3)\n            t3[i2] && (e3[i2] = this.scale.getValue(t3[i2]));\n          this.setAttributes(e3);\n        }, e2.setAttributes = function(t3) {\n          for (var e3 in t3)\n            this._elements[e3] && this._elements[e3].element.setStyle(this.config.attribute, t3[e3]);\n        }, e2.clear = function() {\n          var t3, e3 = {};\n          for (t3 in this._values)\n            this._elements[t3] && (e3[t3] = this._elements[t3].element.shape.style.initial[this.config.attribute]);\n          this.setAttributes(e3), this._values = {};\n        }, t2;\n      }();\n      var E = { mill: function(t2, e2, i2) {\n        return { x: this.radius * (e2 - i2) * this.radDeg, y: -this.radius * Math.log(Math.tan((45 + 0.4 * t2) * this.radDeg)) / 0.8 };\n      }, merc: function(t2, e2, i2) {\n        return { x: this.radius * (e2 - i2) * this.radDeg, y: -this.radius * Math.log(Math.tan(Math.PI / 4 + t2 * Math.PI / 360)) };\n      }, aea: function(t2, e2, i2) {\n        var s2 = i2 * this.radDeg, a2 = 29.5 * this.radDeg, n2 = 45.5 * this.radDeg, r2 = t2 * this.radDeg, o2 = e2 * this.radDeg, h2 = (Math.sin(a2) + Math.sin(n2)) / 2, l2 = Math.cos(a2) * Math.cos(a2) + 2 * h2 * Math.sin(a2), c2 = h2 * (o2 - s2), u2 = Math.sqrt(l2 - 2 * h2 * Math.sin(r2)) / h2, p2 = Math.sqrt(l2 - 2 * h2 * Math.sin(0)) / h2;\n        return { x: u2 * Math.sin(c2) * this.radius, y: -(p2 - u2 * Math.cos(c2)) * this.radius };\n      }, lcc: function(t2, e2, i2) {\n        var s2 = i2 * this.radDeg, a2 = e2 * this.radDeg, n2 = 33 * this.radDeg, r2 = 45 * this.radDeg, o2 = t2 * this.radDeg, h2 = Math.log(Math.cos(n2) * (1 / Math.cos(r2))) / Math.log(Math.tan(Math.PI / 4 + r2 / 2) * (1 / Math.tan(Math.PI / 4 + n2 / 2))), l2 = Math.cos(n2) * Math.pow(Math.tan(Math.PI / 4 + n2 / 2), h2) / h2, c2 = l2 * Math.pow(1 / Math.tan(Math.PI / 4 + o2 / 2), h2), u2 = l2 * Math.pow(1 / Math.tan(Math.PI / 4 + 0), h2);\n        return { x: c2 * Math.sin(h2 * (a2 - s2)) * this.radius, y: -(u2 - c2 * Math.cos(h2 * (a2 - s2))) * this.radius };\n      } };\n      E.degRad = 180 / Math.PI, E.radDeg = Math.PI / 180, E.radius = 6381372;\n      var T = { _setupContainerEvents: function() {\n        var t2, e2, i2 = this, s2 = this, a2 = false;\n        this.params.draggable && (S.on(this.container, \"mousemove\", function(i3) {\n          if (!a2)\n            return false;\n          s2.transX -= (t2 - i3.pageX) / s2.scale, s2.transY -= (e2 - i3.pageY) / s2.scale, s2._applyTransform(), t2 = i3.pageX, e2 = i3.pageY;\n        }), S.on(this.container, \"mousedown\", function(i3) {\n          return a2 = true, t2 = i3.pageX, e2 = i3.pageY, false;\n        }), S.on(document.body, \"mouseup\", function() {\n          a2 = false;\n        })), this.params.zoomOnScroll && S.on(this.container, \"wheel\", function(t3) {\n          var e3 = 75 * ((t3.deltaY || -t3.wheelDelta || t3.detail) >> 10 || 1), a3 = i2.container.getBoundingClientRect(), n2 = t3.pageX - a3.left - window.pageXOffset, r2 = t3.pageY - a3.top - window.pageYOffset, o2 = Math.pow(1 + s2.params.zoomOnScrollSpeed / 1e3, -1.5 * e3);\n          s2.tooltip && s2._tooltip.hide(), s2._setScale(s2.scale * o2, n2, r2), t3.preventDefault();\n        });\n      }, _setupElementEvents: function() {\n        var t2, e2, i2, s2 = this, a2 = this.container;\n        S.on(a2, \"mousemove\", function(s3) {\n          Math.abs(t2 - s3.pageX) + Math.abs(e2 - s3.pageY) > 2 && (i2 = true);\n        }), S.delegate(a2, \"mousedown\", \".jvm-element\", function(s3) {\n          t2 = s3.pageX, e2 = s3.pageY, i2 = false;\n        }), S.delegate(a2, \"mouseover mouseout\", \".jvm-element\", function(t3) {\n          var e3 = M(s2, this, true), i3 = s2.params.showTooltip;\n          \"mouseover\" === t3.type ? (e3.element.hover(true), i3 && (s2._tooltip.text(e3.tooltipText), s2._tooltip.show(), s2._emit(e3.event, [t3, s2._tooltip, e3.code]))) : (e3.element.hover(false), i3 && s2._tooltip.hide());\n        }), S.delegate(a2, \"mouseup\", \".jvm-element\", function(t3) {\n          var e3 = M(s2, this);\n          if (!i2 && (\"region\" === e3.type && s2.params.regionsSelectable || \"marker\" === e3.type && s2.params.markersSelectable)) {\n            var a3 = e3.element;\n            s2.params[e3.type + \"sSelectableOne\"] && s2._clearSelected(e3.type + \"s\"), e3.element.isSelected ? a3.select(false) : a3.select(true), s2._emit(e3.event, [e3.code, a3.isSelected, s2._getSelected(e3.type + \"s\")]);\n          }\n        }), S.delegate(a2, \"click\", \".jvm-element\", function(t3) {\n          var e3 = M(s2, this), i3 = e3.type, a3 = e3.code;\n          s2._emit(\"region\" === i3 ? k.onRegionClick : k.onMarkerClick, [t3, a3]);\n        });\n      }, _setupZoomButtons: function() {\n        var t2 = this, e2 = m(\"div\", \"jvm-zoom-btn jvm-zoomin\", \"&#43;\", true), i2 = m(\"div\", \"jvm-zoom-btn jvm-zoomout\", \"&#x2212\", true);\n        this.container.appendChild(e2), this.container.appendChild(i2);\n        var s2 = function(e3) {\n          return void 0 === e3 && (e3 = true), function() {\n            return t2._setScale(e3 ? t2.scale * t2.params.zoomStep : t2.scale / t2.params.zoomStep, t2._width / 2, t2._height / 2, false, t2.params.zoomAnimate);\n          };\n        };\n        S.on(e2, \"click\", s2()), S.on(i2, \"click\", s2(false));\n      }, _setupContainerTouchEvents: function() {\n        var t2, e2, i2, s2, a2, n2, r2, o2 = this, h2 = function(h3) {\n          var l2, c2, u2, p2, d2 = h3.touches;\n          if (\"touchstart\" == h3.type && (r2 = 0), 1 == d2.length)\n            1 == r2 && (u2 = o2.transX, p2 = o2.transY, o2.transX -= (i2 - d2[0].pageX) / o2.scale, o2.transY -= (s2 - d2[0].pageY) / o2.scale, o2._tooltip.hide(), o2._applyTransform(), u2 == o2.transX && p2 == o2.transY || h3.preventDefault()), i2 = d2[0].pageX, s2 = d2[0].pageY;\n          else if (2 == d2.length)\n            if (2 == r2)\n              c2 = Math.sqrt(Math.pow(d2[0].pageX - d2[1].pageX, 2) + Math.pow(d2[0].pageY - d2[1].pageY, 2)) / e2, o2._setScale(t2 * c2, a2, n2), o2._tooltip.hide(), h3.preventDefault();\n            else {\n              var f2 = o2.container.getBoundingClientRect();\n              l2 = { top: f2.top + window.scrollY, left: f2.left + window.scrollX }, a2 = d2[0].pageX > d2[1].pageX ? d2[1].pageX + (d2[0].pageX - d2[1].pageX) / 2 : d2[0].pageX + (d2[1].pageX - d2[0].pageX) / 2, n2 = d2[0].pageY > d2[1].pageY ? d2[1].pageY + (d2[0].pageY - d2[1].pageY) / 2 : d2[0].pageY + (d2[1].pageY - d2[0].pageY) / 2, a2 -= l2.left, n2 -= l2.top, t2 = o2.scale, e2 = Math.sqrt(Math.pow(d2[0].pageX - d2[1].pageX, 2) + Math.pow(d2[0].pageY - d2[1].pageY, 2));\n            }\n          r2 = d2.length;\n        };\n        S.on(o2.container, \"touchstart\", h2), S.on(o2.container, \"touchmove\", h2);\n      }, _createRegions: function() {\n        for (var t2 in this._regionLabelsGroup = this._regionLabelsGroup || this.canvas.createGroup(\"jvm-regions-labels-group\"), this._mapData.paths) {\n          var e2 = new C({ map: this, code: t2, path: this._mapData.paths[t2].path, style: v({}, this.params.regionStyle), labelStyle: this.params.regionLabelStyle, labelsGroup: this._regionLabelsGroup, label: this.params.labels && this.params.labels.regions });\n          this.regions[t2] = { config: this._mapData.paths[t2], element: e2 };\n        }\n      }, _createLines: function(t2, e2, i2) {\n        void 0 === i2 && (i2 = false);\n        var s2 = false, a2 = false;\n        for (var n2 in this.linesGroup = this.linesGroup || this.canvas.createGroup(\"jvm-lines-group\"), t2) {\n          var r2 = t2[n2];\n          for (var o2 in e2) {\n            var h2 = i2 ? e2[o2].config : e2[o2];\n            h2.name === r2.from && (s2 = this.getMarkerPosition(h2)), h2.name === r2.to && (a2 = this.getMarkerPosition(h2));\n          }\n          false !== s2 && false !== a2 && (this._lines[_(r2.from, r2.to)] = new L({ index: n2, map: this, style: v({ initial: this.params.lineStyle }, { initial: r2.style || {} }, true), x1: s2.x, y1: s2.y, x2: a2.x, y2: a2.y, group: this.linesGroup, config: r2 }));\n        }\n      }, _createMarkers: function(t2, e2) {\n        var i2 = this;\n        void 0 === t2 && (t2 = {}), void 0 === e2 && (e2 = false), this._markersGroup = this._markersGroup || this.canvas.createGroup(\"jvm-markers-group\"), this._markerLabelsGroup = this._markerLabelsGroup || this.canvas.createGroup(\"jvm-markers-labels-group\");\n        var s2 = function() {\n          var s3 = t2[a2], n2 = i2.getMarkerPosition(s3), r2 = s3.coords.join(\":\");\n          if (!n2)\n            return \"continue\";\n          if (e2) {\n            if (Object.keys(i2._markers).filter(function(t3) {\n              return i2._markers[t3]._uid === r2;\n            }).length)\n              return \"continue\";\n            a2 = Object.keys(i2._markers).length;\n          }\n          var o2 = new O({ index: a2, map: i2, style: v(i2.params.markerStyle, { initial: s3.style || {} }, true), label: i2.params.labels && i2.params.labels.markers, labelsGroup: i2._markerLabelsGroup, cx: n2.x, cy: n2.y, group: i2._markersGroup, marker: s3, isRecentlyCreated: e2 });\n          i2._markers[a2] && i2.removeMarkers([a2]), i2._markers[a2] = { _uid: r2, config: s3, element: o2 };\n        };\n        for (var a2 in t2)\n          s2();\n      }, _createSeries: function() {\n        for (var t2 in this.series = { markers: [], regions: [] }, this.params.series)\n          for (var e2 = 0; e2 < this.params.series[t2].length; e2++)\n            this.series[t2][e2] = new Y(this.params.series[t2][e2], \"markers\" === t2 ? this._markers : this.regions, this);\n      }, _applyTransform: function() {\n        var t2, e2, i2, s2;\n        this._defaultWidth * this.scale <= this._width ? (t2 = (this._width - this._defaultWidth * this.scale) / (2 * this.scale), i2 = (this._width - this._defaultWidth * this.scale) / (2 * this.scale)) : (t2 = 0, i2 = (this._width - this._defaultWidth * this.scale) / this.scale), this._defaultHeight * this.scale <= this._height ? (e2 = (this._height - this._defaultHeight * this.scale) / (2 * this.scale), s2 = (this._height - this._defaultHeight * this.scale) / (2 * this.scale)) : (e2 = 0, s2 = (this._height - this._defaultHeight * this.scale) / this.scale), this.transY > e2 ? this.transY = e2 : this.transY < s2 && (this.transY = s2), this.transX > t2 ? this.transX = t2 : this.transX < i2 && (this.transX = i2), this.canvas.applyTransformParams(this.scale, this.transX, this.transY), this._markers && this._repositionMarkers(), this._lines && this._repositionLines(), this._repositionLabels();\n      }, _resize: function() {\n        var t2 = this._baseScale;\n        this._width / this._height > this._defaultWidth / this._defaultHeight ? (this._baseScale = this._height / this._defaultHeight, this._baseTransX = Math.abs(this._width - this._defaultWidth * this._baseScale) / (2 * this._baseScale)) : (this._baseScale = this._width / this._defaultWidth, this._baseTransY = Math.abs(this._height - this._defaultHeight * this._baseScale) / (2 * this._baseScale)), this.scale *= this._baseScale / t2, this.transX *= this._baseScale / t2, this.transY *= this._baseScale / t2;\n      }, _setScale: function(t2, e2, i2, s2, a2) {\n        var n2, r2, o2, h2, l2, c2, u2, p2, d2, f2, m2 = this, g2 = 0, v2 = Math.abs(Math.round(60 * (t2 - this.scale) / Math.max(t2, this.scale)));\n        t2 > this.params.zoomMax * this._baseScale ? t2 = this.params.zoomMax * this._baseScale : t2 < this.params.zoomMin * this._baseScale && (t2 = this.params.zoomMin * this._baseScale), void 0 !== e2 && void 0 !== i2 && (n2 = t2 / this.scale, s2 ? (d2 = e2 + this._defaultWidth * (this._width / (this._defaultWidth * t2)) / 2, f2 = i2 + this._defaultHeight * (this._height / (this._defaultHeight * t2)) / 2) : (d2 = this.transX - (n2 - 1) / t2 * e2, f2 = this.transY - (n2 - 1) / t2 * i2)), a2 && v2 > 0 ? (o2 = this.scale, h2 = (t2 - o2) / v2, l2 = this.transX * this.scale, u2 = this.transY * this.scale, c2 = (d2 * t2 - l2) / v2, p2 = (f2 * t2 - u2) / v2, r2 = setInterval(function() {\n          g2 += 1, m2.scale = o2 + h2 * g2, m2.transX = (l2 + c2 * g2) / m2.scale, m2.transY = (u2 + p2 * g2) / m2.scale, m2._applyTransform(), g2 == v2 && (clearInterval(r2), m2._emit(k.onViewportChange, [m2.scale, m2.transX, m2.transY]));\n        }, 10)) : (this.transX = d2, this.transY = f2, this.scale = t2, this._applyTransform(), this._emit(k.onViewportChange, [this.scale, this.transX, this.transY]));\n      }, setFocus: function(t2) {\n        var e2 = this;\n        void 0 === t2 && (t2 = {});\n        var i2, s2 = [];\n        if (t2.region ? s2.push(t2.region) : t2.regions && (s2 = t2.regions), s2.length)\n          return s2.forEach(function(t3) {\n            if (e2.regions[t3]) {\n              var s3 = e2.regions[t3].element.shape.getBBox();\n              s3 && (i2 = void 0 === i2 ? s3 : { x: Math.min(i2.x, s3.x), y: Math.min(i2.y, s3.y), width: Math.max(i2.x + i2.width, s3.x + s3.width) - Math.min(i2.x, s3.x), height: Math.max(i2.y + i2.height, s3.y + s3.height) - Math.min(i2.y, s3.y) });\n            }\n          }), this._setScale(Math.min(this._width / i2.width, this._height / i2.height), -(i2.x + i2.width / 2), -(i2.y + i2.height / 2), true, t2.animate);\n        if (t2.coords) {\n          var a2 = this.coordsToPoint(t2.coords[0], t2.coords[1]), n2 = this.transX - a2.x / this.scale, r2 = this.transY - a2.y / this.scale;\n          return this._setScale(t2.scale * this._baseScale, n2, r2, true, t2.animate);\n        }\n      }, updateSize: function() {\n        this._width = this.container.offsetWidth, this._height = this.container.offsetHeight, this._resize(), this.canvas.setSize(this._width, this._height), this._applyTransform();\n      }, coordsToPoint: function(t2, e2) {\n        var i2 = G.maps[this.params.map].projection, s2 = E[i2.type](t2, e2, i2.centralMeridian), a2 = s2.x, n2 = s2.y, r2 = this.getInsetForPoint(a2, n2);\n        if (!r2)\n          return false;\n        var o2 = r2.bbox;\n        return a2 = (a2 - o2[0].x) / (o2[1].x - o2[0].x) * r2.width * this.scale, n2 = (n2 - o2[0].y) / (o2[1].y - o2[0].y) * r2.height * this.scale, { x: a2 + this.transX * this.scale + r2.left * this.scale, y: n2 + this.transY * this.scale + r2.top * this.scale };\n      }, getInsetForPoint: function(t2, e2) {\n        for (var i2 = G.maps[this.params.map].insets, s2 = 0; s2 < i2.length; s2++) {\n          var a2 = i2[s2].bbox, n2 = a2[0], r2 = a2[1];\n          if (t2 > n2.x && t2 < r2.x && e2 > n2.y && e2 < r2.y)\n            return i2[s2];\n        }\n      }, getMarkerPosition: function(t2) {\n        var e2 = t2.coords;\n        return G.maps[this.params.map].projection ? this.coordsToPoint.apply(this, e2) : { x: e2[0] * this.scale + this.transX * this.scale, y: e2[1] * this.scale + this.transY * this.scale };\n      }, _repositionLines: function() {\n        var t2 = false, e2 = false;\n        for (var i2 in this._lines) {\n          for (var s2 in this._markers) {\n            var a2 = this._markers[s2];\n            a2.config.name === this._lines[i2].config.from && (t2 = this.getMarkerPosition(a2.config)), a2.config.name === this._lines[i2].config.to && (e2 = this.getMarkerPosition(a2.config));\n          }\n          false !== t2 && false !== e2 && this._lines[i2].setStyle({ x1: t2.x, y1: t2.y, x2: e2.x, y2: e2.y });\n        }\n      }, _repositionMarkers: function() {\n        for (var t2 in this._markers) {\n          var e2 = this.getMarkerPosition(this._markers[t2].config);\n          false !== e2 && this._markers[t2].element.setStyle({ cx: e2.x, cy: e2.y });\n        }\n      }, _repositionLabels: function() {\n        var t2 = this.params.labels;\n        if (t2) {\n          if (t2.regions)\n            for (var e2 in this.regions)\n              this.regions[e2].element.updateLabelPosition();\n          if (t2.markers)\n            for (var i2 in this._markers)\n              this._markers[i2].element.updateLabelPosition();\n        }\n      } }, z = function() {\n        function t2(t3, e3) {\n          this.node = this._createElement(t3), e3 && this.set(e3);\n        }\n        var e2 = t2.prototype;\n        return e2._createElement = function(t3) {\n          return document.createElementNS(\"http://www.w3.org/2000/svg\", t3);\n        }, e2.addClass = function(t3) {\n          this.node.setAttribute(\"class\", t3);\n        }, e2.getBBox = function() {\n          return this.node.getBBox();\n        }, e2.set = function(t3, e3) {\n          if (\"object\" == typeof t3)\n            for (var i2 in t3)\n              this.applyAttr(i2, t3[i2]);\n          else\n            this.applyAttr(t3, e3);\n        }, e2.get = function(t3) {\n          return this.style.initial[t3];\n        }, e2.applyAttr = function(t3, e3) {\n          this.node.setAttribute(t3.replace(/[\\w]([A-Z])/g, function(t4) {\n            return t4[0] + \"-\" + t4[1];\n          }).toLowerCase(), e3);\n        }, e2.remove = function() {\n          g(this.node);\n        }, t2;\n      }(), P = function(e2) {\n        function i2(t2, i3, s3) {\n          var a2;\n          return void 0 === s3 && (s3 = {}), (a2 = e2.call(this, t2, i3) || this).isHovered = false, a2.isSelected = false, a2.style = s3, a2.style.current = {}, a2.updateStyle(), a2;\n        }\n        t(i2, e2);\n        var s2 = i2.prototype;\n        return s2.setStyle = function(t2, e3) {\n          var i3;\n          \"object\" == typeof t2 ? v(this.style.current, t2) : v(this.style.current, ((i3 = {})[t2] = e3, i3));\n          this.updateStyle();\n        }, s2.updateStyle = function() {\n          var t2 = {};\n          v(t2, this.style.initial), v(t2, this.style.current), this.isHovered && v(t2, this.style.hover), this.isSelected && (v(t2, this.style.selected), this.isHovered && v(t2, this.style.selectedHover)), this.set(t2);\n        }, i2;\n      }(z), D = function(e2) {\n        function i2(t2, i3) {\n          return e2.call(this, \"text\", t2, i3) || this;\n        }\n        return t(i2, e2), i2.prototype.applyAttr = function(t2, i3) {\n          \"text\" === t2 ? this.node.textContent = i3 : e2.prototype.applyAttr.call(this, t2, i3);\n        }, i2;\n      }(P), I = function(e2) {\n        function i2(t2, i3) {\n          return e2.call(this, \"image\", t2, i3) || this;\n        }\n        return t(i2, e2), i2.prototype.applyAttr = function(t2, i3) {\n          var s2;\n          \"image\" === t2 ? (\"object\" == typeof i3 ? (s2 = i3.url, this.offset = i3.offset || [0, 0]) : (s2 = i3, this.offset = [0, 0]), this.node.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", s2), this.width = 23, this.height = 23, this.applyAttr(\"width\", this.width), this.applyAttr(\"height\", this.height), this.applyAttr(\"x\", this.cx - this.width / 2 + this.offset[0]), this.applyAttr(\"y\", this.cy - this.height / 2 + this.offset[1])) : \"cx\" == t2 ? (this.cx = i3, this.width && this.applyAttr(\"x\", i3 - this.width / 2 + this.offset[0])) : \"cy\" == t2 ? (this.cy = i3, this.height && this.applyAttr(\"y\", i3 - this.height / 2 + this.offset[1])) : e2.prototype.applyAttr.apply(this, arguments);\n        }, i2;\n      }(P), R = function(e2) {\n        function i2(t2) {\n          var i3;\n          return (i3 = e2.call(this, \"svg\") || this)._container = t2, i3._defsElement = new z(\"defs\"), i3._rootElement = new z(\"g\", { id: \"jvm-regions-group\" }), i3.node.appendChild(i3._defsElement.node), i3.node.appendChild(i3._rootElement.node), i3._container.appendChild(i3.node), i3;\n        }\n        t(i2, e2);\n        var s2 = i2.prototype;\n        return s2.setSize = function(t2, e3) {\n          this.node.setAttribute(\"width\", t2), this.node.setAttribute(\"height\", e3);\n        }, s2.applyTransformParams = function(t2, e3, i3) {\n          this._rootElement.node.setAttribute(\"transform\", \"scale(\" + t2 + \") translate(\" + e3 + \", \" + i3 + \")\");\n        }, s2.createPath = function(t2, e3) {\n          var i3 = new P(\"path\", t2, e3);\n          return i3.node.setAttribute(\"fill-rule\", \"evenodd\"), this._add(i3);\n        }, s2.createCircle = function(t2, e3, i3) {\n          var s3 = new P(\"circle\", t2, e3);\n          return this._add(s3, i3);\n        }, s2.createLine = function(t2, e3, i3) {\n          var s3 = new P(\"line\", t2, e3);\n          return this._add(s3, i3);\n        }, s2.createText = function(t2, e3, i3) {\n          var s3 = new D(t2, e3);\n          return this._add(s3, i3);\n        }, s2.createImage = function(t2, e3, i3) {\n          var s3 = new I(t2, e3);\n          return this._add(s3, i3);\n        }, s2.createGroup = function(t2) {\n          var e3 = new z(\"g\");\n          return this.node.appendChild(e3.node), t2 && (e3.node.id = t2), e3.canvas = this, e3;\n        }, s2._add = function(t2, e3) {\n          return (e3 = e3 || this._rootElement).node.appendChild(t2.node), t2;\n        }, i2;\n      }(z), H = function(e2) {\n        function s2(t2) {\n          var s3;\n          s3 = e2.call(this) || this;\n          var a3 = m(\"div\", \"jvm-tooltip\");\n          return s3._map = t2, s3._tooltip = document.body.appendChild(a3), s3._bindEventListeners(), i(s3) || i(s3);\n        }\n        t(s2, e2);\n        var a2 = s2.prototype;\n        return a2._bindEventListeners = function() {\n          var t2 = this;\n          S.on(this._map.container, \"mousemove\", function(e3) {\n            if (t2._tooltip.classList.contains(\"active\")) {\n              var i2, s3, a3 = (i2 = t2._map.container, s3 = \"#jvm-regions-group\", Element.prototype.querySelector.call(i2, s3)).getBoundingClientRect(), n2 = t2._tooltip.getBoundingClientRect(), r2 = n2.height, o2 = n2.width, h2 = e3.clientY <= a3.top + r2 + 5, l2 = e3.pageY - r2 - 5, c2 = e3.pageX - o2 - 5;\n              h2 && (l2 += r2 + 5, c2 -= 10), e3.clientX < a3.left + o2 + 5 && (c2 = e3.pageX + 5 + 2, h2 && (c2 += 10)), t2.css({ top: l2 + \"px\", left: c2 + \"px\" });\n            }\n          });\n        }, a2.getElement = function() {\n          return this._tooltip;\n        }, a2.show = function() {\n          this._tooltip.classList.add(\"active\");\n        }, a2.hide = function() {\n          this._tooltip.classList.remove(\"active\");\n        }, a2.text = function(t2, e3) {\n          void 0 === e3 && (e3 = false);\n          var i2 = e3 ? \"innerHTML\" : \"textContent\";\n          if (!t2)\n            return this._tooltip[i2];\n          this._tooltip[i2] = t2;\n        }, a2.css = function(t2) {\n          for (var e3 in t2)\n            this._tooltip.style[e3] = t2[e3];\n          return this;\n        }, s2;\n      }(x), V = function() {\n        function t2(t3, e3) {\n          var i2 = t3.scale, s2 = t3.values;\n          this._scale = i2, this._values = s2, this._fromColor = this.hexToRgb(i2[0]), this._toColor = this.hexToRgb(i2[1]), this._map = e3, this.setMinMaxValues(s2), this.visualize();\n        }\n        var e2 = t2.prototype;\n        return e2.setMinMaxValues = function(t3) {\n          for (var e3 in this.min = Number.MAX_VALUE, this.max = 0, t3)\n            (e3 = parseFloat(t3[e3])) > this.max && (this.max = e3), e3 < this.min && (this.min = e3);\n        }, e2.visualize = function() {\n          var t3, e3 = {};\n          for (var i2 in this._values)\n            t3 = parseFloat(this._values[i2]), isNaN(t3) || (e3[i2] = this.getValue(t3));\n          this.setAttributes(e3);\n        }, e2.setAttributes = function(t3) {\n          for (var e3 in t3)\n            this._map.regions[e3] && this._map.regions[e3].element.setStyle(\"fill\", t3[e3]);\n        }, e2.getValue = function(t3) {\n          for (var e3, i2 = \"#\", s2 = 0; s2 < 3; s2++)\n            i2 += (1 === (e3 = Math.round(this._fromColor[s2] + (this._toColor[s2] - this._fromColor[s2]) * ((t3 - this.min) / (this.max - this.min))).toString(16)).length ? \"0\" : \"\") + e3;\n          return i2;\n        }, e2.hexToRgb = function(t3) {\n          var e3 = 0, i2 = 0, s2 = 0;\n          return 4 == t3.length ? (e3 = \"0x\" + t3[1] + t3[1], i2 = \"0x\" + t3[2] + t3[2], s2 = \"0x\" + t3[3] + t3[3]) : 7 == t3.length && (e3 = \"0x\" + t3[1] + t3[2], i2 = \"0x\" + t3[3] + t3[4], s2 = \"0x\" + t3[5] + t3[6]), [parseInt(e3), parseInt(i2), parseInt(s2)];\n        }, t2;\n      }(), G = function() {\n        function t2(e3) {\n          var i2 = this;\n          if (void 0 === e3 && (e3 = {}), this.params = v(t2.defaults, e3, true), !t2.maps[this.params.map])\n            throw new Error(\"Attempt to use map which was not loaded: \" + e3.map);\n          this.regions = {}, this.scale = 1, this.transX = 0, this.transY = 0, this._mapData = t2.maps[this.params.map], this._markers = {}, this._lines = {}, this._defaultWidth = this._mapData.width, this._defaultHeight = this._mapData.height, this._height = 0, this._width = 0, this._baseScale = 1, this._baseTransX = 0, this._baseTransY = 0, \"loading\" !== document.readyState ? this._init() : window.addEventListener(\"DOMContentLoaded\", function() {\n            return i2._init();\n          });\n        }\n        var e2 = t2.prototype;\n        return e2._init = function() {\n          var t3 = this.params;\n          this.container = f(t3.selector), this.container.classList.add(\"jvm-container\"), this.canvas = new R(this.container), this.setBackgroundColor(t3.backgroundColor), this._createRegions(), this.updateSize(), this._createLines(t3.lines || {}, t3.markers || {}), this._createMarkers(t3.markers), this._repositionLabels(), this._setupContainerEvents(), this._setupElementEvents(), t3.zoomButtons && this._setupZoomButtons(), t3.showTooltip && (this._tooltip = new H(this)), t3.selectedRegions && this._setSelected(\"regions\", t3.selectedRegions), t3.selectedMarkers && this._setSelected(\"_markers\", t3.selectedMarkers), t3.focusOn && this.setFocus(t3.focusOn), t3.visualizeData && (this.dataVisualization = new V(t3.visualizeData, this)), t3.bindTouchEvents && (\"ontouchstart\" in window || window.DocumentTouch && document instanceof DocumentTouch) && this._setupContainerTouchEvents(), t3.series && (this.container.appendChild(this.legendHorizontal = m(\"div\", \"jvm-series-container jvm-series-h\")), this.container.appendChild(this.legendVertical = m(\"div\", \"jvm-series-container jvm-series-v\")), this._createSeries()), this._emit(k.onLoaded, [this]);\n        }, e2.setBackgroundColor = function(t3) {\n          this.container.style.backgroundColor = t3;\n        }, e2.getSelectedRegions = function() {\n          return this._getSelected(\"regions\");\n        }, e2.clearSelectedRegions = function() {\n          this._clearSelected(\"regions\");\n        }, e2.getSelectedMarkers = function() {\n          return this._getSelected(\"_markers\");\n        }, e2.clearSelectedMarkers = function() {\n          this._clearSelected(\"_markers\");\n        }, e2.addMarkers = function(t3) {\n          if (Array.isArray(t3))\n            return this._createMarkers(t3, true);\n          this._createMarkers([t3], true);\n        }, e2.removeMarkers = function(t3) {\n          var e3 = this;\n          t3 || (t3 = Object.keys(this._markers)), t3.forEach(function(t4) {\n            e3._markers[t4].element.remove(), delete e3._markers[t4];\n          });\n        }, e2.addLine = function(t3, e3, i2) {\n          void 0 === i2 && (i2 = {}), console.warn(\"`addLine` method is deprecated, please use `addLines` instead.\"), this._createLines([{ from: t3, to: e3, style: i2 }], this._markers, true);\n        }, e2.addLines = function(t3) {\n          var e3 = this._getLinesAsUids();\n          Array.isArray(t3) || (t3 = [t3]), this._createLines(t3.filter(function(t4) {\n            return !(e3.indexOf(_(t4.from, t4.to)) > -1);\n          }), this._markers, true);\n        }, e2.removeLines = function(t3) {\n          var e3 = this;\n          (t3 = Array.isArray(t3) ? t3.map(function(t4) {\n            return _(t4.from, t4.to);\n          }) : this._getLinesAsUids()).forEach(function(t4) {\n            e3._lines[t4].dispose(), delete e3._lines[t4];\n          });\n        }, e2.removeLine = function(t3, e3) {\n          console.warn(\"`removeLine` method is deprecated, please use `removeLines` instead.\");\n          var i2 = _(t3, e3);\n          this._lines.hasOwnProperty(i2) && (this._lines[i2].element.remove(), delete this._lines[i2]);\n        }, e2.reset = function() {\n          for (var t3 in this.series)\n            for (var e3 = 0; e3 < this.series[t3].length; e3++)\n              this.series[t3][e3].clear();\n          this.legendHorizontal && (g(this.legendHorizontal), this.legendHorizontal = null), this.legendVertical && (g(this.legendVertical), this.legendVertical = null), this.scale = this._baseScale, this.transX = this._baseTransX, this.transY = this._baseTransY, this._applyTransform(), this.clearSelectedMarkers(), this.clearSelectedRegions(), this.removeMarkers();\n        }, e2.destroy = function(t3) {\n          var e3 = this;\n          void 0 === t3 && (t3 = true), S.flush(), this._tooltip.dispose(), this._emit(k.onDestroyed), t3 && Object.keys(this).forEach(function(t4) {\n            try {\n              delete e3[t4];\n            } catch (t5) {\n            }\n          });\n        }, e2.extend = function(e3, i2) {\n          if (\"function\" == typeof this[e3])\n            throw new Error(\"The method [\" + e3 + \"] does already exist, please use another name.\");\n          t2.prototype[e3] = i2;\n        }, e2._emit = function(t3, e3) {\n          for (var i2 in k)\n            k[i2] === t3 && \"function\" == typeof this.params[i2] && this.params[i2].apply(this, e3);\n        }, e2._getSelected = function(t3) {\n          var e3 = [];\n          for (var i2 in this[t3])\n            this[t3][i2].element.isSelected && e3.push(i2);\n          return e3;\n        }, e2._setSelected = function(t3, e3) {\n          var i2 = this;\n          e3.forEach(function(e4) {\n            i2[t3][e4] && i2[t3][e4].element.select(true);\n          });\n        }, e2._clearSelected = function(t3) {\n          var e3 = this;\n          this._getSelected(t3).forEach(function(i2) {\n            e3[t3][i2].element.select(false);\n          });\n        }, e2._getLinesAsUids = function() {\n          return Object.keys(this._lines);\n        }, t2;\n      }();\n      G.maps = {}, G.defaults = { map: \"world\", backgroundColor: \"transparent\", draggable: true, zoomButtons: true, zoomOnScroll: true, zoomOnScrollSpeed: 3, zoomMax: 12, zoomMin: 1, zoomAnimate: true, showTooltip: true, zoomStep: 1.5, bindTouchEvents: true, lineStyle: { stroke: \"#808080\", strokeWidth: 1, strokeLinecap: \"round\" }, markersSelectable: false, markersSelectableOne: false, markerStyle: { initial: { r: 7, fill: \"#374151\", fillOpacity: 1, stroke: \"#FFF\", strokeWidth: 5, strokeOpacity: 0.5 }, hover: { fill: \"#3cc0ff\", cursor: \"pointer\" }, selected: { fill: \"blue\" }, selectedHover: {} }, markerLabelStyle: { initial: { fontFamily: \"Verdana\", fontSize: 12, fontWeight: 500, cursor: \"default\", fill: \"#374151\" }, hover: { cursor: \"pointer\" }, selected: {}, selectedHover: {} }, regionsSelectable: false, regionsSelectableOne: false, regionStyle: { initial: { fill: \"#dee2e8\", fillOpacity: 1, stroke: \"none\", strokeWidth: 0 }, hover: { fillOpacity: 0.7, cursor: \"pointer\" }, selected: { fill: \"#9ca3af\" }, selectedHover: {} }, regionLabelStyle: { initial: { fontFamily: \"Verdana\", fontSize: \"12\", fontWeight: \"bold\", cursor: \"default\", fill: \"#35373e\" }, hover: { cursor: \"pointer\" } } }, Object.assign(G.prototype, T);\n      var B = function() {\n        function t2(t3) {\n          if (void 0 === t3 && (t3 = {}), !t3.selector)\n            throw new Error(\"Selector is not given.\");\n          return new G(t3);\n        }\n        return t2.addMap = function(t3, e2) {\n          G.maps[t3] = e2;\n        }, t2;\n      }();\n      return window.jsVectorMap = B;\n    });\n  }\n});\nexport default require_jsvectormap_min();\n//# sourceMappingURL=jsvectormap.js.map\n",
      "start": 1703289449942,
      "end": 1703289449952,
      "sourcemaps": null
    },
    {
      "name": "vite:react-babel",
      "start": 1703289449952,
      "end": 1703289449952,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1703289449952,
      "end": 1703289449952,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1703289449952,
      "end": 1703289449952,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1703289449952,
      "end": 1703289449952,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1703289449952,
      "end": 1703289449952,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1703289449952,
      "end": 1703289449952,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1703289449952,
      "end": 1703289449952,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1703289449952,
      "end": 1703289449953,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1703289449953,
      "end": 1703289449953,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1703289449953,
      "end": 1703289449953,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1703289449953,
      "end": 1703289449953,
      "order": "normal"
    },
    {
      "name": "vite:client-inject",
      "start": 1703289449953,
      "end": 1703289449953,
      "order": "normal"
    },
    {
      "name": "vite:import-analysis",
      "result": "\"use strict\";\n(() => {\n  var __create = Object.create;\n  var __defProp = Object.defineProperty;\n  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n  var __getOwnPropNames = Object.getOwnPropertyNames;\n  var __getProtoOf = Object.getPrototypeOf;\n  var __hasOwnProp = Object.prototype.hasOwnProperty;\n  var __esm = (fn, res) => function __init() {\n    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;\n  };\n  var __commonJS = (cb, mod) => function __require() {\n    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n  };\n  var __copyProps = (to, from, except, desc) => {\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n      for (let key of __getOwnPropNames(from))\n        if (!__hasOwnProp.call(to, key) && key !== except)\n          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n    }\n    return to;\n  };\n  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n    // If the importer is in node compatibility mode or this is not an ESM\n    // file that has been converted to a CommonJS file using a Babel-\n    // compatible transform (i.e. \"__esModule\" has not been set), then set\n    // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n    isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n    mod\n  ));\n\n  // node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js\n  var require_base64_js = __commonJS({\n    \"node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js\"(exports) {\n      \"use strict\";\n      init_dist();\n      exports.byteLength = byteLength;\n      exports.toByteArray = toByteArray;\n      exports.fromByteArray = fromByteArray;\n      var lookup = [];\n      var revLookup = [];\n      var Arr = typeof Uint8Array !== \"undefined\" ? Uint8Array : Array;\n      var code = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n      for (i = 0, len = code.length; i < len; ++i) {\n        lookup[i] = code[i];\n        revLookup[code.charCodeAt(i)] = i;\n      }\n      var i;\n      var len;\n      revLookup[\"-\".charCodeAt(0)] = 62;\n      revLookup[\"_\".charCodeAt(0)] = 63;\n      function getLens(b64) {\n        var len2 = b64.length;\n        if (len2 % 4 > 0) {\n          throw new Error(\"Invalid string. Length must be a multiple of 4\");\n        }\n        var validLen = b64.indexOf(\"=\");\n        if (validLen === -1)\n          validLen = len2;\n        var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;\n        return [validLen, placeHoldersLen];\n      }\n      function byteLength(b64) {\n        var lens = getLens(b64);\n        var validLen = lens[0];\n        var placeHoldersLen = lens[1];\n        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n      }\n      function _byteLength(b64, validLen, placeHoldersLen) {\n        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n      }\n      function toByteArray(b64) {\n        var tmp;\n        var lens = getLens(b64);\n        var validLen = lens[0];\n        var placeHoldersLen = lens[1];\n        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n        var curByte = 0;\n        var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;\n        var i2;\n        for (i2 = 0; i2 < len2; i2 += 4) {\n          tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];\n          arr[curByte++] = tmp >> 16 & 255;\n          arr[curByte++] = tmp >> 8 & 255;\n          arr[curByte++] = tmp & 255;\n        }\n        if (placeHoldersLen === 2) {\n          tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;\n          arr[curByte++] = tmp & 255;\n        }\n        if (placeHoldersLen === 1) {\n          tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;\n          arr[curByte++] = tmp >> 8 & 255;\n          arr[curByte++] = tmp & 255;\n        }\n        return arr;\n      }\n      function tripletToBase64(num) {\n        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];\n      }\n      function encodeChunk(uint8, start, end) {\n        var tmp;\n        var output = [];\n        for (var i2 = start; i2 < end; i2 += 3) {\n          tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);\n          output.push(tripletToBase64(tmp));\n        }\n        return output.join(\"\");\n      }\n      function fromByteArray(uint8) {\n        var tmp;\n        var len2 = uint8.length;\n        var extraBytes = len2 % 3;\n        var parts = [];\n        var maxChunkLength = 16383;\n        for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {\n          parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));\n        }\n        if (extraBytes === 1) {\n          tmp = uint8[len2 - 1];\n          parts.push(\n            lookup[tmp >> 2] + lookup[tmp << 4 & 63] + \"==\"\n          );\n        } else if (extraBytes === 2) {\n          tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];\n          parts.push(\n            lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + \"=\"\n          );\n        }\n        return parts.join(\"\");\n      }\n    }\n  });\n\n  // node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js\n  var require_ieee754 = __commonJS({\n    \"node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js\"(exports) {\n      init_dist();\n      exports.read = function(buffer, offset, isLE, mLen, nBytes) {\n        var e, m;\n        var eLen = nBytes * 8 - mLen - 1;\n        var eMax = (1 << eLen) - 1;\n        var eBias = eMax >> 1;\n        var nBits = -7;\n        var i = isLE ? nBytes - 1 : 0;\n        var d = isLE ? -1 : 1;\n        var s2 = buffer[offset + i];\n        i += d;\n        e = s2 & (1 << -nBits) - 1;\n        s2 >>= -nBits;\n        nBits += eLen;\n        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {\n        }\n        m = e & (1 << -nBits) - 1;\n        e >>= -nBits;\n        nBits += mLen;\n        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {\n        }\n        if (e === 0) {\n          e = 1 - eBias;\n        } else if (e === eMax) {\n          return m ? NaN : (s2 ? -1 : 1) * Infinity;\n        } else {\n          m = m + Math.pow(2, mLen);\n          e = e - eBias;\n        }\n        return (s2 ? -1 : 1) * m * Math.pow(2, e - mLen);\n      };\n      exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {\n        var e, m, c;\n        var eLen = nBytes * 8 - mLen - 1;\n        var eMax = (1 << eLen) - 1;\n        var eBias = eMax >> 1;\n        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n        var i = isLE ? 0 : nBytes - 1;\n        var d = isLE ? 1 : -1;\n        var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n        value = Math.abs(value);\n        if (isNaN(value) || value === Infinity) {\n          m = isNaN(value) ? 1 : 0;\n          e = eMax;\n        } else {\n          e = Math.floor(Math.log(value) / Math.LN2);\n          if (value * (c = Math.pow(2, -e)) < 1) {\n            e--;\n            c *= 2;\n          }\n          if (e + eBias >= 1) {\n            value += rt / c;\n          } else {\n            value += rt * Math.pow(2, 1 - eBias);\n          }\n          if (value * c >= 2) {\n            e++;\n            c /= 2;\n          }\n          if (e + eBias >= eMax) {\n            m = 0;\n            e = eMax;\n          } else if (e + eBias >= 1) {\n            m = (value * c - 1) * Math.pow(2, mLen);\n            e = e + eBias;\n          } else {\n            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n            e = 0;\n          }\n        }\n        for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {\n        }\n        e = e << mLen | m;\n        eLen += mLen;\n        for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {\n        }\n        buffer[offset + i - d] |= s2 * 128;\n      };\n    }\n  });\n\n  // node_modules/.pnpm/buffer@6.0.3_patch_hash=zkkuxompt5d553skpnegwi5wuy/node_modules/buffer/index.js\n  var require_buffer = __commonJS({\n    \"node_modules/.pnpm/buffer@6.0.3_patch_hash=zkkuxompt5d553skpnegwi5wuy/node_modules/buffer/index.js\"(exports) {\n      \"use strict\";\n      init_dist();\n      var base64 = require_base64_js();\n      var ieee754 = require_ieee754();\n      var customInspectSymbol = typeof Symbol === \"function\" && typeof Symbol[\"for\"] === \"function\" ? Symbol[\"for\"](\"nodejs.util.inspect.custom\") : null;\n      exports.Buffer = Buffer2;\n      exports.SlowBuffer = SlowBuffer;\n      exports.INSPECT_MAX_BYTES = 50;\n      var K_MAX_LENGTH = 2147483647;\n      exports.kMaxLength = K_MAX_LENGTH;\n      var { Uint8Array: GlobalUint8Array, ArrayBuffer: GlobalArrayBuffer, SharedArrayBuffer: GlobalSharedArrayBuffer } = globalThis;\n      Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();\n      if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== \"undefined\" && typeof console.error === \"function\") {\n        console.error(\n          \"This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.\"\n        );\n      }\n      function typedArraySupport() {\n        try {\n          const arr = new GlobalUint8Array(1);\n          const proto = { foo: function() {\n            return 42;\n          } };\n          Object.setPrototypeOf(proto, GlobalUint8Array.prototype);\n          Object.setPrototypeOf(arr, proto);\n          return arr.foo() === 42;\n        } catch (e) {\n          return false;\n        }\n      }\n      Object.defineProperty(Buffer2.prototype, \"parent\", {\n        enumerable: true,\n        get: function() {\n          if (!Buffer2.isBuffer(this))\n            return void 0;\n          return this.buffer;\n        }\n      });\n      Object.defineProperty(Buffer2.prototype, \"offset\", {\n        enumerable: true,\n        get: function() {\n          if (!Buffer2.isBuffer(this))\n            return void 0;\n          return this.byteOffset;\n        }\n      });\n      function createBuffer(length) {\n        if (length > K_MAX_LENGTH) {\n          throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"');\n        }\n        const buf = new GlobalUint8Array(length);\n        Object.setPrototypeOf(buf, Buffer2.prototype);\n        return buf;\n      }\n      function Buffer2(arg, encodingOrOffset, length) {\n        if (typeof arg === \"number\") {\n          if (typeof encodingOrOffset === \"string\") {\n            throw new TypeError(\n              'The \"string\" argument must be of type string. Received type number'\n            );\n          }\n          return allocUnsafe(arg);\n        }\n        return from(arg, encodingOrOffset, length);\n      }\n      Buffer2.poolSize = 8192;\n      function from(value, encodingOrOffset, length) {\n        if (typeof value === \"string\") {\n          return fromString(value, encodingOrOffset);\n        }\n        if (GlobalArrayBuffer.isView(value)) {\n          return fromArrayView(value);\n        }\n        if (value == null) {\n          throw new TypeError(\n            \"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value\n          );\n        }\n        if (isInstance(value, GlobalArrayBuffer) || value && isInstance(value.buffer, GlobalArrayBuffer)) {\n          return fromArrayBuffer(value, encodingOrOffset, length);\n        }\n        if (typeof GlobalSharedArrayBuffer !== \"undefined\" && (isInstance(value, GlobalSharedArrayBuffer) || value && isInstance(value.buffer, GlobalSharedArrayBuffer))) {\n          return fromArrayBuffer(value, encodingOrOffset, length);\n        }\n        if (typeof value === \"number\") {\n          throw new TypeError(\n            'The \"value\" argument must not be of type number. Received type number'\n          );\n        }\n        const valueOf = value.valueOf && value.valueOf();\n        if (valueOf != null && valueOf !== value) {\n          return Buffer2.from(valueOf, encodingOrOffset, length);\n        }\n        const b = fromObject(value);\n        if (b)\n          return b;\n        if (typeof Symbol !== \"undefined\" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === \"function\") {\n          return Buffer2.from(value[Symbol.toPrimitive](\"string\"), encodingOrOffset, length);\n        }\n        throw new TypeError(\n          \"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value\n        );\n      }\n      Buffer2.from = function(value, encodingOrOffset, length) {\n        return from(value, encodingOrOffset, length);\n      };\n      Object.setPrototypeOf(Buffer2.prototype, GlobalUint8Array.prototype);\n      Object.setPrototypeOf(Buffer2, GlobalUint8Array);\n      function assertSize(size) {\n        if (typeof size !== \"number\") {\n          throw new TypeError('\"size\" argument must be of type number');\n        } else if (size < 0) {\n          throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"');\n        }\n      }\n      function alloc(size, fill, encoding) {\n        assertSize(size);\n        if (size <= 0) {\n          return createBuffer(size);\n        }\n        if (fill !== void 0) {\n          return typeof encoding === \"string\" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);\n        }\n        return createBuffer(size);\n      }\n      Buffer2.alloc = function(size, fill, encoding) {\n        return alloc(size, fill, encoding);\n      };\n      function allocUnsafe(size) {\n        assertSize(size);\n        return createBuffer(size < 0 ? 0 : checked(size) | 0);\n      }\n      Buffer2.allocUnsafe = function(size) {\n        return allocUnsafe(size);\n      };\n      Buffer2.allocUnsafeSlow = function(size) {\n        return allocUnsafe(size);\n      };\n      function fromString(string, encoding) {\n        if (typeof encoding !== \"string\" || encoding === \"\") {\n          encoding = \"utf8\";\n        }\n        if (!Buffer2.isEncoding(encoding)) {\n          throw new TypeError(\"Unknown encoding: \" + encoding);\n        }\n        const length = byteLength(string, encoding) | 0;\n        let buf = createBuffer(length);\n        const actual = buf.write(string, encoding);\n        if (actual !== length) {\n          buf = buf.slice(0, actual);\n        }\n        return buf;\n      }\n      function fromArrayLike(array) {\n        const length = array.length < 0 ? 0 : checked(array.length) | 0;\n        const buf = createBuffer(length);\n        for (let i = 0; i < length; i += 1) {\n          buf[i] = array[i] & 255;\n        }\n        return buf;\n      }\n      function fromArrayView(arrayView) {\n        if (isInstance(arrayView, GlobalUint8Array)) {\n          const copy = new GlobalUint8Array(arrayView);\n          return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);\n        }\n        return fromArrayLike(arrayView);\n      }\n      function fromArrayBuffer(array, byteOffset, length) {\n        if (byteOffset < 0 || array.byteLength < byteOffset) {\n          throw new RangeError('\"offset\" is outside of buffer bounds');\n        }\n        if (array.byteLength < byteOffset + (length || 0)) {\n          throw new RangeError('\"length\" is outside of buffer bounds');\n        }\n        let buf;\n        if (byteOffset === void 0 && length === void 0) {\n          buf = new GlobalUint8Array(array);\n        } else if (length === void 0) {\n          buf = new GlobalUint8Array(array, byteOffset);\n        } else {\n          buf = new GlobalUint8Array(array, byteOffset, length);\n        }\n        Object.setPrototypeOf(buf, Buffer2.prototype);\n        return buf;\n      }\n      function fromObject(obj) {\n        if (Buffer2.isBuffer(obj)) {\n          const len = checked(obj.length) | 0;\n          const buf = createBuffer(len);\n          if (buf.length === 0) {\n            return buf;\n          }\n          obj.copy(buf, 0, 0, len);\n          return buf;\n        }\n        if (obj.length !== void 0) {\n          if (typeof obj.length !== \"number\" || numberIsNaN(obj.length)) {\n            return createBuffer(0);\n          }\n          return fromArrayLike(obj);\n        }\n        if (obj.type === \"Buffer\" && Array.isArray(obj.data)) {\n          return fromArrayLike(obj.data);\n        }\n      }\n      function checked(length) {\n        if (length >= K_MAX_LENGTH) {\n          throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\" + K_MAX_LENGTH.toString(16) + \" bytes\");\n        }\n        return length | 0;\n      }\n      function SlowBuffer(length) {\n        if (+length != length) {\n          length = 0;\n        }\n        return Buffer2.alloc(+length);\n      }\n      Buffer2.isBuffer = function isBuffer(b) {\n        return b != null && b._isBuffer === true && b !== Buffer2.prototype;\n      };\n      Buffer2.compare = function compare(a, b) {\n        if (isInstance(a, GlobalUint8Array))\n          a = Buffer2.from(a, a.offset, a.byteLength);\n        if (isInstance(b, GlobalUint8Array))\n          b = Buffer2.from(b, b.offset, b.byteLength);\n        if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {\n          throw new TypeError(\n            'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n          );\n        }\n        if (a === b)\n          return 0;\n        let x = a.length;\n        let y = b.length;\n        for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n          if (a[i] !== b[i]) {\n            x = a[i];\n            y = b[i];\n            break;\n          }\n        }\n        if (x < y)\n          return -1;\n        if (y < x)\n          return 1;\n        return 0;\n      };\n      Buffer2.isEncoding = function isEncoding(encoding) {\n        switch (String(encoding).toLowerCase()) {\n          case \"hex\":\n          case \"utf8\":\n          case \"utf-8\":\n          case \"ascii\":\n          case \"latin1\":\n          case \"binary\":\n          case \"base64\":\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return true;\n          default:\n            return false;\n        }\n      };\n      Buffer2.concat = function concat(list, length) {\n        if (!Array.isArray(list)) {\n          throw new TypeError('\"list\" argument must be an Array of Buffers');\n        }\n        if (list.length === 0) {\n          return Buffer2.alloc(0);\n        }\n        let i;\n        if (length === void 0) {\n          length = 0;\n          for (i = 0; i < list.length; ++i) {\n            length += list[i].length;\n          }\n        }\n        const buffer = Buffer2.allocUnsafe(length);\n        let pos = 0;\n        for (i = 0; i < list.length; ++i) {\n          let buf = list[i];\n          if (isInstance(buf, GlobalUint8Array)) {\n            if (pos + buf.length > buffer.length) {\n              if (!Buffer2.isBuffer(buf))\n                buf = Buffer2.from(buf);\n              buf.copy(buffer, pos);\n            } else {\n              GlobalUint8Array.prototype.set.call(\n                buffer,\n                buf,\n                pos\n              );\n            }\n          } else if (!Buffer2.isBuffer(buf)) {\n            throw new TypeError('\"list\" argument must be an Array of Buffers');\n          } else {\n            buf.copy(buffer, pos);\n          }\n          pos += buf.length;\n        }\n        return buffer;\n      };\n      function byteLength(string, encoding) {\n        if (Buffer2.isBuffer(string)) {\n          return string.length;\n        }\n        if (GlobalArrayBuffer.isView(string) || isInstance(string, GlobalArrayBuffer)) {\n          return string.byteLength;\n        }\n        if (typeof string !== \"string\") {\n          throw new TypeError(\n            'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string\n          );\n        }\n        const len = string.length;\n        const mustMatch = arguments.length > 2 && arguments[2] === true;\n        if (!mustMatch && len === 0)\n          return 0;\n        let loweredCase = false;\n        for (; ; ) {\n          switch (encoding) {\n            case \"ascii\":\n            case \"latin1\":\n            case \"binary\":\n              return len;\n            case \"utf8\":\n            case \"utf-8\":\n              return utf8ToBytes(string).length;\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n              return len * 2;\n            case \"hex\":\n              return len >>> 1;\n            case \"base64\":\n              return base64ToBytes(string).length;\n            default:\n              if (loweredCase) {\n                return mustMatch ? -1 : utf8ToBytes(string).length;\n              }\n              encoding = (\"\" + encoding).toLowerCase();\n              loweredCase = true;\n          }\n        }\n      }\n      Buffer2.byteLength = byteLength;\n      function slowToString(encoding, start, end) {\n        let loweredCase = false;\n        if (start === void 0 || start < 0) {\n          start = 0;\n        }\n        if (start > this.length) {\n          return \"\";\n        }\n        if (end === void 0 || end > this.length) {\n          end = this.length;\n        }\n        if (end <= 0) {\n          return \"\";\n        }\n        end >>>= 0;\n        start >>>= 0;\n        if (end <= start) {\n          return \"\";\n        }\n        if (!encoding)\n          encoding = \"utf8\";\n        while (true) {\n          switch (encoding) {\n            case \"hex\":\n              return hexSlice(this, start, end);\n            case \"utf8\":\n            case \"utf-8\":\n              return utf8Slice(this, start, end);\n            case \"ascii\":\n              return asciiSlice(this, start, end);\n            case \"latin1\":\n            case \"binary\":\n              return latin1Slice(this, start, end);\n            case \"base64\":\n              return base64Slice(this, start, end);\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n              return utf16leSlice(this, start, end);\n            default:\n              if (loweredCase)\n                throw new TypeError(\"Unknown encoding: \" + encoding);\n              encoding = (encoding + \"\").toLowerCase();\n              loweredCase = true;\n          }\n        }\n      }\n      Buffer2.prototype._isBuffer = true;\n      function swap(b, n, m) {\n        const i = b[n];\n        b[n] = b[m];\n        b[m] = i;\n      }\n      Buffer2.prototype.swap16 = function swap16() {\n        const len = this.length;\n        if (len % 2 !== 0) {\n          throw new RangeError(\"Buffer size must be a multiple of 16-bits\");\n        }\n        for (let i = 0; i < len; i += 2) {\n          swap(this, i, i + 1);\n        }\n        return this;\n      };\n      Buffer2.prototype.swap32 = function swap32() {\n        const len = this.length;\n        if (len % 4 !== 0) {\n          throw new RangeError(\"Buffer size must be a multiple of 32-bits\");\n        }\n        for (let i = 0; i < len; i += 4) {\n          swap(this, i, i + 3);\n          swap(this, i + 1, i + 2);\n        }\n        return this;\n      };\n      Buffer2.prototype.swap64 = function swap64() {\n        const len = this.length;\n        if (len % 8 !== 0) {\n          throw new RangeError(\"Buffer size must be a multiple of 64-bits\");\n        }\n        for (let i = 0; i < len; i += 8) {\n          swap(this, i, i + 7);\n          swap(this, i + 1, i + 6);\n          swap(this, i + 2, i + 5);\n          swap(this, i + 3, i + 4);\n        }\n        return this;\n      };\n      Buffer2.prototype.toString = function toString() {\n        const length = this.length;\n        if (length === 0)\n          return \"\";\n        if (arguments.length === 0)\n          return utf8Slice(this, 0, length);\n        return slowToString.apply(this, arguments);\n      };\n      Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;\n      Buffer2.prototype.equals = function equals(b) {\n        if (!Buffer2.isBuffer(b))\n          throw new TypeError(\"Argument must be a Buffer\");\n        if (this === b)\n          return true;\n        return Buffer2.compare(this, b) === 0;\n      };\n      Buffer2.prototype.inspect = function inspect() {\n        let str = \"\";\n        const max = exports.INSPECT_MAX_BYTES;\n        str = this.toString(\"hex\", 0, max).replace(/(.{2})/g, \"$1 \").trim();\n        if (this.length > max)\n          str += \" ... \";\n        return \"<Buffer \" + str + \">\";\n      };\n      if (customInspectSymbol) {\n        Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;\n      }\n      Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n        if (isInstance(target, GlobalUint8Array)) {\n          target = Buffer2.from(target, target.offset, target.byteLength);\n        }\n        if (!Buffer2.isBuffer(target)) {\n          throw new TypeError(\n            'The \"target\" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target\n          );\n        }\n        if (start === void 0) {\n          start = 0;\n        }\n        if (end === void 0) {\n          end = target ? target.length : 0;\n        }\n        if (thisStart === void 0) {\n          thisStart = 0;\n        }\n        if (thisEnd === void 0) {\n          thisEnd = this.length;\n        }\n        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n          throw new RangeError(\"out of range index\");\n        }\n        if (thisStart >= thisEnd && start >= end) {\n          return 0;\n        }\n        if (thisStart >= thisEnd) {\n          return -1;\n        }\n        if (start >= end) {\n          return 1;\n        }\n        start >>>= 0;\n        end >>>= 0;\n        thisStart >>>= 0;\n        thisEnd >>>= 0;\n        if (this === target)\n          return 0;\n        let x = thisEnd - thisStart;\n        let y = end - start;\n        const len = Math.min(x, y);\n        const thisCopy = this.slice(thisStart, thisEnd);\n        const targetCopy = target.slice(start, end);\n        for (let i = 0; i < len; ++i) {\n          if (thisCopy[i] !== targetCopy[i]) {\n            x = thisCopy[i];\n            y = targetCopy[i];\n            break;\n          }\n        }\n        if (x < y)\n          return -1;\n        if (y < x)\n          return 1;\n        return 0;\n      };\n      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n        if (buffer.length === 0)\n          return -1;\n        if (typeof byteOffset === \"string\") {\n          encoding = byteOffset;\n          byteOffset = 0;\n        } else if (byteOffset > 2147483647) {\n          byteOffset = 2147483647;\n        } else if (byteOffset < -2147483648) {\n          byteOffset = -2147483648;\n        }\n        byteOffset = +byteOffset;\n        if (numberIsNaN(byteOffset)) {\n          byteOffset = dir ? 0 : buffer.length - 1;\n        }\n        if (byteOffset < 0)\n          byteOffset = buffer.length + byteOffset;\n        if (byteOffset >= buffer.length) {\n          if (dir)\n            return -1;\n          else\n            byteOffset = buffer.length - 1;\n        } else if (byteOffset < 0) {\n          if (dir)\n            byteOffset = 0;\n          else\n            return -1;\n        }\n        if (typeof val === \"string\") {\n          val = Buffer2.from(val, encoding);\n        }\n        if (Buffer2.isBuffer(val)) {\n          if (val.length === 0) {\n            return -1;\n          }\n          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n        } else if (typeof val === \"number\") {\n          val = val & 255;\n          if (typeof GlobalUint8Array.prototype.indexOf === \"function\") {\n            if (dir) {\n              return GlobalUint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n            } else {\n              return GlobalUint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n            }\n          }\n          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);\n        }\n        throw new TypeError(\"val must be string, number or Buffer\");\n      }\n      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n        let indexSize = 1;\n        let arrLength = arr.length;\n        let valLength = val.length;\n        if (encoding !== void 0) {\n          encoding = String(encoding).toLowerCase();\n          if (encoding === \"ucs2\" || encoding === \"ucs-2\" || encoding === \"utf16le\" || encoding === \"utf-16le\") {\n            if (arr.length < 2 || val.length < 2) {\n              return -1;\n            }\n            indexSize = 2;\n            arrLength /= 2;\n            valLength /= 2;\n            byteOffset /= 2;\n          }\n        }\n        function read(buf, i2) {\n          if (indexSize === 1) {\n            return buf[i2];\n          } else {\n            return buf.readUInt16BE(i2 * indexSize);\n          }\n        }\n        let i;\n        if (dir) {\n          let foundIndex = -1;\n          for (i = byteOffset; i < arrLength; i++) {\n            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n              if (foundIndex === -1)\n                foundIndex = i;\n              if (i - foundIndex + 1 === valLength)\n                return foundIndex * indexSize;\n            } else {\n              if (foundIndex !== -1)\n                i -= i - foundIndex;\n              foundIndex = -1;\n            }\n          }\n        } else {\n          if (byteOffset + valLength > arrLength)\n            byteOffset = arrLength - valLength;\n          for (i = byteOffset; i >= 0; i--) {\n            let found = true;\n            for (let j = 0; j < valLength; j++) {\n              if (read(arr, i + j) !== read(val, j)) {\n                found = false;\n                break;\n              }\n            }\n            if (found)\n              return i;\n          }\n        }\n        return -1;\n      }\n      Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {\n        return this.indexOf(val, byteOffset, encoding) !== -1;\n      };\n      Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n      };\n      Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n      };\n      function hexWrite(buf, string, offset, length) {\n        offset = Number(offset) || 0;\n        const remaining = buf.length - offset;\n        if (!length) {\n          length = remaining;\n        } else {\n          length = Number(length);\n          if (length > remaining) {\n            length = remaining;\n          }\n        }\n        const strLen = string.length;\n        if (length > strLen / 2) {\n          length = strLen / 2;\n        }\n        let i;\n        for (i = 0; i < length; ++i) {\n          const parsed = parseInt(string.substr(i * 2, 2), 16);\n          if (numberIsNaN(parsed))\n            return i;\n          buf[offset + i] = parsed;\n        }\n        return i;\n      }\n      function utf8Write(buf, string, offset, length) {\n        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n      }\n      function asciiWrite(buf, string, offset, length) {\n        return blitBuffer(asciiToBytes(string), buf, offset, length);\n      }\n      function base64Write(buf, string, offset, length) {\n        return blitBuffer(base64ToBytes(string), buf, offset, length);\n      }\n      function ucs2Write(buf, string, offset, length) {\n        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n      }\n      Buffer2.prototype.write = function write(string, offset, length, encoding) {\n        if (offset === void 0) {\n          encoding = \"utf8\";\n          length = this.length;\n          offset = 0;\n        } else if (length === void 0 && typeof offset === \"string\") {\n          encoding = offset;\n          length = this.length;\n          offset = 0;\n        } else if (isFinite(offset)) {\n          offset = offset >>> 0;\n          if (isFinite(length)) {\n            length = length >>> 0;\n            if (encoding === void 0)\n              encoding = \"utf8\";\n          } else {\n            encoding = length;\n            length = void 0;\n          }\n        } else {\n          throw new Error(\n            \"Buffer.write(string, encoding, offset[, length]) is no longer supported\"\n          );\n        }\n        const remaining = this.length - offset;\n        if (length === void 0 || length > remaining)\n          length = remaining;\n        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n          throw new RangeError(\"Attempt to write outside buffer bounds\");\n        }\n        if (!encoding)\n          encoding = \"utf8\";\n        let loweredCase = false;\n        for (; ; ) {\n          switch (encoding) {\n            case \"hex\":\n              return hexWrite(this, string, offset, length);\n            case \"utf8\":\n            case \"utf-8\":\n              return utf8Write(this, string, offset, length);\n            case \"ascii\":\n            case \"latin1\":\n            case \"binary\":\n              return asciiWrite(this, string, offset, length);\n            case \"base64\":\n              return base64Write(this, string, offset, length);\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n              return ucs2Write(this, string, offset, length);\n            default:\n              if (loweredCase)\n                throw new TypeError(\"Unknown encoding: \" + encoding);\n              encoding = (\"\" + encoding).toLowerCase();\n              loweredCase = true;\n          }\n        }\n      };\n      Buffer2.prototype.toJSON = function toJSON() {\n        return {\n          type: \"Buffer\",\n          data: Array.prototype.slice.call(this._arr || this, 0)\n        };\n      };\n      function base64Slice(buf, start, end) {\n        if (start === 0 && end === buf.length) {\n          return base64.fromByteArray(buf);\n        } else {\n          return base64.fromByteArray(buf.slice(start, end));\n        }\n      }\n      function utf8Slice(buf, start, end) {\n        end = Math.min(buf.length, end);\n        const res = [];\n        let i = start;\n        while (i < end) {\n          const firstByte = buf[i];\n          let codePoint = null;\n          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;\n          if (i + bytesPerSequence <= end) {\n            let secondByte, thirdByte, fourthByte, tempCodePoint;\n            switch (bytesPerSequence) {\n              case 1:\n                if (firstByte < 128) {\n                  codePoint = firstByte;\n                }\n                break;\n              case 2:\n                secondByte = buf[i + 1];\n                if ((secondByte & 192) === 128) {\n                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;\n                  if (tempCodePoint > 127) {\n                    codePoint = tempCodePoint;\n                  }\n                }\n                break;\n              case 3:\n                secondByte = buf[i + 1];\n                thirdByte = buf[i + 2];\n                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {\n                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;\n                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {\n                    codePoint = tempCodePoint;\n                  }\n                }\n                break;\n              case 4:\n                secondByte = buf[i + 1];\n                thirdByte = buf[i + 2];\n                fourthByte = buf[i + 3];\n                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {\n                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;\n                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {\n                    codePoint = tempCodePoint;\n                  }\n                }\n            }\n          }\n          if (codePoint === null) {\n            codePoint = 65533;\n            bytesPerSequence = 1;\n          } else if (codePoint > 65535) {\n            codePoint -= 65536;\n            res.push(codePoint >>> 10 & 1023 | 55296);\n            codePoint = 56320 | codePoint & 1023;\n          }\n          res.push(codePoint);\n          i += bytesPerSequence;\n        }\n        return decodeCodePointsArray(res);\n      }\n      var MAX_ARGUMENTS_LENGTH = 4096;\n      function decodeCodePointsArray(codePoints) {\n        const len = codePoints.length;\n        if (len <= MAX_ARGUMENTS_LENGTH) {\n          return String.fromCharCode.apply(String, codePoints);\n        }\n        let res = \"\";\n        let i = 0;\n        while (i < len) {\n          res += String.fromCharCode.apply(\n            String,\n            codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n          );\n        }\n        return res;\n      }\n      function asciiSlice(buf, start, end) {\n        let ret = \"\";\n        end = Math.min(buf.length, end);\n        for (let i = start; i < end; ++i) {\n          ret += String.fromCharCode(buf[i] & 127);\n        }\n        return ret;\n      }\n      function latin1Slice(buf, start, end) {\n        let ret = \"\";\n        end = Math.min(buf.length, end);\n        for (let i = start; i < end; ++i) {\n          ret += String.fromCharCode(buf[i]);\n        }\n        return ret;\n      }\n      function hexSlice(buf, start, end) {\n        const len = buf.length;\n        if (!start || start < 0)\n          start = 0;\n        if (!end || end < 0 || end > len)\n          end = len;\n        let out = \"\";\n        for (let i = start; i < end; ++i) {\n          out += hexSliceLookupTable[buf[i]];\n        }\n        return out;\n      }\n      function utf16leSlice(buf, start, end) {\n        const bytes = buf.slice(start, end);\n        let res = \"\";\n        for (let i = 0; i < bytes.length - 1; i += 2) {\n          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n        }\n        return res;\n      }\n      Buffer2.prototype.slice = function slice(start, end) {\n        const len = this.length;\n        start = ~~start;\n        end = end === void 0 ? len : ~~end;\n        if (start < 0) {\n          start += len;\n          if (start < 0)\n            start = 0;\n        } else if (start > len) {\n          start = len;\n        }\n        if (end < 0) {\n          end += len;\n          if (end < 0)\n            end = 0;\n        } else if (end > len) {\n          end = len;\n        }\n        if (end < start)\n          end = start;\n        const newBuf = this.subarray(start, end);\n        Object.setPrototypeOf(newBuf, Buffer2.prototype);\n        return newBuf;\n      };\n      function checkOffset(offset, ext, length) {\n        if (offset % 1 !== 0 || offset < 0)\n          throw new RangeError(\"offset is not uint\");\n        if (offset + ext > length)\n          throw new RangeError(\"Trying to access beyond buffer length\");\n      }\n      Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert)\n          checkOffset(offset, byteLength2, this.length);\n        let val = this[offset];\n        let mul = 1;\n        let i = 0;\n        while (++i < byteLength2 && (mul *= 256)) {\n          val += this[offset + i] * mul;\n        }\n        return val;\n      };\n      Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert) {\n          checkOffset(offset, byteLength2, this.length);\n        }\n        let val = this[offset + --byteLength2];\n        let mul = 1;\n        while (byteLength2 > 0 && (mul *= 256)) {\n          val += this[offset + --byteLength2] * mul;\n        }\n        return val;\n      };\n      Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 1, this.length);\n        return this[offset];\n      };\n      Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 2, this.length);\n        return this[offset] | this[offset + 1] << 8;\n      };\n      Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 2, this.length);\n        return this[offset] << 8 | this[offset + 1];\n      };\n      Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;\n      };\n      Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n      };\n      Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {\n        offset = offset >>> 0;\n        validateNumber(offset, \"offset\");\n        const first = this[offset];\n        const last = this[offset + 7];\n        if (first === void 0 || last === void 0) {\n          boundsError(offset, this.length - 8);\n        }\n        const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;\n        const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;\n        return BigInt(lo) + (BigInt(hi) << BigInt(32));\n      });\n      Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {\n        offset = offset >>> 0;\n        validateNumber(offset, \"offset\");\n        const first = this[offset];\n        const last = this[offset + 7];\n        if (first === void 0 || last === void 0) {\n          boundsError(offset, this.length - 8);\n        }\n        const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];\n        const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;\n        return (BigInt(hi) << BigInt(32)) + BigInt(lo);\n      });\n      Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert)\n          checkOffset(offset, byteLength2, this.length);\n        let val = this[offset];\n        let mul = 1;\n        let i = 0;\n        while (++i < byteLength2 && (mul *= 256)) {\n          val += this[offset + i] * mul;\n        }\n        mul *= 128;\n        if (val >= mul)\n          val -= Math.pow(2, 8 * byteLength2);\n        return val;\n      };\n      Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert)\n          checkOffset(offset, byteLength2, this.length);\n        let i = byteLength2;\n        let mul = 1;\n        let val = this[offset + --i];\n        while (i > 0 && (mul *= 256)) {\n          val += this[offset + --i] * mul;\n        }\n        mul *= 128;\n        if (val >= mul)\n          val -= Math.pow(2, 8 * byteLength2);\n        return val;\n      };\n      Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 1, this.length);\n        if (!(this[offset] & 128))\n          return this[offset];\n        return (255 - this[offset] + 1) * -1;\n      };\n      Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 2, this.length);\n        const val = this[offset] | this[offset + 1] << 8;\n        return val & 32768 ? val | 4294901760 : val;\n      };\n      Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 2, this.length);\n        const val = this[offset + 1] | this[offset] << 8;\n        return val & 32768 ? val | 4294901760 : val;\n      };\n      Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n      };\n      Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n      };\n      Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {\n        offset = offset >>> 0;\n        validateNumber(offset, \"offset\");\n        const first = this[offset];\n        const last = this[offset + 7];\n        if (first === void 0 || last === void 0) {\n          boundsError(offset, this.length - 8);\n        }\n        const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);\n        return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);\n      });\n      Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {\n        offset = offset >>> 0;\n        validateNumber(offset, \"offset\");\n        const first = this[offset];\n        const last = this[offset + 7];\n        if (first === void 0 || last === void 0) {\n          boundsError(offset, this.length - 8);\n        }\n        const val = (first << 24) + // Overflow\n        this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];\n        return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);\n      });\n      Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return ieee754.read(this, offset, true, 23, 4);\n      };\n      Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return ieee754.read(this, offset, false, 23, 4);\n      };\n      Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 8, this.length);\n        return ieee754.read(this, offset, true, 52, 8);\n      };\n      Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 8, this.length);\n        return ieee754.read(this, offset, false, 52, 8);\n      };\n      function checkInt(buf, value, offset, ext, max, min) {\n        if (!Buffer2.isBuffer(buf))\n          throw new TypeError('\"buffer\" argument must be a Buffer instance');\n        if (value > max || value < min)\n          throw new RangeError('\"value\" argument is out of bounds');\n        if (offset + ext > buf.length)\n          throw new RangeError(\"Index out of range\");\n      }\n      Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert) {\n          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;\n          checkInt(this, value, offset, byteLength2, maxBytes, 0);\n        }\n        let mul = 1;\n        let i = 0;\n        this[offset] = value & 255;\n        while (++i < byteLength2 && (mul *= 256)) {\n          this[offset + i] = value / mul & 255;\n        }\n        return offset + byteLength2;\n      };\n      Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert) {\n          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;\n          checkInt(this, value, offset, byteLength2, maxBytes, 0);\n        }\n        let i = byteLength2 - 1;\n        let mul = 1;\n        this[offset + i] = value & 255;\n        while (--i >= 0 && (mul *= 256)) {\n          this[offset + i] = value / mul & 255;\n        }\n        return offset + byteLength2;\n      };\n      Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 1, 255, 0);\n        this[offset] = value & 255;\n        return offset + 1;\n      };\n      Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 2, 65535, 0);\n        this[offset] = value & 255;\n        this[offset + 1] = value >>> 8;\n        return offset + 2;\n      };\n      Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 2, 65535, 0);\n        this[offset] = value >>> 8;\n        this[offset + 1] = value & 255;\n        return offset + 2;\n      };\n      Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 4, 4294967295, 0);\n        this[offset + 3] = value >>> 24;\n        this[offset + 2] = value >>> 16;\n        this[offset + 1] = value >>> 8;\n        this[offset] = value & 255;\n        return offset + 4;\n      };\n      Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 4, 4294967295, 0);\n        this[offset] = value >>> 24;\n        this[offset + 1] = value >>> 16;\n        this[offset + 2] = value >>> 8;\n        this[offset + 3] = value & 255;\n        return offset + 4;\n      };\n      function wrtBigUInt64LE(buf, value, offset, min, max) {\n        checkIntBI(value, min, max, buf, offset, 7);\n        let lo = Number(value & BigInt(4294967295));\n        buf[offset++] = lo;\n        lo = lo >> 8;\n        buf[offset++] = lo;\n        lo = lo >> 8;\n        buf[offset++] = lo;\n        lo = lo >> 8;\n        buf[offset++] = lo;\n        let hi = Number(value >> BigInt(32) & BigInt(4294967295));\n        buf[offset++] = hi;\n        hi = hi >> 8;\n        buf[offset++] = hi;\n        hi = hi >> 8;\n        buf[offset++] = hi;\n        hi = hi >> 8;\n        buf[offset++] = hi;\n        return offset;\n      }\n      function wrtBigUInt64BE(buf, value, offset, min, max) {\n        checkIntBI(value, min, max, buf, offset, 7);\n        let lo = Number(value & BigInt(4294967295));\n        buf[offset + 7] = lo;\n        lo = lo >> 8;\n        buf[offset + 6] = lo;\n        lo = lo >> 8;\n        buf[offset + 5] = lo;\n        lo = lo >> 8;\n        buf[offset + 4] = lo;\n        let hi = Number(value >> BigInt(32) & BigInt(4294967295));\n        buf[offset + 3] = hi;\n        hi = hi >> 8;\n        buf[offset + 2] = hi;\n        hi = hi >> 8;\n        buf[offset + 1] = hi;\n        hi = hi >> 8;\n        buf[offset] = hi;\n        return offset + 8;\n      }\n      Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {\n        return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n      });\n      Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {\n        return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n      });\n      Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          const limit = Math.pow(2, 8 * byteLength2 - 1);\n          checkInt(this, value, offset, byteLength2, limit - 1, -limit);\n        }\n        let i = 0;\n        let mul = 1;\n        let sub = 0;\n        this[offset] = value & 255;\n        while (++i < byteLength2 && (mul *= 256)) {\n          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n            sub = 1;\n          }\n          this[offset + i] = (value / mul >> 0) - sub & 255;\n        }\n        return offset + byteLength2;\n      };\n      Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          const limit = Math.pow(2, 8 * byteLength2 - 1);\n          checkInt(this, value, offset, byteLength2, limit - 1, -limit);\n        }\n        let i = byteLength2 - 1;\n        let mul = 1;\n        let sub = 0;\n        this[offset + i] = value & 255;\n        while (--i >= 0 && (mul *= 256)) {\n          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n            sub = 1;\n          }\n          this[offset + i] = (value / mul >> 0) - sub & 255;\n        }\n        return offset + byteLength2;\n      };\n      Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 1, 127, -128);\n        if (value < 0)\n          value = 255 + value + 1;\n        this[offset] = value & 255;\n        return offset + 1;\n      };\n      Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 2, 32767, -32768);\n        this[offset] = value & 255;\n        this[offset + 1] = value >>> 8;\n        return offset + 2;\n      };\n      Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 2, 32767, -32768);\n        this[offset] = value >>> 8;\n        this[offset + 1] = value & 255;\n        return offset + 2;\n      };\n      Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 4, 2147483647, -2147483648);\n        this[offset] = value & 255;\n        this[offset + 1] = value >>> 8;\n        this[offset + 2] = value >>> 16;\n        this[offset + 3] = value >>> 24;\n        return offset + 4;\n      };\n      Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 4, 2147483647, -2147483648);\n        if (value < 0)\n          value = 4294967295 + value + 1;\n        this[offset] = value >>> 24;\n        this[offset + 1] = value >>> 16;\n        this[offset + 2] = value >>> 8;\n        this[offset + 3] = value & 255;\n        return offset + 4;\n      };\n      Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {\n        return wrtBigUInt64LE(this, value, offset, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n      });\n      Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {\n        return wrtBigUInt64BE(this, value, offset, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n      });\n      function checkIEEE754(buf, value, offset, ext, max, min) {\n        if (offset + ext > buf.length)\n          throw new RangeError(\"Index out of range\");\n        if (offset < 0)\n          throw new RangeError(\"Index out of range\");\n      }\n      function writeFloat(buf, value, offset, littleEndian, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);\n        }\n        ieee754.write(buf, value, offset, littleEndian, 23, 4);\n        return offset + 4;\n      }\n      Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n        return writeFloat(this, value, offset, true, noAssert);\n      };\n      Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n        return writeFloat(this, value, offset, false, noAssert);\n      };\n      function writeDouble(buf, value, offset, littleEndian, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);\n        }\n        ieee754.write(buf, value, offset, littleEndian, 52, 8);\n        return offset + 8;\n      }\n      Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n        return writeDouble(this, value, offset, true, noAssert);\n      };\n      Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n        return writeDouble(this, value, offset, false, noAssert);\n      };\n      Buffer2.prototype.copy = function copy(target, targetStart, start, end) {\n        if (!Buffer2.isBuffer(target))\n          throw new TypeError(\"argument should be a Buffer\");\n        if (!start)\n          start = 0;\n        if (!end && end !== 0)\n          end = this.length;\n        if (targetStart >= target.length)\n          targetStart = target.length;\n        if (!targetStart)\n          targetStart = 0;\n        if (end > 0 && end < start)\n          end = start;\n        if (end === start)\n          return 0;\n        if (target.length === 0 || this.length === 0)\n          return 0;\n        if (targetStart < 0) {\n          throw new RangeError(\"targetStart out of bounds\");\n        }\n        if (start < 0 || start >= this.length)\n          throw new RangeError(\"Index out of range\");\n        if (end < 0)\n          throw new RangeError(\"sourceEnd out of bounds\");\n        if (end > this.length)\n          end = this.length;\n        if (target.length - targetStart < end - start) {\n          end = target.length - targetStart + start;\n        }\n        const len = end - start;\n        if (this === target && typeof GlobalUint8Array.prototype.copyWithin === \"function\") {\n          this.copyWithin(targetStart, start, end);\n        } else {\n          GlobalUint8Array.prototype.set.call(\n            target,\n            this.subarray(start, end),\n            targetStart\n          );\n        }\n        return len;\n      };\n      Buffer2.prototype.fill = function fill(val, start, end, encoding) {\n        if (typeof val === \"string\") {\n          if (typeof start === \"string\") {\n            encoding = start;\n            start = 0;\n            end = this.length;\n          } else if (typeof end === \"string\") {\n            encoding = end;\n            end = this.length;\n          }\n          if (encoding !== void 0 && typeof encoding !== \"string\") {\n            throw new TypeError(\"encoding must be a string\");\n          }\n          if (typeof encoding === \"string\" && !Buffer2.isEncoding(encoding)) {\n            throw new TypeError(\"Unknown encoding: \" + encoding);\n          }\n          if (val.length === 1) {\n            const code = val.charCodeAt(0);\n            if (encoding === \"utf8\" && code < 128 || encoding === \"latin1\") {\n              val = code;\n            }\n          }\n        } else if (typeof val === \"number\") {\n          val = val & 255;\n        } else if (typeof val === \"boolean\") {\n          val = Number(val);\n        }\n        if (start < 0 || this.length < start || this.length < end) {\n          throw new RangeError(\"Out of range index\");\n        }\n        if (end <= start) {\n          return this;\n        }\n        start = start >>> 0;\n        end = end === void 0 ? this.length : end >>> 0;\n        if (!val)\n          val = 0;\n        let i;\n        if (typeof val === \"number\") {\n          for (i = start; i < end; ++i) {\n            this[i] = val;\n          }\n        } else {\n          const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);\n          const len = bytes.length;\n          if (len === 0) {\n            throw new TypeError('The value \"' + val + '\" is invalid for argument \"value\"');\n          }\n          for (i = 0; i < end - start; ++i) {\n            this[i + start] = bytes[i % len];\n          }\n        }\n        return this;\n      };\n      var errors = {};\n      function E(sym, getMessage, Base) {\n        errors[sym] = class NodeError extends Base {\n          constructor() {\n            super();\n            Object.defineProperty(this, \"message\", {\n              value: getMessage.apply(this, arguments),\n              writable: true,\n              configurable: true\n            });\n            this.name = `${this.name} [${sym}]`;\n            this.stack;\n            delete this.name;\n          }\n          get code() {\n            return sym;\n          }\n          set code(value) {\n            Object.defineProperty(this, \"code\", {\n              configurable: true,\n              enumerable: true,\n              value,\n              writable: true\n            });\n          }\n          toString() {\n            return `${this.name} [${sym}]: ${this.message}`;\n          }\n        };\n      }\n      E(\n        \"ERR_BUFFER_OUT_OF_BOUNDS\",\n        function(name) {\n          if (name) {\n            return `${name} is outside of buffer bounds`;\n          }\n          return \"Attempt to access memory outside buffer bounds\";\n        },\n        RangeError\n      );\n      E(\n        \"ERR_INVALID_ARG_TYPE\",\n        function(name, actual) {\n          return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`;\n        },\n        TypeError\n      );\n      E(\n        \"ERR_OUT_OF_RANGE\",\n        function(str, range, input) {\n          let msg = `The value of \"${str}\" is out of range.`;\n          let received = input;\n          if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n            received = addNumericalSeparator(String(input));\n          } else if (typeof input === \"bigint\") {\n            received = String(input);\n            if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n              received = addNumericalSeparator(received);\n            }\n            received += \"n\";\n          }\n          msg += ` It must be ${range}. Received ${received}`;\n          return msg;\n        },\n        RangeError\n      );\n      function addNumericalSeparator(val) {\n        let res = \"\";\n        let i = val.length;\n        const start = val[0] === \"-\" ? 1 : 0;\n        for (; i >= start + 4; i -= 3) {\n          res = `_${val.slice(i - 3, i)}${res}`;\n        }\n        return `${val.slice(0, i)}${res}`;\n      }\n      function checkBounds(buf, offset, byteLength2) {\n        validateNumber(offset, \"offset\");\n        if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {\n          boundsError(offset, buf.length - (byteLength2 + 1));\n        }\n      }\n      function checkIntBI(value, min, max, buf, offset, byteLength2) {\n        if (value > max || value < min) {\n          const n = typeof min === \"bigint\" ? \"n\" : \"\";\n          let range;\n          if (byteLength2 > 3) {\n            if (min === 0 || min === BigInt(0)) {\n              range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;\n            } else {\n              range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;\n            }\n          } else {\n            range = `>= ${min}${n} and <= ${max}${n}`;\n          }\n          throw new errors.ERR_OUT_OF_RANGE(\"value\", range, value);\n        }\n        checkBounds(buf, offset, byteLength2);\n      }\n      function validateNumber(value, name) {\n        if (typeof value !== \"number\") {\n          throw new errors.ERR_INVALID_ARG_TYPE(name, \"number\", value);\n        }\n      }\n      function boundsError(value, length, type) {\n        if (Math.floor(value) !== value) {\n          validateNumber(value, type);\n          throw new errors.ERR_OUT_OF_RANGE(type || \"offset\", \"an integer\", value);\n        }\n        if (length < 0) {\n          throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();\n        }\n        throw new errors.ERR_OUT_OF_RANGE(\n          type || \"offset\",\n          `>= ${type ? 1 : 0} and <= ${length}`,\n          value\n        );\n      }\n      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;\n      function base64clean(str) {\n        str = str.split(\"=\")[0];\n        str = str.trim().replace(INVALID_BASE64_RE, \"\");\n        if (str.length < 2)\n          return \"\";\n        while (str.length % 4 !== 0) {\n          str = str + \"=\";\n        }\n        return str;\n      }\n      function utf8ToBytes(string, units) {\n        units = units || Infinity;\n        let codePoint;\n        const length = string.length;\n        let leadSurrogate = null;\n        const bytes = [];\n        for (let i = 0; i < length; ++i) {\n          codePoint = string.charCodeAt(i);\n          if (codePoint > 55295 && codePoint < 57344) {\n            if (!leadSurrogate) {\n              if (codePoint > 56319) {\n                if ((units -= 3) > -1)\n                  bytes.push(239, 191, 189);\n                continue;\n              } else if (i + 1 === length) {\n                if ((units -= 3) > -1)\n                  bytes.push(239, 191, 189);\n                continue;\n              }\n              leadSurrogate = codePoint;\n              continue;\n            }\n            if (codePoint < 56320) {\n              if ((units -= 3) > -1)\n                bytes.push(239, 191, 189);\n              leadSurrogate = codePoint;\n              continue;\n            }\n            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;\n          } else if (leadSurrogate) {\n            if ((units -= 3) > -1)\n              bytes.push(239, 191, 189);\n          }\n          leadSurrogate = null;\n          if (codePoint < 128) {\n            if ((units -= 1) < 0)\n              break;\n            bytes.push(codePoint);\n          } else if (codePoint < 2048) {\n            if ((units -= 2) < 0)\n              break;\n            bytes.push(\n              codePoint >> 6 | 192,\n              codePoint & 63 | 128\n            );\n          } else if (codePoint < 65536) {\n            if ((units -= 3) < 0)\n              break;\n            bytes.push(\n              codePoint >> 12 | 224,\n              codePoint >> 6 & 63 | 128,\n              codePoint & 63 | 128\n            );\n          } else if (codePoint < 1114112) {\n            if ((units -= 4) < 0)\n              break;\n            bytes.push(\n              codePoint >> 18 | 240,\n              codePoint >> 12 & 63 | 128,\n              codePoint >> 6 & 63 | 128,\n              codePoint & 63 | 128\n            );\n          } else {\n            throw new Error(\"Invalid code point\");\n          }\n        }\n        return bytes;\n      }\n      function asciiToBytes(str) {\n        const byteArray = [];\n        for (let i = 0; i < str.length; ++i) {\n          byteArray.push(str.charCodeAt(i) & 255);\n        }\n        return byteArray;\n      }\n      function utf16leToBytes(str, units) {\n        let c, hi, lo;\n        const byteArray = [];\n        for (let i = 0; i < str.length; ++i) {\n          if ((units -= 2) < 0)\n            break;\n          c = str.charCodeAt(i);\n          hi = c >> 8;\n          lo = c % 256;\n          byteArray.push(lo);\n          byteArray.push(hi);\n        }\n        return byteArray;\n      }\n      function base64ToBytes(str) {\n        return base64.toByteArray(base64clean(str));\n      }\n      function blitBuffer(src, dst, offset, length) {\n        let i;\n        for (i = 0; i < length; ++i) {\n          if (i + offset >= dst.length || i >= src.length)\n            break;\n          dst[i + offset] = src[i];\n        }\n        return i;\n      }\n      function isInstance(obj, type) {\n        return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;\n      }\n      function numberIsNaN(obj) {\n        return obj !== obj;\n      }\n      var hexSliceLookupTable = function() {\n        const alphabet = \"0123456789abcdef\";\n        const table = new Array(256);\n        for (let i = 0; i < 16; ++i) {\n          const i16 = i * 16;\n          for (let j = 0; j < 16; ++j) {\n            table[i16 + j] = alphabet[i] + alphabet[j];\n          }\n        }\n        return table;\n      }();\n      function defineBigIntMethod(fn) {\n        return typeof BigInt === \"undefined\" ? BufferBigIntNotDefined : fn;\n      }\n      function BufferBigIntNotDefined() {\n        throw new Error(\"BigInt not supported\");\n      }\n    }\n  });\n\n  // node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js\n  var require_browser = __commonJS({\n    \"node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js\"(exports, module) {\n      init_dist();\n      var process = module.exports = {};\n      var cachedSetTimeout;\n      var cachedClearTimeout;\n      function defaultSetTimout() {\n        throw new Error(\"setTimeout has not been defined\");\n      }\n      function defaultClearTimeout() {\n        throw new Error(\"clearTimeout has not been defined\");\n      }\n      (function() {\n        try {\n          if (typeof setTimeout === \"function\") {\n            cachedSetTimeout = setTimeout;\n          } else {\n            cachedSetTimeout = defaultSetTimout;\n          }\n        } catch (e) {\n          cachedSetTimeout = defaultSetTimout;\n        }\n        try {\n          if (typeof clearTimeout === \"function\") {\n            cachedClearTimeout = clearTimeout;\n          } else {\n            cachedClearTimeout = defaultClearTimeout;\n          }\n        } catch (e) {\n          cachedClearTimeout = defaultClearTimeout;\n        }\n      })();\n      function runTimeout(fun) {\n        if (cachedSetTimeout === setTimeout) {\n          return setTimeout(fun, 0);\n        }\n        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n          cachedSetTimeout = setTimeout;\n          return setTimeout(fun, 0);\n        }\n        try {\n          return cachedSetTimeout(fun, 0);\n        } catch (e) {\n          try {\n            return cachedSetTimeout.call(null, fun, 0);\n          } catch (e2) {\n            return cachedSetTimeout.call(this, fun, 0);\n          }\n        }\n      }\n      function runClearTimeout(marker) {\n        if (cachedClearTimeout === clearTimeout) {\n          return clearTimeout(marker);\n        }\n        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n          cachedClearTimeout = clearTimeout;\n          return clearTimeout(marker);\n        }\n        try {\n          return cachedClearTimeout(marker);\n        } catch (e) {\n          try {\n            return cachedClearTimeout.call(null, marker);\n          } catch (e2) {\n            return cachedClearTimeout.call(this, marker);\n          }\n        }\n      }\n      var queue = [];\n      var draining = false;\n      var currentQueue;\n      var queueIndex = -1;\n      function cleanUpNextTick() {\n        if (!draining || !currentQueue) {\n          return;\n        }\n        draining = false;\n        if (currentQueue.length) {\n          queue = currentQueue.concat(queue);\n        } else {\n          queueIndex = -1;\n        }\n        if (queue.length) {\n          drainQueue();\n        }\n      }\n      function drainQueue() {\n        if (draining) {\n          return;\n        }\n        var timeout = runTimeout(cleanUpNextTick);\n        draining = true;\n        var len = queue.length;\n        while (len) {\n          currentQueue = queue;\n          queue = [];\n          while (++queueIndex < len) {\n            if (currentQueue) {\n              currentQueue[queueIndex].run();\n            }\n          }\n          queueIndex = -1;\n          len = queue.length;\n        }\n        currentQueue = null;\n        draining = false;\n        runClearTimeout(timeout);\n      }\n      process.nextTick = function(fun) {\n        var args = new Array(arguments.length - 1);\n        if (arguments.length > 1) {\n          for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n          }\n        }\n        queue.push(new Item(fun, args));\n        if (queue.length === 1 && !draining) {\n          runTimeout(drainQueue);\n        }\n      };\n      function Item(fun, array) {\n        this.fun = fun;\n        this.array = array;\n      }\n      Item.prototype.run = function() {\n        this.fun.apply(null, this.array);\n      };\n      process.title = \"browser\";\n      process.browser = true;\n      process.env = {};\n      process.argv = [];\n      process.version = \"\";\n      process.versions = {};\n      function noop() {\n      }\n      process.on = noop;\n      process.addListener = noop;\n      process.once = noop;\n      process.off = noop;\n      process.removeListener = noop;\n      process.removeAllListeners = noop;\n      process.emit = noop;\n      process.prependListener = noop;\n      process.prependOnceListener = noop;\n      process.listeners = function(name) {\n        return [];\n      };\n      process.binding = function(name) {\n        throw new Error(\"process.binding is not supported\");\n      };\n      process.cwd = function() {\n        return \"/\";\n      };\n      process.chdir = function(dir) {\n        throw new Error(\"process.chdir is not supported\");\n      };\n      process.umask = function() {\n        return 0;\n      };\n    }\n  });\n\n  // shims/dist/index.js\n  var import_buffer_polyfill, import_process, o;\n  var init_dist = __esm({\n    \"shims/dist/index.js\"() {\n      \"use strict\";\n      import_buffer_polyfill = __toESM(require_buffer(), 1);\n      import_process = __toESM(require_browser(), 1);\n      o = globalThis || void 0 || self;\n    }\n  });\n\n  // shims/banner/index.cjs\n  var require_banner = __commonJS({\n    \"shims/banner/index.cjs\"() {\n      init_dist();\n      globalThis.Buffer = globalThis.Buffer || import_buffer_polyfill.Buffer;\n      globalThis.global = globalThis.global || o;\n      globalThis.process = globalThis.process || import_process.default;\n    }\n  });\n  require_banner();\n})();\n/*! Bundled license information:\n\nieee754/index.js:\n  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)\n\nbuffer/index.js:\n  (*!\n   * The buffer module from node.js, for the browser.\n   *\n   * @author   Feross Aboukhadijeh <https://feross.org>\n   * @license  MIT\n   *)\n*/\n\nimport {\n  __commonJS,\n  __toESM,\n  require_dist\n} from \"/node_modules/.vite/deps/chunk-VMXIV7NB.js?v=733ce8d4\";\n\n// node_modules/jsvectormap/dist/js/jsvectormap.min.js\nvar require_jsvectormap_min = __commonJS({\n  \"node_modules/jsvectormap/dist/js/jsvectormap.min.js\"(exports, module) {\n    var import_dist = __toESM(require_dist());\n    !function(t, e) {\n      \"object\" == typeof exports && \"undefined\" != typeof module ? module.exports = e() : \"function\" == typeof define && define.amd ? define(e) : (t = \"undefined\" != typeof globalThis ? globalThis : t || self).jsVectorMap = e();\n    }(exports, function() {\n      \"use strict\";\n      function t(t2, i2) {\n        t2.prototype = Object.create(i2.prototype), t2.prototype.constructor = t2, e(t2, i2);\n      }\n      function e(t2, i2) {\n        return e = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t3, e2) {\n          return t3.__proto__ = e2, t3;\n        }, e(t2, i2);\n      }\n      function i(t2) {\n        if (void 0 === t2)\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        return t2;\n      }\n      function s(t2) {\n        throw new TypeError('\"' + t2 + '\" is read-only');\n      }\n      function a(t2, e2) {\n        (null == e2 || e2 > t2.length) && (e2 = t2.length);\n        for (var i2 = 0, s2 = new Array(e2); i2 < e2; i2++)\n          s2[i2] = t2[i2];\n        return s2;\n      }\n      function n(t2, e2) {\n        var i2 = \"undefined\" != typeof Symbol && t2[Symbol.iterator] || t2[\"@@iterator\"];\n        if (i2)\n          return (i2 = i2.call(t2)).next.bind(i2);\n        if (Array.isArray(t2) || (i2 = function(t3, e3) {\n          if (t3) {\n            if (\"string\" == typeof t3)\n              return a(t3, e3);\n            var i3 = Object.prototype.toString.call(t3).slice(8, -1);\n            return \"Object\" === i3 && t3.constructor && (i3 = t3.constructor.name), \"Map\" === i3 || \"Set\" === i3 ? Array.from(t3) : \"Arguments\" === i3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i3) ? a(t3, e3) : void 0;\n          }\n        }(t2)) || e2 && t2 && \"number\" == typeof t2.length) {\n          i2 && (t2 = i2);\n          var s2 = 0;\n          return function() {\n            return s2 >= t2.length ? { done: true } : { done: false, value: t2[s2++] };\n          };\n        }\n        throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n      }\n      Element.prototype.matches || (Element.prototype.matches = Element.prototype.matchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector || Element.prototype.webkitMatchesSelector || function(t2) {\n        for (var e2 = (this.document || this.ownerDocument).querySelectorAll(t2), i2 = e2.length; s(\"i\") >= 0 && e2.item(i2) !== this; )\n          ;\n        return i2 > -1;\n      }), Object.assign || Object.defineProperty(Object, \"assign\", { enumerable: false, configurable: true, writable: true, value: function(t2) {\n        if (null == t2)\n          throw new TypeError(\"Cannot convert first argument to object\");\n        for (var e2 = Object(t2), i2 = 1; i2 < arguments.length; i2++) {\n          var s2 = arguments[i2];\n          if (null != s2) {\n            s2 = Object(s2);\n            for (var a2 = Object.keys(Object(s2)), n2 = 0, r2 = a2.length; n2 < r2; n2++) {\n              var o2 = a2[n2], h2 = Object.getOwnPropertyDescriptor(s2, o2);\n              void 0 !== h2 && h2.enumerable && (e2[o2] = s2[o2]);\n            }\n          }\n        }\n        return e2;\n      } });\n      var r = function(t2) {\n        return /* @__PURE__ */ function(t3) {\n          return !!t3 && \"object\" == typeof t3;\n        }(t2) && !function(t3) {\n          var e2 = Object.prototype.toString.call(t3);\n          return \"[object RegExp]\" === e2 || \"[object Date]\" === e2 || function(t4) {\n            return t4 instanceof Node;\n          }(t3) || function(t4) {\n            return t4.$$typeof === o;\n          }(t3);\n        }(t2);\n      };\n      var o = \"function\" == typeof Symbol && Symbol.for ? Symbol.for(\"react.element\") : 60103;\n      function h(t2, e2) {\n        return false !== e2.clone && e2.isMergeableObject(t2) ? d((i2 = t2, Array.isArray(i2) ? [] : {}), t2, e2) : t2;\n        var i2;\n      }\n      function l(t2, e2, i2) {\n        return t2.concat(e2).map(function(t3) {\n          return h(t3, i2);\n        });\n      }\n      function c(t2) {\n        return Object.keys(t2).concat(function(t3) {\n          return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(t3).filter(function(e2) {\n            return t3.propertyIsEnumerable(e2);\n          }) : [];\n        }(t2));\n      }\n      function u(t2, e2) {\n        try {\n          return e2 in t2;\n        } catch (t3) {\n          return false;\n        }\n      }\n      function p(t2, e2, i2) {\n        var s2 = {};\n        return i2.isMergeableObject(t2) && c(t2).forEach(function(e3) {\n          s2[e3] = h(t2[e3], i2);\n        }), c(e2).forEach(function(a2) {\n          (function(t3, e3) {\n            return u(t3, e3) && !(Object.hasOwnProperty.call(t3, e3) && Object.propertyIsEnumerable.call(t3, e3));\n          })(t2, a2) || (u(t2, a2) && i2.isMergeableObject(e2[a2]) ? s2[a2] = function(t3, e3) {\n            if (!e3.customMerge)\n              return d;\n            var i3 = e3.customMerge(t3);\n            return \"function\" == typeof i3 ? i3 : d;\n          }(a2, i2)(t2[a2], e2[a2], i2) : s2[a2] = h(e2[a2], i2));\n        }), s2;\n      }\n      var d = function(t2, e2, i2) {\n        (i2 = i2 || {}).arrayMerge = i2.arrayMerge || l, i2.isMergeableObject = i2.isMergeableObject || r, i2.cloneUnlessOtherwiseSpecified = h;\n        var s2 = Array.isArray(e2);\n        return s2 === Array.isArray(t2) ? s2 ? i2.arrayMerge(t2, e2, i2) : p(t2, e2, i2) : h(e2, i2);\n      }, f = function(t2) {\n        return \"object\" == typeof t2 && void 0 !== t2.nodeType ? t2 : \"string\" == typeof t2 ? document.querySelector(t2) : null;\n      }, m = function(t2, e2, i2, s2) {\n        void 0 === s2 && (s2 = false);\n        var a2 = document.createElement(t2);\n        return i2 && (a2[s2 ? \"innerHTML\" : \"textContent\"] = i2), e2 && (a2.className = e2), a2;\n      }, g = function(t2) {\n        t2.parentNode.removeChild(t2);\n      }, v = function(t2, e2, i2) {\n        return void 0 === i2 && (i2 = false), i2 ? d(t2, e2) : Object.assign(t2, e2);\n      }, _ = function(t2, e2) {\n        return t2.toLowerCase() + \":to:\" + e2.toLowerCase();\n      }, y = function(t2, e2) {\n        Object.assign(t2.prototype, e2);\n      }, b = {}, w = 1, S = { on: function(t2, e2, i2, s2) {\n        void 0 === s2 && (s2 = {});\n        var a2 = \"jvm:\" + e2 + \"::\" + w++;\n        b[a2] = { selector: t2, handler: i2 }, i2._uid = a2, t2.addEventListener(e2, i2, s2);\n      }, delegate: function(t2, e2, i2, s2) {\n        (e2 = e2.split(\" \")).forEach(function(e3) {\n          S.on(t2, e3, function(t3) {\n            var e4 = t3.target;\n            e4.matches(i2) && s2.call(e4, t3);\n          });\n        });\n      }, off: function(t2, e2, i2) {\n        var s2 = e2.split(\":\")[1];\n        t2.removeEventListener(s2, i2), delete b[i2._uid];\n      }, flush: function() {\n        Object.keys(b).forEach(function(t2) {\n          S.off(b[t2].selector, t2, b[t2].handler);\n        });\n      }, getEventRegistry: function() {\n        return b;\n      } };\n      var k = { onLoaded: \"map:loaded\", onViewportChange: \"viewport:changed\", onRegionClick: \"region:clicked\", onMarkerClick: \"marker:clicked\", onRegionSelected: \"region:selected\", onMarkerSelected: \"marker:selected\", onRegionTooltipShow: \"region.tooltip:show\", onMarkerTooltipShow: \"marker.tooltip:show\", onDestroyed: \"map:destroyed\" }, M = function(t2, e2, i2) {\n        var s2 = f(e2), a2 = -1 === s2.getAttribute(\"class\").indexOf(\"jvm-region\") ? \"marker\" : \"region\", n2 = \"region\" === a2, r2 = n2 ? s2.getAttribute(\"data-code\") : s2.getAttribute(\"data-index\"), o2 = n2 ? k.onRegionSelected : k.onMarkerSelected;\n        return i2 && (o2 = n2 ? k.onRegionTooltipShow : k.onMarkerTooltipShow), { type: a2, code: r2, event: o2, element: n2 ? t2.regions[r2].element : t2._markers[r2].element, tooltipText: n2 ? t2._mapData.paths[r2].name || \"\" : t2._markers[r2].config.name || \"\" };\n      };\n      var x = function() {\n        function t2() {\n        }\n        return t2.prototype.dispose = function() {\n          this._tooltip ? g(this._tooltip) : this.shape.remove();\n          for (var t3, e2 = n(Object.getOwnPropertyNames(this)); !(t3 = e2()).done; ) {\n            this[t3.value] = null;\n          }\n        }, t2;\n      }(), j = { getLabelText: function(t2, e2) {\n        if (e2) {\n          if (\"function\" == typeof e2.render) {\n            var i2 = [];\n            return this.config && this.config.marker && i2.push(this.config.marker), i2.push(t2), e2.render.apply(this, i2);\n          }\n          return t2;\n        }\n      }, getLabelOffsets: function(t2, e2) {\n        return \"function\" == typeof e2.offsets ? e2.offsets(t2) : Array.isArray(e2.offsets) ? e2.offsets[t2] : [0, 0];\n      }, setStyle: function(t2, e2) {\n        this.shape.setStyle(t2, e2);\n      }, remove: function() {\n        this.shape.remove(), this.label && this.label.remove();\n      }, hover: function(t2) {\n        this._setStatus(\"isHovered\", t2);\n      }, select: function(t2) {\n        this._setStatus(\"isSelected\", t2);\n      }, _setStatus: function(t2, e2) {\n        this.shape[t2] = e2, this.shape.updateStyle(), this[t2] = e2, this.label && (this.label[t2] = e2, this.label.updateStyle());\n      } }, C = function(e2) {\n        function i2(t2) {\n          var i3, s3 = t2.map, a2 = t2.code, n2 = t2.path, r2 = t2.style, o2 = t2.label, h2 = t2.labelStyle, l2 = t2.labelsGroup;\n          (i3 = e2.call(this) || this)._map = s3, i3.shape = i3._createRegion(n2, a2, r2);\n          var c2 = i3.getLabelText(a2, o2);\n          if (o2 && c2) {\n            var u2 = i3.shape.getBBox(), p2 = i3.getLabelOffsets(a2, o2);\n            i3.labelX = u2.x + u2.width / 2 + p2[0], i3.labelY = u2.y + u2.height / 2 + p2[1], i3.label = i3._map.canvas.createText({ text: c2, textAnchor: \"middle\", alignmentBaseline: \"central\", dataCode: a2, x: i3.labelX, y: i3.labelY }, h2, l2), i3.label.addClass(\"jvm-region jvm-element\");\n          }\n          return i3;\n        }\n        t(i2, e2);\n        var s2 = i2.prototype;\n        return s2._createRegion = function(t2, e3, i3) {\n          return (t2 = this._map.canvas.createPath({ d: t2, dataCode: e3 }, i3)).addClass(\"jvm-region jvm-element\"), t2;\n        }, s2.updateLabelPosition = function() {\n          this.label && this.label.set({ x: this.labelX * this._map.scale + this._map.transX * this._map.scale, y: this.labelY * this._map.scale + this._map.transY * this._map.scale });\n        }, i2;\n      }(x);\n      y(C, j);\n      var L = function(e2) {\n        function i2(t2) {\n          var i3, s2 = t2.index, a2 = t2.map, n2 = t2.style, r2 = t2.x1, o2 = t2.y1, h2 = t2.x2, l2 = t2.y2, c2 = t2.group, u2 = t2.config;\n          return (i3 = e2.call(this) || this).config = u2, i3.shape = a2.canvas.createLine({ x1: r2, y1: o2, x2: h2, y2: l2, dataIndex: s2 }, n2, c2), i3.shape.addClass(\"jvm-line\"), i3;\n        }\n        return t(i2, e2), i2.prototype.setStyle = function(t2, e3) {\n          this.shape.setStyle(t2, e3);\n        }, i2;\n      }(x);\n      var O = function(e2) {\n        function i2(t2) {\n          var i3, s3 = t2.index, a2 = t2.style, n2 = t2.label, r2 = t2.cx, o2 = t2.cy, h2 = t2.map, l2 = t2.group;\n          return (i3 = e2.call(this) || this)._map = h2, i3._isImage = !!a2.initial.image, i3.config = arguments[0], i3.shape = h2.canvas[i3._isImage ? \"createImage\" : \"createCircle\"]({ dataIndex: s3, cx: r2, cy: o2 }, a2, l2), i3.shape.addClass(\"jvm-marker jvm-element\"), i3._isImage && i3.updateLabelPosition(), n2 && i3._createLabel(i3.config), i3;\n        }\n        t(i2, e2);\n        var s2 = i2.prototype;\n        return s2.updateLabelPosition = function() {\n          this.label && this.label.set({ x: this._labelX * this._map.scale + this._offsets[0] + this._map.transX * this._map.scale + 5 + (this._isImage ? (this.shape.width || 0) / 2 : this.shape.node.r.baseVal.value), y: this._labelY * this._map.scale + this._map.transY * this._map.scale + this._offsets[1] });\n        }, s2._createLabel = function(t2) {\n          var e3 = t2.index, i3 = t2.map, s3 = t2.label, a2 = t2.labelsGroup, n2 = t2.cx, r2 = t2.cy, o2 = t2.marker, h2 = t2.isRecentlyCreated, l2 = this.getLabelText(e3, s3);\n          this._labelX = n2 / i3.scale - i3.transX, this._labelY = r2 / i3.scale - i3.transY, this._offsets = h2 && o2.offsets ? o2.offsets : this.getLabelOffsets(e3, s3), this.label = i3.canvas.createText({ text: l2, dataIndex: e3, x: this._labelX, y: this._labelY, dy: \"0.6ex\" }, i3.params.markerLabelStyle, a2), this.label.addClass(\"jvm-marker jvm-element\"), h2 && this.updateLabelPosition();\n        }, i2;\n      }(x);\n      y(O, j);\n      var A = function() {\n        function t2(t3) {\n          void 0 === t3 && (t3 = {}), this._options = t3, this._map = this._options.map, this._series = this._options.series, this._body = m(\"div\", \"jvm-legend\"), this._options.cssClass && this._body.setAttribute(\"class\", this._options.cssClass), t3.vertical ? this._map.legendVertical.appendChild(this._body) : this._map.legendHorizontal.appendChild(this._body), this.render();\n        }\n        return t2.prototype.render = function() {\n          var t3, e2 = this._series.scale.getTicks(), i2 = m(\"div\", \"jvm-legend-inner\");\n          if (this._body.innderHTML = \"\", this._options.title) {\n            var s2 = m(\"div\", \"jvm-legend-title\", this._options.title);\n            this._body.appendChild(s2);\n          }\n          this._body.appendChild(i2);\n          for (var a2 = 0; a2 < e2.length; a2++) {\n            var n2 = m(\"div\", \"jvm-legend-tick\"), r2 = m(\"div\", \"jvm-legend-tick-sample\");\n            switch (this._series.config.attribute) {\n              case \"fill\":\n                t3 = e2[a2].value, /\\.(jpg|gif|png)$/.test(t3) ? r2.style.background = \"url(\" + e2[a2].value + \")\" : r2.style.background = e2[a2].value;\n                break;\n              case \"stroke\":\n                r2.style.background = e2[a2].value;\n                break;\n              case \"image\":\n                r2.style.background = \"url(\" + (\"object\" == typeof e2[a2].value ? e2[a2].value.url : e2[a2].value) + \") no-repeat center center\", r2.style.backgroundSize = \"cover\";\n            }\n            n2.appendChild(r2);\n            var o2 = e2[a2].label;\n            this._options.labelRender && (o2 = this._options.labelRender(o2));\n            var h2 = m(\"div\", \"jvm-legend-tick-text\", o2);\n            n2.appendChild(h2), i2.appendChild(n2);\n          }\n        }, t2;\n      }(), X = function() {\n        function t2(t3) {\n          this._scale = t3;\n        }\n        var e2 = t2.prototype;\n        return e2.getValue = function(t3) {\n          return this._scale[t3];\n        }, e2.getTicks = function() {\n          var t3 = [];\n          for (var e3 in this._scale)\n            t3.push({ label: e3, value: this._scale[e3] });\n          return t3;\n        }, t2;\n      }(), Y = function() {\n        function t2(t3, e3, i2) {\n          void 0 === t3 && (t3 = {}), this._map = i2, this._elements = e3, this._values = t3.values || {}, this.config = t3, this.config.attribute = t3.attribute || \"fill\", t3.attributes && this.setAttributes(t3.attributes), \"object\" == typeof t3.scale && (this.scale = new X(t3.scale)), this.config.legend && (this.legend = new A(v({ map: this._map, series: this }, this.config.legend))), this.setValues(this._values);\n        }\n        var e2 = t2.prototype;\n        return e2.setValues = function(t3) {\n          var e3 = {};\n          for (var i2 in t3)\n            t3[i2] && (e3[i2] = this.scale.getValue(t3[i2]));\n          this.setAttributes(e3);\n        }, e2.setAttributes = function(t3) {\n          for (var e3 in t3)\n            this._elements[e3] && this._elements[e3].element.setStyle(this.config.attribute, t3[e3]);\n        }, e2.clear = function() {\n          var t3, e3 = {};\n          for (t3 in this._values)\n            this._elements[t3] && (e3[t3] = this._elements[t3].element.shape.style.initial[this.config.attribute]);\n          this.setAttributes(e3), this._values = {};\n        }, t2;\n      }();\n      var E = { mill: function(t2, e2, i2) {\n        return { x: this.radius * (e2 - i2) * this.radDeg, y: -this.radius * Math.log(Math.tan((45 + 0.4 * t2) * this.radDeg)) / 0.8 };\n      }, merc: function(t2, e2, i2) {\n        return { x: this.radius * (e2 - i2) * this.radDeg, y: -this.radius * Math.log(Math.tan(Math.PI / 4 + t2 * Math.PI / 360)) };\n      }, aea: function(t2, e2, i2) {\n        var s2 = i2 * this.radDeg, a2 = 29.5 * this.radDeg, n2 = 45.5 * this.radDeg, r2 = t2 * this.radDeg, o2 = e2 * this.radDeg, h2 = (Math.sin(a2) + Math.sin(n2)) / 2, l2 = Math.cos(a2) * Math.cos(a2) + 2 * h2 * Math.sin(a2), c2 = h2 * (o2 - s2), u2 = Math.sqrt(l2 - 2 * h2 * Math.sin(r2)) / h2, p2 = Math.sqrt(l2 - 2 * h2 * Math.sin(0)) / h2;\n        return { x: u2 * Math.sin(c2) * this.radius, y: -(p2 - u2 * Math.cos(c2)) * this.radius };\n      }, lcc: function(t2, e2, i2) {\n        var s2 = i2 * this.radDeg, a2 = e2 * this.radDeg, n2 = 33 * this.radDeg, r2 = 45 * this.radDeg, o2 = t2 * this.radDeg, h2 = Math.log(Math.cos(n2) * (1 / Math.cos(r2))) / Math.log(Math.tan(Math.PI / 4 + r2 / 2) * (1 / Math.tan(Math.PI / 4 + n2 / 2))), l2 = Math.cos(n2) * Math.pow(Math.tan(Math.PI / 4 + n2 / 2), h2) / h2, c2 = l2 * Math.pow(1 / Math.tan(Math.PI / 4 + o2 / 2), h2), u2 = l2 * Math.pow(1 / Math.tan(Math.PI / 4 + 0), h2);\n        return { x: c2 * Math.sin(h2 * (a2 - s2)) * this.radius, y: -(u2 - c2 * Math.cos(h2 * (a2 - s2))) * this.radius };\n      } };\n      E.degRad = 180 / Math.PI, E.radDeg = Math.PI / 180, E.radius = 6381372;\n      var T = { _setupContainerEvents: function() {\n        var t2, e2, i2 = this, s2 = this, a2 = false;\n        this.params.draggable && (S.on(this.container, \"mousemove\", function(i3) {\n          if (!a2)\n            return false;\n          s2.transX -= (t2 - i3.pageX) / s2.scale, s2.transY -= (e2 - i3.pageY) / s2.scale, s2._applyTransform(), t2 = i3.pageX, e2 = i3.pageY;\n        }), S.on(this.container, \"mousedown\", function(i3) {\n          return a2 = true, t2 = i3.pageX, e2 = i3.pageY, false;\n        }), S.on(document.body, \"mouseup\", function() {\n          a2 = false;\n        })), this.params.zoomOnScroll && S.on(this.container, \"wheel\", function(t3) {\n          var e3 = 75 * ((t3.deltaY || -t3.wheelDelta || t3.detail) >> 10 || 1), a3 = i2.container.getBoundingClientRect(), n2 = t3.pageX - a3.left - window.pageXOffset, r2 = t3.pageY - a3.top - window.pageYOffset, o2 = Math.pow(1 + s2.params.zoomOnScrollSpeed / 1e3, -1.5 * e3);\n          s2.tooltip && s2._tooltip.hide(), s2._setScale(s2.scale * o2, n2, r2), t3.preventDefault();\n        });\n      }, _setupElementEvents: function() {\n        var t2, e2, i2, s2 = this, a2 = this.container;\n        S.on(a2, \"mousemove\", function(s3) {\n          Math.abs(t2 - s3.pageX) + Math.abs(e2 - s3.pageY) > 2 && (i2 = true);\n        }), S.delegate(a2, \"mousedown\", \".jvm-element\", function(s3) {\n          t2 = s3.pageX, e2 = s3.pageY, i2 = false;\n        }), S.delegate(a2, \"mouseover mouseout\", \".jvm-element\", function(t3) {\n          var e3 = M(s2, this, true), i3 = s2.params.showTooltip;\n          \"mouseover\" === t3.type ? (e3.element.hover(true), i3 && (s2._tooltip.text(e3.tooltipText), s2._tooltip.show(), s2._emit(e3.event, [t3, s2._tooltip, e3.code]))) : (e3.element.hover(false), i3 && s2._tooltip.hide());\n        }), S.delegate(a2, \"mouseup\", \".jvm-element\", function(t3) {\n          var e3 = M(s2, this);\n          if (!i2 && (\"region\" === e3.type && s2.params.regionsSelectable || \"marker\" === e3.type && s2.params.markersSelectable)) {\n            var a3 = e3.element;\n            s2.params[e3.type + \"sSelectableOne\"] && s2._clearSelected(e3.type + \"s\"), e3.element.isSelected ? a3.select(false) : a3.select(true), s2._emit(e3.event, [e3.code, a3.isSelected, s2._getSelected(e3.type + \"s\")]);\n          }\n        }), S.delegate(a2, \"click\", \".jvm-element\", function(t3) {\n          var e3 = M(s2, this), i3 = e3.type, a3 = e3.code;\n          s2._emit(\"region\" === i3 ? k.onRegionClick : k.onMarkerClick, [t3, a3]);\n        });\n      }, _setupZoomButtons: function() {\n        var t2 = this, e2 = m(\"div\", \"jvm-zoom-btn jvm-zoomin\", \"&#43;\", true), i2 = m(\"div\", \"jvm-zoom-btn jvm-zoomout\", \"&#x2212\", true);\n        this.container.appendChild(e2), this.container.appendChild(i2);\n        var s2 = function(e3) {\n          return void 0 === e3 && (e3 = true), function() {\n            return t2._setScale(e3 ? t2.scale * t2.params.zoomStep : t2.scale / t2.params.zoomStep, t2._width / 2, t2._height / 2, false, t2.params.zoomAnimate);\n          };\n        };\n        S.on(e2, \"click\", s2()), S.on(i2, \"click\", s2(false));\n      }, _setupContainerTouchEvents: function() {\n        var t2, e2, i2, s2, a2, n2, r2, o2 = this, h2 = function(h3) {\n          var l2, c2, u2, p2, d2 = h3.touches;\n          if (\"touchstart\" == h3.type && (r2 = 0), 1 == d2.length)\n            1 == r2 && (u2 = o2.transX, p2 = o2.transY, o2.transX -= (i2 - d2[0].pageX) / o2.scale, o2.transY -= (s2 - d2[0].pageY) / o2.scale, o2._tooltip.hide(), o2._applyTransform(), u2 == o2.transX && p2 == o2.transY || h3.preventDefault()), i2 = d2[0].pageX, s2 = d2[0].pageY;\n          else if (2 == d2.length)\n            if (2 == r2)\n              c2 = Math.sqrt(Math.pow(d2[0].pageX - d2[1].pageX, 2) + Math.pow(d2[0].pageY - d2[1].pageY, 2)) / e2, o2._setScale(t2 * c2, a2, n2), o2._tooltip.hide(), h3.preventDefault();\n            else {\n              var f2 = o2.container.getBoundingClientRect();\n              l2 = { top: f2.top + window.scrollY, left: f2.left + window.scrollX }, a2 = d2[0].pageX > d2[1].pageX ? d2[1].pageX + (d2[0].pageX - d2[1].pageX) / 2 : d2[0].pageX + (d2[1].pageX - d2[0].pageX) / 2, n2 = d2[0].pageY > d2[1].pageY ? d2[1].pageY + (d2[0].pageY - d2[1].pageY) / 2 : d2[0].pageY + (d2[1].pageY - d2[0].pageY) / 2, a2 -= l2.left, n2 -= l2.top, t2 = o2.scale, e2 = Math.sqrt(Math.pow(d2[0].pageX - d2[1].pageX, 2) + Math.pow(d2[0].pageY - d2[1].pageY, 2));\n            }\n          r2 = d2.length;\n        };\n        S.on(o2.container, \"touchstart\", h2), S.on(o2.container, \"touchmove\", h2);\n      }, _createRegions: function() {\n        for (var t2 in this._regionLabelsGroup = this._regionLabelsGroup || this.canvas.createGroup(\"jvm-regions-labels-group\"), this._mapData.paths) {\n          var e2 = new C({ map: this, code: t2, path: this._mapData.paths[t2].path, style: v({}, this.params.regionStyle), labelStyle: this.params.regionLabelStyle, labelsGroup: this._regionLabelsGroup, label: this.params.labels && this.params.labels.regions });\n          this.regions[t2] = { config: this._mapData.paths[t2], element: e2 };\n        }\n      }, _createLines: function(t2, e2, i2) {\n        void 0 === i2 && (i2 = false);\n        var s2 = false, a2 = false;\n        for (var n2 in this.linesGroup = this.linesGroup || this.canvas.createGroup(\"jvm-lines-group\"), t2) {\n          var r2 = t2[n2];\n          for (var o2 in e2) {\n            var h2 = i2 ? e2[o2].config : e2[o2];\n            h2.name === r2.from && (s2 = this.getMarkerPosition(h2)), h2.name === r2.to && (a2 = this.getMarkerPosition(h2));\n          }\n          false !== s2 && false !== a2 && (this._lines[_(r2.from, r2.to)] = new L({ index: n2, map: this, style: v({ initial: this.params.lineStyle }, { initial: r2.style || {} }, true), x1: s2.x, y1: s2.y, x2: a2.x, y2: a2.y, group: this.linesGroup, config: r2 }));\n        }\n      }, _createMarkers: function(t2, e2) {\n        var i2 = this;\n        void 0 === t2 && (t2 = {}), void 0 === e2 && (e2 = false), this._markersGroup = this._markersGroup || this.canvas.createGroup(\"jvm-markers-group\"), this._markerLabelsGroup = this._markerLabelsGroup || this.canvas.createGroup(\"jvm-markers-labels-group\");\n        var s2 = function() {\n          var s3 = t2[a2], n2 = i2.getMarkerPosition(s3), r2 = s3.coords.join(\":\");\n          if (!n2)\n            return \"continue\";\n          if (e2) {\n            if (Object.keys(i2._markers).filter(function(t3) {\n              return i2._markers[t3]._uid === r2;\n            }).length)\n              return \"continue\";\n            a2 = Object.keys(i2._markers).length;\n          }\n          var o2 = new O({ index: a2, map: i2, style: v(i2.params.markerStyle, { initial: s3.style || {} }, true), label: i2.params.labels && i2.params.labels.markers, labelsGroup: i2._markerLabelsGroup, cx: n2.x, cy: n2.y, group: i2._markersGroup, marker: s3, isRecentlyCreated: e2 });\n          i2._markers[a2] && i2.removeMarkers([a2]), i2._markers[a2] = { _uid: r2, config: s3, element: o2 };\n        };\n        for (var a2 in t2)\n          s2();\n      }, _createSeries: function() {\n        for (var t2 in this.series = { markers: [], regions: [] }, this.params.series)\n          for (var e2 = 0; e2 < this.params.series[t2].length; e2++)\n            this.series[t2][e2] = new Y(this.params.series[t2][e2], \"markers\" === t2 ? this._markers : this.regions, this);\n      }, _applyTransform: function() {\n        var t2, e2, i2, s2;\n        this._defaultWidth * this.scale <= this._width ? (t2 = (this._width - this._defaultWidth * this.scale) / (2 * this.scale), i2 = (this._width - this._defaultWidth * this.scale) / (2 * this.scale)) : (t2 = 0, i2 = (this._width - this._defaultWidth * this.scale) / this.scale), this._defaultHeight * this.scale <= this._height ? (e2 = (this._height - this._defaultHeight * this.scale) / (2 * this.scale), s2 = (this._height - this._defaultHeight * this.scale) / (2 * this.scale)) : (e2 = 0, s2 = (this._height - this._defaultHeight * this.scale) / this.scale), this.transY > e2 ? this.transY = e2 : this.transY < s2 && (this.transY = s2), this.transX > t2 ? this.transX = t2 : this.transX < i2 && (this.transX = i2), this.canvas.applyTransformParams(this.scale, this.transX, this.transY), this._markers && this._repositionMarkers(), this._lines && this._repositionLines(), this._repositionLabels();\n      }, _resize: function() {\n        var t2 = this._baseScale;\n        this._width / this._height > this._defaultWidth / this._defaultHeight ? (this._baseScale = this._height / this._defaultHeight, this._baseTransX = Math.abs(this._width - this._defaultWidth * this._baseScale) / (2 * this._baseScale)) : (this._baseScale = this._width / this._defaultWidth, this._baseTransY = Math.abs(this._height - this._defaultHeight * this._baseScale) / (2 * this._baseScale)), this.scale *= this._baseScale / t2, this.transX *= this._baseScale / t2, this.transY *= this._baseScale / t2;\n      }, _setScale: function(t2, e2, i2, s2, a2) {\n        var n2, r2, o2, h2, l2, c2, u2, p2, d2, f2, m2 = this, g2 = 0, v2 = Math.abs(Math.round(60 * (t2 - this.scale) / Math.max(t2, this.scale)));\n        t2 > this.params.zoomMax * this._baseScale ? t2 = this.params.zoomMax * this._baseScale : t2 < this.params.zoomMin * this._baseScale && (t2 = this.params.zoomMin * this._baseScale), void 0 !== e2 && void 0 !== i2 && (n2 = t2 / this.scale, s2 ? (d2 = e2 + this._defaultWidth * (this._width / (this._defaultWidth * t2)) / 2, f2 = i2 + this._defaultHeight * (this._height / (this._defaultHeight * t2)) / 2) : (d2 = this.transX - (n2 - 1) / t2 * e2, f2 = this.transY - (n2 - 1) / t2 * i2)), a2 && v2 > 0 ? (o2 = this.scale, h2 = (t2 - o2) / v2, l2 = this.transX * this.scale, u2 = this.transY * this.scale, c2 = (d2 * t2 - l2) / v2, p2 = (f2 * t2 - u2) / v2, r2 = setInterval(function() {\n          g2 += 1, m2.scale = o2 + h2 * g2, m2.transX = (l2 + c2 * g2) / m2.scale, m2.transY = (u2 + p2 * g2) / m2.scale, m2._applyTransform(), g2 == v2 && (clearInterval(r2), m2._emit(k.onViewportChange, [m2.scale, m2.transX, m2.transY]));\n        }, 10)) : (this.transX = d2, this.transY = f2, this.scale = t2, this._applyTransform(), this._emit(k.onViewportChange, [this.scale, this.transX, this.transY]));\n      }, setFocus: function(t2) {\n        var e2 = this;\n        void 0 === t2 && (t2 = {});\n        var i2, s2 = [];\n        if (t2.region ? s2.push(t2.region) : t2.regions && (s2 = t2.regions), s2.length)\n          return s2.forEach(function(t3) {\n            if (e2.regions[t3]) {\n              var s3 = e2.regions[t3].element.shape.getBBox();\n              s3 && (i2 = void 0 === i2 ? s3 : { x: Math.min(i2.x, s3.x), y: Math.min(i2.y, s3.y), width: Math.max(i2.x + i2.width, s3.x + s3.width) - Math.min(i2.x, s3.x), height: Math.max(i2.y + i2.height, s3.y + s3.height) - Math.min(i2.y, s3.y) });\n            }\n          }), this._setScale(Math.min(this._width / i2.width, this._height / i2.height), -(i2.x + i2.width / 2), -(i2.y + i2.height / 2), true, t2.animate);\n        if (t2.coords) {\n          var a2 = this.coordsToPoint(t2.coords[0], t2.coords[1]), n2 = this.transX - a2.x / this.scale, r2 = this.transY - a2.y / this.scale;\n          return this._setScale(t2.scale * this._baseScale, n2, r2, true, t2.animate);\n        }\n      }, updateSize: function() {\n        this._width = this.container.offsetWidth, this._height = this.container.offsetHeight, this._resize(), this.canvas.setSize(this._width, this._height), this._applyTransform();\n      }, coordsToPoint: function(t2, e2) {\n        var i2 = G.maps[this.params.map].projection, s2 = E[i2.type](t2, e2, i2.centralMeridian), a2 = s2.x, n2 = s2.y, r2 = this.getInsetForPoint(a2, n2);\n        if (!r2)\n          return false;\n        var o2 = r2.bbox;\n        return a2 = (a2 - o2[0].x) / (o2[1].x - o2[0].x) * r2.width * this.scale, n2 = (n2 - o2[0].y) / (o2[1].y - o2[0].y) * r2.height * this.scale, { x: a2 + this.transX * this.scale + r2.left * this.scale, y: n2 + this.transY * this.scale + r2.top * this.scale };\n      }, getInsetForPoint: function(t2, e2) {\n        for (var i2 = G.maps[this.params.map].insets, s2 = 0; s2 < i2.length; s2++) {\n          var a2 = i2[s2].bbox, n2 = a2[0], r2 = a2[1];\n          if (t2 > n2.x && t2 < r2.x && e2 > n2.y && e2 < r2.y)\n            return i2[s2];\n        }\n      }, getMarkerPosition: function(t2) {\n        var e2 = t2.coords;\n        return G.maps[this.params.map].projection ? this.coordsToPoint.apply(this, e2) : { x: e2[0] * this.scale + this.transX * this.scale, y: e2[1] * this.scale + this.transY * this.scale };\n      }, _repositionLines: function() {\n        var t2 = false, e2 = false;\n        for (var i2 in this._lines) {\n          for (var s2 in this._markers) {\n            var a2 = this._markers[s2];\n            a2.config.name === this._lines[i2].config.from && (t2 = this.getMarkerPosition(a2.config)), a2.config.name === this._lines[i2].config.to && (e2 = this.getMarkerPosition(a2.config));\n          }\n          false !== t2 && false !== e2 && this._lines[i2].setStyle({ x1: t2.x, y1: t2.y, x2: e2.x, y2: e2.y });\n        }\n      }, _repositionMarkers: function() {\n        for (var t2 in this._markers) {\n          var e2 = this.getMarkerPosition(this._markers[t2].config);\n          false !== e2 && this._markers[t2].element.setStyle({ cx: e2.x, cy: e2.y });\n        }\n      }, _repositionLabels: function() {\n        var t2 = this.params.labels;\n        if (t2) {\n          if (t2.regions)\n            for (var e2 in this.regions)\n              this.regions[e2].element.updateLabelPosition();\n          if (t2.markers)\n            for (var i2 in this._markers)\n              this._markers[i2].element.updateLabelPosition();\n        }\n      } }, z = function() {\n        function t2(t3, e3) {\n          this.node = this._createElement(t3), e3 && this.set(e3);\n        }\n        var e2 = t2.prototype;\n        return e2._createElement = function(t3) {\n          return document.createElementNS(\"http://www.w3.org/2000/svg\", t3);\n        }, e2.addClass = function(t3) {\n          this.node.setAttribute(\"class\", t3);\n        }, e2.getBBox = function() {\n          return this.node.getBBox();\n        }, e2.set = function(t3, e3) {\n          if (\"object\" == typeof t3)\n            for (var i2 in t3)\n              this.applyAttr(i2, t3[i2]);\n          else\n            this.applyAttr(t3, e3);\n        }, e2.get = function(t3) {\n          return this.style.initial[t3];\n        }, e2.applyAttr = function(t3, e3) {\n          this.node.setAttribute(t3.replace(/[\\w]([A-Z])/g, function(t4) {\n            return t4[0] + \"-\" + t4[1];\n          }).toLowerCase(), e3);\n        }, e2.remove = function() {\n          g(this.node);\n        }, t2;\n      }(), P = function(e2) {\n        function i2(t2, i3, s3) {\n          var a2;\n          return void 0 === s3 && (s3 = {}), (a2 = e2.call(this, t2, i3) || this).isHovered = false, a2.isSelected = false, a2.style = s3, a2.style.current = {}, a2.updateStyle(), a2;\n        }\n        t(i2, e2);\n        var s2 = i2.prototype;\n        return s2.setStyle = function(t2, e3) {\n          var i3;\n          \"object\" == typeof t2 ? v(this.style.current, t2) : v(this.style.current, ((i3 = {})[t2] = e3, i3));\n          this.updateStyle();\n        }, s2.updateStyle = function() {\n          var t2 = {};\n          v(t2, this.style.initial), v(t2, this.style.current), this.isHovered && v(t2, this.style.hover), this.isSelected && (v(t2, this.style.selected), this.isHovered && v(t2, this.style.selectedHover)), this.set(t2);\n        }, i2;\n      }(z), D = function(e2) {\n        function i2(t2, i3) {\n          return e2.call(this, \"text\", t2, i3) || this;\n        }\n        return t(i2, e2), i2.prototype.applyAttr = function(t2, i3) {\n          \"text\" === t2 ? this.node.textContent = i3 : e2.prototype.applyAttr.call(this, t2, i3);\n        }, i2;\n      }(P), I = function(e2) {\n        function i2(t2, i3) {\n          return e2.call(this, \"image\", t2, i3) || this;\n        }\n        return t(i2, e2), i2.prototype.applyAttr = function(t2, i3) {\n          var s2;\n          \"image\" === t2 ? (\"object\" == typeof i3 ? (s2 = i3.url, this.offset = i3.offset || [0, 0]) : (s2 = i3, this.offset = [0, 0]), this.node.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", s2), this.width = 23, this.height = 23, this.applyAttr(\"width\", this.width), this.applyAttr(\"height\", this.height), this.applyAttr(\"x\", this.cx - this.width / 2 + this.offset[0]), this.applyAttr(\"y\", this.cy - this.height / 2 + this.offset[1])) : \"cx\" == t2 ? (this.cx = i3, this.width && this.applyAttr(\"x\", i3 - this.width / 2 + this.offset[0])) : \"cy\" == t2 ? (this.cy = i3, this.height && this.applyAttr(\"y\", i3 - this.height / 2 + this.offset[1])) : e2.prototype.applyAttr.apply(this, arguments);\n        }, i2;\n      }(P), R = function(e2) {\n        function i2(t2) {\n          var i3;\n          return (i3 = e2.call(this, \"svg\") || this)._container = t2, i3._defsElement = new z(\"defs\"), i3._rootElement = new z(\"g\", { id: \"jvm-regions-group\" }), i3.node.appendChild(i3._defsElement.node), i3.node.appendChild(i3._rootElement.node), i3._container.appendChild(i3.node), i3;\n        }\n        t(i2, e2);\n        var s2 = i2.prototype;\n        return s2.setSize = function(t2, e3) {\n          this.node.setAttribute(\"width\", t2), this.node.setAttribute(\"height\", e3);\n        }, s2.applyTransformParams = function(t2, e3, i3) {\n          this._rootElement.node.setAttribute(\"transform\", \"scale(\" + t2 + \") translate(\" + e3 + \", \" + i3 + \")\");\n        }, s2.createPath = function(t2, e3) {\n          var i3 = new P(\"path\", t2, e3);\n          return i3.node.setAttribute(\"fill-rule\", \"evenodd\"), this._add(i3);\n        }, s2.createCircle = function(t2, e3, i3) {\n          var s3 = new P(\"circle\", t2, e3);\n          return this._add(s3, i3);\n        }, s2.createLine = function(t2, e3, i3) {\n          var s3 = new P(\"line\", t2, e3);\n          return this._add(s3, i3);\n        }, s2.createText = function(t2, e3, i3) {\n          var s3 = new D(t2, e3);\n          return this._add(s3, i3);\n        }, s2.createImage = function(t2, e3, i3) {\n          var s3 = new I(t2, e3);\n          return this._add(s3, i3);\n        }, s2.createGroup = function(t2) {\n          var e3 = new z(\"g\");\n          return this.node.appendChild(e3.node), t2 && (e3.node.id = t2), e3.canvas = this, e3;\n        }, s2._add = function(t2, e3) {\n          return (e3 = e3 || this._rootElement).node.appendChild(t2.node), t2;\n        }, i2;\n      }(z), H = function(e2) {\n        function s2(t2) {\n          var s3;\n          s3 = e2.call(this) || this;\n          var a3 = m(\"div\", \"jvm-tooltip\");\n          return s3._map = t2, s3._tooltip = document.body.appendChild(a3), s3._bindEventListeners(), i(s3) || i(s3);\n        }\n        t(s2, e2);\n        var a2 = s2.prototype;\n        return a2._bindEventListeners = function() {\n          var t2 = this;\n          S.on(this._map.container, \"mousemove\", function(e3) {\n            if (t2._tooltip.classList.contains(\"active\")) {\n              var i2, s3, a3 = (i2 = t2._map.container, s3 = \"#jvm-regions-group\", Element.prototype.querySelector.call(i2, s3)).getBoundingClientRect(), n2 = t2._tooltip.getBoundingClientRect(), r2 = n2.height, o2 = n2.width, h2 = e3.clientY <= a3.top + r2 + 5, l2 = e3.pageY - r2 - 5, c2 = e3.pageX - o2 - 5;\n              h2 && (l2 += r2 + 5, c2 -= 10), e3.clientX < a3.left + o2 + 5 && (c2 = e3.pageX + 5 + 2, h2 && (c2 += 10)), t2.css({ top: l2 + \"px\", left: c2 + \"px\" });\n            }\n          });\n        }, a2.getElement = function() {\n          return this._tooltip;\n        }, a2.show = function() {\n          this._tooltip.classList.add(\"active\");\n        }, a2.hide = function() {\n          this._tooltip.classList.remove(\"active\");\n        }, a2.text = function(t2, e3) {\n          void 0 === e3 && (e3 = false);\n          var i2 = e3 ? \"innerHTML\" : \"textContent\";\n          if (!t2)\n            return this._tooltip[i2];\n          this._tooltip[i2] = t2;\n        }, a2.css = function(t2) {\n          for (var e3 in t2)\n            this._tooltip.style[e3] = t2[e3];\n          return this;\n        }, s2;\n      }(x), V = function() {\n        function t2(t3, e3) {\n          var i2 = t3.scale, s2 = t3.values;\n          this._scale = i2, this._values = s2, this._fromColor = this.hexToRgb(i2[0]), this._toColor = this.hexToRgb(i2[1]), this._map = e3, this.setMinMaxValues(s2), this.visualize();\n        }\n        var e2 = t2.prototype;\n        return e2.setMinMaxValues = function(t3) {\n          for (var e3 in this.min = Number.MAX_VALUE, this.max = 0, t3)\n            (e3 = parseFloat(t3[e3])) > this.max && (this.max = e3), e3 < this.min && (this.min = e3);\n        }, e2.visualize = function() {\n          var t3, e3 = {};\n          for (var i2 in this._values)\n            t3 = parseFloat(this._values[i2]), isNaN(t3) || (e3[i2] = this.getValue(t3));\n          this.setAttributes(e3);\n        }, e2.setAttributes = function(t3) {\n          for (var e3 in t3)\n            this._map.regions[e3] && this._map.regions[e3].element.setStyle(\"fill\", t3[e3]);\n        }, e2.getValue = function(t3) {\n          for (var e3, i2 = \"#\", s2 = 0; s2 < 3; s2++)\n            i2 += (1 === (e3 = Math.round(this._fromColor[s2] + (this._toColor[s2] - this._fromColor[s2]) * ((t3 - this.min) / (this.max - this.min))).toString(16)).length ? \"0\" : \"\") + e3;\n          return i2;\n        }, e2.hexToRgb = function(t3) {\n          var e3 = 0, i2 = 0, s2 = 0;\n          return 4 == t3.length ? (e3 = \"0x\" + t3[1] + t3[1], i2 = \"0x\" + t3[2] + t3[2], s2 = \"0x\" + t3[3] + t3[3]) : 7 == t3.length && (e3 = \"0x\" + t3[1] + t3[2], i2 = \"0x\" + t3[3] + t3[4], s2 = \"0x\" + t3[5] + t3[6]), [parseInt(e3), parseInt(i2), parseInt(s2)];\n        }, t2;\n      }(), G = function() {\n        function t2(e3) {\n          var i2 = this;\n          if (void 0 === e3 && (e3 = {}), this.params = v(t2.defaults, e3, true), !t2.maps[this.params.map])\n            throw new Error(\"Attempt to use map which was not loaded: \" + e3.map);\n          this.regions = {}, this.scale = 1, this.transX = 0, this.transY = 0, this._mapData = t2.maps[this.params.map], this._markers = {}, this._lines = {}, this._defaultWidth = this._mapData.width, this._defaultHeight = this._mapData.height, this._height = 0, this._width = 0, this._baseScale = 1, this._baseTransX = 0, this._baseTransY = 0, \"loading\" !== document.readyState ? this._init() : window.addEventListener(\"DOMContentLoaded\", function() {\n            return i2._init();\n          });\n        }\n        var e2 = t2.prototype;\n        return e2._init = function() {\n          var t3 = this.params;\n          this.container = f(t3.selector), this.container.classList.add(\"jvm-container\"), this.canvas = new R(this.container), this.setBackgroundColor(t3.backgroundColor), this._createRegions(), this.updateSize(), this._createLines(t3.lines || {}, t3.markers || {}), this._createMarkers(t3.markers), this._repositionLabels(), this._setupContainerEvents(), this._setupElementEvents(), t3.zoomButtons && this._setupZoomButtons(), t3.showTooltip && (this._tooltip = new H(this)), t3.selectedRegions && this._setSelected(\"regions\", t3.selectedRegions), t3.selectedMarkers && this._setSelected(\"_markers\", t3.selectedMarkers), t3.focusOn && this.setFocus(t3.focusOn), t3.visualizeData && (this.dataVisualization = new V(t3.visualizeData, this)), t3.bindTouchEvents && (\"ontouchstart\" in window || window.DocumentTouch && document instanceof DocumentTouch) && this._setupContainerTouchEvents(), t3.series && (this.container.appendChild(this.legendHorizontal = m(\"div\", \"jvm-series-container jvm-series-h\")), this.container.appendChild(this.legendVertical = m(\"div\", \"jvm-series-container jvm-series-v\")), this._createSeries()), this._emit(k.onLoaded, [this]);\n        }, e2.setBackgroundColor = function(t3) {\n          this.container.style.backgroundColor = t3;\n        }, e2.getSelectedRegions = function() {\n          return this._getSelected(\"regions\");\n        }, e2.clearSelectedRegions = function() {\n          this._clearSelected(\"regions\");\n        }, e2.getSelectedMarkers = function() {\n          return this._getSelected(\"_markers\");\n        }, e2.clearSelectedMarkers = function() {\n          this._clearSelected(\"_markers\");\n        }, e2.addMarkers = function(t3) {\n          if (Array.isArray(t3))\n            return this._createMarkers(t3, true);\n          this._createMarkers([t3], true);\n        }, e2.removeMarkers = function(t3) {\n          var e3 = this;\n          t3 || (t3 = Object.keys(this._markers)), t3.forEach(function(t4) {\n            e3._markers[t4].element.remove(), delete e3._markers[t4];\n          });\n        }, e2.addLine = function(t3, e3, i2) {\n          void 0 === i2 && (i2 = {}), console.warn(\"`addLine` method is deprecated, please use `addLines` instead.\"), this._createLines([{ from: t3, to: e3, style: i2 }], this._markers, true);\n        }, e2.addLines = function(t3) {\n          var e3 = this._getLinesAsUids();\n          Array.isArray(t3) || (t3 = [t3]), this._createLines(t3.filter(function(t4) {\n            return !(e3.indexOf(_(t4.from, t4.to)) > -1);\n          }), this._markers, true);\n        }, e2.removeLines = function(t3) {\n          var e3 = this;\n          (t3 = Array.isArray(t3) ? t3.map(function(t4) {\n            return _(t4.from, t4.to);\n          }) : this._getLinesAsUids()).forEach(function(t4) {\n            e3._lines[t4].dispose(), delete e3._lines[t4];\n          });\n        }, e2.removeLine = function(t3, e3) {\n          console.warn(\"`removeLine` method is deprecated, please use `removeLines` instead.\");\n          var i2 = _(t3, e3);\n          this._lines.hasOwnProperty(i2) && (this._lines[i2].element.remove(), delete this._lines[i2]);\n        }, e2.reset = function() {\n          for (var t3 in this.series)\n            for (var e3 = 0; e3 < this.series[t3].length; e3++)\n              this.series[t3][e3].clear();\n          this.legendHorizontal && (g(this.legendHorizontal), this.legendHorizontal = null), this.legendVertical && (g(this.legendVertical), this.legendVertical = null), this.scale = this._baseScale, this.transX = this._baseTransX, this.transY = this._baseTransY, this._applyTransform(), this.clearSelectedMarkers(), this.clearSelectedRegions(), this.removeMarkers();\n        }, e2.destroy = function(t3) {\n          var e3 = this;\n          void 0 === t3 && (t3 = true), S.flush(), this._tooltip.dispose(), this._emit(k.onDestroyed), t3 && Object.keys(this).forEach(function(t4) {\n            try {\n              delete e3[t4];\n            } catch (t5) {\n            }\n          });\n        }, e2.extend = function(e3, i2) {\n          if (\"function\" == typeof this[e3])\n            throw new Error(\"The method [\" + e3 + \"] does already exist, please use another name.\");\n          t2.prototype[e3] = i2;\n        }, e2._emit = function(t3, e3) {\n          for (var i2 in k)\n            k[i2] === t3 && \"function\" == typeof this.params[i2] && this.params[i2].apply(this, e3);\n        }, e2._getSelected = function(t3) {\n          var e3 = [];\n          for (var i2 in this[t3])\n            this[t3][i2].element.isSelected && e3.push(i2);\n          return e3;\n        }, e2._setSelected = function(t3, e3) {\n          var i2 = this;\n          e3.forEach(function(e4) {\n            i2[t3][e4] && i2[t3][e4].element.select(true);\n          });\n        }, e2._clearSelected = function(t3) {\n          var e3 = this;\n          this._getSelected(t3).forEach(function(i2) {\n            e3[t3][i2].element.select(false);\n          });\n        }, e2._getLinesAsUids = function() {\n          return Object.keys(this._lines);\n        }, t2;\n      }();\n      G.maps = {}, G.defaults = { map: \"world\", backgroundColor: \"transparent\", draggable: true, zoomButtons: true, zoomOnScroll: true, zoomOnScrollSpeed: 3, zoomMax: 12, zoomMin: 1, zoomAnimate: true, showTooltip: true, zoomStep: 1.5, bindTouchEvents: true, lineStyle: { stroke: \"#808080\", strokeWidth: 1, strokeLinecap: \"round\" }, markersSelectable: false, markersSelectableOne: false, markerStyle: { initial: { r: 7, fill: \"#374151\", fillOpacity: 1, stroke: \"#FFF\", strokeWidth: 5, strokeOpacity: 0.5 }, hover: { fill: \"#3cc0ff\", cursor: \"pointer\" }, selected: { fill: \"blue\" }, selectedHover: {} }, markerLabelStyle: { initial: { fontFamily: \"Verdana\", fontSize: 12, fontWeight: 500, cursor: \"default\", fill: \"#374151\" }, hover: { cursor: \"pointer\" }, selected: {}, selectedHover: {} }, regionsSelectable: false, regionsSelectableOne: false, regionStyle: { initial: { fill: \"#dee2e8\", fillOpacity: 1, stroke: \"none\", strokeWidth: 0 }, hover: { fillOpacity: 0.7, cursor: \"pointer\" }, selected: { fill: \"#9ca3af\" }, selectedHover: {} }, regionLabelStyle: { initial: { fontFamily: \"Verdana\", fontSize: \"12\", fontWeight: \"bold\", cursor: \"default\", fill: \"#35373e\" }, hover: { cursor: \"pointer\" } } }, Object.assign(G.prototype, T);\n      var B = function() {\n        function t2(t3) {\n          if (void 0 === t3 && (t3 = {}), !t3.selector)\n            throw new Error(\"Selector is not given.\");\n          return new G(t3);\n        }\n        return t2.addMap = function(t3, e2) {\n          G.maps[t3] = e2;\n        }, t2;\n      }();\n      return window.jsVectorMap = B;\n    });\n  }\n});\nexport default require_jsvectormap_min();\n//# sourceMappingURL=jsvectormap.js.map\n",
      "start": 1703289449953,
      "end": 1703289449953,
      "order": "normal",
      "sourcemaps": null
    }
  ]
}
