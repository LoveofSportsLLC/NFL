{
  "resolvedId": "/app/node_modules/.vite/deps/realm-web.js?v=4d074b82",
  "transforms": [
    {
      "name": "vite:optimized-deps",
      "result": "\"use strict\";\n(() => {\n  var __create = Object.create;\n  var __defProp = Object.defineProperty;\n  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n  var __getOwnPropNames = Object.getOwnPropertyNames;\n  var __getProtoOf = Object.getPrototypeOf;\n  var __hasOwnProp = Object.prototype.hasOwnProperty;\n  var __esm = (fn, res) => function __init() {\n    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;\n  };\n  var __commonJS = (cb, mod) => function __require() {\n    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n  };\n  var __copyProps = (to, from, except, desc) => {\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n      for (let key of __getOwnPropNames(from))\n        if (!__hasOwnProp.call(to, key) && key !== except)\n          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n    }\n    return to;\n  };\n  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n    // If the importer is in node compatibility mode or this is not an ESM\n    // file that has been converted to a CommonJS file using a Babel-\n    // compatible transform (i.e. \"__esModule\" has not been set), then set\n    // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n    isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n    mod\n  ));\n\n  // node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js\n  var require_base64_js = __commonJS({\n    \"node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js\"(exports) {\n      \"use strict\";\n      init_dist();\n      exports.byteLength = byteLength;\n      exports.toByteArray = toByteArray;\n      exports.fromByteArray = fromByteArray;\n      var lookup = [];\n      var revLookup = [];\n      var Arr = typeof Uint8Array !== \"undefined\" ? Uint8Array : Array;\n      var code = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n      for (i = 0, len = code.length; i < len; ++i) {\n        lookup[i] = code[i];\n        revLookup[code.charCodeAt(i)] = i;\n      }\n      var i;\n      var len;\n      revLookup[\"-\".charCodeAt(0)] = 62;\n      revLookup[\"_\".charCodeAt(0)] = 63;\n      function getLens(b64) {\n        var len2 = b64.length;\n        if (len2 % 4 > 0) {\n          throw new Error(\"Invalid string. Length must be a multiple of 4\");\n        }\n        var validLen = b64.indexOf(\"=\");\n        if (validLen === -1)\n          validLen = len2;\n        var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;\n        return [validLen, placeHoldersLen];\n      }\n      function byteLength(b64) {\n        var lens = getLens(b64);\n        var validLen = lens[0];\n        var placeHoldersLen = lens[1];\n        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n      }\n      function _byteLength(b64, validLen, placeHoldersLen) {\n        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n      }\n      function toByteArray(b64) {\n        var tmp;\n        var lens = getLens(b64);\n        var validLen = lens[0];\n        var placeHoldersLen = lens[1];\n        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n        var curByte = 0;\n        var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;\n        var i2;\n        for (i2 = 0; i2 < len2; i2 += 4) {\n          tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];\n          arr[curByte++] = tmp >> 16 & 255;\n          arr[curByte++] = tmp >> 8 & 255;\n          arr[curByte++] = tmp & 255;\n        }\n        if (placeHoldersLen === 2) {\n          tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;\n          arr[curByte++] = tmp & 255;\n        }\n        if (placeHoldersLen === 1) {\n          tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;\n          arr[curByte++] = tmp >> 8 & 255;\n          arr[curByte++] = tmp & 255;\n        }\n        return arr;\n      }\n      function tripletToBase64(num) {\n        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];\n      }\n      function encodeChunk(uint8, start, end) {\n        var tmp;\n        var output = [];\n        for (var i2 = start; i2 < end; i2 += 3) {\n          tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);\n          output.push(tripletToBase64(tmp));\n        }\n        return output.join(\"\");\n      }\n      function fromByteArray(uint8) {\n        var tmp;\n        var len2 = uint8.length;\n        var extraBytes = len2 % 3;\n        var parts = [];\n        var maxChunkLength = 16383;\n        for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {\n          parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));\n        }\n        if (extraBytes === 1) {\n          tmp = uint8[len2 - 1];\n          parts.push(\n            lookup[tmp >> 2] + lookup[tmp << 4 & 63] + \"==\"\n          );\n        } else if (extraBytes === 2) {\n          tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];\n          parts.push(\n            lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + \"=\"\n          );\n        }\n        return parts.join(\"\");\n      }\n    }\n  });\n\n  // node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js\n  var require_ieee754 = __commonJS({\n    \"node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js\"(exports) {\n      init_dist();\n      exports.read = function(buffer, offset, isLE, mLen, nBytes) {\n        var e, m;\n        var eLen = nBytes * 8 - mLen - 1;\n        var eMax = (1 << eLen) - 1;\n        var eBias = eMax >> 1;\n        var nBits = -7;\n        var i = isLE ? nBytes - 1 : 0;\n        var d = isLE ? -1 : 1;\n        var s2 = buffer[offset + i];\n        i += d;\n        e = s2 & (1 << -nBits) - 1;\n        s2 >>= -nBits;\n        nBits += eLen;\n        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {\n        }\n        m = e & (1 << -nBits) - 1;\n        e >>= -nBits;\n        nBits += mLen;\n        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {\n        }\n        if (e === 0) {\n          e = 1 - eBias;\n        } else if (e === eMax) {\n          return m ? NaN : (s2 ? -1 : 1) * Infinity;\n        } else {\n          m = m + Math.pow(2, mLen);\n          e = e - eBias;\n        }\n        return (s2 ? -1 : 1) * m * Math.pow(2, e - mLen);\n      };\n      exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {\n        var e, m, c;\n        var eLen = nBytes * 8 - mLen - 1;\n        var eMax = (1 << eLen) - 1;\n        var eBias = eMax >> 1;\n        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n        var i = isLE ? 0 : nBytes - 1;\n        var d = isLE ? 1 : -1;\n        var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n        value = Math.abs(value);\n        if (isNaN(value) || value === Infinity) {\n          m = isNaN(value) ? 1 : 0;\n          e = eMax;\n        } else {\n          e = Math.floor(Math.log(value) / Math.LN2);\n          if (value * (c = Math.pow(2, -e)) < 1) {\n            e--;\n            c *= 2;\n          }\n          if (e + eBias >= 1) {\n            value += rt / c;\n          } else {\n            value += rt * Math.pow(2, 1 - eBias);\n          }\n          if (value * c >= 2) {\n            e++;\n            c /= 2;\n          }\n          if (e + eBias >= eMax) {\n            m = 0;\n            e = eMax;\n          } else if (e + eBias >= 1) {\n            m = (value * c - 1) * Math.pow(2, mLen);\n            e = e + eBias;\n          } else {\n            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n            e = 0;\n          }\n        }\n        for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {\n        }\n        e = e << mLen | m;\n        eLen += mLen;\n        for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {\n        }\n        buffer[offset + i - d] |= s2 * 128;\n      };\n    }\n  });\n\n  // node_modules/.pnpm/buffer@6.0.3_patch_hash=zkkuxompt5d553skpnegwi5wuy/node_modules/buffer/index.js\n  var require_buffer = __commonJS({\n    \"node_modules/.pnpm/buffer@6.0.3_patch_hash=zkkuxompt5d553skpnegwi5wuy/node_modules/buffer/index.js\"(exports) {\n      \"use strict\";\n      init_dist();\n      var base64 = require_base64_js();\n      var ieee754 = require_ieee754();\n      var customInspectSymbol = typeof Symbol === \"function\" && typeof Symbol[\"for\"] === \"function\" ? Symbol[\"for\"](\"nodejs.util.inspect.custom\") : null;\n      exports.Buffer = Buffer2;\n      exports.SlowBuffer = SlowBuffer;\n      exports.INSPECT_MAX_BYTES = 50;\n      var K_MAX_LENGTH = 2147483647;\n      exports.kMaxLength = K_MAX_LENGTH;\n      var { Uint8Array: GlobalUint8Array, ArrayBuffer: GlobalArrayBuffer, SharedArrayBuffer: GlobalSharedArrayBuffer } = globalThis;\n      Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();\n      if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== \"undefined\" && typeof console.error === \"function\") {\n        console.error(\n          \"This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.\"\n        );\n      }\n      function typedArraySupport() {\n        try {\n          const arr = new GlobalUint8Array(1);\n          const proto = { foo: function() {\n            return 42;\n          } };\n          Object.setPrototypeOf(proto, GlobalUint8Array.prototype);\n          Object.setPrototypeOf(arr, proto);\n          return arr.foo() === 42;\n        } catch (e) {\n          return false;\n        }\n      }\n      Object.defineProperty(Buffer2.prototype, \"parent\", {\n        enumerable: true,\n        get: function() {\n          if (!Buffer2.isBuffer(this))\n            return void 0;\n          return this.buffer;\n        }\n      });\n      Object.defineProperty(Buffer2.prototype, \"offset\", {\n        enumerable: true,\n        get: function() {\n          if (!Buffer2.isBuffer(this))\n            return void 0;\n          return this.byteOffset;\n        }\n      });\n      function createBuffer(length) {\n        if (length > K_MAX_LENGTH) {\n          throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"');\n        }\n        const buf = new GlobalUint8Array(length);\n        Object.setPrototypeOf(buf, Buffer2.prototype);\n        return buf;\n      }\n      function Buffer2(arg, encodingOrOffset, length) {\n        if (typeof arg === \"number\") {\n          if (typeof encodingOrOffset === \"string\") {\n            throw new TypeError(\n              'The \"string\" argument must be of type string. Received type number'\n            );\n          }\n          return allocUnsafe(arg);\n        }\n        return from(arg, encodingOrOffset, length);\n      }\n      Buffer2.poolSize = 8192;\n      function from(value, encodingOrOffset, length) {\n        if (typeof value === \"string\") {\n          return fromString(value, encodingOrOffset);\n        }\n        if (GlobalArrayBuffer.isView(value)) {\n          return fromArrayView(value);\n        }\n        if (value == null) {\n          throw new TypeError(\n            \"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value\n          );\n        }\n        if (isInstance(value, GlobalArrayBuffer) || value && isInstance(value.buffer, GlobalArrayBuffer)) {\n          return fromArrayBuffer(value, encodingOrOffset, length);\n        }\n        if (typeof GlobalSharedArrayBuffer !== \"undefined\" && (isInstance(value, GlobalSharedArrayBuffer) || value && isInstance(value.buffer, GlobalSharedArrayBuffer))) {\n          return fromArrayBuffer(value, encodingOrOffset, length);\n        }\n        if (typeof value === \"number\") {\n          throw new TypeError(\n            'The \"value\" argument must not be of type number. Received type number'\n          );\n        }\n        const valueOf = value.valueOf && value.valueOf();\n        if (valueOf != null && valueOf !== value) {\n          return Buffer2.from(valueOf, encodingOrOffset, length);\n        }\n        const b = fromObject(value);\n        if (b)\n          return b;\n        if (typeof Symbol !== \"undefined\" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === \"function\") {\n          return Buffer2.from(value[Symbol.toPrimitive](\"string\"), encodingOrOffset, length);\n        }\n        throw new TypeError(\n          \"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value\n        );\n      }\n      Buffer2.from = function(value, encodingOrOffset, length) {\n        return from(value, encodingOrOffset, length);\n      };\n      Object.setPrototypeOf(Buffer2.prototype, GlobalUint8Array.prototype);\n      Object.setPrototypeOf(Buffer2, GlobalUint8Array);\n      function assertSize(size) {\n        if (typeof size !== \"number\") {\n          throw new TypeError('\"size\" argument must be of type number');\n        } else if (size < 0) {\n          throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"');\n        }\n      }\n      function alloc(size, fill, encoding) {\n        assertSize(size);\n        if (size <= 0) {\n          return createBuffer(size);\n        }\n        if (fill !== void 0) {\n          return typeof encoding === \"string\" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);\n        }\n        return createBuffer(size);\n      }\n      Buffer2.alloc = function(size, fill, encoding) {\n        return alloc(size, fill, encoding);\n      };\n      function allocUnsafe(size) {\n        assertSize(size);\n        return createBuffer(size < 0 ? 0 : checked(size) | 0);\n      }\n      Buffer2.allocUnsafe = function(size) {\n        return allocUnsafe(size);\n      };\n      Buffer2.allocUnsafeSlow = function(size) {\n        return allocUnsafe(size);\n      };\n      function fromString(string, encoding) {\n        if (typeof encoding !== \"string\" || encoding === \"\") {\n          encoding = \"utf8\";\n        }\n        if (!Buffer2.isEncoding(encoding)) {\n          throw new TypeError(\"Unknown encoding: \" + encoding);\n        }\n        const length = byteLength(string, encoding) | 0;\n        let buf = createBuffer(length);\n        const actual = buf.write(string, encoding);\n        if (actual !== length) {\n          buf = buf.slice(0, actual);\n        }\n        return buf;\n      }\n      function fromArrayLike(array) {\n        const length = array.length < 0 ? 0 : checked(array.length) | 0;\n        const buf = createBuffer(length);\n        for (let i = 0; i < length; i += 1) {\n          buf[i] = array[i] & 255;\n        }\n        return buf;\n      }\n      function fromArrayView(arrayView) {\n        if (isInstance(arrayView, GlobalUint8Array)) {\n          const copy = new GlobalUint8Array(arrayView);\n          return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);\n        }\n        return fromArrayLike(arrayView);\n      }\n      function fromArrayBuffer(array, byteOffset, length) {\n        if (byteOffset < 0 || array.byteLength < byteOffset) {\n          throw new RangeError('\"offset\" is outside of buffer bounds');\n        }\n        if (array.byteLength < byteOffset + (length || 0)) {\n          throw new RangeError('\"length\" is outside of buffer bounds');\n        }\n        let buf;\n        if (byteOffset === void 0 && length === void 0) {\n          buf = new GlobalUint8Array(array);\n        } else if (length === void 0) {\n          buf = new GlobalUint8Array(array, byteOffset);\n        } else {\n          buf = new GlobalUint8Array(array, byteOffset, length);\n        }\n        Object.setPrototypeOf(buf, Buffer2.prototype);\n        return buf;\n      }\n      function fromObject(obj) {\n        if (Buffer2.isBuffer(obj)) {\n          const len = checked(obj.length) | 0;\n          const buf = createBuffer(len);\n          if (buf.length === 0) {\n            return buf;\n          }\n          obj.copy(buf, 0, 0, len);\n          return buf;\n        }\n        if (obj.length !== void 0) {\n          if (typeof obj.length !== \"number\" || numberIsNaN(obj.length)) {\n            return createBuffer(0);\n          }\n          return fromArrayLike(obj);\n        }\n        if (obj.type === \"Buffer\" && Array.isArray(obj.data)) {\n          return fromArrayLike(obj.data);\n        }\n      }\n      function checked(length) {\n        if (length >= K_MAX_LENGTH) {\n          throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\" + K_MAX_LENGTH.toString(16) + \" bytes\");\n        }\n        return length | 0;\n      }\n      function SlowBuffer(length) {\n        if (+length != length) {\n          length = 0;\n        }\n        return Buffer2.alloc(+length);\n      }\n      Buffer2.isBuffer = function isBuffer(b) {\n        return b != null && b._isBuffer === true && b !== Buffer2.prototype;\n      };\n      Buffer2.compare = function compare(a, b) {\n        if (isInstance(a, GlobalUint8Array))\n          a = Buffer2.from(a, a.offset, a.byteLength);\n        if (isInstance(b, GlobalUint8Array))\n          b = Buffer2.from(b, b.offset, b.byteLength);\n        if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {\n          throw new TypeError(\n            'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n          );\n        }\n        if (a === b)\n          return 0;\n        let x = a.length;\n        let y = b.length;\n        for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n          if (a[i] !== b[i]) {\n            x = a[i];\n            y = b[i];\n            break;\n          }\n        }\n        if (x < y)\n          return -1;\n        if (y < x)\n          return 1;\n        return 0;\n      };\n      Buffer2.isEncoding = function isEncoding(encoding) {\n        switch (String(encoding).toLowerCase()) {\n          case \"hex\":\n          case \"utf8\":\n          case \"utf-8\":\n          case \"ascii\":\n          case \"latin1\":\n          case \"binary\":\n          case \"base64\":\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return true;\n          default:\n            return false;\n        }\n      };\n      Buffer2.concat = function concat(list, length) {\n        if (!Array.isArray(list)) {\n          throw new TypeError('\"list\" argument must be an Array of Buffers');\n        }\n        if (list.length === 0) {\n          return Buffer2.alloc(0);\n        }\n        let i;\n        if (length === void 0) {\n          length = 0;\n          for (i = 0; i < list.length; ++i) {\n            length += list[i].length;\n          }\n        }\n        const buffer = Buffer2.allocUnsafe(length);\n        let pos = 0;\n        for (i = 0; i < list.length; ++i) {\n          let buf = list[i];\n          if (isInstance(buf, GlobalUint8Array)) {\n            if (pos + buf.length > buffer.length) {\n              if (!Buffer2.isBuffer(buf))\n                buf = Buffer2.from(buf);\n              buf.copy(buffer, pos);\n            } else {\n              GlobalUint8Array.prototype.set.call(\n                buffer,\n                buf,\n                pos\n              );\n            }\n          } else if (!Buffer2.isBuffer(buf)) {\n            throw new TypeError('\"list\" argument must be an Array of Buffers');\n          } else {\n            buf.copy(buffer, pos);\n          }\n          pos += buf.length;\n        }\n        return buffer;\n      };\n      function byteLength(string, encoding) {\n        if (Buffer2.isBuffer(string)) {\n          return string.length;\n        }\n        if (GlobalArrayBuffer.isView(string) || isInstance(string, GlobalArrayBuffer)) {\n          return string.byteLength;\n        }\n        if (typeof string !== \"string\") {\n          throw new TypeError(\n            'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string\n          );\n        }\n        const len = string.length;\n        const mustMatch = arguments.length > 2 && arguments[2] === true;\n        if (!mustMatch && len === 0)\n          return 0;\n        let loweredCase = false;\n        for (; ; ) {\n          switch (encoding) {\n            case \"ascii\":\n            case \"latin1\":\n            case \"binary\":\n              return len;\n            case \"utf8\":\n            case \"utf-8\":\n              return utf8ToBytes(string).length;\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n              return len * 2;\n            case \"hex\":\n              return len >>> 1;\n            case \"base64\":\n              return base64ToBytes(string).length;\n            default:\n              if (loweredCase) {\n                return mustMatch ? -1 : utf8ToBytes(string).length;\n              }\n              encoding = (\"\" + encoding).toLowerCase();\n              loweredCase = true;\n          }\n        }\n      }\n      Buffer2.byteLength = byteLength;\n      function slowToString(encoding, start, end) {\n        let loweredCase = false;\n        if (start === void 0 || start < 0) {\n          start = 0;\n        }\n        if (start > this.length) {\n          return \"\";\n        }\n        if (end === void 0 || end > this.length) {\n          end = this.length;\n        }\n        if (end <= 0) {\n          return \"\";\n        }\n        end >>>= 0;\n        start >>>= 0;\n        if (end <= start) {\n          return \"\";\n        }\n        if (!encoding)\n          encoding = \"utf8\";\n        while (true) {\n          switch (encoding) {\n            case \"hex\":\n              return hexSlice(this, start, end);\n            case \"utf8\":\n            case \"utf-8\":\n              return utf8Slice(this, start, end);\n            case \"ascii\":\n              return asciiSlice(this, start, end);\n            case \"latin1\":\n            case \"binary\":\n              return latin1Slice(this, start, end);\n            case \"base64\":\n              return base64Slice(this, start, end);\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n              return utf16leSlice(this, start, end);\n            default:\n              if (loweredCase)\n                throw new TypeError(\"Unknown encoding: \" + encoding);\n              encoding = (encoding + \"\").toLowerCase();\n              loweredCase = true;\n          }\n        }\n      }\n      Buffer2.prototype._isBuffer = true;\n      function swap(b, n, m) {\n        const i = b[n];\n        b[n] = b[m];\n        b[m] = i;\n      }\n      Buffer2.prototype.swap16 = function swap16() {\n        const len = this.length;\n        if (len % 2 !== 0) {\n          throw new RangeError(\"Buffer size must be a multiple of 16-bits\");\n        }\n        for (let i = 0; i < len; i += 2) {\n          swap(this, i, i + 1);\n        }\n        return this;\n      };\n      Buffer2.prototype.swap32 = function swap32() {\n        const len = this.length;\n        if (len % 4 !== 0) {\n          throw new RangeError(\"Buffer size must be a multiple of 32-bits\");\n        }\n        for (let i = 0; i < len; i += 4) {\n          swap(this, i, i + 3);\n          swap(this, i + 1, i + 2);\n        }\n        return this;\n      };\n      Buffer2.prototype.swap64 = function swap64() {\n        const len = this.length;\n        if (len % 8 !== 0) {\n          throw new RangeError(\"Buffer size must be a multiple of 64-bits\");\n        }\n        for (let i = 0; i < len; i += 8) {\n          swap(this, i, i + 7);\n          swap(this, i + 1, i + 6);\n          swap(this, i + 2, i + 5);\n          swap(this, i + 3, i + 4);\n        }\n        return this;\n      };\n      Buffer2.prototype.toString = function toString() {\n        const length = this.length;\n        if (length === 0)\n          return \"\";\n        if (arguments.length === 0)\n          return utf8Slice(this, 0, length);\n        return slowToString.apply(this, arguments);\n      };\n      Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;\n      Buffer2.prototype.equals = function equals(b) {\n        if (!Buffer2.isBuffer(b))\n          throw new TypeError(\"Argument must be a Buffer\");\n        if (this === b)\n          return true;\n        return Buffer2.compare(this, b) === 0;\n      };\n      Buffer2.prototype.inspect = function inspect() {\n        let str = \"\";\n        const max = exports.INSPECT_MAX_BYTES;\n        str = this.toString(\"hex\", 0, max).replace(/(.{2})/g, \"$1 \").trim();\n        if (this.length > max)\n          str += \" ... \";\n        return \"<Buffer \" + str + \">\";\n      };\n      if (customInspectSymbol) {\n        Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;\n      }\n      Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n        if (isInstance(target, GlobalUint8Array)) {\n          target = Buffer2.from(target, target.offset, target.byteLength);\n        }\n        if (!Buffer2.isBuffer(target)) {\n          throw new TypeError(\n            'The \"target\" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target\n          );\n        }\n        if (start === void 0) {\n          start = 0;\n        }\n        if (end === void 0) {\n          end = target ? target.length : 0;\n        }\n        if (thisStart === void 0) {\n          thisStart = 0;\n        }\n        if (thisEnd === void 0) {\n          thisEnd = this.length;\n        }\n        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n          throw new RangeError(\"out of range index\");\n        }\n        if (thisStart >= thisEnd && start >= end) {\n          return 0;\n        }\n        if (thisStart >= thisEnd) {\n          return -1;\n        }\n        if (start >= end) {\n          return 1;\n        }\n        start >>>= 0;\n        end >>>= 0;\n        thisStart >>>= 0;\n        thisEnd >>>= 0;\n        if (this === target)\n          return 0;\n        let x = thisEnd - thisStart;\n        let y = end - start;\n        const len = Math.min(x, y);\n        const thisCopy = this.slice(thisStart, thisEnd);\n        const targetCopy = target.slice(start, end);\n        for (let i = 0; i < len; ++i) {\n          if (thisCopy[i] !== targetCopy[i]) {\n            x = thisCopy[i];\n            y = targetCopy[i];\n            break;\n          }\n        }\n        if (x < y)\n          return -1;\n        if (y < x)\n          return 1;\n        return 0;\n      };\n      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n        if (buffer.length === 0)\n          return -1;\n        if (typeof byteOffset === \"string\") {\n          encoding = byteOffset;\n          byteOffset = 0;\n        } else if (byteOffset > 2147483647) {\n          byteOffset = 2147483647;\n        } else if (byteOffset < -2147483648) {\n          byteOffset = -2147483648;\n        }\n        byteOffset = +byteOffset;\n        if (numberIsNaN(byteOffset)) {\n          byteOffset = dir ? 0 : buffer.length - 1;\n        }\n        if (byteOffset < 0)\n          byteOffset = buffer.length + byteOffset;\n        if (byteOffset >= buffer.length) {\n          if (dir)\n            return -1;\n          else\n            byteOffset = buffer.length - 1;\n        } else if (byteOffset < 0) {\n          if (dir)\n            byteOffset = 0;\n          else\n            return -1;\n        }\n        if (typeof val === \"string\") {\n          val = Buffer2.from(val, encoding);\n        }\n        if (Buffer2.isBuffer(val)) {\n          if (val.length === 0) {\n            return -1;\n          }\n          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n        } else if (typeof val === \"number\") {\n          val = val & 255;\n          if (typeof GlobalUint8Array.prototype.indexOf === \"function\") {\n            if (dir) {\n              return GlobalUint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n            } else {\n              return GlobalUint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n            }\n          }\n          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);\n        }\n        throw new TypeError(\"val must be string, number or Buffer\");\n      }\n      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n        let indexSize = 1;\n        let arrLength = arr.length;\n        let valLength = val.length;\n        if (encoding !== void 0) {\n          encoding = String(encoding).toLowerCase();\n          if (encoding === \"ucs2\" || encoding === \"ucs-2\" || encoding === \"utf16le\" || encoding === \"utf-16le\") {\n            if (arr.length < 2 || val.length < 2) {\n              return -1;\n            }\n            indexSize = 2;\n            arrLength /= 2;\n            valLength /= 2;\n            byteOffset /= 2;\n          }\n        }\n        function read(buf, i2) {\n          if (indexSize === 1) {\n            return buf[i2];\n          } else {\n            return buf.readUInt16BE(i2 * indexSize);\n          }\n        }\n        let i;\n        if (dir) {\n          let foundIndex = -1;\n          for (i = byteOffset; i < arrLength; i++) {\n            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n              if (foundIndex === -1)\n                foundIndex = i;\n              if (i - foundIndex + 1 === valLength)\n                return foundIndex * indexSize;\n            } else {\n              if (foundIndex !== -1)\n                i -= i - foundIndex;\n              foundIndex = -1;\n            }\n          }\n        } else {\n          if (byteOffset + valLength > arrLength)\n            byteOffset = arrLength - valLength;\n          for (i = byteOffset; i >= 0; i--) {\n            let found = true;\n            for (let j = 0; j < valLength; j++) {\n              if (read(arr, i + j) !== read(val, j)) {\n                found = false;\n                break;\n              }\n            }\n            if (found)\n              return i;\n          }\n        }\n        return -1;\n      }\n      Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {\n        return this.indexOf(val, byteOffset, encoding) !== -1;\n      };\n      Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n      };\n      Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n      };\n      function hexWrite(buf, string, offset, length) {\n        offset = Number(offset) || 0;\n        const remaining = buf.length - offset;\n        if (!length) {\n          length = remaining;\n        } else {\n          length = Number(length);\n          if (length > remaining) {\n            length = remaining;\n          }\n        }\n        const strLen = string.length;\n        if (length > strLen / 2) {\n          length = strLen / 2;\n        }\n        let i;\n        for (i = 0; i < length; ++i) {\n          const parsed = parseInt(string.substr(i * 2, 2), 16);\n          if (numberIsNaN(parsed))\n            return i;\n          buf[offset + i] = parsed;\n        }\n        return i;\n      }\n      function utf8Write(buf, string, offset, length) {\n        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n      }\n      function asciiWrite(buf, string, offset, length) {\n        return blitBuffer(asciiToBytes(string), buf, offset, length);\n      }\n      function base64Write(buf, string, offset, length) {\n        return blitBuffer(base64ToBytes(string), buf, offset, length);\n      }\n      function ucs2Write(buf, string, offset, length) {\n        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n      }\n      Buffer2.prototype.write = function write(string, offset, length, encoding) {\n        if (offset === void 0) {\n          encoding = \"utf8\";\n          length = this.length;\n          offset = 0;\n        } else if (length === void 0 && typeof offset === \"string\") {\n          encoding = offset;\n          length = this.length;\n          offset = 0;\n        } else if (isFinite(offset)) {\n          offset = offset >>> 0;\n          if (isFinite(length)) {\n            length = length >>> 0;\n            if (encoding === void 0)\n              encoding = \"utf8\";\n          } else {\n            encoding = length;\n            length = void 0;\n          }\n        } else {\n          throw new Error(\n            \"Buffer.write(string, encoding, offset[, length]) is no longer supported\"\n          );\n        }\n        const remaining = this.length - offset;\n        if (length === void 0 || length > remaining)\n          length = remaining;\n        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n          throw new RangeError(\"Attempt to write outside buffer bounds\");\n        }\n        if (!encoding)\n          encoding = \"utf8\";\n        let loweredCase = false;\n        for (; ; ) {\n          switch (encoding) {\n            case \"hex\":\n              return hexWrite(this, string, offset, length);\n            case \"utf8\":\n            case \"utf-8\":\n              return utf8Write(this, string, offset, length);\n            case \"ascii\":\n            case \"latin1\":\n            case \"binary\":\n              return asciiWrite(this, string, offset, length);\n            case \"base64\":\n              return base64Write(this, string, offset, length);\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n              return ucs2Write(this, string, offset, length);\n            default:\n              if (loweredCase)\n                throw new TypeError(\"Unknown encoding: \" + encoding);\n              encoding = (\"\" + encoding).toLowerCase();\n              loweredCase = true;\n          }\n        }\n      };\n      Buffer2.prototype.toJSON = function toJSON() {\n        return {\n          type: \"Buffer\",\n          data: Array.prototype.slice.call(this._arr || this, 0)\n        };\n      };\n      function base64Slice(buf, start, end) {\n        if (start === 0 && end === buf.length) {\n          return base64.fromByteArray(buf);\n        } else {\n          return base64.fromByteArray(buf.slice(start, end));\n        }\n      }\n      function utf8Slice(buf, start, end) {\n        end = Math.min(buf.length, end);\n        const res = [];\n        let i = start;\n        while (i < end) {\n          const firstByte = buf[i];\n          let codePoint = null;\n          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;\n          if (i + bytesPerSequence <= end) {\n            let secondByte, thirdByte, fourthByte, tempCodePoint;\n            switch (bytesPerSequence) {\n              case 1:\n                if (firstByte < 128) {\n                  codePoint = firstByte;\n                }\n                break;\n              case 2:\n                secondByte = buf[i + 1];\n                if ((secondByte & 192) === 128) {\n                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;\n                  if (tempCodePoint > 127) {\n                    codePoint = tempCodePoint;\n                  }\n                }\n                break;\n              case 3:\n                secondByte = buf[i + 1];\n                thirdByte = buf[i + 2];\n                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {\n                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;\n                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {\n                    codePoint = tempCodePoint;\n                  }\n                }\n                break;\n              case 4:\n                secondByte = buf[i + 1];\n                thirdByte = buf[i + 2];\n                fourthByte = buf[i + 3];\n                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {\n                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;\n                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {\n                    codePoint = tempCodePoint;\n                  }\n                }\n            }\n          }\n          if (codePoint === null) {\n            codePoint = 65533;\n            bytesPerSequence = 1;\n          } else if (codePoint > 65535) {\n            codePoint -= 65536;\n            res.push(codePoint >>> 10 & 1023 | 55296);\n            codePoint = 56320 | codePoint & 1023;\n          }\n          res.push(codePoint);\n          i += bytesPerSequence;\n        }\n        return decodeCodePointsArray(res);\n      }\n      var MAX_ARGUMENTS_LENGTH = 4096;\n      function decodeCodePointsArray(codePoints) {\n        const len = codePoints.length;\n        if (len <= MAX_ARGUMENTS_LENGTH) {\n          return String.fromCharCode.apply(String, codePoints);\n        }\n        let res = \"\";\n        let i = 0;\n        while (i < len) {\n          res += String.fromCharCode.apply(\n            String,\n            codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n          );\n        }\n        return res;\n      }\n      function asciiSlice(buf, start, end) {\n        let ret = \"\";\n        end = Math.min(buf.length, end);\n        for (let i = start; i < end; ++i) {\n          ret += String.fromCharCode(buf[i] & 127);\n        }\n        return ret;\n      }\n      function latin1Slice(buf, start, end) {\n        let ret = \"\";\n        end = Math.min(buf.length, end);\n        for (let i = start; i < end; ++i) {\n          ret += String.fromCharCode(buf[i]);\n        }\n        return ret;\n      }\n      function hexSlice(buf, start, end) {\n        const len = buf.length;\n        if (!start || start < 0)\n          start = 0;\n        if (!end || end < 0 || end > len)\n          end = len;\n        let out = \"\";\n        for (let i = start; i < end; ++i) {\n          out += hexSliceLookupTable[buf[i]];\n        }\n        return out;\n      }\n      function utf16leSlice(buf, start, end) {\n        const bytes = buf.slice(start, end);\n        let res = \"\";\n        for (let i = 0; i < bytes.length - 1; i += 2) {\n          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n        }\n        return res;\n      }\n      Buffer2.prototype.slice = function slice(start, end) {\n        const len = this.length;\n        start = ~~start;\n        end = end === void 0 ? len : ~~end;\n        if (start < 0) {\n          start += len;\n          if (start < 0)\n            start = 0;\n        } else if (start > len) {\n          start = len;\n        }\n        if (end < 0) {\n          end += len;\n          if (end < 0)\n            end = 0;\n        } else if (end > len) {\n          end = len;\n        }\n        if (end < start)\n          end = start;\n        const newBuf = this.subarray(start, end);\n        Object.setPrototypeOf(newBuf, Buffer2.prototype);\n        return newBuf;\n      };\n      function checkOffset(offset, ext, length) {\n        if (offset % 1 !== 0 || offset < 0)\n          throw new RangeError(\"offset is not uint\");\n        if (offset + ext > length)\n          throw new RangeError(\"Trying to access beyond buffer length\");\n      }\n      Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert)\n          checkOffset(offset, byteLength2, this.length);\n        let val = this[offset];\n        let mul = 1;\n        let i = 0;\n        while (++i < byteLength2 && (mul *= 256)) {\n          val += this[offset + i] * mul;\n        }\n        return val;\n      };\n      Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert) {\n          checkOffset(offset, byteLength2, this.length);\n        }\n        let val = this[offset + --byteLength2];\n        let mul = 1;\n        while (byteLength2 > 0 && (mul *= 256)) {\n          val += this[offset + --byteLength2] * mul;\n        }\n        return val;\n      };\n      Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 1, this.length);\n        return this[offset];\n      };\n      Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 2, this.length);\n        return this[offset] | this[offset + 1] << 8;\n      };\n      Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 2, this.length);\n        return this[offset] << 8 | this[offset + 1];\n      };\n      Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;\n      };\n      Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n      };\n      Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {\n        offset = offset >>> 0;\n        validateNumber(offset, \"offset\");\n        const first = this[offset];\n        const last = this[offset + 7];\n        if (first === void 0 || last === void 0) {\n          boundsError(offset, this.length - 8);\n        }\n        const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;\n        const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;\n        return BigInt(lo) + (BigInt(hi) << BigInt(32));\n      });\n      Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {\n        offset = offset >>> 0;\n        validateNumber(offset, \"offset\");\n        const first = this[offset];\n        const last = this[offset + 7];\n        if (first === void 0 || last === void 0) {\n          boundsError(offset, this.length - 8);\n        }\n        const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];\n        const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;\n        return (BigInt(hi) << BigInt(32)) + BigInt(lo);\n      });\n      Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert)\n          checkOffset(offset, byteLength2, this.length);\n        let val = this[offset];\n        let mul = 1;\n        let i = 0;\n        while (++i < byteLength2 && (mul *= 256)) {\n          val += this[offset + i] * mul;\n        }\n        mul *= 128;\n        if (val >= mul)\n          val -= Math.pow(2, 8 * byteLength2);\n        return val;\n      };\n      Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert)\n          checkOffset(offset, byteLength2, this.length);\n        let i = byteLength2;\n        let mul = 1;\n        let val = this[offset + --i];\n        while (i > 0 && (mul *= 256)) {\n          val += this[offset + --i] * mul;\n        }\n        mul *= 128;\n        if (val >= mul)\n          val -= Math.pow(2, 8 * byteLength2);\n        return val;\n      };\n      Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 1, this.length);\n        if (!(this[offset] & 128))\n          return this[offset];\n        return (255 - this[offset] + 1) * -1;\n      };\n      Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 2, this.length);\n        const val = this[offset] | this[offset + 1] << 8;\n        return val & 32768 ? val | 4294901760 : val;\n      };\n      Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 2, this.length);\n        const val = this[offset + 1] | this[offset] << 8;\n        return val & 32768 ? val | 4294901760 : val;\n      };\n      Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n      };\n      Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n      };\n      Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {\n        offset = offset >>> 0;\n        validateNumber(offset, \"offset\");\n        const first = this[offset];\n        const last = this[offset + 7];\n        if (first === void 0 || last === void 0) {\n          boundsError(offset, this.length - 8);\n        }\n        const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);\n        return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);\n      });\n      Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {\n        offset = offset >>> 0;\n        validateNumber(offset, \"offset\");\n        const first = this[offset];\n        const last = this[offset + 7];\n        if (first === void 0 || last === void 0) {\n          boundsError(offset, this.length - 8);\n        }\n        const val = (first << 24) + // Overflow\n        this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];\n        return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);\n      });\n      Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return ieee754.read(this, offset, true, 23, 4);\n      };\n      Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return ieee754.read(this, offset, false, 23, 4);\n      };\n      Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 8, this.length);\n        return ieee754.read(this, offset, true, 52, 8);\n      };\n      Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 8, this.length);\n        return ieee754.read(this, offset, false, 52, 8);\n      };\n      function checkInt(buf, value, offset, ext, max, min) {\n        if (!Buffer2.isBuffer(buf))\n          throw new TypeError('\"buffer\" argument must be a Buffer instance');\n        if (value > max || value < min)\n          throw new RangeError('\"value\" argument is out of bounds');\n        if (offset + ext > buf.length)\n          throw new RangeError(\"Index out of range\");\n      }\n      Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert) {\n          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;\n          checkInt(this, value, offset, byteLength2, maxBytes, 0);\n        }\n        let mul = 1;\n        let i = 0;\n        this[offset] = value & 255;\n        while (++i < byteLength2 && (mul *= 256)) {\n          this[offset + i] = value / mul & 255;\n        }\n        return offset + byteLength2;\n      };\n      Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert) {\n          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;\n          checkInt(this, value, offset, byteLength2, maxBytes, 0);\n        }\n        let i = byteLength2 - 1;\n        let mul = 1;\n        this[offset + i] = value & 255;\n        while (--i >= 0 && (mul *= 256)) {\n          this[offset + i] = value / mul & 255;\n        }\n        return offset + byteLength2;\n      };\n      Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 1, 255, 0);\n        this[offset] = value & 255;\n        return offset + 1;\n      };\n      Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 2, 65535, 0);\n        this[offset] = value & 255;\n        this[offset + 1] = value >>> 8;\n        return offset + 2;\n      };\n      Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 2, 65535, 0);\n        this[offset] = value >>> 8;\n        this[offset + 1] = value & 255;\n        return offset + 2;\n      };\n      Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 4, 4294967295, 0);\n        this[offset + 3] = value >>> 24;\n        this[offset + 2] = value >>> 16;\n        this[offset + 1] = value >>> 8;\n        this[offset] = value & 255;\n        return offset + 4;\n      };\n      Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 4, 4294967295, 0);\n        this[offset] = value >>> 24;\n        this[offset + 1] = value >>> 16;\n        this[offset + 2] = value >>> 8;\n        this[offset + 3] = value & 255;\n        return offset + 4;\n      };\n      function wrtBigUInt64LE(buf, value, offset, min, max) {\n        checkIntBI(value, min, max, buf, offset, 7);\n        let lo = Number(value & BigInt(4294967295));\n        buf[offset++] = lo;\n        lo = lo >> 8;\n        buf[offset++] = lo;\n        lo = lo >> 8;\n        buf[offset++] = lo;\n        lo = lo >> 8;\n        buf[offset++] = lo;\n        let hi = Number(value >> BigInt(32) & BigInt(4294967295));\n        buf[offset++] = hi;\n        hi = hi >> 8;\n        buf[offset++] = hi;\n        hi = hi >> 8;\n        buf[offset++] = hi;\n        hi = hi >> 8;\n        buf[offset++] = hi;\n        return offset;\n      }\n      function wrtBigUInt64BE(buf, value, offset, min, max) {\n        checkIntBI(value, min, max, buf, offset, 7);\n        let lo = Number(value & BigInt(4294967295));\n        buf[offset + 7] = lo;\n        lo = lo >> 8;\n        buf[offset + 6] = lo;\n        lo = lo >> 8;\n        buf[offset + 5] = lo;\n        lo = lo >> 8;\n        buf[offset + 4] = lo;\n        let hi = Number(value >> BigInt(32) & BigInt(4294967295));\n        buf[offset + 3] = hi;\n        hi = hi >> 8;\n        buf[offset + 2] = hi;\n        hi = hi >> 8;\n        buf[offset + 1] = hi;\n        hi = hi >> 8;\n        buf[offset] = hi;\n        return offset + 8;\n      }\n      Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {\n        return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n      });\n      Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {\n        return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n      });\n      Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          const limit = Math.pow(2, 8 * byteLength2 - 1);\n          checkInt(this, value, offset, byteLength2, limit - 1, -limit);\n        }\n        let i = 0;\n        let mul = 1;\n        let sub = 0;\n        this[offset] = value & 255;\n        while (++i < byteLength2 && (mul *= 256)) {\n          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n            sub = 1;\n          }\n          this[offset + i] = (value / mul >> 0) - sub & 255;\n        }\n        return offset + byteLength2;\n      };\n      Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          const limit = Math.pow(2, 8 * byteLength2 - 1);\n          checkInt(this, value, offset, byteLength2, limit - 1, -limit);\n        }\n        let i = byteLength2 - 1;\n        let mul = 1;\n        let sub = 0;\n        this[offset + i] = value & 255;\n        while (--i >= 0 && (mul *= 256)) {\n          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n            sub = 1;\n          }\n          this[offset + i] = (value / mul >> 0) - sub & 255;\n        }\n        return offset + byteLength2;\n      };\n      Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 1, 127, -128);\n        if (value < 0)\n          value = 255 + value + 1;\n        this[offset] = value & 255;\n        return offset + 1;\n      };\n      Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 2, 32767, -32768);\n        this[offset] = value & 255;\n        this[offset + 1] = value >>> 8;\n        return offset + 2;\n      };\n      Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 2, 32767, -32768);\n        this[offset] = value >>> 8;\n        this[offset + 1] = value & 255;\n        return offset + 2;\n      };\n      Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 4, 2147483647, -2147483648);\n        this[offset] = value & 255;\n        this[offset + 1] = value >>> 8;\n        this[offset + 2] = value >>> 16;\n        this[offset + 3] = value >>> 24;\n        return offset + 4;\n      };\n      Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 4, 2147483647, -2147483648);\n        if (value < 0)\n          value = 4294967295 + value + 1;\n        this[offset] = value >>> 24;\n        this[offset + 1] = value >>> 16;\n        this[offset + 2] = value >>> 8;\n        this[offset + 3] = value & 255;\n        return offset + 4;\n      };\n      Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {\n        return wrtBigUInt64LE(this, value, offset, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n      });\n      Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {\n        return wrtBigUInt64BE(this, value, offset, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n      });\n      function checkIEEE754(buf, value, offset, ext, max, min) {\n        if (offset + ext > buf.length)\n          throw new RangeError(\"Index out of range\");\n        if (offset < 0)\n          throw new RangeError(\"Index out of range\");\n      }\n      function writeFloat(buf, value, offset, littleEndian, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);\n        }\n        ieee754.write(buf, value, offset, littleEndian, 23, 4);\n        return offset + 4;\n      }\n      Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n        return writeFloat(this, value, offset, true, noAssert);\n      };\n      Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n        return writeFloat(this, value, offset, false, noAssert);\n      };\n      function writeDouble(buf, value, offset, littleEndian, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);\n        }\n        ieee754.write(buf, value, offset, littleEndian, 52, 8);\n        return offset + 8;\n      }\n      Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n        return writeDouble(this, value, offset, true, noAssert);\n      };\n      Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n        return writeDouble(this, value, offset, false, noAssert);\n      };\n      Buffer2.prototype.copy = function copy(target, targetStart, start, end) {\n        if (!Buffer2.isBuffer(target))\n          throw new TypeError(\"argument should be a Buffer\");\n        if (!start)\n          start = 0;\n        if (!end && end !== 0)\n          end = this.length;\n        if (targetStart >= target.length)\n          targetStart = target.length;\n        if (!targetStart)\n          targetStart = 0;\n        if (end > 0 && end < start)\n          end = start;\n        if (end === start)\n          return 0;\n        if (target.length === 0 || this.length === 0)\n          return 0;\n        if (targetStart < 0) {\n          throw new RangeError(\"targetStart out of bounds\");\n        }\n        if (start < 0 || start >= this.length)\n          throw new RangeError(\"Index out of range\");\n        if (end < 0)\n          throw new RangeError(\"sourceEnd out of bounds\");\n        if (end > this.length)\n          end = this.length;\n        if (target.length - targetStart < end - start) {\n          end = target.length - targetStart + start;\n        }\n        const len = end - start;\n        if (this === target && typeof GlobalUint8Array.prototype.copyWithin === \"function\") {\n          this.copyWithin(targetStart, start, end);\n        } else {\n          GlobalUint8Array.prototype.set.call(\n            target,\n            this.subarray(start, end),\n            targetStart\n          );\n        }\n        return len;\n      };\n      Buffer2.prototype.fill = function fill(val, start, end, encoding) {\n        if (typeof val === \"string\") {\n          if (typeof start === \"string\") {\n            encoding = start;\n            start = 0;\n            end = this.length;\n          } else if (typeof end === \"string\") {\n            encoding = end;\n            end = this.length;\n          }\n          if (encoding !== void 0 && typeof encoding !== \"string\") {\n            throw new TypeError(\"encoding must be a string\");\n          }\n          if (typeof encoding === \"string\" && !Buffer2.isEncoding(encoding)) {\n            throw new TypeError(\"Unknown encoding: \" + encoding);\n          }\n          if (val.length === 1) {\n            const code = val.charCodeAt(0);\n            if (encoding === \"utf8\" && code < 128 || encoding === \"latin1\") {\n              val = code;\n            }\n          }\n        } else if (typeof val === \"number\") {\n          val = val & 255;\n        } else if (typeof val === \"boolean\") {\n          val = Number(val);\n        }\n        if (start < 0 || this.length < start || this.length < end) {\n          throw new RangeError(\"Out of range index\");\n        }\n        if (end <= start) {\n          return this;\n        }\n        start = start >>> 0;\n        end = end === void 0 ? this.length : end >>> 0;\n        if (!val)\n          val = 0;\n        let i;\n        if (typeof val === \"number\") {\n          for (i = start; i < end; ++i) {\n            this[i] = val;\n          }\n        } else {\n          const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);\n          const len = bytes.length;\n          if (len === 0) {\n            throw new TypeError('The value \"' + val + '\" is invalid for argument \"value\"');\n          }\n          for (i = 0; i < end - start; ++i) {\n            this[i + start] = bytes[i % len];\n          }\n        }\n        return this;\n      };\n      var errors = {};\n      function E(sym, getMessage, Base) {\n        errors[sym] = class NodeError extends Base {\n          constructor() {\n            super();\n            Object.defineProperty(this, \"message\", {\n              value: getMessage.apply(this, arguments),\n              writable: true,\n              configurable: true\n            });\n            this.name = `${this.name} [${sym}]`;\n            this.stack;\n            delete this.name;\n          }\n          get code() {\n            return sym;\n          }\n          set code(value) {\n            Object.defineProperty(this, \"code\", {\n              configurable: true,\n              enumerable: true,\n              value,\n              writable: true\n            });\n          }\n          toString() {\n            return `${this.name} [${sym}]: ${this.message}`;\n          }\n        };\n      }\n      E(\n        \"ERR_BUFFER_OUT_OF_BOUNDS\",\n        function(name) {\n          if (name) {\n            return `${name} is outside of buffer bounds`;\n          }\n          return \"Attempt to access memory outside buffer bounds\";\n        },\n        RangeError\n      );\n      E(\n        \"ERR_INVALID_ARG_TYPE\",\n        function(name, actual) {\n          return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`;\n        },\n        TypeError\n      );\n      E(\n        \"ERR_OUT_OF_RANGE\",\n        function(str, range, input) {\n          let msg = `The value of \"${str}\" is out of range.`;\n          let received = input;\n          if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n            received = addNumericalSeparator(String(input));\n          } else if (typeof input === \"bigint\") {\n            received = String(input);\n            if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n              received = addNumericalSeparator(received);\n            }\n            received += \"n\";\n          }\n          msg += ` It must be ${range}. Received ${received}`;\n          return msg;\n        },\n        RangeError\n      );\n      function addNumericalSeparator(val) {\n        let res = \"\";\n        let i = val.length;\n        const start = val[0] === \"-\" ? 1 : 0;\n        for (; i >= start + 4; i -= 3) {\n          res = `_${val.slice(i - 3, i)}${res}`;\n        }\n        return `${val.slice(0, i)}${res}`;\n      }\n      function checkBounds(buf, offset, byteLength2) {\n        validateNumber(offset, \"offset\");\n        if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {\n          boundsError(offset, buf.length - (byteLength2 + 1));\n        }\n      }\n      function checkIntBI(value, min, max, buf, offset, byteLength2) {\n        if (value > max || value < min) {\n          const n = typeof min === \"bigint\" ? \"n\" : \"\";\n          let range;\n          if (byteLength2 > 3) {\n            if (min === 0 || min === BigInt(0)) {\n              range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;\n            } else {\n              range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;\n            }\n          } else {\n            range = `>= ${min}${n} and <= ${max}${n}`;\n          }\n          throw new errors.ERR_OUT_OF_RANGE(\"value\", range, value);\n        }\n        checkBounds(buf, offset, byteLength2);\n      }\n      function validateNumber(value, name) {\n        if (typeof value !== \"number\") {\n          throw new errors.ERR_INVALID_ARG_TYPE(name, \"number\", value);\n        }\n      }\n      function boundsError(value, length, type) {\n        if (Math.floor(value) !== value) {\n          validateNumber(value, type);\n          throw new errors.ERR_OUT_OF_RANGE(type || \"offset\", \"an integer\", value);\n        }\n        if (length < 0) {\n          throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();\n        }\n        throw new errors.ERR_OUT_OF_RANGE(\n          type || \"offset\",\n          `>= ${type ? 1 : 0} and <= ${length}`,\n          value\n        );\n      }\n      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;\n      function base64clean(str) {\n        str = str.split(\"=\")[0];\n        str = str.trim().replace(INVALID_BASE64_RE, \"\");\n        if (str.length < 2)\n          return \"\";\n        while (str.length % 4 !== 0) {\n          str = str + \"=\";\n        }\n        return str;\n      }\n      function utf8ToBytes(string, units) {\n        units = units || Infinity;\n        let codePoint;\n        const length = string.length;\n        let leadSurrogate = null;\n        const bytes = [];\n        for (let i = 0; i < length; ++i) {\n          codePoint = string.charCodeAt(i);\n          if (codePoint > 55295 && codePoint < 57344) {\n            if (!leadSurrogate) {\n              if (codePoint > 56319) {\n                if ((units -= 3) > -1)\n                  bytes.push(239, 191, 189);\n                continue;\n              } else if (i + 1 === length) {\n                if ((units -= 3) > -1)\n                  bytes.push(239, 191, 189);\n                continue;\n              }\n              leadSurrogate = codePoint;\n              continue;\n            }\n            if (codePoint < 56320) {\n              if ((units -= 3) > -1)\n                bytes.push(239, 191, 189);\n              leadSurrogate = codePoint;\n              continue;\n            }\n            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;\n          } else if (leadSurrogate) {\n            if ((units -= 3) > -1)\n              bytes.push(239, 191, 189);\n          }\n          leadSurrogate = null;\n          if (codePoint < 128) {\n            if ((units -= 1) < 0)\n              break;\n            bytes.push(codePoint);\n          } else if (codePoint < 2048) {\n            if ((units -= 2) < 0)\n              break;\n            bytes.push(\n              codePoint >> 6 | 192,\n              codePoint & 63 | 128\n            );\n          } else if (codePoint < 65536) {\n            if ((units -= 3) < 0)\n              break;\n            bytes.push(\n              codePoint >> 12 | 224,\n              codePoint >> 6 & 63 | 128,\n              codePoint & 63 | 128\n            );\n          } else if (codePoint < 1114112) {\n            if ((units -= 4) < 0)\n              break;\n            bytes.push(\n              codePoint >> 18 | 240,\n              codePoint >> 12 & 63 | 128,\n              codePoint >> 6 & 63 | 128,\n              codePoint & 63 | 128\n            );\n          } else {\n            throw new Error(\"Invalid code point\");\n          }\n        }\n        return bytes;\n      }\n      function asciiToBytes(str) {\n        const byteArray = [];\n        for (let i = 0; i < str.length; ++i) {\n          byteArray.push(str.charCodeAt(i) & 255);\n        }\n        return byteArray;\n      }\n      function utf16leToBytes(str, units) {\n        let c, hi, lo;\n        const byteArray = [];\n        for (let i = 0; i < str.length; ++i) {\n          if ((units -= 2) < 0)\n            break;\n          c = str.charCodeAt(i);\n          hi = c >> 8;\n          lo = c % 256;\n          byteArray.push(lo);\n          byteArray.push(hi);\n        }\n        return byteArray;\n      }\n      function base64ToBytes(str) {\n        return base64.toByteArray(base64clean(str));\n      }\n      function blitBuffer(src, dst, offset, length) {\n        let i;\n        for (i = 0; i < length; ++i) {\n          if (i + offset >= dst.length || i >= src.length)\n            break;\n          dst[i + offset] = src[i];\n        }\n        return i;\n      }\n      function isInstance(obj, type) {\n        return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;\n      }\n      function numberIsNaN(obj) {\n        return obj !== obj;\n      }\n      var hexSliceLookupTable = function() {\n        const alphabet = \"0123456789abcdef\";\n        const table = new Array(256);\n        for (let i = 0; i < 16; ++i) {\n          const i16 = i * 16;\n          for (let j = 0; j < 16; ++j) {\n            table[i16 + j] = alphabet[i] + alphabet[j];\n          }\n        }\n        return table;\n      }();\n      function defineBigIntMethod(fn) {\n        return typeof BigInt === \"undefined\" ? BufferBigIntNotDefined : fn;\n      }\n      function BufferBigIntNotDefined() {\n        throw new Error(\"BigInt not supported\");\n      }\n    }\n  });\n\n  // node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js\n  var require_browser = __commonJS({\n    \"node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js\"(exports, module) {\n      init_dist();\n      var process = module.exports = {};\n      var cachedSetTimeout;\n      var cachedClearTimeout;\n      function defaultSetTimout() {\n        throw new Error(\"setTimeout has not been defined\");\n      }\n      function defaultClearTimeout() {\n        throw new Error(\"clearTimeout has not been defined\");\n      }\n      (function() {\n        try {\n          if (typeof setTimeout === \"function\") {\n            cachedSetTimeout = setTimeout;\n          } else {\n            cachedSetTimeout = defaultSetTimout;\n          }\n        } catch (e) {\n          cachedSetTimeout = defaultSetTimout;\n        }\n        try {\n          if (typeof clearTimeout === \"function\") {\n            cachedClearTimeout = clearTimeout;\n          } else {\n            cachedClearTimeout = defaultClearTimeout;\n          }\n        } catch (e) {\n          cachedClearTimeout = defaultClearTimeout;\n        }\n      })();\n      function runTimeout(fun) {\n        if (cachedSetTimeout === setTimeout) {\n          return setTimeout(fun, 0);\n        }\n        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n          cachedSetTimeout = setTimeout;\n          return setTimeout(fun, 0);\n        }\n        try {\n          return cachedSetTimeout(fun, 0);\n        } catch (e) {\n          try {\n            return cachedSetTimeout.call(null, fun, 0);\n          } catch (e2) {\n            return cachedSetTimeout.call(this, fun, 0);\n          }\n        }\n      }\n      function runClearTimeout(marker) {\n        if (cachedClearTimeout === clearTimeout) {\n          return clearTimeout(marker);\n        }\n        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n          cachedClearTimeout = clearTimeout;\n          return clearTimeout(marker);\n        }\n        try {\n          return cachedClearTimeout(marker);\n        } catch (e) {\n          try {\n            return cachedClearTimeout.call(null, marker);\n          } catch (e2) {\n            return cachedClearTimeout.call(this, marker);\n          }\n        }\n      }\n      var queue = [];\n      var draining = false;\n      var currentQueue;\n      var queueIndex = -1;\n      function cleanUpNextTick() {\n        if (!draining || !currentQueue) {\n          return;\n        }\n        draining = false;\n        if (currentQueue.length) {\n          queue = currentQueue.concat(queue);\n        } else {\n          queueIndex = -1;\n        }\n        if (queue.length) {\n          drainQueue();\n        }\n      }\n      function drainQueue() {\n        if (draining) {\n          return;\n        }\n        var timeout = runTimeout(cleanUpNextTick);\n        draining = true;\n        var len = queue.length;\n        while (len) {\n          currentQueue = queue;\n          queue = [];\n          while (++queueIndex < len) {\n            if (currentQueue) {\n              currentQueue[queueIndex].run();\n            }\n          }\n          queueIndex = -1;\n          len = queue.length;\n        }\n        currentQueue = null;\n        draining = false;\n        runClearTimeout(timeout);\n      }\n      process.nextTick = function(fun) {\n        var args = new Array(arguments.length - 1);\n        if (arguments.length > 1) {\n          for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n          }\n        }\n        queue.push(new Item(fun, args));\n        if (queue.length === 1 && !draining) {\n          runTimeout(drainQueue);\n        }\n      };\n      function Item(fun, array) {\n        this.fun = fun;\n        this.array = array;\n      }\n      Item.prototype.run = function() {\n        this.fun.apply(null, this.array);\n      };\n      process.title = \"browser\";\n      process.browser = true;\n      process.env = {};\n      process.argv = [];\n      process.version = \"\";\n      process.versions = {};\n      function noop() {\n      }\n      process.on = noop;\n      process.addListener = noop;\n      process.once = noop;\n      process.off = noop;\n      process.removeListener = noop;\n      process.removeAllListeners = noop;\n      process.emit = noop;\n      process.prependListener = noop;\n      process.prependOnceListener = noop;\n      process.listeners = function(name) {\n        return [];\n      };\n      process.binding = function(name) {\n        throw new Error(\"process.binding is not supported\");\n      };\n      process.cwd = function() {\n        return \"/\";\n      };\n      process.chdir = function(dir) {\n        throw new Error(\"process.chdir is not supported\");\n      };\n      process.umask = function() {\n        return 0;\n      };\n    }\n  });\n\n  // shims/dist/index.js\n  var import_buffer_polyfill, import_process, o;\n  var init_dist = __esm({\n    \"shims/dist/index.js\"() {\n      \"use strict\";\n      import_buffer_polyfill = __toESM(require_buffer(), 1);\n      import_process = __toESM(require_browser(), 1);\n      o = globalThis || void 0 || self;\n    }\n  });\n\n  // shims/banner/index.cjs\n  var require_banner = __commonJS({\n    \"shims/banner/index.cjs\"() {\n      init_dist();\n      globalThis.Buffer = globalThis.Buffer || import_buffer_polyfill.Buffer;\n      globalThis.global = globalThis.global || o;\n      globalThis.process = globalThis.process || import_process.default;\n    }\n  });\n  require_banner();\n})();\n/*! Bundled license information:\n\nieee754/index.js:\n  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)\n\nbuffer/index.js:\n  (*!\n   * The buffer module from node.js, for the browser.\n   *\n   * @author   Feross Aboukhadijeh <https://feross.org>\n   * @license  MIT\n   *)\n*/\n\nimport {\n  __export,\n  __toESM,\n  require_dist\n} from \"./chunk-4KAQPM64.js\";\n\n// node_modules/realm-web/dist/bundle.dom.es.js\nvar import_dist2 = __toESM(require_dist());\n\n// node_modules/realm-web/node_modules/bson/dist/bson.browser.esm.js\nvar bson_browser_esm_exports = {};\n__export(bson_browser_esm_exports, {\n  BSONError: () => BSONError,\n  BSONRegExp: () => BSONRegExp,\n  BSONSymbol: () => BSONSymbol,\n  BSONTypeError: () => BSONTypeError,\n  BSON_BINARY_SUBTYPE_BYTE_ARRAY: () => BSON_BINARY_SUBTYPE_BYTE_ARRAY,\n  BSON_BINARY_SUBTYPE_COLUMN: () => BSON_BINARY_SUBTYPE_COLUMN,\n  BSON_BINARY_SUBTYPE_DEFAULT: () => BSON_BINARY_SUBTYPE_DEFAULT,\n  BSON_BINARY_SUBTYPE_ENCRYPTED: () => BSON_BINARY_SUBTYPE_ENCRYPTED,\n  BSON_BINARY_SUBTYPE_FUNCTION: () => BSON_BINARY_SUBTYPE_FUNCTION,\n  BSON_BINARY_SUBTYPE_MD5: () => BSON_BINARY_SUBTYPE_MD5,\n  BSON_BINARY_SUBTYPE_USER_DEFINED: () => BSON_BINARY_SUBTYPE_USER_DEFINED,\n  BSON_BINARY_SUBTYPE_UUID: () => BSON_BINARY_SUBTYPE_UUID,\n  BSON_BINARY_SUBTYPE_UUID_NEW: () => BSON_BINARY_SUBTYPE_UUID_NEW,\n  BSON_DATA_ARRAY: () => BSON_DATA_ARRAY,\n  BSON_DATA_BINARY: () => BSON_DATA_BINARY,\n  BSON_DATA_BOOLEAN: () => BSON_DATA_BOOLEAN,\n  BSON_DATA_CODE: () => BSON_DATA_CODE,\n  BSON_DATA_CODE_W_SCOPE: () => BSON_DATA_CODE_W_SCOPE,\n  BSON_DATA_DATE: () => BSON_DATA_DATE,\n  BSON_DATA_DBPOINTER: () => BSON_DATA_DBPOINTER,\n  BSON_DATA_DECIMAL128: () => BSON_DATA_DECIMAL128,\n  BSON_DATA_INT: () => BSON_DATA_INT,\n  BSON_DATA_LONG: () => BSON_DATA_LONG,\n  BSON_DATA_MAX_KEY: () => BSON_DATA_MAX_KEY,\n  BSON_DATA_MIN_KEY: () => BSON_DATA_MIN_KEY,\n  BSON_DATA_NULL: () => BSON_DATA_NULL,\n  BSON_DATA_NUMBER: () => BSON_DATA_NUMBER,\n  BSON_DATA_OBJECT: () => BSON_DATA_OBJECT,\n  BSON_DATA_OID: () => BSON_DATA_OID,\n  BSON_DATA_REGEXP: () => BSON_DATA_REGEXP,\n  BSON_DATA_STRING: () => BSON_DATA_STRING,\n  BSON_DATA_SYMBOL: () => BSON_DATA_SYMBOL,\n  BSON_DATA_TIMESTAMP: () => BSON_DATA_TIMESTAMP,\n  BSON_DATA_UNDEFINED: () => BSON_DATA_UNDEFINED,\n  BSON_INT32_MAX: () => BSON_INT32_MAX$1,\n  BSON_INT32_MIN: () => BSON_INT32_MIN$1,\n  BSON_INT64_MAX: () => BSON_INT64_MAX$1,\n  BSON_INT64_MIN: () => BSON_INT64_MIN$1,\n  Binary: () => Binary,\n  Code: () => Code,\n  DBRef: () => DBRef,\n  Decimal128: () => Decimal128,\n  Double: () => Double,\n  EJSON: () => EJSON,\n  Int32: () => Int32,\n  Long: () => Long,\n  LongWithoutOverridesClass: () => LongWithoutOverridesClass,\n  Map: () => bsonMap,\n  MaxKey: () => MaxKey,\n  MinKey: () => MinKey,\n  ObjectID: () => ObjectId,\n  ObjectId: () => ObjectId,\n  Timestamp: () => Timestamp,\n  UUID: () => UUID,\n  calculateObjectSize: () => calculateObjectSize,\n  default: () => bson_browser_esm_default,\n  deserialize: () => deserialize,\n  deserializeStream: () => deserializeStream,\n  serialize: () => serialize,\n  serializeWithBufferAndIndex: () => serializeWithBufferAndIndex,\n  setInternalBufferSize: () => setInternalBufferSize\n});\nvar import_dist = __toESM(require_dist());\nfunction createCommonjsModule(fn, module) {\n  return module = { exports: {} }, fn(module, module.exports), module.exports;\n}\nvar byteLength_1 = byteLength;\nvar toByteArray_1 = toByteArray;\nvar fromByteArray_1 = fromByteArray;\nvar lookup = [];\nvar revLookup = [];\nvar Arr = typeof Uint8Array !== \"undefined\" ? Uint8Array : Array;\nvar code = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nfor (i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i];\n  revLookup[code.charCodeAt(i)] = i;\n}\nvar i;\nvar len;\nrevLookup[\"-\".charCodeAt(0)] = 62;\nrevLookup[\"_\".charCodeAt(0)] = 63;\nfunction getLens(b64) {\n  var len = b64.length;\n  if (len % 4 > 0) {\n    throw new Error(\"Invalid string. Length must be a multiple of 4\");\n  }\n  var validLen = b64.indexOf(\"=\");\n  if (validLen === -1)\n    validLen = len;\n  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;\n  return [validLen, placeHoldersLen];\n}\nfunction byteLength(b64) {\n  var lens = getLens(b64);\n  var validLen = lens[0];\n  var placeHoldersLen = lens[1];\n  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n}\nfunction _byteLength(b64, validLen, placeHoldersLen) {\n  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n}\nfunction toByteArray(b64) {\n  var tmp;\n  var lens = getLens(b64);\n  var validLen = lens[0];\n  var placeHoldersLen = lens[1];\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n  var curByte = 0;\n  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;\n  var i;\n  for (i = 0; i < len; i += 4) {\n    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n    arr[curByte++] = tmp >> 16 & 255;\n    arr[curByte++] = tmp >> 8 & 255;\n    arr[curByte++] = tmp & 255;\n  }\n  if (placeHoldersLen === 2) {\n    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n    arr[curByte++] = tmp & 255;\n  }\n  if (placeHoldersLen === 1) {\n    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n    arr[curByte++] = tmp >> 8 & 255;\n    arr[curByte++] = tmp & 255;\n  }\n  return arr;\n}\nfunction tripletToBase64(num) {\n  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];\n}\nfunction encodeChunk(uint8, start, end) {\n  var tmp;\n  var output = [];\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (uint8[i + 2] & 255);\n    output.push(tripletToBase64(tmp));\n  }\n  return output.join(\"\");\n}\nfunction fromByteArray(uint8) {\n  var tmp;\n  var len = uint8.length;\n  var extraBytes = len % 3;\n  var parts = [];\n  var maxChunkLength = 16383;\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));\n  }\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1];\n    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + \"==\");\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + \"=\");\n  }\n  return parts.join(\"\");\n}\nvar base64Js = {\n  byteLength: byteLength_1,\n  toByteArray: toByteArray_1,\n  fromByteArray: fromByteArray_1\n};\nvar read = function read2(buffer2, offset, isLE, mLen, nBytes) {\n  var e, m;\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var nBits = -7;\n  var i = isLE ? nBytes - 1 : 0;\n  var d = isLE ? -1 : 1;\n  var s = buffer2[offset + i];\n  i += d;\n  e = s & (1 << -nBits) - 1;\n  s >>= -nBits;\n  nBits += eLen;\n  for (; nBits > 0; e = e * 256 + buffer2[offset + i], i += d, nBits -= 8) {\n  }\n  m = e & (1 << -nBits) - 1;\n  e >>= -nBits;\n  nBits += mLen;\n  for (; nBits > 0; m = m * 256 + buffer2[offset + i], i += d, nBits -= 8) {\n  }\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : (s ? -1 : 1) * Infinity;\n  } else {\n    m = m + Math.pow(2, mLen);\n    e = e - eBias;\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n};\nvar write = function write2(buffer2, value, offset, isLE, mLen, nBytes) {\n  var e, m, c;\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n  var i = isLE ? 0 : nBytes - 1;\n  var d = isLE ? 1 : -1;\n  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n  value = Math.abs(value);\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0;\n    e = eMax;\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2);\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * Math.pow(2, 1 - eBias);\n    }\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n      e = 0;\n    }\n  }\n  for (; mLen >= 8; buffer2[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {\n  }\n  e = e << mLen | m;\n  eLen += mLen;\n  for (; eLen > 0; buffer2[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {\n  }\n  buffer2[offset + i - d] |= s * 128;\n};\nvar ieee754 = {\n  read,\n  write\n};\nvar buffer$1 = createCommonjsModule(function(module, exports) {\n  var customInspectSymbol = typeof Symbol === \"function\" && typeof Symbol[\"for\"] === \"function\" ? (\n    // eslint-disable-line dot-notation\n    Symbol[\"for\"](\"nodejs.util.inspect.custom\")\n  ) : null;\n  exports.Buffer = Buffer2;\n  exports.SlowBuffer = SlowBuffer;\n  exports.INSPECT_MAX_BYTES = 50;\n  var K_MAX_LENGTH = 2147483647;\n  exports.kMaxLength = K_MAX_LENGTH;\n  Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();\n  if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== \"undefined\" && typeof console.error === \"function\") {\n    console.error(\"This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.\");\n  }\n  function typedArraySupport() {\n    try {\n      var arr = new Uint8Array(1);\n      var proto = {\n        foo: function foo() {\n          return 42;\n        }\n      };\n      Object.setPrototypeOf(proto, Uint8Array.prototype);\n      Object.setPrototypeOf(arr, proto);\n      return arr.foo() === 42;\n    } catch (e) {\n      return false;\n    }\n  }\n  Object.defineProperty(Buffer2.prototype, \"parent\", {\n    enumerable: true,\n    get: function get() {\n      if (!Buffer2.isBuffer(this))\n        return void 0;\n      return this.buffer;\n    }\n  });\n  Object.defineProperty(Buffer2.prototype, \"offset\", {\n    enumerable: true,\n    get: function get() {\n      if (!Buffer2.isBuffer(this))\n        return void 0;\n      return this.byteOffset;\n    }\n  });\n  function createBuffer(length) {\n    if (length > K_MAX_LENGTH) {\n      throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"');\n    }\n    var buf = new Uint8Array(length);\n    Object.setPrototypeOf(buf, Buffer2.prototype);\n    return buf;\n  }\n  function Buffer2(arg, encodingOrOffset, length) {\n    if (typeof arg === \"number\") {\n      if (typeof encodingOrOffset === \"string\") {\n        throw new TypeError('The \"string\" argument must be of type string. Received type number');\n      }\n      return allocUnsafe(arg);\n    }\n    return from(arg, encodingOrOffset, length);\n  }\n  Buffer2.poolSize = 8192;\n  function from(value, encodingOrOffset, length) {\n    if (typeof value === \"string\") {\n      return fromString(value, encodingOrOffset);\n    }\n    if (ArrayBuffer.isView(value)) {\n      return fromArrayView(value);\n    }\n    if (value == null) {\n      throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + babelHelpers[\"typeof\"](value));\n    }\n    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {\n      return fromArrayBuffer(value, encodingOrOffset, length);\n    }\n    if (typeof SharedArrayBuffer !== \"undefined\" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {\n      return fromArrayBuffer(value, encodingOrOffset, length);\n    }\n    if (typeof value === \"number\") {\n      throw new TypeError('The \"value\" argument must not be of type number. Received type number');\n    }\n    var valueOf = value.valueOf && value.valueOf();\n    if (valueOf != null && valueOf !== value) {\n      return Buffer2.from(valueOf, encodingOrOffset, length);\n    }\n    var b = fromObject(value);\n    if (b)\n      return b;\n    if (typeof Symbol !== \"undefined\" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === \"function\") {\n      return Buffer2.from(value[Symbol.toPrimitive](\"string\"), encodingOrOffset, length);\n    }\n    throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + babelHelpers[\"typeof\"](value));\n  }\n  Buffer2.from = function(value, encodingOrOffset, length) {\n    return from(value, encodingOrOffset, length);\n  };\n  Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);\n  Object.setPrototypeOf(Buffer2, Uint8Array);\n  function assertSize(size) {\n    if (typeof size !== \"number\") {\n      throw new TypeError('\"size\" argument must be of type number');\n    } else if (size < 0) {\n      throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"');\n    }\n  }\n  function alloc(size, fill, encoding) {\n    assertSize(size);\n    if (size <= 0) {\n      return createBuffer(size);\n    }\n    if (fill !== void 0) {\n      return typeof encoding === \"string\" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);\n    }\n    return createBuffer(size);\n  }\n  Buffer2.alloc = function(size, fill, encoding) {\n    return alloc(size, fill, encoding);\n  };\n  function allocUnsafe(size) {\n    assertSize(size);\n    return createBuffer(size < 0 ? 0 : checked(size) | 0);\n  }\n  Buffer2.allocUnsafe = function(size) {\n    return allocUnsafe(size);\n  };\n  Buffer2.allocUnsafeSlow = function(size) {\n    return allocUnsafe(size);\n  };\n  function fromString(string, encoding) {\n    if (typeof encoding !== \"string\" || encoding === \"\") {\n      encoding = \"utf8\";\n    }\n    if (!Buffer2.isEncoding(encoding)) {\n      throw new TypeError(\"Unknown encoding: \" + encoding);\n    }\n    var length = byteLength2(string, encoding) | 0;\n    var buf = createBuffer(length);\n    var actual = buf.write(string, encoding);\n    if (actual !== length) {\n      buf = buf.slice(0, actual);\n    }\n    return buf;\n  }\n  function fromArrayLike(array) {\n    var length = array.length < 0 ? 0 : checked(array.length) | 0;\n    var buf = createBuffer(length);\n    for (var i = 0; i < length; i += 1) {\n      buf[i] = array[i] & 255;\n    }\n    return buf;\n  }\n  function fromArrayView(arrayView) {\n    if (isInstance(arrayView, Uint8Array)) {\n      var copy = new Uint8Array(arrayView);\n      return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);\n    }\n    return fromArrayLike(arrayView);\n  }\n  function fromArrayBuffer(array, byteOffset, length) {\n    if (byteOffset < 0 || array.byteLength < byteOffset) {\n      throw new RangeError('\"offset\" is outside of buffer bounds');\n    }\n    if (array.byteLength < byteOffset + (length || 0)) {\n      throw new RangeError('\"length\" is outside of buffer bounds');\n    }\n    var buf;\n    if (byteOffset === void 0 && length === void 0) {\n      buf = new Uint8Array(array);\n    } else if (length === void 0) {\n      buf = new Uint8Array(array, byteOffset);\n    } else {\n      buf = new Uint8Array(array, byteOffset, length);\n    }\n    Object.setPrototypeOf(buf, Buffer2.prototype);\n    return buf;\n  }\n  function fromObject(obj) {\n    if (Buffer2.isBuffer(obj)) {\n      var len = checked(obj.length) | 0;\n      var buf = createBuffer(len);\n      if (buf.length === 0) {\n        return buf;\n      }\n      obj.copy(buf, 0, 0, len);\n      return buf;\n    }\n    if (obj.length !== void 0) {\n      if (typeof obj.length !== \"number\" || numberIsNaN(obj.length)) {\n        return createBuffer(0);\n      }\n      return fromArrayLike(obj);\n    }\n    if (obj.type === \"Buffer\" && Array.isArray(obj.data)) {\n      return fromArrayLike(obj.data);\n    }\n  }\n  function checked(length) {\n    if (length >= K_MAX_LENGTH) {\n      throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\" + K_MAX_LENGTH.toString(16) + \" bytes\");\n    }\n    return length | 0;\n  }\n  function SlowBuffer(length) {\n    if (+length != length) {\n      length = 0;\n    }\n    return Buffer2.alloc(+length);\n  }\n  Buffer2.isBuffer = function isBuffer(b) {\n    return b != null && b._isBuffer === true && b !== Buffer2.prototype;\n  };\n  Buffer2.compare = function compare(a, b) {\n    if (isInstance(a, Uint8Array))\n      a = Buffer2.from(a, a.offset, a.byteLength);\n    if (isInstance(b, Uint8Array))\n      b = Buffer2.from(b, b.offset, b.byteLength);\n    if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {\n      throw new TypeError('The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array');\n    }\n    if (a === b)\n      return 0;\n    var x = a.length;\n    var y = b.length;\n    for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n      if (a[i] !== b[i]) {\n        x = a[i];\n        y = b[i];\n        break;\n      }\n    }\n    if (x < y)\n      return -1;\n    if (y < x)\n      return 1;\n    return 0;\n  };\n  Buffer2.isEncoding = function isEncoding(encoding) {\n    switch (String(encoding).toLowerCase()) {\n      case \"hex\":\n      case \"utf8\":\n      case \"utf-8\":\n      case \"ascii\":\n      case \"latin1\":\n      case \"binary\":\n      case \"base64\":\n      case \"ucs2\":\n      case \"ucs-2\":\n      case \"utf16le\":\n      case \"utf-16le\":\n        return true;\n      default:\n        return false;\n    }\n  };\n  Buffer2.concat = function concat(list, length) {\n    if (!Array.isArray(list)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers');\n    }\n    if (list.length === 0) {\n      return Buffer2.alloc(0);\n    }\n    var i;\n    if (length === void 0) {\n      length = 0;\n      for (i = 0; i < list.length; ++i) {\n        length += list[i].length;\n      }\n    }\n    var buffer2 = Buffer2.allocUnsafe(length);\n    var pos = 0;\n    for (i = 0; i < list.length; ++i) {\n      var buf = list[i];\n      if (isInstance(buf, Uint8Array)) {\n        if (pos + buf.length > buffer2.length) {\n          Buffer2.from(buf).copy(buffer2, pos);\n        } else {\n          Uint8Array.prototype.set.call(buffer2, buf, pos);\n        }\n      } else if (!Buffer2.isBuffer(buf)) {\n        throw new TypeError('\"list\" argument must be an Array of Buffers');\n      } else {\n        buf.copy(buffer2, pos);\n      }\n      pos += buf.length;\n    }\n    return buffer2;\n  };\n  function byteLength2(string, encoding) {\n    if (Buffer2.isBuffer(string)) {\n      return string.length;\n    }\n    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n      return string.byteLength;\n    }\n    if (typeof string !== \"string\") {\n      throw new TypeError('The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + babelHelpers[\"typeof\"](string));\n    }\n    var len = string.length;\n    var mustMatch = arguments.length > 2 && arguments[2] === true;\n    if (!mustMatch && len === 0)\n      return 0;\n    var loweredCase = false;\n    for (; ; ) {\n      switch (encoding) {\n        case \"ascii\":\n        case \"latin1\":\n        case \"binary\":\n          return len;\n        case \"utf8\":\n        case \"utf-8\":\n          return utf8ToBytes(string).length;\n        case \"ucs2\":\n        case \"ucs-2\":\n        case \"utf16le\":\n        case \"utf-16le\":\n          return len * 2;\n        case \"hex\":\n          return len >>> 1;\n        case \"base64\":\n          return base64ToBytes(string).length;\n        default:\n          if (loweredCase) {\n            return mustMatch ? -1 : utf8ToBytes(string).length;\n          }\n          encoding = (\"\" + encoding).toLowerCase();\n          loweredCase = true;\n      }\n    }\n  }\n  Buffer2.byteLength = byteLength2;\n  function slowToString(encoding, start, end) {\n    var loweredCase = false;\n    if (start === void 0 || start < 0) {\n      start = 0;\n    }\n    if (start > this.length) {\n      return \"\";\n    }\n    if (end === void 0 || end > this.length) {\n      end = this.length;\n    }\n    if (end <= 0) {\n      return \"\";\n    }\n    end >>>= 0;\n    start >>>= 0;\n    if (end <= start) {\n      return \"\";\n    }\n    if (!encoding)\n      encoding = \"utf8\";\n    while (true) {\n      switch (encoding) {\n        case \"hex\":\n          return hexSlice(this, start, end);\n        case \"utf8\":\n        case \"utf-8\":\n          return utf8Slice(this, start, end);\n        case \"ascii\":\n          return asciiSlice(this, start, end);\n        case \"latin1\":\n        case \"binary\":\n          return latin1Slice(this, start, end);\n        case \"base64\":\n          return base64Slice(this, start, end);\n        case \"ucs2\":\n        case \"ucs-2\":\n        case \"utf16le\":\n        case \"utf-16le\":\n          return utf16leSlice(this, start, end);\n        default:\n          if (loweredCase)\n            throw new TypeError(\"Unknown encoding: \" + encoding);\n          encoding = (encoding + \"\").toLowerCase();\n          loweredCase = true;\n      }\n    }\n  }\n  Buffer2.prototype._isBuffer = true;\n  function swap(b, n, m) {\n    var i = b[n];\n    b[n] = b[m];\n    b[m] = i;\n  }\n  Buffer2.prototype.swap16 = function swap16() {\n    var len = this.length;\n    if (len % 2 !== 0) {\n      throw new RangeError(\"Buffer size must be a multiple of 16-bits\");\n    }\n    for (var i = 0; i < len; i += 2) {\n      swap(this, i, i + 1);\n    }\n    return this;\n  };\n  Buffer2.prototype.swap32 = function swap32() {\n    var len = this.length;\n    if (len % 4 !== 0) {\n      throw new RangeError(\"Buffer size must be a multiple of 32-bits\");\n    }\n    for (var i = 0; i < len; i += 4) {\n      swap(this, i, i + 3);\n      swap(this, i + 1, i + 2);\n    }\n    return this;\n  };\n  Buffer2.prototype.swap64 = function swap64() {\n    var len = this.length;\n    if (len % 8 !== 0) {\n      throw new RangeError(\"Buffer size must be a multiple of 64-bits\");\n    }\n    for (var i = 0; i < len; i += 8) {\n      swap(this, i, i + 7);\n      swap(this, i + 1, i + 6);\n      swap(this, i + 2, i + 5);\n      swap(this, i + 3, i + 4);\n    }\n    return this;\n  };\n  Buffer2.prototype.toString = function toString() {\n    var length = this.length;\n    if (length === 0)\n      return \"\";\n    if (arguments.length === 0)\n      return utf8Slice(this, 0, length);\n    return slowToString.apply(this, arguments);\n  };\n  Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;\n  Buffer2.prototype.equals = function equals(b) {\n    if (!Buffer2.isBuffer(b))\n      throw new TypeError(\"Argument must be a Buffer\");\n    if (this === b)\n      return true;\n    return Buffer2.compare(this, b) === 0;\n  };\n  Buffer2.prototype.inspect = function inspect() {\n    var str = \"\";\n    var max = exports.INSPECT_MAX_BYTES;\n    str = this.toString(\"hex\", 0, max).replace(/(.{2})/g, \"$1 \").trim();\n    if (this.length > max)\n      str += \" ... \";\n    return \"<Buffer \" + str + \">\";\n  };\n  if (customInspectSymbol) {\n    Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;\n  }\n  Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n    if (isInstance(target, Uint8Array)) {\n      target = Buffer2.from(target, target.offset, target.byteLength);\n    }\n    if (!Buffer2.isBuffer(target)) {\n      throw new TypeError('The \"target\" argument must be one of type Buffer or Uint8Array. Received type ' + babelHelpers[\"typeof\"](target));\n    }\n    if (start === void 0) {\n      start = 0;\n    }\n    if (end === void 0) {\n      end = target ? target.length : 0;\n    }\n    if (thisStart === void 0) {\n      thisStart = 0;\n    }\n    if (thisEnd === void 0) {\n      thisEnd = this.length;\n    }\n    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n      throw new RangeError(\"out of range index\");\n    }\n    if (thisStart >= thisEnd && start >= end) {\n      return 0;\n    }\n    if (thisStart >= thisEnd) {\n      return -1;\n    }\n    if (start >= end) {\n      return 1;\n    }\n    start >>>= 0;\n    end >>>= 0;\n    thisStart >>>= 0;\n    thisEnd >>>= 0;\n    if (this === target)\n      return 0;\n    var x = thisEnd - thisStart;\n    var y = end - start;\n    var len = Math.min(x, y);\n    var thisCopy = this.slice(thisStart, thisEnd);\n    var targetCopy = target.slice(start, end);\n    for (var i = 0; i < len; ++i) {\n      if (thisCopy[i] !== targetCopy[i]) {\n        x = thisCopy[i];\n        y = targetCopy[i];\n        break;\n      }\n    }\n    if (x < y)\n      return -1;\n    if (y < x)\n      return 1;\n    return 0;\n  };\n  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {\n    if (buffer2.length === 0)\n      return -1;\n    if (typeof byteOffset === \"string\") {\n      encoding = byteOffset;\n      byteOffset = 0;\n    } else if (byteOffset > 2147483647) {\n      byteOffset = 2147483647;\n    } else if (byteOffset < -2147483648) {\n      byteOffset = -2147483648;\n    }\n    byteOffset = +byteOffset;\n    if (numberIsNaN(byteOffset)) {\n      byteOffset = dir ? 0 : buffer2.length - 1;\n    }\n    if (byteOffset < 0)\n      byteOffset = buffer2.length + byteOffset;\n    if (byteOffset >= buffer2.length) {\n      if (dir)\n        return -1;\n      else\n        byteOffset = buffer2.length - 1;\n    } else if (byteOffset < 0) {\n      if (dir)\n        byteOffset = 0;\n      else\n        return -1;\n    }\n    if (typeof val === \"string\") {\n      val = Buffer2.from(val, encoding);\n    }\n    if (Buffer2.isBuffer(val)) {\n      if (val.length === 0) {\n        return -1;\n      }\n      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);\n    } else if (typeof val === \"number\") {\n      val = val & 255;\n      if (typeof Uint8Array.prototype.indexOf === \"function\") {\n        if (dir) {\n          return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);\n        } else {\n          return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);\n        }\n      }\n      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);\n    }\n    throw new TypeError(\"val must be string, number or Buffer\");\n  }\n  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n    var indexSize = 1;\n    var arrLength = arr.length;\n    var valLength = val.length;\n    if (encoding !== void 0) {\n      encoding = String(encoding).toLowerCase();\n      if (encoding === \"ucs2\" || encoding === \"ucs-2\" || encoding === \"utf16le\" || encoding === \"utf-16le\") {\n        if (arr.length < 2 || val.length < 2) {\n          return -1;\n        }\n        indexSize = 2;\n        arrLength /= 2;\n        valLength /= 2;\n        byteOffset /= 2;\n      }\n    }\n    function read3(buf, i2) {\n      if (indexSize === 1) {\n        return buf[i2];\n      } else {\n        return buf.readUInt16BE(i2 * indexSize);\n      }\n    }\n    var i;\n    if (dir) {\n      var foundIndex = -1;\n      for (i = byteOffset; i < arrLength; i++) {\n        if (read3(arr, i) === read3(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n          if (foundIndex === -1)\n            foundIndex = i;\n          if (i - foundIndex + 1 === valLength)\n            return foundIndex * indexSize;\n        } else {\n          if (foundIndex !== -1)\n            i -= i - foundIndex;\n          foundIndex = -1;\n        }\n      }\n    } else {\n      if (byteOffset + valLength > arrLength)\n        byteOffset = arrLength - valLength;\n      for (i = byteOffset; i >= 0; i--) {\n        var found = true;\n        for (var j = 0; j < valLength; j++) {\n          if (read3(arr, i + j) !== read3(val, j)) {\n            found = false;\n            break;\n          }\n        }\n        if (found)\n          return i;\n      }\n    }\n    return -1;\n  }\n  Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {\n    return this.indexOf(val, byteOffset, encoding) !== -1;\n  };\n  Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n  };\n  Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n  };\n  function hexWrite(buf, string, offset, length) {\n    offset = Number(offset) || 0;\n    var remaining = buf.length - offset;\n    if (!length) {\n      length = remaining;\n    } else {\n      length = Number(length);\n      if (length > remaining) {\n        length = remaining;\n      }\n    }\n    var strLen = string.length;\n    if (length > strLen / 2) {\n      length = strLen / 2;\n    }\n    for (var i = 0; i < length; ++i) {\n      var parsed = parseInt(string.substr(i * 2, 2), 16);\n      if (numberIsNaN(parsed))\n        return i;\n      buf[offset + i] = parsed;\n    }\n    return i;\n  }\n  function utf8Write(buf, string, offset, length) {\n    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n  }\n  function asciiWrite(buf, string, offset, length) {\n    return blitBuffer(asciiToBytes(string), buf, offset, length);\n  }\n  function base64Write(buf, string, offset, length) {\n    return blitBuffer(base64ToBytes(string), buf, offset, length);\n  }\n  function ucs2Write(buf, string, offset, length) {\n    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n  }\n  Buffer2.prototype.write = function write3(string, offset, length, encoding) {\n    if (offset === void 0) {\n      encoding = \"utf8\";\n      length = this.length;\n      offset = 0;\n    } else if (length === void 0 && typeof offset === \"string\") {\n      encoding = offset;\n      length = this.length;\n      offset = 0;\n    } else if (isFinite(offset)) {\n      offset = offset >>> 0;\n      if (isFinite(length)) {\n        length = length >>> 0;\n        if (encoding === void 0)\n          encoding = \"utf8\";\n      } else {\n        encoding = length;\n        length = void 0;\n      }\n    } else {\n      throw new Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\");\n    }\n    var remaining = this.length - offset;\n    if (length === void 0 || length > remaining)\n      length = remaining;\n    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n      throw new RangeError(\"Attempt to write outside buffer bounds\");\n    }\n    if (!encoding)\n      encoding = \"utf8\";\n    var loweredCase = false;\n    for (; ; ) {\n      switch (encoding) {\n        case \"hex\":\n          return hexWrite(this, string, offset, length);\n        case \"utf8\":\n        case \"utf-8\":\n          return utf8Write(this, string, offset, length);\n        case \"ascii\":\n        case \"latin1\":\n        case \"binary\":\n          return asciiWrite(this, string, offset, length);\n        case \"base64\":\n          return base64Write(this, string, offset, length);\n        case \"ucs2\":\n        case \"ucs-2\":\n        case \"utf16le\":\n        case \"utf-16le\":\n          return ucs2Write(this, string, offset, length);\n        default:\n          if (loweredCase)\n            throw new TypeError(\"Unknown encoding: \" + encoding);\n          encoding = (\"\" + encoding).toLowerCase();\n          loweredCase = true;\n      }\n    }\n  };\n  Buffer2.prototype.toJSON = function toJSON() {\n    return {\n      type: \"Buffer\",\n      data: Array.prototype.slice.call(this._arr || this, 0)\n    };\n  };\n  function base64Slice(buf, start, end) {\n    if (start === 0 && end === buf.length) {\n      return base64Js.fromByteArray(buf);\n    } else {\n      return base64Js.fromByteArray(buf.slice(start, end));\n    }\n  }\n  function utf8Slice(buf, start, end) {\n    end = Math.min(buf.length, end);\n    var res = [];\n    var i = start;\n    while (i < end) {\n      var firstByte = buf[i];\n      var codePoint = null;\n      var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;\n      if (i + bytesPerSequence <= end) {\n        var secondByte, thirdByte, fourthByte, tempCodePoint;\n        switch (bytesPerSequence) {\n          case 1:\n            if (firstByte < 128) {\n              codePoint = firstByte;\n            }\n            break;\n          case 2:\n            secondByte = buf[i + 1];\n            if ((secondByte & 192) === 128) {\n              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;\n              if (tempCodePoint > 127) {\n                codePoint = tempCodePoint;\n              }\n            }\n            break;\n          case 3:\n            secondByte = buf[i + 1];\n            thirdByte = buf[i + 2];\n            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {\n              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;\n              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {\n                codePoint = tempCodePoint;\n              }\n            }\n            break;\n          case 4:\n            secondByte = buf[i + 1];\n            thirdByte = buf[i + 2];\n            fourthByte = buf[i + 3];\n            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {\n              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;\n              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {\n                codePoint = tempCodePoint;\n              }\n            }\n        }\n      }\n      if (codePoint === null) {\n        codePoint = 65533;\n        bytesPerSequence = 1;\n      } else if (codePoint > 65535) {\n        codePoint -= 65536;\n        res.push(codePoint >>> 10 & 1023 | 55296);\n        codePoint = 56320 | codePoint & 1023;\n      }\n      res.push(codePoint);\n      i += bytesPerSequence;\n    }\n    return decodeCodePointsArray(res);\n  }\n  var MAX_ARGUMENTS_LENGTH = 4096;\n  function decodeCodePointsArray(codePoints) {\n    var len = codePoints.length;\n    if (len <= MAX_ARGUMENTS_LENGTH) {\n      return String.fromCharCode.apply(String, codePoints);\n    }\n    var res = \"\";\n    var i = 0;\n    while (i < len) {\n      res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\n    }\n    return res;\n  }\n  function asciiSlice(buf, start, end) {\n    var ret = \"\";\n    end = Math.min(buf.length, end);\n    for (var i = start; i < end; ++i) {\n      ret += String.fromCharCode(buf[i] & 127);\n    }\n    return ret;\n  }\n  function latin1Slice(buf, start, end) {\n    var ret = \"\";\n    end = Math.min(buf.length, end);\n    for (var i = start; i < end; ++i) {\n      ret += String.fromCharCode(buf[i]);\n    }\n    return ret;\n  }\n  function hexSlice(buf, start, end) {\n    var len = buf.length;\n    if (!start || start < 0)\n      start = 0;\n    if (!end || end < 0 || end > len)\n      end = len;\n    var out = \"\";\n    for (var i = start; i < end; ++i) {\n      out += hexSliceLookupTable[buf[i]];\n    }\n    return out;\n  }\n  function utf16leSlice(buf, start, end) {\n    var bytes = buf.slice(start, end);\n    var res = \"\";\n    for (var i = 0; i < bytes.length - 1; i += 2) {\n      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n    }\n    return res;\n  }\n  Buffer2.prototype.slice = function slice(start, end) {\n    var len = this.length;\n    start = ~~start;\n    end = end === void 0 ? len : ~~end;\n    if (start < 0) {\n      start += len;\n      if (start < 0)\n        start = 0;\n    } else if (start > len) {\n      start = len;\n    }\n    if (end < 0) {\n      end += len;\n      if (end < 0)\n        end = 0;\n    } else if (end > len) {\n      end = len;\n    }\n    if (end < start)\n      end = start;\n    var newBuf = this.subarray(start, end);\n    Object.setPrototypeOf(newBuf, Buffer2.prototype);\n    return newBuf;\n  };\n  function checkOffset(offset, ext, length) {\n    if (offset % 1 !== 0 || offset < 0)\n      throw new RangeError(\"offset is not uint\");\n    if (offset + ext > length)\n      throw new RangeError(\"Trying to access beyond buffer length\");\n  }\n  Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {\n    offset = offset >>> 0;\n    byteLength3 = byteLength3 >>> 0;\n    if (!noAssert)\n      checkOffset(offset, byteLength3, this.length);\n    var val = this[offset];\n    var mul = 1;\n    var i = 0;\n    while (++i < byteLength3 && (mul *= 256)) {\n      val += this[offset + i] * mul;\n    }\n    return val;\n  };\n  Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {\n    offset = offset >>> 0;\n    byteLength3 = byteLength3 >>> 0;\n    if (!noAssert) {\n      checkOffset(offset, byteLength3, this.length);\n    }\n    var val = this[offset + --byteLength3];\n    var mul = 1;\n    while (byteLength3 > 0 && (mul *= 256)) {\n      val += this[offset + --byteLength3] * mul;\n    }\n    return val;\n  };\n  Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkOffset(offset, 1, this.length);\n    return this[offset];\n  };\n  Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkOffset(offset, 2, this.length);\n    return this[offset] | this[offset + 1] << 8;\n  };\n  Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkOffset(offset, 2, this.length);\n    return this[offset] << 8 | this[offset + 1];\n  };\n  Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkOffset(offset, 4, this.length);\n    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;\n  };\n  Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkOffset(offset, 4, this.length);\n    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n  };\n  Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {\n    offset = offset >>> 0;\n    byteLength3 = byteLength3 >>> 0;\n    if (!noAssert)\n      checkOffset(offset, byteLength3, this.length);\n    var val = this[offset];\n    var mul = 1;\n    var i = 0;\n    while (++i < byteLength3 && (mul *= 256)) {\n      val += this[offset + i] * mul;\n    }\n    mul *= 128;\n    if (val >= mul)\n      val -= Math.pow(2, 8 * byteLength3);\n    return val;\n  };\n  Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {\n    offset = offset >>> 0;\n    byteLength3 = byteLength3 >>> 0;\n    if (!noAssert)\n      checkOffset(offset, byteLength3, this.length);\n    var i = byteLength3;\n    var mul = 1;\n    var val = this[offset + --i];\n    while (i > 0 && (mul *= 256)) {\n      val += this[offset + --i] * mul;\n    }\n    mul *= 128;\n    if (val >= mul)\n      val -= Math.pow(2, 8 * byteLength3);\n    return val;\n  };\n  Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkOffset(offset, 1, this.length);\n    if (!(this[offset] & 128))\n      return this[offset];\n    return (255 - this[offset] + 1) * -1;\n  };\n  Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkOffset(offset, 2, this.length);\n    var val = this[offset] | this[offset + 1] << 8;\n    return val & 32768 ? val | 4294901760 : val;\n  };\n  Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkOffset(offset, 2, this.length);\n    var val = this[offset + 1] | this[offset] << 8;\n    return val & 32768 ? val | 4294901760 : val;\n  };\n  Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkOffset(offset, 4, this.length);\n    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n  };\n  Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkOffset(offset, 4, this.length);\n    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n  };\n  Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkOffset(offset, 4, this.length);\n    return ieee754.read(this, offset, true, 23, 4);\n  };\n  Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkOffset(offset, 4, this.length);\n    return ieee754.read(this, offset, false, 23, 4);\n  };\n  Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkOffset(offset, 8, this.length);\n    return ieee754.read(this, offset, true, 52, 8);\n  };\n  Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkOffset(offset, 8, this.length);\n    return ieee754.read(this, offset, false, 52, 8);\n  };\n  function checkInt(buf, value, offset, ext, max, min) {\n    if (!Buffer2.isBuffer(buf))\n      throw new TypeError('\"buffer\" argument must be a Buffer instance');\n    if (value > max || value < min)\n      throw new RangeError('\"value\" argument is out of bounds');\n    if (offset + ext > buf.length)\n      throw new RangeError(\"Index out of range\");\n  }\n  Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    byteLength3 = byteLength3 >>> 0;\n    if (!noAssert) {\n      var maxBytes = Math.pow(2, 8 * byteLength3) - 1;\n      checkInt(this, value, offset, byteLength3, maxBytes, 0);\n    }\n    var mul = 1;\n    var i = 0;\n    this[offset] = value & 255;\n    while (++i < byteLength3 && (mul *= 256)) {\n      this[offset + i] = value / mul & 255;\n    }\n    return offset + byteLength3;\n  };\n  Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    byteLength3 = byteLength3 >>> 0;\n    if (!noAssert) {\n      var maxBytes = Math.pow(2, 8 * byteLength3) - 1;\n      checkInt(this, value, offset, byteLength3, maxBytes, 0);\n    }\n    var i = byteLength3 - 1;\n    var mul = 1;\n    this[offset + i] = value & 255;\n    while (--i >= 0 && (mul *= 256)) {\n      this[offset + i] = value / mul & 255;\n    }\n    return offset + byteLength3;\n  };\n  Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkInt(this, value, offset, 1, 255, 0);\n    this[offset] = value & 255;\n    return offset + 1;\n  };\n  Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkInt(this, value, offset, 2, 65535, 0);\n    this[offset] = value & 255;\n    this[offset + 1] = value >>> 8;\n    return offset + 2;\n  };\n  Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkInt(this, value, offset, 2, 65535, 0);\n    this[offset] = value >>> 8;\n    this[offset + 1] = value & 255;\n    return offset + 2;\n  };\n  Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkInt(this, value, offset, 4, 4294967295, 0);\n    this[offset + 3] = value >>> 24;\n    this[offset + 2] = value >>> 16;\n    this[offset + 1] = value >>> 8;\n    this[offset] = value & 255;\n    return offset + 4;\n  };\n  Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkInt(this, value, offset, 4, 4294967295, 0);\n    this[offset] = value >>> 24;\n    this[offset + 1] = value >>> 16;\n    this[offset + 2] = value >>> 8;\n    this[offset + 3] = value & 255;\n    return offset + 4;\n  };\n  Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) {\n      var limit = Math.pow(2, 8 * byteLength3 - 1);\n      checkInt(this, value, offset, byteLength3, limit - 1, -limit);\n    }\n    var i = 0;\n    var mul = 1;\n    var sub = 0;\n    this[offset] = value & 255;\n    while (++i < byteLength3 && (mul *= 256)) {\n      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n        sub = 1;\n      }\n      this[offset + i] = (value / mul >> 0) - sub & 255;\n    }\n    return offset + byteLength3;\n  };\n  Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) {\n      var limit = Math.pow(2, 8 * byteLength3 - 1);\n      checkInt(this, value, offset, byteLength3, limit - 1, -limit);\n    }\n    var i = byteLength3 - 1;\n    var mul = 1;\n    var sub = 0;\n    this[offset + i] = value & 255;\n    while (--i >= 0 && (mul *= 256)) {\n      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n        sub = 1;\n      }\n      this[offset + i] = (value / mul >> 0) - sub & 255;\n    }\n    return offset + byteLength3;\n  };\n  Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkInt(this, value, offset, 1, 127, -128);\n    if (value < 0)\n      value = 255 + value + 1;\n    this[offset] = value & 255;\n    return offset + 1;\n  };\n  Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkInt(this, value, offset, 2, 32767, -32768);\n    this[offset] = value & 255;\n    this[offset + 1] = value >>> 8;\n    return offset + 2;\n  };\n  Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkInt(this, value, offset, 2, 32767, -32768);\n    this[offset] = value >>> 8;\n    this[offset + 1] = value & 255;\n    return offset + 2;\n  };\n  Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkInt(this, value, offset, 4, 2147483647, -2147483648);\n    this[offset] = value & 255;\n    this[offset + 1] = value >>> 8;\n    this[offset + 2] = value >>> 16;\n    this[offset + 3] = value >>> 24;\n    return offset + 4;\n  };\n  Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkInt(this, value, offset, 4, 2147483647, -2147483648);\n    if (value < 0)\n      value = 4294967295 + value + 1;\n    this[offset] = value >>> 24;\n    this[offset + 1] = value >>> 16;\n    this[offset + 2] = value >>> 8;\n    this[offset + 3] = value & 255;\n    return offset + 4;\n  };\n  function checkIEEE754(buf, value, offset, ext, max, min) {\n    if (offset + ext > buf.length)\n      throw new RangeError(\"Index out of range\");\n    if (offset < 0)\n      throw new RangeError(\"Index out of range\");\n  }\n  function writeFloat(buf, value, offset, littleEndian, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) {\n      checkIEEE754(buf, value, offset, 4);\n    }\n    ieee754.write(buf, value, offset, littleEndian, 23, 4);\n    return offset + 4;\n  }\n  Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n    return writeFloat(this, value, offset, true, noAssert);\n  };\n  Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n    return writeFloat(this, value, offset, false, noAssert);\n  };\n  function writeDouble(buf, value, offset, littleEndian, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) {\n      checkIEEE754(buf, value, offset, 8);\n    }\n    ieee754.write(buf, value, offset, littleEndian, 52, 8);\n    return offset + 8;\n  }\n  Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n    return writeDouble(this, value, offset, true, noAssert);\n  };\n  Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n    return writeDouble(this, value, offset, false, noAssert);\n  };\n  Buffer2.prototype.copy = function copy(target, targetStart, start, end) {\n    if (!Buffer2.isBuffer(target))\n      throw new TypeError(\"argument should be a Buffer\");\n    if (!start)\n      start = 0;\n    if (!end && end !== 0)\n      end = this.length;\n    if (targetStart >= target.length)\n      targetStart = target.length;\n    if (!targetStart)\n      targetStart = 0;\n    if (end > 0 && end < start)\n      end = start;\n    if (end === start)\n      return 0;\n    if (target.length === 0 || this.length === 0)\n      return 0;\n    if (targetStart < 0) {\n      throw new RangeError(\"targetStart out of bounds\");\n    }\n    if (start < 0 || start >= this.length)\n      throw new RangeError(\"Index out of range\");\n    if (end < 0)\n      throw new RangeError(\"sourceEnd out of bounds\");\n    if (end > this.length)\n      end = this.length;\n    if (target.length - targetStart < end - start) {\n      end = target.length - targetStart + start;\n    }\n    var len = end - start;\n    if (this === target && typeof Uint8Array.prototype.copyWithin === \"function\") {\n      this.copyWithin(targetStart, start, end);\n    } else {\n      Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);\n    }\n    return len;\n  };\n  Buffer2.prototype.fill = function fill(val, start, end, encoding) {\n    if (typeof val === \"string\") {\n      if (typeof start === \"string\") {\n        encoding = start;\n        start = 0;\n        end = this.length;\n      } else if (typeof end === \"string\") {\n        encoding = end;\n        end = this.length;\n      }\n      if (encoding !== void 0 && typeof encoding !== \"string\") {\n        throw new TypeError(\"encoding must be a string\");\n      }\n      if (typeof encoding === \"string\" && !Buffer2.isEncoding(encoding)) {\n        throw new TypeError(\"Unknown encoding: \" + encoding);\n      }\n      if (val.length === 1) {\n        var code2 = val.charCodeAt(0);\n        if (encoding === \"utf8\" && code2 < 128 || encoding === \"latin1\") {\n          val = code2;\n        }\n      }\n    } else if (typeof val === \"number\") {\n      val = val & 255;\n    } else if (typeof val === \"boolean\") {\n      val = Number(val);\n    }\n    if (start < 0 || this.length < start || this.length < end) {\n      throw new RangeError(\"Out of range index\");\n    }\n    if (end <= start) {\n      return this;\n    }\n    start = start >>> 0;\n    end = end === void 0 ? this.length : end >>> 0;\n    if (!val)\n      val = 0;\n    var i;\n    if (typeof val === \"number\") {\n      for (i = start; i < end; ++i) {\n        this[i] = val;\n      }\n    } else {\n      var bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);\n      var len = bytes.length;\n      if (len === 0) {\n        throw new TypeError('The value \"' + val + '\" is invalid for argument \"value\"');\n      }\n      for (i = 0; i < end - start; ++i) {\n        this[i + start] = bytes[i % len];\n      }\n    }\n    return this;\n  };\n  var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;\n  function base64clean(str) {\n    str = str.split(\"=\")[0];\n    str = str.trim().replace(INVALID_BASE64_RE, \"\");\n    if (str.length < 2)\n      return \"\";\n    while (str.length % 4 !== 0) {\n      str = str + \"=\";\n    }\n    return str;\n  }\n  function utf8ToBytes(string, units) {\n    units = units || Infinity;\n    var codePoint;\n    var length = string.length;\n    var leadSurrogate = null;\n    var bytes = [];\n    for (var i = 0; i < length; ++i) {\n      codePoint = string.charCodeAt(i);\n      if (codePoint > 55295 && codePoint < 57344) {\n        if (!leadSurrogate) {\n          if (codePoint > 56319) {\n            if ((units -= 3) > -1)\n              bytes.push(239, 191, 189);\n            continue;\n          } else if (i + 1 === length) {\n            if ((units -= 3) > -1)\n              bytes.push(239, 191, 189);\n            continue;\n          }\n          leadSurrogate = codePoint;\n          continue;\n        }\n        if (codePoint < 56320) {\n          if ((units -= 3) > -1)\n            bytes.push(239, 191, 189);\n          leadSurrogate = codePoint;\n          continue;\n        }\n        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;\n      } else if (leadSurrogate) {\n        if ((units -= 3) > -1)\n          bytes.push(239, 191, 189);\n      }\n      leadSurrogate = null;\n      if (codePoint < 128) {\n        if ((units -= 1) < 0)\n          break;\n        bytes.push(codePoint);\n      } else if (codePoint < 2048) {\n        if ((units -= 2) < 0)\n          break;\n        bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);\n      } else if (codePoint < 65536) {\n        if ((units -= 3) < 0)\n          break;\n        bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);\n      } else if (codePoint < 1114112) {\n        if ((units -= 4) < 0)\n          break;\n        bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);\n      } else {\n        throw new Error(\"Invalid code point\");\n      }\n    }\n    return bytes;\n  }\n  function asciiToBytes(str) {\n    var byteArray = [];\n    for (var i = 0; i < str.length; ++i) {\n      byteArray.push(str.charCodeAt(i) & 255);\n    }\n    return byteArray;\n  }\n  function utf16leToBytes(str, units) {\n    var c, hi, lo;\n    var byteArray = [];\n    for (var i = 0; i < str.length; ++i) {\n      if ((units -= 2) < 0)\n        break;\n      c = str.charCodeAt(i);\n      hi = c >> 8;\n      lo = c % 256;\n      byteArray.push(lo);\n      byteArray.push(hi);\n    }\n    return byteArray;\n  }\n  function base64ToBytes(str) {\n    return base64Js.toByteArray(base64clean(str));\n  }\n  function blitBuffer(src, dst, offset, length) {\n    for (var i = 0; i < length; ++i) {\n      if (i + offset >= dst.length || i >= src.length)\n        break;\n      dst[i + offset] = src[i];\n    }\n    return i;\n  }\n  function isInstance(obj, type) {\n    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;\n  }\n  function numberIsNaN(obj) {\n    return obj !== obj;\n  }\n  var hexSliceLookupTable = function() {\n    var alphabet = \"0123456789abcdef\";\n    var table = new Array(256);\n    for (var i = 0; i < 16; ++i) {\n      var i16 = i * 16;\n      for (var j = 0; j < 16; ++j) {\n        table[i16 + j] = alphabet[i] + alphabet[j];\n      }\n    }\n    return table;\n  }();\n});\nvar buffer_1 = buffer$1.Buffer;\nbuffer$1.SlowBuffer;\nbuffer$1.INSPECT_MAX_BYTES;\nbuffer$1.kMaxLength;\nvar _extendStatics = function extendStatics(d, b) {\n  _extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function(d2, b2) {\n    d2.__proto__ = b2;\n  } || function(d2, b2) {\n    for (var p in b2) {\n      if (b2.hasOwnProperty(p))\n        d2[p] = b2[p];\n    }\n  };\n  return _extendStatics(d, b);\n};\nfunction __extends(d, b) {\n  _extendStatics(d, b);\n  function __() {\n    this.constructor = d;\n  }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nvar _assign = function __assign() {\n  _assign = Object.assign || function __assign2(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p))\n          t[p] = s[p];\n      }\n    }\n    return t;\n  };\n  return _assign.apply(this, arguments);\n};\nvar BSONError = (\n  /** @class */\n  function(_super) {\n    __extends(BSONError2, _super);\n    function BSONError2(message) {\n      var _this = _super.call(this, message) || this;\n      Object.setPrototypeOf(_this, BSONError2.prototype);\n      return _this;\n    }\n    Object.defineProperty(BSONError2.prototype, \"name\", {\n      get: function() {\n        return \"BSONError\";\n      },\n      enumerable: false,\n      configurable: true\n    });\n    return BSONError2;\n  }(Error)\n);\nvar BSONTypeError = (\n  /** @class */\n  function(_super) {\n    __extends(BSONTypeError2, _super);\n    function BSONTypeError2(message) {\n      var _this = _super.call(this, message) || this;\n      Object.setPrototypeOf(_this, BSONTypeError2.prototype);\n      return _this;\n    }\n    Object.defineProperty(BSONTypeError2.prototype, \"name\", {\n      get: function() {\n        return \"BSONTypeError\";\n      },\n      enumerable: false,\n      configurable: true\n    });\n    return BSONTypeError2;\n  }(TypeError)\n);\nfunction checkForMath(potentialGlobal) {\n  return potentialGlobal && potentialGlobal.Math == Math && potentialGlobal;\n}\nfunction getGlobal() {\n  return checkForMath(typeof globalThis === \"object\" && globalThis) || checkForMath(typeof window === \"object\" && window) || checkForMath(typeof self === \"object\" && self) || checkForMath(typeof global === \"object\" && global) || // eslint-disable-next-line @typescript-eslint/no-implied-eval\n  Function(\"return this\")();\n}\nfunction normalizedFunctionString(fn) {\n  return fn.toString().replace(\"function(\", \"function (\");\n}\nfunction isReactNative() {\n  var g = getGlobal();\n  return typeof g.navigator === \"object\" && g.navigator.product === \"ReactNative\";\n}\nvar insecureRandomBytes = function insecureRandomBytes2(size) {\n  var insecureWarning = isReactNative() ? \"BSON: For React Native please polyfill crypto.getRandomValues, e.g. using: https://www.npmjs.com/package/react-native-get-random-values.\" : \"BSON: No cryptographic implementation for random bytes present, falling back to a less secure implementation.\";\n  console.warn(insecureWarning);\n  var result = buffer_1.alloc(size);\n  for (var i = 0; i < size; ++i)\n    result[i] = Math.floor(Math.random() * 256);\n  return result;\n};\nvar detectRandomBytes = function() {\n  {\n    if (typeof window !== \"undefined\") {\n      var target_1 = window.crypto || window.msCrypto;\n      if (target_1 && target_1.getRandomValues) {\n        return function(size) {\n          return target_1.getRandomValues(buffer_1.alloc(size));\n        };\n      }\n    }\n    if (typeof global !== \"undefined\" && global.crypto && global.crypto.getRandomValues) {\n      return function(size) {\n        return global.crypto.getRandomValues(buffer_1.alloc(size));\n      };\n    }\n    return insecureRandomBytes;\n  }\n};\nvar randomBytes = detectRandomBytes();\nfunction isAnyArrayBuffer(value) {\n  return [\"[object ArrayBuffer]\", \"[object SharedArrayBuffer]\"].includes(Object.prototype.toString.call(value));\n}\nfunction isUint8Array(value) {\n  return Object.prototype.toString.call(value) === \"[object Uint8Array]\";\n}\nfunction isBigInt64Array(value) {\n  return Object.prototype.toString.call(value) === \"[object BigInt64Array]\";\n}\nfunction isBigUInt64Array(value) {\n  return Object.prototype.toString.call(value) === \"[object BigUint64Array]\";\n}\nfunction isRegExp(d) {\n  return Object.prototype.toString.call(d) === \"[object RegExp]\";\n}\nfunction isMap(d) {\n  return Object.prototype.toString.call(d) === \"[object Map]\";\n}\nfunction isDate(d) {\n  return isObjectLike(d) && Object.prototype.toString.call(d) === \"[object Date]\";\n}\nfunction isObjectLike(candidate) {\n  return typeof candidate === \"object\" && candidate !== null;\n}\nfunction deprecate(fn, message) {\n  var warned = false;\n  function deprecated() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    if (!warned) {\n      console.warn(message);\n      warned = true;\n    }\n    return fn.apply(this, args);\n  }\n  return deprecated;\n}\nfunction ensureBuffer(potentialBuffer) {\n  if (ArrayBuffer.isView(potentialBuffer)) {\n    return buffer_1.from(potentialBuffer.buffer, potentialBuffer.byteOffset, potentialBuffer.byteLength);\n  }\n  if (isAnyArrayBuffer(potentialBuffer)) {\n    return buffer_1.from(potentialBuffer);\n  }\n  throw new BSONTypeError(\"Must use either Buffer or TypedArray\");\n}\nvar VALIDATION_REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|[0-9a-f]{12}4[0-9a-f]{3}[89ab][0-9a-f]{15})$/i;\nvar uuidValidateString = function(str) {\n  return typeof str === \"string\" && VALIDATION_REGEX.test(str);\n};\nvar uuidHexStringToBuffer = function(hexString) {\n  if (!uuidValidateString(hexString)) {\n    throw new BSONTypeError('UUID string representations must be a 32 or 36 character hex string (dashes excluded/included). Format: \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\" or \"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\".');\n  }\n  var sanitizedHexString = hexString.replace(/-/g, \"\");\n  return buffer_1.from(sanitizedHexString, \"hex\");\n};\nvar bufferToUuidHexString = function(buffer2, includeDashes) {\n  if (includeDashes === void 0) {\n    includeDashes = true;\n  }\n  return includeDashes ? buffer2.toString(\"hex\", 0, 4) + \"-\" + buffer2.toString(\"hex\", 4, 6) + \"-\" + buffer2.toString(\"hex\", 6, 8) + \"-\" + buffer2.toString(\"hex\", 8, 10) + \"-\" + buffer2.toString(\"hex\", 10, 16) : buffer2.toString(\"hex\");\n};\nvar BSON_INT32_MAX$1 = 2147483647;\nvar BSON_INT32_MIN$1 = -2147483648;\nvar BSON_INT64_MAX$1 = Math.pow(2, 63) - 1;\nvar BSON_INT64_MIN$1 = -Math.pow(2, 63);\nvar JS_INT_MAX = Math.pow(2, 53);\nvar JS_INT_MIN = -Math.pow(2, 53);\nvar BSON_DATA_NUMBER = 1;\nvar BSON_DATA_STRING = 2;\nvar BSON_DATA_OBJECT = 3;\nvar BSON_DATA_ARRAY = 4;\nvar BSON_DATA_BINARY = 5;\nvar BSON_DATA_UNDEFINED = 6;\nvar BSON_DATA_OID = 7;\nvar BSON_DATA_BOOLEAN = 8;\nvar BSON_DATA_DATE = 9;\nvar BSON_DATA_NULL = 10;\nvar BSON_DATA_REGEXP = 11;\nvar BSON_DATA_DBPOINTER = 12;\nvar BSON_DATA_CODE = 13;\nvar BSON_DATA_SYMBOL = 14;\nvar BSON_DATA_CODE_W_SCOPE = 15;\nvar BSON_DATA_INT = 16;\nvar BSON_DATA_TIMESTAMP = 17;\nvar BSON_DATA_LONG = 18;\nvar BSON_DATA_DECIMAL128 = 19;\nvar BSON_DATA_MIN_KEY = 255;\nvar BSON_DATA_MAX_KEY = 127;\nvar BSON_BINARY_SUBTYPE_DEFAULT = 0;\nvar BSON_BINARY_SUBTYPE_FUNCTION = 1;\nvar BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;\nvar BSON_BINARY_SUBTYPE_UUID = 3;\nvar BSON_BINARY_SUBTYPE_UUID_NEW = 4;\nvar BSON_BINARY_SUBTYPE_MD5 = 5;\nvar BSON_BINARY_SUBTYPE_ENCRYPTED = 6;\nvar BSON_BINARY_SUBTYPE_COLUMN = 7;\nvar BSON_BINARY_SUBTYPE_USER_DEFINED = 128;\nvar Binary = (\n  /** @class */\n  function() {\n    function Binary2(buffer2, subType) {\n      if (!(this instanceof Binary2))\n        return new Binary2(buffer2, subType);\n      if (!(buffer2 == null) && !(typeof buffer2 === \"string\") && !ArrayBuffer.isView(buffer2) && !(buffer2 instanceof ArrayBuffer) && !Array.isArray(buffer2)) {\n        throw new BSONTypeError(\"Binary can only be constructed from string, Buffer, TypedArray, or Array<number>\");\n      }\n      this.sub_type = subType !== null && subType !== void 0 ? subType : Binary2.BSON_BINARY_SUBTYPE_DEFAULT;\n      if (buffer2 == null) {\n        this.buffer = buffer_1.alloc(Binary2.BUFFER_SIZE);\n        this.position = 0;\n      } else {\n        if (typeof buffer2 === \"string\") {\n          this.buffer = buffer_1.from(buffer2, \"binary\");\n        } else if (Array.isArray(buffer2)) {\n          this.buffer = buffer_1.from(buffer2);\n        } else {\n          this.buffer = ensureBuffer(buffer2);\n        }\n        this.position = this.buffer.byteLength;\n      }\n    }\n    Binary2.prototype.put = function(byteValue) {\n      if (typeof byteValue === \"string\" && byteValue.length !== 1) {\n        throw new BSONTypeError(\"only accepts single character String\");\n      } else if (typeof byteValue !== \"number\" && byteValue.length !== 1)\n        throw new BSONTypeError(\"only accepts single character Uint8Array or Array\");\n      var decodedByte;\n      if (typeof byteValue === \"string\") {\n        decodedByte = byteValue.charCodeAt(0);\n      } else if (typeof byteValue === \"number\") {\n        decodedByte = byteValue;\n      } else {\n        decodedByte = byteValue[0];\n      }\n      if (decodedByte < 0 || decodedByte > 255) {\n        throw new BSONTypeError(\"only accepts number in a valid unsigned byte range 0-255\");\n      }\n      if (this.buffer.length > this.position) {\n        this.buffer[this.position++] = decodedByte;\n      } else {\n        var buffer2 = buffer_1.alloc(Binary2.BUFFER_SIZE + this.buffer.length);\n        this.buffer.copy(buffer2, 0, 0, this.buffer.length);\n        this.buffer = buffer2;\n        this.buffer[this.position++] = decodedByte;\n      }\n    };\n    Binary2.prototype.write = function(sequence, offset) {\n      offset = typeof offset === \"number\" ? offset : this.position;\n      if (this.buffer.length < offset + sequence.length) {\n        var buffer2 = buffer_1.alloc(this.buffer.length + sequence.length);\n        this.buffer.copy(buffer2, 0, 0, this.buffer.length);\n        this.buffer = buffer2;\n      }\n      if (ArrayBuffer.isView(sequence)) {\n        this.buffer.set(ensureBuffer(sequence), offset);\n        this.position = offset + sequence.byteLength > this.position ? offset + sequence.length : this.position;\n      } else if (typeof sequence === \"string\") {\n        this.buffer.write(sequence, offset, sequence.length, \"binary\");\n        this.position = offset + sequence.length > this.position ? offset + sequence.length : this.position;\n      }\n    };\n    Binary2.prototype.read = function(position, length) {\n      length = length && length > 0 ? length : this.position;\n      return this.buffer.slice(position, position + length);\n    };\n    Binary2.prototype.value = function(asRaw) {\n      asRaw = !!asRaw;\n      if (asRaw && this.buffer.length === this.position) {\n        return this.buffer;\n      }\n      if (asRaw) {\n        return this.buffer.slice(0, this.position);\n      }\n      return this.buffer.toString(\"binary\", 0, this.position);\n    };\n    Binary2.prototype.length = function() {\n      return this.position;\n    };\n    Binary2.prototype.toJSON = function() {\n      return this.buffer.toString(\"base64\");\n    };\n    Binary2.prototype.toString = function(format) {\n      return this.buffer.toString(format);\n    };\n    Binary2.prototype.toExtendedJSON = function(options) {\n      options = options || {};\n      var base64String = this.buffer.toString(\"base64\");\n      var subType = Number(this.sub_type).toString(16);\n      if (options.legacy) {\n        return {\n          $binary: base64String,\n          $type: subType.length === 1 ? \"0\" + subType : subType\n        };\n      }\n      return {\n        $binary: {\n          base64: base64String,\n          subType: subType.length === 1 ? \"0\" + subType : subType\n        }\n      };\n    };\n    Binary2.prototype.toUUID = function() {\n      if (this.sub_type === Binary2.SUBTYPE_UUID) {\n        return new UUID(this.buffer.slice(0, this.position));\n      }\n      throw new BSONError('Binary sub_type \"'.concat(this.sub_type, '\" is not supported for converting to UUID. Only \"').concat(Binary2.SUBTYPE_UUID, '\" is currently supported.'));\n    };\n    Binary2.fromExtendedJSON = function(doc, options) {\n      options = options || {};\n      var data;\n      var type;\n      if (\"$binary\" in doc) {\n        if (options.legacy && typeof doc.$binary === \"string\" && \"$type\" in doc) {\n          type = doc.$type ? parseInt(doc.$type, 16) : 0;\n          data = buffer_1.from(doc.$binary, \"base64\");\n        } else {\n          if (typeof doc.$binary !== \"string\") {\n            type = doc.$binary.subType ? parseInt(doc.$binary.subType, 16) : 0;\n            data = buffer_1.from(doc.$binary.base64, \"base64\");\n          }\n        }\n      } else if (\"$uuid\" in doc) {\n        type = 4;\n        data = uuidHexStringToBuffer(doc.$uuid);\n      }\n      if (!data) {\n        throw new BSONTypeError(\"Unexpected Binary Extended JSON format \".concat(JSON.stringify(doc)));\n      }\n      return type === BSON_BINARY_SUBTYPE_UUID_NEW ? new UUID(data) : new Binary2(data, type);\n    };\n    Binary2.prototype[Symbol.for(\"nodejs.util.inspect.custom\")] = function() {\n      return this.inspect();\n    };\n    Binary2.prototype.inspect = function() {\n      var asBuffer = this.value(true);\n      return 'new Binary(Buffer.from(\"'.concat(asBuffer.toString(\"hex\"), '\", \"hex\"), ').concat(this.sub_type, \")\");\n    };\n    Binary2.BSON_BINARY_SUBTYPE_DEFAULT = 0;\n    Binary2.BUFFER_SIZE = 256;\n    Binary2.SUBTYPE_DEFAULT = 0;\n    Binary2.SUBTYPE_FUNCTION = 1;\n    Binary2.SUBTYPE_BYTE_ARRAY = 2;\n    Binary2.SUBTYPE_UUID_OLD = 3;\n    Binary2.SUBTYPE_UUID = 4;\n    Binary2.SUBTYPE_MD5 = 5;\n    Binary2.SUBTYPE_ENCRYPTED = 6;\n    Binary2.SUBTYPE_COLUMN = 7;\n    Binary2.SUBTYPE_USER_DEFINED = 128;\n    return Binary2;\n  }()\n);\nObject.defineProperty(Binary.prototype, \"_bsontype\", { value: \"Binary\" });\nvar UUID_BYTE_LENGTH = 16;\nvar UUID = (\n  /** @class */\n  function(_super) {\n    __extends(UUID2, _super);\n    function UUID2(input) {\n      var _this = this;\n      var bytes;\n      var hexStr;\n      if (input == null) {\n        bytes = UUID2.generate();\n      } else if (input instanceof UUID2) {\n        bytes = buffer_1.from(input.buffer);\n        hexStr = input.__id;\n      } else if (ArrayBuffer.isView(input) && input.byteLength === UUID_BYTE_LENGTH) {\n        bytes = ensureBuffer(input);\n      } else if (typeof input === \"string\") {\n        bytes = uuidHexStringToBuffer(input);\n      } else {\n        throw new BSONTypeError(\"Argument passed in UUID constructor must be a UUID, a 16 byte Buffer or a 32/36 character hex string (dashes excluded/included, format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx).\");\n      }\n      _this = _super.call(this, bytes, BSON_BINARY_SUBTYPE_UUID_NEW) || this;\n      _this.__id = hexStr;\n      return _this;\n    }\n    Object.defineProperty(UUID2.prototype, \"id\", {\n      /**\n       * The UUID bytes\n       * @readonly\n       */\n      get: function() {\n        return this.buffer;\n      },\n      set: function(value) {\n        this.buffer = value;\n        if (UUID2.cacheHexString) {\n          this.__id = bufferToUuidHexString(value);\n        }\n      },\n      enumerable: false,\n      configurable: true\n    });\n    UUID2.prototype.toHexString = function(includeDashes) {\n      if (includeDashes === void 0) {\n        includeDashes = true;\n      }\n      if (UUID2.cacheHexString && this.__id) {\n        return this.__id;\n      }\n      var uuidHexString = bufferToUuidHexString(this.id, includeDashes);\n      if (UUID2.cacheHexString) {\n        this.__id = uuidHexString;\n      }\n      return uuidHexString;\n    };\n    UUID2.prototype.toString = function(encoding) {\n      return encoding ? this.id.toString(encoding) : this.toHexString();\n    };\n    UUID2.prototype.toJSON = function() {\n      return this.toHexString();\n    };\n    UUID2.prototype.equals = function(otherId) {\n      if (!otherId) {\n        return false;\n      }\n      if (otherId instanceof UUID2) {\n        return otherId.id.equals(this.id);\n      }\n      try {\n        return new UUID2(otherId).id.equals(this.id);\n      } catch (_a) {\n        return false;\n      }\n    };\n    UUID2.prototype.toBinary = function() {\n      return new Binary(this.id, Binary.SUBTYPE_UUID);\n    };\n    UUID2.generate = function() {\n      var bytes = randomBytes(UUID_BYTE_LENGTH);\n      bytes[6] = bytes[6] & 15 | 64;\n      bytes[8] = bytes[8] & 63 | 128;\n      return buffer_1.from(bytes);\n    };\n    UUID2.isValid = function(input) {\n      if (!input) {\n        return false;\n      }\n      if (input instanceof UUID2) {\n        return true;\n      }\n      if (typeof input === \"string\") {\n        return uuidValidateString(input);\n      }\n      if (isUint8Array(input)) {\n        if (input.length !== UUID_BYTE_LENGTH) {\n          return false;\n        }\n        return (input[6] & 240) === 64 && (input[8] & 128) === 128;\n      }\n      return false;\n    };\n    UUID2.createFromHexString = function(hexString) {\n      var buffer2 = uuidHexStringToBuffer(hexString);\n      return new UUID2(buffer2);\n    };\n    UUID2.prototype[Symbol.for(\"nodejs.util.inspect.custom\")] = function() {\n      return this.inspect();\n    };\n    UUID2.prototype.inspect = function() {\n      return 'new UUID(\"'.concat(this.toHexString(), '\")');\n    };\n    return UUID2;\n  }(Binary)\n);\nvar Code = (\n  /** @class */\n  function() {\n    function Code2(code2, scope) {\n      if (!(this instanceof Code2))\n        return new Code2(code2, scope);\n      this.code = code2;\n      this.scope = scope;\n    }\n    Code2.prototype.toJSON = function() {\n      return { code: this.code, scope: this.scope };\n    };\n    Code2.prototype.toExtendedJSON = function() {\n      if (this.scope) {\n        return { $code: this.code, $scope: this.scope };\n      }\n      return { $code: this.code };\n    };\n    Code2.fromExtendedJSON = function(doc) {\n      return new Code2(doc.$code, doc.$scope);\n    };\n    Code2.prototype[Symbol.for(\"nodejs.util.inspect.custom\")] = function() {\n      return this.inspect();\n    };\n    Code2.prototype.inspect = function() {\n      var codeJson = this.toJSON();\n      return 'new Code(\"'.concat(String(codeJson.code), '\"').concat(codeJson.scope ? \", \".concat(JSON.stringify(codeJson.scope)) : \"\", \")\");\n    };\n    return Code2;\n  }()\n);\nObject.defineProperty(Code.prototype, \"_bsontype\", { value: \"Code\" });\nfunction isDBRefLike(value) {\n  return isObjectLike(value) && value.$id != null && typeof value.$ref === \"string\" && (value.$db == null || typeof value.$db === \"string\");\n}\nvar DBRef = (\n  /** @class */\n  function() {\n    function DBRef2(collection, oid, db, fields) {\n      if (!(this instanceof DBRef2))\n        return new DBRef2(collection, oid, db, fields);\n      var parts = collection.split(\".\");\n      if (parts.length === 2) {\n        db = parts.shift();\n        collection = parts.shift();\n      }\n      this.collection = collection;\n      this.oid = oid;\n      this.db = db;\n      this.fields = fields || {};\n    }\n    Object.defineProperty(DBRef2.prototype, \"namespace\", {\n      // Property provided for compatibility with the 1.x parser\n      // the 1.x parser used a \"namespace\" property, while 4.x uses \"collection\"\n      /** @internal */\n      get: function() {\n        return this.collection;\n      },\n      set: function(value) {\n        this.collection = value;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    DBRef2.prototype.toJSON = function() {\n      var o = Object.assign({\n        $ref: this.collection,\n        $id: this.oid\n      }, this.fields);\n      if (this.db != null)\n        o.$db = this.db;\n      return o;\n    };\n    DBRef2.prototype.toExtendedJSON = function(options) {\n      options = options || {};\n      var o = {\n        $ref: this.collection,\n        $id: this.oid\n      };\n      if (options.legacy) {\n        return o;\n      }\n      if (this.db)\n        o.$db = this.db;\n      o = Object.assign(o, this.fields);\n      return o;\n    };\n    DBRef2.fromExtendedJSON = function(doc) {\n      var copy = Object.assign({}, doc);\n      delete copy.$ref;\n      delete copy.$id;\n      delete copy.$db;\n      return new DBRef2(doc.$ref, doc.$id, doc.$db, copy);\n    };\n    DBRef2.prototype[Symbol.for(\"nodejs.util.inspect.custom\")] = function() {\n      return this.inspect();\n    };\n    DBRef2.prototype.inspect = function() {\n      var oid = this.oid === void 0 || this.oid.toString === void 0 ? this.oid : this.oid.toString();\n      return 'new DBRef(\"'.concat(this.namespace, '\", new ObjectId(\"').concat(String(oid), '\")').concat(this.db ? ', \"'.concat(this.db, '\"') : \"\", \")\");\n    };\n    return DBRef2;\n  }()\n);\nObject.defineProperty(DBRef.prototype, \"_bsontype\", { value: \"DBRef\" });\nvar wasm = void 0;\ntry {\n  wasm = new WebAssembly.Instance(new WebAssembly.Module(\n    // prettier-ignore\n    new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])\n  ), {}).exports;\n} catch (_a) {\n}\nvar TWO_PWR_16_DBL = 1 << 16;\nvar TWO_PWR_24_DBL = 1 << 24;\nvar TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\nvar TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\nvar TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\nvar INT_CACHE = {};\nvar UINT_CACHE = {};\nvar Long = (\n  /** @class */\n  function() {\n    function Long2(low, high, unsigned) {\n      if (low === void 0) {\n        low = 0;\n      }\n      if (!(this instanceof Long2))\n        return new Long2(low, high, unsigned);\n      if (typeof low === \"bigint\") {\n        Object.assign(this, Long2.fromBigInt(low, !!high));\n      } else if (typeof low === \"string\") {\n        Object.assign(this, Long2.fromString(low, !!high));\n      } else {\n        this.low = low | 0;\n        this.high = high | 0;\n        this.unsigned = !!unsigned;\n      }\n      Object.defineProperty(this, \"__isLong__\", {\n        value: true,\n        configurable: false,\n        writable: false,\n        enumerable: false\n      });\n    }\n    Long2.fromBits = function(lowBits, highBits, unsigned) {\n      return new Long2(lowBits, highBits, unsigned);\n    };\n    Long2.fromInt = function(value, unsigned) {\n      var obj, cachedObj, cache;\n      if (unsigned) {\n        value >>>= 0;\n        if (cache = 0 <= value && value < 256) {\n          cachedObj = UINT_CACHE[value];\n          if (cachedObj)\n            return cachedObj;\n        }\n        obj = Long2.fromBits(value, (value | 0) < 0 ? -1 : 0, true);\n        if (cache)\n          UINT_CACHE[value] = obj;\n        return obj;\n      } else {\n        value |= 0;\n        if (cache = -128 <= value && value < 128) {\n          cachedObj = INT_CACHE[value];\n          if (cachedObj)\n            return cachedObj;\n        }\n        obj = Long2.fromBits(value, value < 0 ? -1 : 0, false);\n        if (cache)\n          INT_CACHE[value] = obj;\n        return obj;\n      }\n    };\n    Long2.fromNumber = function(value, unsigned) {\n      if (isNaN(value))\n        return unsigned ? Long2.UZERO : Long2.ZERO;\n      if (unsigned) {\n        if (value < 0)\n          return Long2.UZERO;\n        if (value >= TWO_PWR_64_DBL)\n          return Long2.MAX_UNSIGNED_VALUE;\n      } else {\n        if (value <= -TWO_PWR_63_DBL)\n          return Long2.MIN_VALUE;\n        if (value + 1 >= TWO_PWR_63_DBL)\n          return Long2.MAX_VALUE;\n      }\n      if (value < 0)\n        return Long2.fromNumber(-value, unsigned).neg();\n      return Long2.fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);\n    };\n    Long2.fromBigInt = function(value, unsigned) {\n      return Long2.fromString(value.toString(), unsigned);\n    };\n    Long2.fromString = function(str, unsigned, radix) {\n      if (str.length === 0)\n        throw Error(\"empty string\");\n      if (str === \"NaN\" || str === \"Infinity\" || str === \"+Infinity\" || str === \"-Infinity\")\n        return Long2.ZERO;\n      if (typeof unsigned === \"number\") {\n        radix = unsigned, unsigned = false;\n      } else {\n        unsigned = !!unsigned;\n      }\n      radix = radix || 10;\n      if (radix < 2 || 36 < radix)\n        throw RangeError(\"radix\");\n      var p;\n      if ((p = str.indexOf(\"-\")) > 0)\n        throw Error(\"interior hyphen\");\n      else if (p === 0) {\n        return Long2.fromString(str.substring(1), unsigned, radix).neg();\n      }\n      var radixToPower = Long2.fromNumber(Math.pow(radix, 8));\n      var result = Long2.ZERO;\n      for (var i = 0; i < str.length; i += 8) {\n        var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);\n        if (size < 8) {\n          var power = Long2.fromNumber(Math.pow(radix, size));\n          result = result.mul(power).add(Long2.fromNumber(value));\n        } else {\n          result = result.mul(radixToPower);\n          result = result.add(Long2.fromNumber(value));\n        }\n      }\n      result.unsigned = unsigned;\n      return result;\n    };\n    Long2.fromBytes = function(bytes, unsigned, le) {\n      return le ? Long2.fromBytesLE(bytes, unsigned) : Long2.fromBytesBE(bytes, unsigned);\n    };\n    Long2.fromBytesLE = function(bytes, unsigned) {\n      return new Long2(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);\n    };\n    Long2.fromBytesBE = function(bytes, unsigned) {\n      return new Long2(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);\n    };\n    Long2.isLong = function(value) {\n      return isObjectLike(value) && value[\"__isLong__\"] === true;\n    };\n    Long2.fromValue = function(val, unsigned) {\n      if (typeof val === \"number\")\n        return Long2.fromNumber(val, unsigned);\n      if (typeof val === \"string\")\n        return Long2.fromString(val, unsigned);\n      return Long2.fromBits(val.low, val.high, typeof unsigned === \"boolean\" ? unsigned : val.unsigned);\n    };\n    Long2.prototype.add = function(addend) {\n      if (!Long2.isLong(addend))\n        addend = Long2.fromValue(addend);\n      var a48 = this.high >>> 16;\n      var a32 = this.high & 65535;\n      var a16 = this.low >>> 16;\n      var a00 = this.low & 65535;\n      var b48 = addend.high >>> 16;\n      var b32 = addend.high & 65535;\n      var b16 = addend.low >>> 16;\n      var b00 = addend.low & 65535;\n      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n      c00 += a00 + b00;\n      c16 += c00 >>> 16;\n      c00 &= 65535;\n      c16 += a16 + b16;\n      c32 += c16 >>> 16;\n      c16 &= 65535;\n      c32 += a32 + b32;\n      c48 += c32 >>> 16;\n      c32 &= 65535;\n      c48 += a48 + b48;\n      c48 &= 65535;\n      return Long2.fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);\n    };\n    Long2.prototype.and = function(other) {\n      if (!Long2.isLong(other))\n        other = Long2.fromValue(other);\n      return Long2.fromBits(this.low & other.low, this.high & other.high, this.unsigned);\n    };\n    Long2.prototype.compare = function(other) {\n      if (!Long2.isLong(other))\n        other = Long2.fromValue(other);\n      if (this.eq(other))\n        return 0;\n      var thisNeg = this.isNegative(), otherNeg = other.isNegative();\n      if (thisNeg && !otherNeg)\n        return -1;\n      if (!thisNeg && otherNeg)\n        return 1;\n      if (!this.unsigned)\n        return this.sub(other).isNegative() ? -1 : 1;\n      return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;\n    };\n    Long2.prototype.comp = function(other) {\n      return this.compare(other);\n    };\n    Long2.prototype.divide = function(divisor) {\n      if (!Long2.isLong(divisor))\n        divisor = Long2.fromValue(divisor);\n      if (divisor.isZero())\n        throw Error(\"division by zero\");\n      if (wasm) {\n        if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {\n          return this;\n        }\n        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(this.low, this.high, divisor.low, divisor.high);\n        return Long2.fromBits(low, wasm.get_high(), this.unsigned);\n      }\n      if (this.isZero())\n        return this.unsigned ? Long2.UZERO : Long2.ZERO;\n      var approx, rem, res;\n      if (!this.unsigned) {\n        if (this.eq(Long2.MIN_VALUE)) {\n          if (divisor.eq(Long2.ONE) || divisor.eq(Long2.NEG_ONE))\n            return Long2.MIN_VALUE;\n          else if (divisor.eq(Long2.MIN_VALUE))\n            return Long2.ONE;\n          else {\n            var halfThis = this.shr(1);\n            approx = halfThis.div(divisor).shl(1);\n            if (approx.eq(Long2.ZERO)) {\n              return divisor.isNegative() ? Long2.ONE : Long2.NEG_ONE;\n            } else {\n              rem = this.sub(divisor.mul(approx));\n              res = approx.add(rem.div(divisor));\n              return res;\n            }\n          }\n        } else if (divisor.eq(Long2.MIN_VALUE))\n          return this.unsigned ? Long2.UZERO : Long2.ZERO;\n        if (this.isNegative()) {\n          if (divisor.isNegative())\n            return this.neg().div(divisor.neg());\n          return this.neg().div(divisor).neg();\n        } else if (divisor.isNegative())\n          return this.div(divisor.neg()).neg();\n        res = Long2.ZERO;\n      } else {\n        if (!divisor.unsigned)\n          divisor = divisor.toUnsigned();\n        if (divisor.gt(this))\n          return Long2.UZERO;\n        if (divisor.gt(this.shru(1)))\n          return Long2.UONE;\n        res = Long2.UZERO;\n      }\n      rem = this;\n      while (rem.gte(divisor)) {\n        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));\n        var log2 = Math.ceil(Math.log(approx) / Math.LN2);\n        var delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);\n        var approxRes = Long2.fromNumber(approx);\n        var approxRem = approxRes.mul(divisor);\n        while (approxRem.isNegative() || approxRem.gt(rem)) {\n          approx -= delta;\n          approxRes = Long2.fromNumber(approx, this.unsigned);\n          approxRem = approxRes.mul(divisor);\n        }\n        if (approxRes.isZero())\n          approxRes = Long2.ONE;\n        res = res.add(approxRes);\n        rem = rem.sub(approxRem);\n      }\n      return res;\n    };\n    Long2.prototype.div = function(divisor) {\n      return this.divide(divisor);\n    };\n    Long2.prototype.equals = function(other) {\n      if (!Long2.isLong(other))\n        other = Long2.fromValue(other);\n      if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)\n        return false;\n      return this.high === other.high && this.low === other.low;\n    };\n    Long2.prototype.eq = function(other) {\n      return this.equals(other);\n    };\n    Long2.prototype.getHighBits = function() {\n      return this.high;\n    };\n    Long2.prototype.getHighBitsUnsigned = function() {\n      return this.high >>> 0;\n    };\n    Long2.prototype.getLowBits = function() {\n      return this.low;\n    };\n    Long2.prototype.getLowBitsUnsigned = function() {\n      return this.low >>> 0;\n    };\n    Long2.prototype.getNumBitsAbs = function() {\n      if (this.isNegative()) {\n        return this.eq(Long2.MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\n      }\n      var val = this.high !== 0 ? this.high : this.low;\n      var bit;\n      for (bit = 31; bit > 0; bit--)\n        if ((val & 1 << bit) !== 0)\n          break;\n      return this.high !== 0 ? bit + 33 : bit + 1;\n    };\n    Long2.prototype.greaterThan = function(other) {\n      return this.comp(other) > 0;\n    };\n    Long2.prototype.gt = function(other) {\n      return this.greaterThan(other);\n    };\n    Long2.prototype.greaterThanOrEqual = function(other) {\n      return this.comp(other) >= 0;\n    };\n    Long2.prototype.gte = function(other) {\n      return this.greaterThanOrEqual(other);\n    };\n    Long2.prototype.ge = function(other) {\n      return this.greaterThanOrEqual(other);\n    };\n    Long2.prototype.isEven = function() {\n      return (this.low & 1) === 0;\n    };\n    Long2.prototype.isNegative = function() {\n      return !this.unsigned && this.high < 0;\n    };\n    Long2.prototype.isOdd = function() {\n      return (this.low & 1) === 1;\n    };\n    Long2.prototype.isPositive = function() {\n      return this.unsigned || this.high >= 0;\n    };\n    Long2.prototype.isZero = function() {\n      return this.high === 0 && this.low === 0;\n    };\n    Long2.prototype.lessThan = function(other) {\n      return this.comp(other) < 0;\n    };\n    Long2.prototype.lt = function(other) {\n      return this.lessThan(other);\n    };\n    Long2.prototype.lessThanOrEqual = function(other) {\n      return this.comp(other) <= 0;\n    };\n    Long2.prototype.lte = function(other) {\n      return this.lessThanOrEqual(other);\n    };\n    Long2.prototype.modulo = function(divisor) {\n      if (!Long2.isLong(divisor))\n        divisor = Long2.fromValue(divisor);\n      if (wasm) {\n        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(this.low, this.high, divisor.low, divisor.high);\n        return Long2.fromBits(low, wasm.get_high(), this.unsigned);\n      }\n      return this.sub(this.div(divisor).mul(divisor));\n    };\n    Long2.prototype.mod = function(divisor) {\n      return this.modulo(divisor);\n    };\n    Long2.prototype.rem = function(divisor) {\n      return this.modulo(divisor);\n    };\n    Long2.prototype.multiply = function(multiplier) {\n      if (this.isZero())\n        return Long2.ZERO;\n      if (!Long2.isLong(multiplier))\n        multiplier = Long2.fromValue(multiplier);\n      if (wasm) {\n        var low = wasm.mul(this.low, this.high, multiplier.low, multiplier.high);\n        return Long2.fromBits(low, wasm.get_high(), this.unsigned);\n      }\n      if (multiplier.isZero())\n        return Long2.ZERO;\n      if (this.eq(Long2.MIN_VALUE))\n        return multiplier.isOdd() ? Long2.MIN_VALUE : Long2.ZERO;\n      if (multiplier.eq(Long2.MIN_VALUE))\n        return this.isOdd() ? Long2.MIN_VALUE : Long2.ZERO;\n      if (this.isNegative()) {\n        if (multiplier.isNegative())\n          return this.neg().mul(multiplier.neg());\n        else\n          return this.neg().mul(multiplier).neg();\n      } else if (multiplier.isNegative())\n        return this.mul(multiplier.neg()).neg();\n      if (this.lt(Long2.TWO_PWR_24) && multiplier.lt(Long2.TWO_PWR_24))\n        return Long2.fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);\n      var a48 = this.high >>> 16;\n      var a32 = this.high & 65535;\n      var a16 = this.low >>> 16;\n      var a00 = this.low & 65535;\n      var b48 = multiplier.high >>> 16;\n      var b32 = multiplier.high & 65535;\n      var b16 = multiplier.low >>> 16;\n      var b00 = multiplier.low & 65535;\n      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n      c00 += a00 * b00;\n      c16 += c00 >>> 16;\n      c00 &= 65535;\n      c16 += a16 * b00;\n      c32 += c16 >>> 16;\n      c16 &= 65535;\n      c16 += a00 * b16;\n      c32 += c16 >>> 16;\n      c16 &= 65535;\n      c32 += a32 * b00;\n      c48 += c32 >>> 16;\n      c32 &= 65535;\n      c32 += a16 * b16;\n      c48 += c32 >>> 16;\n      c32 &= 65535;\n      c32 += a00 * b32;\n      c48 += c32 >>> 16;\n      c32 &= 65535;\n      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n      c48 &= 65535;\n      return Long2.fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);\n    };\n    Long2.prototype.mul = function(multiplier) {\n      return this.multiply(multiplier);\n    };\n    Long2.prototype.negate = function() {\n      if (!this.unsigned && this.eq(Long2.MIN_VALUE))\n        return Long2.MIN_VALUE;\n      return this.not().add(Long2.ONE);\n    };\n    Long2.prototype.neg = function() {\n      return this.negate();\n    };\n    Long2.prototype.not = function() {\n      return Long2.fromBits(~this.low, ~this.high, this.unsigned);\n    };\n    Long2.prototype.notEquals = function(other) {\n      return !this.equals(other);\n    };\n    Long2.prototype.neq = function(other) {\n      return this.notEquals(other);\n    };\n    Long2.prototype.ne = function(other) {\n      return this.notEquals(other);\n    };\n    Long2.prototype.or = function(other) {\n      if (!Long2.isLong(other))\n        other = Long2.fromValue(other);\n      return Long2.fromBits(this.low | other.low, this.high | other.high, this.unsigned);\n    };\n    Long2.prototype.shiftLeft = function(numBits) {\n      if (Long2.isLong(numBits))\n        numBits = numBits.toInt();\n      if ((numBits &= 63) === 0)\n        return this;\n      else if (numBits < 32)\n        return Long2.fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);\n      else\n        return Long2.fromBits(0, this.low << numBits - 32, this.unsigned);\n    };\n    Long2.prototype.shl = function(numBits) {\n      return this.shiftLeft(numBits);\n    };\n    Long2.prototype.shiftRight = function(numBits) {\n      if (Long2.isLong(numBits))\n        numBits = numBits.toInt();\n      if ((numBits &= 63) === 0)\n        return this;\n      else if (numBits < 32)\n        return Long2.fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);\n      else\n        return Long2.fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);\n    };\n    Long2.prototype.shr = function(numBits) {\n      return this.shiftRight(numBits);\n    };\n    Long2.prototype.shiftRightUnsigned = function(numBits) {\n      if (Long2.isLong(numBits))\n        numBits = numBits.toInt();\n      numBits &= 63;\n      if (numBits === 0)\n        return this;\n      else {\n        var high = this.high;\n        if (numBits < 32) {\n          var low = this.low;\n          return Long2.fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);\n        } else if (numBits === 32)\n          return Long2.fromBits(high, 0, this.unsigned);\n        else\n          return Long2.fromBits(high >>> numBits - 32, 0, this.unsigned);\n      }\n    };\n    Long2.prototype.shr_u = function(numBits) {\n      return this.shiftRightUnsigned(numBits);\n    };\n    Long2.prototype.shru = function(numBits) {\n      return this.shiftRightUnsigned(numBits);\n    };\n    Long2.prototype.subtract = function(subtrahend) {\n      if (!Long2.isLong(subtrahend))\n        subtrahend = Long2.fromValue(subtrahend);\n      return this.add(subtrahend.neg());\n    };\n    Long2.prototype.sub = function(subtrahend) {\n      return this.subtract(subtrahend);\n    };\n    Long2.prototype.toInt = function() {\n      return this.unsigned ? this.low >>> 0 : this.low;\n    };\n    Long2.prototype.toNumber = function() {\n      if (this.unsigned)\n        return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);\n      return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\n    };\n    Long2.prototype.toBigInt = function() {\n      return BigInt(this.toString());\n    };\n    Long2.prototype.toBytes = function(le) {\n      return le ? this.toBytesLE() : this.toBytesBE();\n    };\n    Long2.prototype.toBytesLE = function() {\n      var hi = this.high, lo = this.low;\n      return [\n        lo & 255,\n        lo >>> 8 & 255,\n        lo >>> 16 & 255,\n        lo >>> 24,\n        hi & 255,\n        hi >>> 8 & 255,\n        hi >>> 16 & 255,\n        hi >>> 24\n      ];\n    };\n    Long2.prototype.toBytesBE = function() {\n      var hi = this.high, lo = this.low;\n      return [\n        hi >>> 24,\n        hi >>> 16 & 255,\n        hi >>> 8 & 255,\n        hi & 255,\n        lo >>> 24,\n        lo >>> 16 & 255,\n        lo >>> 8 & 255,\n        lo & 255\n      ];\n    };\n    Long2.prototype.toSigned = function() {\n      if (!this.unsigned)\n        return this;\n      return Long2.fromBits(this.low, this.high, false);\n    };\n    Long2.prototype.toString = function(radix) {\n      radix = radix || 10;\n      if (radix < 2 || 36 < radix)\n        throw RangeError(\"radix\");\n      if (this.isZero())\n        return \"0\";\n      if (this.isNegative()) {\n        if (this.eq(Long2.MIN_VALUE)) {\n          var radixLong = Long2.fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);\n          return div.toString(radix) + rem1.toInt().toString(radix);\n        } else\n          return \"-\" + this.neg().toString(radix);\n      }\n      var radixToPower = Long2.fromNumber(Math.pow(radix, 6), this.unsigned);\n      var rem = this;\n      var result = \"\";\n      while (true) {\n        var remDiv = rem.div(radixToPower);\n        var intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0;\n        var digits = intval.toString(radix);\n        rem = remDiv;\n        if (rem.isZero()) {\n          return digits + result;\n        } else {\n          while (digits.length < 6)\n            digits = \"0\" + digits;\n          result = \"\" + digits + result;\n        }\n      }\n    };\n    Long2.prototype.toUnsigned = function() {\n      if (this.unsigned)\n        return this;\n      return Long2.fromBits(this.low, this.high, true);\n    };\n    Long2.prototype.xor = function(other) {\n      if (!Long2.isLong(other))\n        other = Long2.fromValue(other);\n      return Long2.fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\n    };\n    Long2.prototype.eqz = function() {\n      return this.isZero();\n    };\n    Long2.prototype.le = function(other) {\n      return this.lessThanOrEqual(other);\n    };\n    Long2.prototype.toExtendedJSON = function(options) {\n      if (options && options.relaxed)\n        return this.toNumber();\n      return { $numberLong: this.toString() };\n    };\n    Long2.fromExtendedJSON = function(doc, options) {\n      var result = Long2.fromString(doc.$numberLong);\n      return options && options.relaxed ? result.toNumber() : result;\n    };\n    Long2.prototype[Symbol.for(\"nodejs.util.inspect.custom\")] = function() {\n      return this.inspect();\n    };\n    Long2.prototype.inspect = function() {\n      return 'new Long(\"'.concat(this.toString(), '\"').concat(this.unsigned ? \", true\" : \"\", \")\");\n    };\n    Long2.TWO_PWR_24 = Long2.fromInt(TWO_PWR_24_DBL);\n    Long2.MAX_UNSIGNED_VALUE = Long2.fromBits(4294967295 | 0, 4294967295 | 0, true);\n    Long2.ZERO = Long2.fromInt(0);\n    Long2.UZERO = Long2.fromInt(0, true);\n    Long2.ONE = Long2.fromInt(1);\n    Long2.UONE = Long2.fromInt(1, true);\n    Long2.NEG_ONE = Long2.fromInt(-1);\n    Long2.MAX_VALUE = Long2.fromBits(4294967295 | 0, 2147483647 | 0, false);\n    Long2.MIN_VALUE = Long2.fromBits(0, 2147483648 | 0, false);\n    return Long2;\n  }()\n);\nObject.defineProperty(Long.prototype, \"__isLong__\", { value: true });\nObject.defineProperty(Long.prototype, \"_bsontype\", { value: \"Long\" });\nvar PARSE_STRING_REGEXP = /^(\\+|-)?(\\d+|(\\d*\\.\\d*))?(E|e)?([-+])?(\\d+)?$/;\nvar PARSE_INF_REGEXP = /^(\\+|-)?(Infinity|inf)$/i;\nvar PARSE_NAN_REGEXP = /^(\\+|-)?NaN$/i;\nvar EXPONENT_MAX = 6111;\nvar EXPONENT_MIN = -6176;\nvar EXPONENT_BIAS = 6176;\nvar MAX_DIGITS = 34;\nvar NAN_BUFFER = [\n  124,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0\n].reverse();\nvar INF_NEGATIVE_BUFFER = [\n  248,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0\n].reverse();\nvar INF_POSITIVE_BUFFER = [\n  120,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0\n].reverse();\nvar EXPONENT_REGEX = /^([-+])?(\\d+)?$/;\nvar COMBINATION_MASK = 31;\nvar EXPONENT_MASK = 16383;\nvar COMBINATION_INFINITY = 30;\nvar COMBINATION_NAN = 31;\nfunction isDigit(value) {\n  return !isNaN(parseInt(value, 10));\n}\nfunction divideu128(value) {\n  var DIVISOR = Long.fromNumber(1e3 * 1e3 * 1e3);\n  var _rem = Long.fromNumber(0);\n  if (!value.parts[0] && !value.parts[1] && !value.parts[2] && !value.parts[3]) {\n    return { quotient: value, rem: _rem };\n  }\n  for (var i = 0; i <= 3; i++) {\n    _rem = _rem.shiftLeft(32);\n    _rem = _rem.add(new Long(value.parts[i], 0));\n    value.parts[i] = _rem.div(DIVISOR).low;\n    _rem = _rem.modulo(DIVISOR);\n  }\n  return { quotient: value, rem: _rem };\n}\nfunction multiply64x2(left, right) {\n  if (!left && !right) {\n    return { high: Long.fromNumber(0), low: Long.fromNumber(0) };\n  }\n  var leftHigh = left.shiftRightUnsigned(32);\n  var leftLow = new Long(left.getLowBits(), 0);\n  var rightHigh = right.shiftRightUnsigned(32);\n  var rightLow = new Long(right.getLowBits(), 0);\n  var productHigh = leftHigh.multiply(rightHigh);\n  var productMid = leftHigh.multiply(rightLow);\n  var productMid2 = leftLow.multiply(rightHigh);\n  var productLow = leftLow.multiply(rightLow);\n  productHigh = productHigh.add(productMid.shiftRightUnsigned(32));\n  productMid = new Long(productMid.getLowBits(), 0).add(productMid2).add(productLow.shiftRightUnsigned(32));\n  productHigh = productHigh.add(productMid.shiftRightUnsigned(32));\n  productLow = productMid.shiftLeft(32).add(new Long(productLow.getLowBits(), 0));\n  return { high: productHigh, low: productLow };\n}\nfunction lessThan(left, right) {\n  var uhleft = left.high >>> 0;\n  var uhright = right.high >>> 0;\n  if (uhleft < uhright) {\n    return true;\n  } else if (uhleft === uhright) {\n    var ulleft = left.low >>> 0;\n    var ulright = right.low >>> 0;\n    if (ulleft < ulright)\n      return true;\n  }\n  return false;\n}\nfunction invalidErr(string, message) {\n  throw new BSONTypeError('\"'.concat(string, '\" is not a valid Decimal128 string - ').concat(message));\n}\nvar Decimal128 = (\n  /** @class */\n  function() {\n    function Decimal1282(bytes) {\n      if (!(this instanceof Decimal1282))\n        return new Decimal1282(bytes);\n      if (typeof bytes === \"string\") {\n        this.bytes = Decimal1282.fromString(bytes).bytes;\n      } else if (isUint8Array(bytes)) {\n        if (bytes.byteLength !== 16) {\n          throw new BSONTypeError(\"Decimal128 must take a Buffer of 16 bytes\");\n        }\n        this.bytes = bytes;\n      } else {\n        throw new BSONTypeError(\"Decimal128 must take a Buffer or string\");\n      }\n    }\n    Decimal1282.fromString = function(representation) {\n      var isNegative = false;\n      var sawRadix = false;\n      var foundNonZero = false;\n      var significantDigits = 0;\n      var nDigitsRead = 0;\n      var nDigits = 0;\n      var radixPosition = 0;\n      var firstNonZero = 0;\n      var digits = [0];\n      var nDigitsStored = 0;\n      var digitsInsert = 0;\n      var firstDigit = 0;\n      var lastDigit = 0;\n      var exponent = 0;\n      var i = 0;\n      var significandHigh = new Long(0, 0);\n      var significandLow = new Long(0, 0);\n      var biasedExponent = 0;\n      var index = 0;\n      if (representation.length >= 7e3) {\n        throw new BSONTypeError(\"\" + representation + \" not a valid Decimal128 string\");\n      }\n      var stringMatch = representation.match(PARSE_STRING_REGEXP);\n      var infMatch = representation.match(PARSE_INF_REGEXP);\n      var nanMatch = representation.match(PARSE_NAN_REGEXP);\n      if (!stringMatch && !infMatch && !nanMatch || representation.length === 0) {\n        throw new BSONTypeError(\"\" + representation + \" not a valid Decimal128 string\");\n      }\n      if (stringMatch) {\n        var unsignedNumber = stringMatch[2];\n        var e = stringMatch[4];\n        var expSign = stringMatch[5];\n        var expNumber = stringMatch[6];\n        if (e && expNumber === void 0)\n          invalidErr(representation, \"missing exponent power\");\n        if (e && unsignedNumber === void 0)\n          invalidErr(representation, \"missing exponent base\");\n        if (e === void 0 && (expSign || expNumber)) {\n          invalidErr(representation, \"missing e before exponent\");\n        }\n      }\n      if (representation[index] === \"+\" || representation[index] === \"-\") {\n        isNegative = representation[index++] === \"-\";\n      }\n      if (!isDigit(representation[index]) && representation[index] !== \".\") {\n        if (representation[index] === \"i\" || representation[index] === \"I\") {\n          return new Decimal1282(buffer_1.from(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER));\n        } else if (representation[index] === \"N\") {\n          return new Decimal1282(buffer_1.from(NAN_BUFFER));\n        }\n      }\n      while (isDigit(representation[index]) || representation[index] === \".\") {\n        if (representation[index] === \".\") {\n          if (sawRadix)\n            invalidErr(representation, \"contains multiple periods\");\n          sawRadix = true;\n          index = index + 1;\n          continue;\n        }\n        if (nDigitsStored < 34) {\n          if (representation[index] !== \"0\" || foundNonZero) {\n            if (!foundNonZero) {\n              firstNonZero = nDigitsRead;\n            }\n            foundNonZero = true;\n            digits[digitsInsert++] = parseInt(representation[index], 10);\n            nDigitsStored = nDigitsStored + 1;\n          }\n        }\n        if (foundNonZero)\n          nDigits = nDigits + 1;\n        if (sawRadix)\n          radixPosition = radixPosition + 1;\n        nDigitsRead = nDigitsRead + 1;\n        index = index + 1;\n      }\n      if (sawRadix && !nDigitsRead)\n        throw new BSONTypeError(\"\" + representation + \" not a valid Decimal128 string\");\n      if (representation[index] === \"e\" || representation[index] === \"E\") {\n        var match = representation.substr(++index).match(EXPONENT_REGEX);\n        if (!match || !match[2])\n          return new Decimal1282(buffer_1.from(NAN_BUFFER));\n        exponent = parseInt(match[0], 10);\n        index = index + match[0].length;\n      }\n      if (representation[index])\n        return new Decimal1282(buffer_1.from(NAN_BUFFER));\n      firstDigit = 0;\n      if (!nDigitsStored) {\n        firstDigit = 0;\n        lastDigit = 0;\n        digits[0] = 0;\n        nDigits = 1;\n        nDigitsStored = 1;\n        significantDigits = 0;\n      } else {\n        lastDigit = nDigitsStored - 1;\n        significantDigits = nDigits;\n        if (significantDigits !== 1) {\n          while (digits[firstNonZero + significantDigits - 1] === 0) {\n            significantDigits = significantDigits - 1;\n          }\n        }\n      }\n      if (exponent <= radixPosition && radixPosition - exponent > 1 << 14) {\n        exponent = EXPONENT_MIN;\n      } else {\n        exponent = exponent - radixPosition;\n      }\n      while (exponent > EXPONENT_MAX) {\n        lastDigit = lastDigit + 1;\n        if (lastDigit - firstDigit > MAX_DIGITS) {\n          var digitsString = digits.join(\"\");\n          if (digitsString.match(/^0+$/)) {\n            exponent = EXPONENT_MAX;\n            break;\n          }\n          invalidErr(representation, \"overflow\");\n        }\n        exponent = exponent - 1;\n      }\n      while (exponent < EXPONENT_MIN || nDigitsStored < nDigits) {\n        if (lastDigit === 0 && significantDigits < nDigitsStored) {\n          exponent = EXPONENT_MIN;\n          significantDigits = 0;\n          break;\n        }\n        if (nDigitsStored < nDigits) {\n          nDigits = nDigits - 1;\n        } else {\n          lastDigit = lastDigit - 1;\n        }\n        if (exponent < EXPONENT_MAX) {\n          exponent = exponent + 1;\n        } else {\n          var digitsString = digits.join(\"\");\n          if (digitsString.match(/^0+$/)) {\n            exponent = EXPONENT_MAX;\n            break;\n          }\n          invalidErr(representation, \"overflow\");\n        }\n      }\n      if (lastDigit - firstDigit + 1 < significantDigits) {\n        var endOfString = nDigitsRead;\n        if (sawRadix) {\n          firstNonZero = firstNonZero + 1;\n          endOfString = endOfString + 1;\n        }\n        if (isNegative) {\n          firstNonZero = firstNonZero + 1;\n          endOfString = endOfString + 1;\n        }\n        var roundDigit = parseInt(representation[firstNonZero + lastDigit + 1], 10);\n        var roundBit = 0;\n        if (roundDigit >= 5) {\n          roundBit = 1;\n          if (roundDigit === 5) {\n            roundBit = digits[lastDigit] % 2 === 1 ? 1 : 0;\n            for (i = firstNonZero + lastDigit + 2; i < endOfString; i++) {\n              if (parseInt(representation[i], 10)) {\n                roundBit = 1;\n                break;\n              }\n            }\n          }\n        }\n        if (roundBit) {\n          var dIdx = lastDigit;\n          for (; dIdx >= 0; dIdx--) {\n            if (++digits[dIdx] > 9) {\n              digits[dIdx] = 0;\n              if (dIdx === 0) {\n                if (exponent < EXPONENT_MAX) {\n                  exponent = exponent + 1;\n                  digits[dIdx] = 1;\n                } else {\n                  return new Decimal1282(buffer_1.from(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER));\n                }\n              }\n            }\n          }\n        }\n      }\n      significandHigh = Long.fromNumber(0);\n      significandLow = Long.fromNumber(0);\n      if (significantDigits === 0) {\n        significandHigh = Long.fromNumber(0);\n        significandLow = Long.fromNumber(0);\n      } else if (lastDigit - firstDigit < 17) {\n        var dIdx = firstDigit;\n        significandLow = Long.fromNumber(digits[dIdx++]);\n        significandHigh = new Long(0, 0);\n        for (; dIdx <= lastDigit; dIdx++) {\n          significandLow = significandLow.multiply(Long.fromNumber(10));\n          significandLow = significandLow.add(Long.fromNumber(digits[dIdx]));\n        }\n      } else {\n        var dIdx = firstDigit;\n        significandHigh = Long.fromNumber(digits[dIdx++]);\n        for (; dIdx <= lastDigit - 17; dIdx++) {\n          significandHigh = significandHigh.multiply(Long.fromNumber(10));\n          significandHigh = significandHigh.add(Long.fromNumber(digits[dIdx]));\n        }\n        significandLow = Long.fromNumber(digits[dIdx++]);\n        for (; dIdx <= lastDigit; dIdx++) {\n          significandLow = significandLow.multiply(Long.fromNumber(10));\n          significandLow = significandLow.add(Long.fromNumber(digits[dIdx]));\n        }\n      }\n      var significand = multiply64x2(significandHigh, Long.fromString(\"100000000000000000\"));\n      significand.low = significand.low.add(significandLow);\n      if (lessThan(significand.low, significandLow)) {\n        significand.high = significand.high.add(Long.fromNumber(1));\n      }\n      biasedExponent = exponent + EXPONENT_BIAS;\n      var dec = { low: Long.fromNumber(0), high: Long.fromNumber(0) };\n      if (significand.high.shiftRightUnsigned(49).and(Long.fromNumber(1)).equals(Long.fromNumber(1))) {\n        dec.high = dec.high.or(Long.fromNumber(3).shiftLeft(61));\n        dec.high = dec.high.or(Long.fromNumber(biasedExponent).and(Long.fromNumber(16383).shiftLeft(47)));\n        dec.high = dec.high.or(significand.high.and(Long.fromNumber(140737488355327)));\n      } else {\n        dec.high = dec.high.or(Long.fromNumber(biasedExponent & 16383).shiftLeft(49));\n        dec.high = dec.high.or(significand.high.and(Long.fromNumber(562949953421311)));\n      }\n      dec.low = significand.low;\n      if (isNegative) {\n        dec.high = dec.high.or(Long.fromString(\"9223372036854775808\"));\n      }\n      var buffer2 = buffer_1.alloc(16);\n      index = 0;\n      buffer2[index++] = dec.low.low & 255;\n      buffer2[index++] = dec.low.low >> 8 & 255;\n      buffer2[index++] = dec.low.low >> 16 & 255;\n      buffer2[index++] = dec.low.low >> 24 & 255;\n      buffer2[index++] = dec.low.high & 255;\n      buffer2[index++] = dec.low.high >> 8 & 255;\n      buffer2[index++] = dec.low.high >> 16 & 255;\n      buffer2[index++] = dec.low.high >> 24 & 255;\n      buffer2[index++] = dec.high.low & 255;\n      buffer2[index++] = dec.high.low >> 8 & 255;\n      buffer2[index++] = dec.high.low >> 16 & 255;\n      buffer2[index++] = dec.high.low >> 24 & 255;\n      buffer2[index++] = dec.high.high & 255;\n      buffer2[index++] = dec.high.high >> 8 & 255;\n      buffer2[index++] = dec.high.high >> 16 & 255;\n      buffer2[index++] = dec.high.high >> 24 & 255;\n      return new Decimal1282(buffer2);\n    };\n    Decimal1282.prototype.toString = function() {\n      var biased_exponent;\n      var significand_digits = 0;\n      var significand = new Array(36);\n      for (var i = 0; i < significand.length; i++)\n        significand[i] = 0;\n      var index = 0;\n      var is_zero = false;\n      var significand_msb;\n      var significand128 = { parts: [0, 0, 0, 0] };\n      var j, k;\n      var string = [];\n      index = 0;\n      var buffer2 = this.bytes;\n      var low = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;\n      var midl = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;\n      var midh = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;\n      var high = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;\n      index = 0;\n      var dec = {\n        low: new Long(low, midl),\n        high: new Long(midh, high)\n      };\n      if (dec.high.lessThan(Long.ZERO)) {\n        string.push(\"-\");\n      }\n      var combination = high >> 26 & COMBINATION_MASK;\n      if (combination >> 3 === 3) {\n        if (combination === COMBINATION_INFINITY) {\n          return string.join(\"\") + \"Infinity\";\n        } else if (combination === COMBINATION_NAN) {\n          return \"NaN\";\n        } else {\n          biased_exponent = high >> 15 & EXPONENT_MASK;\n          significand_msb = 8 + (high >> 14 & 1);\n        }\n      } else {\n        significand_msb = high >> 14 & 7;\n        biased_exponent = high >> 17 & EXPONENT_MASK;\n      }\n      var exponent = biased_exponent - EXPONENT_BIAS;\n      significand128.parts[0] = (high & 16383) + ((significand_msb & 15) << 14);\n      significand128.parts[1] = midh;\n      significand128.parts[2] = midl;\n      significand128.parts[3] = low;\n      if (significand128.parts[0] === 0 && significand128.parts[1] === 0 && significand128.parts[2] === 0 && significand128.parts[3] === 0) {\n        is_zero = true;\n      } else {\n        for (k = 3; k >= 0; k--) {\n          var least_digits = 0;\n          var result = divideu128(significand128);\n          significand128 = result.quotient;\n          least_digits = result.rem.low;\n          if (!least_digits)\n            continue;\n          for (j = 8; j >= 0; j--) {\n            significand[k * 9 + j] = least_digits % 10;\n            least_digits = Math.floor(least_digits / 10);\n          }\n        }\n      }\n      if (is_zero) {\n        significand_digits = 1;\n        significand[index] = 0;\n      } else {\n        significand_digits = 36;\n        while (!significand[index]) {\n          significand_digits = significand_digits - 1;\n          index = index + 1;\n        }\n      }\n      var scientific_exponent = significand_digits - 1 + exponent;\n      if (scientific_exponent >= 34 || scientific_exponent <= -7 || exponent > 0) {\n        if (significand_digits > 34) {\n          string.push(\"\".concat(0));\n          if (exponent > 0)\n            string.push(\"E+\".concat(exponent));\n          else if (exponent < 0)\n            string.push(\"E\".concat(exponent));\n          return string.join(\"\");\n        }\n        string.push(\"\".concat(significand[index++]));\n        significand_digits = significand_digits - 1;\n        if (significand_digits) {\n          string.push(\".\");\n        }\n        for (var i = 0; i < significand_digits; i++) {\n          string.push(\"\".concat(significand[index++]));\n        }\n        string.push(\"E\");\n        if (scientific_exponent > 0) {\n          string.push(\"+\".concat(scientific_exponent));\n        } else {\n          string.push(\"\".concat(scientific_exponent));\n        }\n      } else {\n        if (exponent >= 0) {\n          for (var i = 0; i < significand_digits; i++) {\n            string.push(\"\".concat(significand[index++]));\n          }\n        } else {\n          var radix_position = significand_digits + exponent;\n          if (radix_position > 0) {\n            for (var i = 0; i < radix_position; i++) {\n              string.push(\"\".concat(significand[index++]));\n            }\n          } else {\n            string.push(\"0\");\n          }\n          string.push(\".\");\n          while (radix_position++ < 0) {\n            string.push(\"0\");\n          }\n          for (var i = 0; i < significand_digits - Math.max(radix_position - 1, 0); i++) {\n            string.push(\"\".concat(significand[index++]));\n          }\n        }\n      }\n      return string.join(\"\");\n    };\n    Decimal1282.prototype.toJSON = function() {\n      return { $numberDecimal: this.toString() };\n    };\n    Decimal1282.prototype.toExtendedJSON = function() {\n      return { $numberDecimal: this.toString() };\n    };\n    Decimal1282.fromExtendedJSON = function(doc) {\n      return Decimal1282.fromString(doc.$numberDecimal);\n    };\n    Decimal1282.prototype[Symbol.for(\"nodejs.util.inspect.custom\")] = function() {\n      return this.inspect();\n    };\n    Decimal1282.prototype.inspect = function() {\n      return 'new Decimal128(\"'.concat(this.toString(), '\")');\n    };\n    return Decimal1282;\n  }()\n);\nObject.defineProperty(Decimal128.prototype, \"_bsontype\", { value: \"Decimal128\" });\nvar Double = (\n  /** @class */\n  function() {\n    function Double2(value) {\n      if (!(this instanceof Double2))\n        return new Double2(value);\n      if (value instanceof Number) {\n        value = value.valueOf();\n      }\n      this.value = +value;\n    }\n    Double2.prototype.valueOf = function() {\n      return this.value;\n    };\n    Double2.prototype.toJSON = function() {\n      return this.value;\n    };\n    Double2.prototype.toString = function(radix) {\n      return this.value.toString(radix);\n    };\n    Double2.prototype.toExtendedJSON = function(options) {\n      if (options && (options.legacy || options.relaxed && isFinite(this.value))) {\n        return this.value;\n      }\n      if (Object.is(Math.sign(this.value), -0)) {\n        return { $numberDouble: \"-\".concat(this.value.toFixed(1)) };\n      }\n      return {\n        $numberDouble: Number.isInteger(this.value) ? this.value.toFixed(1) : this.value.toString()\n      };\n    };\n    Double2.fromExtendedJSON = function(doc, options) {\n      var doubleValue = parseFloat(doc.$numberDouble);\n      return options && options.relaxed ? doubleValue : new Double2(doubleValue);\n    };\n    Double2.prototype[Symbol.for(\"nodejs.util.inspect.custom\")] = function() {\n      return this.inspect();\n    };\n    Double2.prototype.inspect = function() {\n      var eJSON = this.toExtendedJSON();\n      return \"new Double(\".concat(eJSON.$numberDouble, \")\");\n    };\n    return Double2;\n  }()\n);\nObject.defineProperty(Double.prototype, \"_bsontype\", { value: \"Double\" });\nvar Int32 = (\n  /** @class */\n  function() {\n    function Int322(value) {\n      if (!(this instanceof Int322))\n        return new Int322(value);\n      if (value instanceof Number) {\n        value = value.valueOf();\n      }\n      this.value = +value | 0;\n    }\n    Int322.prototype.valueOf = function() {\n      return this.value;\n    };\n    Int322.prototype.toString = function(radix) {\n      return this.value.toString(radix);\n    };\n    Int322.prototype.toJSON = function() {\n      return this.value;\n    };\n    Int322.prototype.toExtendedJSON = function(options) {\n      if (options && (options.relaxed || options.legacy))\n        return this.value;\n      return { $numberInt: this.value.toString() };\n    };\n    Int322.fromExtendedJSON = function(doc, options) {\n      return options && options.relaxed ? parseInt(doc.$numberInt, 10) : new Int322(doc.$numberInt);\n    };\n    Int322.prototype[Symbol.for(\"nodejs.util.inspect.custom\")] = function() {\n      return this.inspect();\n    };\n    Int322.prototype.inspect = function() {\n      return \"new Int32(\".concat(this.valueOf(), \")\");\n    };\n    return Int322;\n  }()\n);\nObject.defineProperty(Int32.prototype, \"_bsontype\", { value: \"Int32\" });\nvar MaxKey = (\n  /** @class */\n  function() {\n    function MaxKey2() {\n      if (!(this instanceof MaxKey2))\n        return new MaxKey2();\n    }\n    MaxKey2.prototype.toExtendedJSON = function() {\n      return { $maxKey: 1 };\n    };\n    MaxKey2.fromExtendedJSON = function() {\n      return new MaxKey2();\n    };\n    MaxKey2.prototype[Symbol.for(\"nodejs.util.inspect.custom\")] = function() {\n      return this.inspect();\n    };\n    MaxKey2.prototype.inspect = function() {\n      return \"new MaxKey()\";\n    };\n    return MaxKey2;\n  }()\n);\nObject.defineProperty(MaxKey.prototype, \"_bsontype\", { value: \"MaxKey\" });\nvar MinKey = (\n  /** @class */\n  function() {\n    function MinKey2() {\n      if (!(this instanceof MinKey2))\n        return new MinKey2();\n    }\n    MinKey2.prototype.toExtendedJSON = function() {\n      return { $minKey: 1 };\n    };\n    MinKey2.fromExtendedJSON = function() {\n      return new MinKey2();\n    };\n    MinKey2.prototype[Symbol.for(\"nodejs.util.inspect.custom\")] = function() {\n      return this.inspect();\n    };\n    MinKey2.prototype.inspect = function() {\n      return \"new MinKey()\";\n    };\n    return MinKey2;\n  }()\n);\nObject.defineProperty(MinKey.prototype, \"_bsontype\", { value: \"MinKey\" });\nvar checkForHexRegExp = new RegExp(\"^[0-9a-fA-F]{24}$\");\nvar PROCESS_UNIQUE = null;\nvar kId = Symbol(\"id\");\nvar ObjectId = (\n  /** @class */\n  function() {\n    function ObjectId2(inputId) {\n      if (!(this instanceof ObjectId2))\n        return new ObjectId2(inputId);\n      var workingId;\n      if (typeof inputId === \"object\" && inputId && \"id\" in inputId) {\n        if (typeof inputId.id !== \"string\" && !ArrayBuffer.isView(inputId.id)) {\n          throw new BSONTypeError(\"Argument passed in must have an id that is of type string or Buffer\");\n        }\n        if (\"toHexString\" in inputId && typeof inputId.toHexString === \"function\") {\n          workingId = buffer_1.from(inputId.toHexString(), \"hex\");\n        } else {\n          workingId = inputId.id;\n        }\n      } else {\n        workingId = inputId;\n      }\n      if (workingId == null || typeof workingId === \"number\") {\n        this[kId] = ObjectId2.generate(typeof workingId === \"number\" ? workingId : void 0);\n      } else if (ArrayBuffer.isView(workingId) && workingId.byteLength === 12) {\n        this[kId] = workingId instanceof buffer_1 ? workingId : ensureBuffer(workingId);\n      } else if (typeof workingId === \"string\") {\n        if (workingId.length === 12) {\n          var bytes = buffer_1.from(workingId);\n          if (bytes.byteLength === 12) {\n            this[kId] = bytes;\n          } else {\n            throw new BSONTypeError(\"Argument passed in must be a string of 12 bytes\");\n          }\n        } else if (workingId.length === 24 && checkForHexRegExp.test(workingId)) {\n          this[kId] = buffer_1.from(workingId, \"hex\");\n        } else {\n          throw new BSONTypeError(\"Argument passed in must be a string of 12 bytes or a string of 24 hex characters or an integer\");\n        }\n      } else {\n        throw new BSONTypeError(\"Argument passed in does not match the accepted types\");\n      }\n      if (ObjectId2.cacheHexString) {\n        this.__id = this.id.toString(\"hex\");\n      }\n    }\n    Object.defineProperty(ObjectId2.prototype, \"id\", {\n      /**\n       * The ObjectId bytes\n       * @readonly\n       */\n      get: function() {\n        return this[kId];\n      },\n      set: function(value) {\n        this[kId] = value;\n        if (ObjectId2.cacheHexString) {\n          this.__id = value.toString(\"hex\");\n        }\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(ObjectId2.prototype, \"generationTime\", {\n      /**\n       * The generation time of this ObjectId instance\n       * @deprecated Please use getTimestamp / createFromTime which returns an int32 epoch\n       */\n      get: function() {\n        return this.id.readInt32BE(0);\n      },\n      set: function(value) {\n        this.id.writeUInt32BE(value, 0);\n      },\n      enumerable: false,\n      configurable: true\n    });\n    ObjectId2.prototype.toHexString = function() {\n      if (ObjectId2.cacheHexString && this.__id) {\n        return this.__id;\n      }\n      var hexString = this.id.toString(\"hex\");\n      if (ObjectId2.cacheHexString && !this.__id) {\n        this.__id = hexString;\n      }\n      return hexString;\n    };\n    ObjectId2.getInc = function() {\n      return ObjectId2.index = (ObjectId2.index + 1) % 16777215;\n    };\n    ObjectId2.generate = function(time) {\n      if (\"number\" !== typeof time) {\n        time = Math.floor(Date.now() / 1e3);\n      }\n      var inc = ObjectId2.getInc();\n      var buffer2 = buffer_1.alloc(12);\n      buffer2.writeUInt32BE(time, 0);\n      if (PROCESS_UNIQUE === null) {\n        PROCESS_UNIQUE = randomBytes(5);\n      }\n      buffer2[4] = PROCESS_UNIQUE[0];\n      buffer2[5] = PROCESS_UNIQUE[1];\n      buffer2[6] = PROCESS_UNIQUE[2];\n      buffer2[7] = PROCESS_UNIQUE[3];\n      buffer2[8] = PROCESS_UNIQUE[4];\n      buffer2[11] = inc & 255;\n      buffer2[10] = inc >> 8 & 255;\n      buffer2[9] = inc >> 16 & 255;\n      return buffer2;\n    };\n    ObjectId2.prototype.toString = function(format) {\n      if (format)\n        return this.id.toString(format);\n      return this.toHexString();\n    };\n    ObjectId2.prototype.toJSON = function() {\n      return this.toHexString();\n    };\n    ObjectId2.prototype.equals = function(otherId) {\n      if (otherId === void 0 || otherId === null) {\n        return false;\n      }\n      if (otherId instanceof ObjectId2) {\n        return this[kId][11] === otherId[kId][11] && this[kId].equals(otherId[kId]);\n      }\n      if (typeof otherId === \"string\" && ObjectId2.isValid(otherId) && otherId.length === 12 && isUint8Array(this.id)) {\n        return otherId === buffer_1.prototype.toString.call(this.id, \"latin1\");\n      }\n      if (typeof otherId === \"string\" && ObjectId2.isValid(otherId) && otherId.length === 24) {\n        return otherId.toLowerCase() === this.toHexString();\n      }\n      if (typeof otherId === \"string\" && ObjectId2.isValid(otherId) && otherId.length === 12) {\n        return buffer_1.from(otherId).equals(this.id);\n      }\n      if (typeof otherId === \"object\" && \"toHexString\" in otherId && typeof otherId.toHexString === \"function\") {\n        var otherIdString = otherId.toHexString();\n        var thisIdString = this.toHexString().toLowerCase();\n        return typeof otherIdString === \"string\" && otherIdString.toLowerCase() === thisIdString;\n      }\n      return false;\n    };\n    ObjectId2.prototype.getTimestamp = function() {\n      var timestamp = /* @__PURE__ */ new Date();\n      var time = this.id.readUInt32BE(0);\n      timestamp.setTime(Math.floor(time) * 1e3);\n      return timestamp;\n    };\n    ObjectId2.createPk = function() {\n      return new ObjectId2();\n    };\n    ObjectId2.createFromTime = function(time) {\n      var buffer2 = buffer_1.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n      buffer2.writeUInt32BE(time, 0);\n      return new ObjectId2(buffer2);\n    };\n    ObjectId2.createFromHexString = function(hexString) {\n      if (typeof hexString === \"undefined\" || hexString != null && hexString.length !== 24) {\n        throw new BSONTypeError(\"Argument passed in must be a single String of 12 bytes or a string of 24 hex characters\");\n      }\n      return new ObjectId2(buffer_1.from(hexString, \"hex\"));\n    };\n    ObjectId2.isValid = function(id) {\n      if (id == null)\n        return false;\n      try {\n        new ObjectId2(id);\n        return true;\n      } catch (_a) {\n        return false;\n      }\n    };\n    ObjectId2.prototype.toExtendedJSON = function() {\n      if (this.toHexString)\n        return { $oid: this.toHexString() };\n      return { $oid: this.toString(\"hex\") };\n    };\n    ObjectId2.fromExtendedJSON = function(doc) {\n      return new ObjectId2(doc.$oid);\n    };\n    ObjectId2.prototype[Symbol.for(\"nodejs.util.inspect.custom\")] = function() {\n      return this.inspect();\n    };\n    ObjectId2.prototype.inspect = function() {\n      return 'new ObjectId(\"'.concat(this.toHexString(), '\")');\n    };\n    ObjectId2.index = Math.floor(Math.random() * 16777215);\n    return ObjectId2;\n  }()\n);\nObject.defineProperty(ObjectId.prototype, \"generate\", {\n  value: deprecate(function(time) {\n    return ObjectId.generate(time);\n  }, \"Please use the static `ObjectId.generate(time)` instead\")\n});\nObject.defineProperty(ObjectId.prototype, \"getInc\", {\n  value: deprecate(function() {\n    return ObjectId.getInc();\n  }, \"Please use the static `ObjectId.getInc()` instead\")\n});\nObject.defineProperty(ObjectId.prototype, \"get_inc\", {\n  value: deprecate(function() {\n    return ObjectId.getInc();\n  }, \"Please use the static `ObjectId.getInc()` instead\")\n});\nObject.defineProperty(ObjectId, \"get_inc\", {\n  value: deprecate(function() {\n    return ObjectId.getInc();\n  }, \"Please use the static `ObjectId.getInc()` instead\")\n});\nObject.defineProperty(ObjectId.prototype, \"_bsontype\", { value: \"ObjectID\" });\nfunction alphabetize(str) {\n  return str.split(\"\").sort().join(\"\");\n}\nvar BSONRegExp = (\n  /** @class */\n  function() {\n    function BSONRegExp2(pattern, options) {\n      if (!(this instanceof BSONRegExp2))\n        return new BSONRegExp2(pattern, options);\n      this.pattern = pattern;\n      this.options = alphabetize(options !== null && options !== void 0 ? options : \"\");\n      if (this.pattern.indexOf(\"\\0\") !== -1) {\n        throw new BSONError(\"BSON Regex patterns cannot contain null bytes, found: \".concat(JSON.stringify(this.pattern)));\n      }\n      if (this.options.indexOf(\"\\0\") !== -1) {\n        throw new BSONError(\"BSON Regex options cannot contain null bytes, found: \".concat(JSON.stringify(this.options)));\n      }\n      for (var i = 0; i < this.options.length; i++) {\n        if (!(this.options[i] === \"i\" || this.options[i] === \"m\" || this.options[i] === \"x\" || this.options[i] === \"l\" || this.options[i] === \"s\" || this.options[i] === \"u\")) {\n          throw new BSONError(\"The regular expression option [\".concat(this.options[i], \"] is not supported\"));\n        }\n      }\n    }\n    BSONRegExp2.parseOptions = function(options) {\n      return options ? options.split(\"\").sort().join(\"\") : \"\";\n    };\n    BSONRegExp2.prototype.toExtendedJSON = function(options) {\n      options = options || {};\n      if (options.legacy) {\n        return { $regex: this.pattern, $options: this.options };\n      }\n      return { $regularExpression: { pattern: this.pattern, options: this.options } };\n    };\n    BSONRegExp2.fromExtendedJSON = function(doc) {\n      if (\"$regex\" in doc) {\n        if (typeof doc.$regex !== \"string\") {\n          if (doc.$regex._bsontype === \"BSONRegExp\") {\n            return doc;\n          }\n        } else {\n          return new BSONRegExp2(doc.$regex, BSONRegExp2.parseOptions(doc.$options));\n        }\n      }\n      if (\"$regularExpression\" in doc) {\n        return new BSONRegExp2(doc.$regularExpression.pattern, BSONRegExp2.parseOptions(doc.$regularExpression.options));\n      }\n      throw new BSONTypeError(\"Unexpected BSONRegExp EJSON object form: \".concat(JSON.stringify(doc)));\n    };\n    return BSONRegExp2;\n  }()\n);\nObject.defineProperty(BSONRegExp.prototype, \"_bsontype\", { value: \"BSONRegExp\" });\nvar BSONSymbol = (\n  /** @class */\n  function() {\n    function BSONSymbol2(value) {\n      if (!(this instanceof BSONSymbol2))\n        return new BSONSymbol2(value);\n      this.value = value;\n    }\n    BSONSymbol2.prototype.valueOf = function() {\n      return this.value;\n    };\n    BSONSymbol2.prototype.toString = function() {\n      return this.value;\n    };\n    BSONSymbol2.prototype.inspect = function() {\n      return 'new BSONSymbol(\"'.concat(this.value, '\")');\n    };\n    BSONSymbol2.prototype.toJSON = function() {\n      return this.value;\n    };\n    BSONSymbol2.prototype.toExtendedJSON = function() {\n      return { $symbol: this.value };\n    };\n    BSONSymbol2.fromExtendedJSON = function(doc) {\n      return new BSONSymbol2(doc.$symbol);\n    };\n    BSONSymbol2.prototype[Symbol.for(\"nodejs.util.inspect.custom\")] = function() {\n      return this.inspect();\n    };\n    return BSONSymbol2;\n  }()\n);\nObject.defineProperty(BSONSymbol.prototype, \"_bsontype\", { value: \"Symbol\" });\nvar LongWithoutOverridesClass = Long;\nvar Timestamp = (\n  /** @class */\n  function(_super) {\n    __extends(Timestamp2, _super);\n    function Timestamp2(low, high) {\n      var _this = this;\n      if (!(_this instanceof Timestamp2))\n        return new Timestamp2(low, high);\n      if (Long.isLong(low)) {\n        _this = _super.call(this, low.low, low.high, true) || this;\n      } else if (isObjectLike(low) && typeof low.t !== \"undefined\" && typeof low.i !== \"undefined\") {\n        _this = _super.call(this, low.i, low.t, true) || this;\n      } else {\n        _this = _super.call(this, low, high, true) || this;\n      }\n      Object.defineProperty(_this, \"_bsontype\", {\n        value: \"Timestamp\",\n        writable: false,\n        configurable: false,\n        enumerable: false\n      });\n      return _this;\n    }\n    Timestamp2.prototype.toJSON = function() {\n      return {\n        $timestamp: this.toString()\n      };\n    };\n    Timestamp2.fromInt = function(value) {\n      return new Timestamp2(Long.fromInt(value, true));\n    };\n    Timestamp2.fromNumber = function(value) {\n      return new Timestamp2(Long.fromNumber(value, true));\n    };\n    Timestamp2.fromBits = function(lowBits, highBits) {\n      return new Timestamp2(lowBits, highBits);\n    };\n    Timestamp2.fromString = function(str, optRadix) {\n      return new Timestamp2(Long.fromString(str, true, optRadix));\n    };\n    Timestamp2.prototype.toExtendedJSON = function() {\n      return { $timestamp: { t: this.high >>> 0, i: this.low >>> 0 } };\n    };\n    Timestamp2.fromExtendedJSON = function(doc) {\n      return new Timestamp2(doc.$timestamp);\n    };\n    Timestamp2.prototype[Symbol.for(\"nodejs.util.inspect.custom\")] = function() {\n      return this.inspect();\n    };\n    Timestamp2.prototype.inspect = function() {\n      return \"new Timestamp({ t: \".concat(this.getHighBits(), \", i: \").concat(this.getLowBits(), \" })\");\n    };\n    Timestamp2.MAX_VALUE = Long.MAX_UNSIGNED_VALUE;\n    return Timestamp2;\n  }(LongWithoutOverridesClass)\n);\nfunction isBSONType(value) {\n  return isObjectLike(value) && Reflect.has(value, \"_bsontype\") && typeof value._bsontype === \"string\";\n}\nvar BSON_INT32_MAX = 2147483647;\nvar BSON_INT32_MIN = -2147483648;\nvar BSON_INT64_MAX = 9223372036854776e3;\nvar BSON_INT64_MIN = -9223372036854776e3;\nvar keysToCodecs = {\n  $oid: ObjectId,\n  $binary: Binary,\n  $uuid: Binary,\n  $symbol: BSONSymbol,\n  $numberInt: Int32,\n  $numberDecimal: Decimal128,\n  $numberDouble: Double,\n  $numberLong: Long,\n  $minKey: MinKey,\n  $maxKey: MaxKey,\n  $regex: BSONRegExp,\n  $regularExpression: BSONRegExp,\n  $timestamp: Timestamp\n};\nfunction deserializeValue(value, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  if (typeof value === \"number\") {\n    if (options.relaxed || options.legacy) {\n      return value;\n    }\n    if (Math.floor(value) === value) {\n      if (value >= BSON_INT32_MIN && value <= BSON_INT32_MAX)\n        return new Int32(value);\n      if (value >= BSON_INT64_MIN && value <= BSON_INT64_MAX)\n        return Long.fromNumber(value);\n    }\n    return new Double(value);\n  }\n  if (value == null || typeof value !== \"object\")\n    return value;\n  if (value.$undefined)\n    return null;\n  var keys = Object.keys(value).filter(function(k) {\n    return k.startsWith(\"$\") && value[k] != null;\n  });\n  for (var i = 0; i < keys.length; i++) {\n    var c = keysToCodecs[keys[i]];\n    if (c)\n      return c.fromExtendedJSON(value, options);\n  }\n  if (value.$date != null) {\n    var d = value.$date;\n    var date = /* @__PURE__ */ new Date();\n    if (options.legacy) {\n      if (typeof d === \"number\")\n        date.setTime(d);\n      else if (typeof d === \"string\")\n        date.setTime(Date.parse(d));\n    } else {\n      if (typeof d === \"string\")\n        date.setTime(Date.parse(d));\n      else if (Long.isLong(d))\n        date.setTime(d.toNumber());\n      else if (typeof d === \"number\" && options.relaxed)\n        date.setTime(d);\n    }\n    return date;\n  }\n  if (value.$code != null) {\n    var copy = Object.assign({}, value);\n    if (value.$scope) {\n      copy.$scope = deserializeValue(value.$scope);\n    }\n    return Code.fromExtendedJSON(value);\n  }\n  if (isDBRefLike(value) || value.$dbPointer) {\n    var v = value.$ref ? value : value.$dbPointer;\n    if (v instanceof DBRef)\n      return v;\n    var dollarKeys = Object.keys(v).filter(function(k) {\n      return k.startsWith(\"$\");\n    });\n    var valid_1 = true;\n    dollarKeys.forEach(function(k) {\n      if ([\"$ref\", \"$id\", \"$db\"].indexOf(k) === -1)\n        valid_1 = false;\n    });\n    if (valid_1)\n      return DBRef.fromExtendedJSON(v);\n  }\n  return value;\n}\nfunction serializeArray(array, options) {\n  return array.map(function(v, index) {\n    options.seenObjects.push({ propertyName: \"index \".concat(index), obj: null });\n    try {\n      return serializeValue(v, options);\n    } finally {\n      options.seenObjects.pop();\n    }\n  });\n}\nfunction getISOString(date) {\n  var isoStr = date.toISOString();\n  return date.getUTCMilliseconds() !== 0 ? isoStr : isoStr.slice(0, -5) + \"Z\";\n}\nfunction serializeValue(value, options) {\n  if ((typeof value === \"object\" || typeof value === \"function\") && value !== null) {\n    var index = options.seenObjects.findIndex(function(entry) {\n      return entry.obj === value;\n    });\n    if (index !== -1) {\n      var props = options.seenObjects.map(function(entry) {\n        return entry.propertyName;\n      });\n      var leadingPart = props.slice(0, index).map(function(prop) {\n        return \"\".concat(prop, \" -> \");\n      }).join(\"\");\n      var alreadySeen = props[index];\n      var circularPart = \" -> \" + props.slice(index + 1, props.length - 1).map(function(prop) {\n        return \"\".concat(prop, \" -> \");\n      }).join(\"\");\n      var current = props[props.length - 1];\n      var leadingSpace = \" \".repeat(leadingPart.length + alreadySeen.length / 2);\n      var dashes = \"-\".repeat(circularPart.length + (alreadySeen.length + current.length) / 2 - 1);\n      throw new BSONTypeError(\"Converting circular structure to EJSON:\\n\" + \"    \".concat(leadingPart).concat(alreadySeen).concat(circularPart).concat(current, \"\\n\") + \"    \".concat(leadingSpace, \"\\\\\").concat(dashes, \"/\"));\n    }\n    options.seenObjects[options.seenObjects.length - 1].obj = value;\n  }\n  if (Array.isArray(value))\n    return serializeArray(value, options);\n  if (value === void 0)\n    return null;\n  if (value instanceof Date || isDate(value)) {\n    var dateNum = value.getTime(), inRange = dateNum > -1 && dateNum < 2534023188e5;\n    if (options.legacy) {\n      return options.relaxed && inRange ? { $date: value.getTime() } : { $date: getISOString(value) };\n    }\n    return options.relaxed && inRange ? { $date: getISOString(value) } : { $date: { $numberLong: value.getTime().toString() } };\n  }\n  if (typeof value === \"number\" && (!options.relaxed || !isFinite(value))) {\n    if (Math.floor(value) === value) {\n      var int32Range = value >= BSON_INT32_MIN && value <= BSON_INT32_MAX, int64Range = value >= BSON_INT64_MIN && value <= BSON_INT64_MAX;\n      if (int32Range)\n        return { $numberInt: value.toString() };\n      if (int64Range)\n        return { $numberLong: value.toString() };\n    }\n    return { $numberDouble: value.toString() };\n  }\n  if (value instanceof RegExp || isRegExp(value)) {\n    var flags = value.flags;\n    if (flags === void 0) {\n      var match = value.toString().match(/[gimuy]*$/);\n      if (match) {\n        flags = match[0];\n      }\n    }\n    var rx = new BSONRegExp(value.source, flags);\n    return rx.toExtendedJSON(options);\n  }\n  if (value != null && typeof value === \"object\")\n    return serializeDocument(value, options);\n  return value;\n}\nvar BSON_TYPE_MAPPINGS = {\n  Binary: function(o) {\n    return new Binary(o.value(), o.sub_type);\n  },\n  Code: function(o) {\n    return new Code(o.code, o.scope);\n  },\n  DBRef: function(o) {\n    return new DBRef(o.collection || o.namespace, o.oid, o.db, o.fields);\n  },\n  Decimal128: function(o) {\n    return new Decimal128(o.bytes);\n  },\n  Double: function(o) {\n    return new Double(o.value);\n  },\n  Int32: function(o) {\n    return new Int32(o.value);\n  },\n  Long: function(o) {\n    return Long.fromBits(\n      // underscore variants for 1.x backwards compatibility\n      o.low != null ? o.low : o.low_,\n      o.low != null ? o.high : o.high_,\n      o.low != null ? o.unsigned : o.unsigned_\n    );\n  },\n  MaxKey: function() {\n    return new MaxKey();\n  },\n  MinKey: function() {\n    return new MinKey();\n  },\n  ObjectID: function(o) {\n    return new ObjectId(o);\n  },\n  ObjectId: function(o) {\n    return new ObjectId(o);\n  },\n  BSONRegExp: function(o) {\n    return new BSONRegExp(o.pattern, o.options);\n  },\n  Symbol: function(o) {\n    return new BSONSymbol(o.value);\n  },\n  Timestamp: function(o) {\n    return Timestamp.fromBits(o.low, o.high);\n  }\n};\nfunction serializeDocument(doc, options) {\n  if (doc == null || typeof doc !== \"object\")\n    throw new BSONError(\"not an object instance\");\n  var bsontype = doc._bsontype;\n  if (typeof bsontype === \"undefined\") {\n    var _doc = {};\n    for (var name in doc) {\n      options.seenObjects.push({ propertyName: name, obj: null });\n      try {\n        var value = serializeValue(doc[name], options);\n        if (name === \"__proto__\") {\n          Object.defineProperty(_doc, name, {\n            value,\n            writable: true,\n            enumerable: true,\n            configurable: true\n          });\n        } else {\n          _doc[name] = value;\n        }\n      } finally {\n        options.seenObjects.pop();\n      }\n    }\n    return _doc;\n  } else if (isBSONType(doc)) {\n    var outDoc = doc;\n    if (typeof outDoc.toExtendedJSON !== \"function\") {\n      var mapper = BSON_TYPE_MAPPINGS[doc._bsontype];\n      if (!mapper) {\n        throw new BSONTypeError(\"Unrecognized or invalid _bsontype: \" + doc._bsontype);\n      }\n      outDoc = mapper(outDoc);\n    }\n    if (bsontype === \"Code\" && outDoc.scope) {\n      outDoc = new Code(outDoc.code, serializeValue(outDoc.scope, options));\n    } else if (bsontype === \"DBRef\" && outDoc.oid) {\n      outDoc = new DBRef(serializeValue(outDoc.collection, options), serializeValue(outDoc.oid, options), serializeValue(outDoc.db, options), serializeValue(outDoc.fields, options));\n    }\n    return outDoc.toExtendedJSON(options);\n  } else {\n    throw new BSONError(\"_bsontype must be a string, but was: \" + typeof bsontype);\n  }\n}\nvar EJSON;\n(function(EJSON2) {\n  function parse(text, options) {\n    var finalOptions = Object.assign({}, { relaxed: true, legacy: false }, options);\n    if (typeof finalOptions.relaxed === \"boolean\")\n      finalOptions.strict = !finalOptions.relaxed;\n    if (typeof finalOptions.strict === \"boolean\")\n      finalOptions.relaxed = !finalOptions.strict;\n    return JSON.parse(text, function(key, value) {\n      if (key.indexOf(\"\\0\") !== -1) {\n        throw new BSONError(\"BSON Document field names cannot contain null bytes, found: \".concat(JSON.stringify(key)));\n      }\n      return deserializeValue(value, finalOptions);\n    });\n  }\n  EJSON2.parse = parse;\n  function stringify(value, replacer, space, options) {\n    if (space != null && typeof space === \"object\") {\n      options = space;\n      space = 0;\n    }\n    if (replacer != null && typeof replacer === \"object\" && !Array.isArray(replacer)) {\n      options = replacer;\n      replacer = void 0;\n      space = 0;\n    }\n    var serializeOptions = Object.assign({ relaxed: true, legacy: false }, options, {\n      seenObjects: [{ propertyName: \"(root)\", obj: null }]\n    });\n    var doc = serializeValue(value, serializeOptions);\n    return JSON.stringify(doc, replacer, space);\n  }\n  EJSON2.stringify = stringify;\n  function serialize3(value, options) {\n    options = options || {};\n    return JSON.parse(stringify(value, options));\n  }\n  EJSON2.serialize = serialize3;\n  function deserialize3(ejson, options) {\n    options = options || {};\n    return parse(JSON.stringify(ejson), options);\n  }\n  EJSON2.deserialize = deserialize3;\n})(EJSON || (EJSON = {}));\nvar bsonMap;\nvar bsonGlobal = getGlobal();\nif (bsonGlobal.Map) {\n  bsonMap = bsonGlobal.Map;\n} else {\n  bsonMap = /** @class */\n  function() {\n    function Map(array) {\n      if (array === void 0) {\n        array = [];\n      }\n      this._keys = [];\n      this._values = {};\n      for (var i = 0; i < array.length; i++) {\n        if (array[i] == null)\n          continue;\n        var entry = array[i];\n        var key = entry[0];\n        var value = entry[1];\n        this._keys.push(key);\n        this._values[key] = { v: value, i: this._keys.length - 1 };\n      }\n    }\n    Map.prototype.clear = function() {\n      this._keys = [];\n      this._values = {};\n    };\n    Map.prototype.delete = function(key) {\n      var value = this._values[key];\n      if (value == null)\n        return false;\n      delete this._values[key];\n      this._keys.splice(value.i, 1);\n      return true;\n    };\n    Map.prototype.entries = function() {\n      var _this = this;\n      var index = 0;\n      return {\n        next: function() {\n          var key = _this._keys[index++];\n          return {\n            value: key !== void 0 ? [key, _this._values[key].v] : void 0,\n            done: key !== void 0 ? false : true\n          };\n        }\n      };\n    };\n    Map.prototype.forEach = function(callback, self2) {\n      self2 = self2 || this;\n      for (var i = 0; i < this._keys.length; i++) {\n        var key = this._keys[i];\n        callback.call(self2, this._values[key].v, key, self2);\n      }\n    };\n    Map.prototype.get = function(key) {\n      return this._values[key] ? this._values[key].v : void 0;\n    };\n    Map.prototype.has = function(key) {\n      return this._values[key] != null;\n    };\n    Map.prototype.keys = function() {\n      var _this = this;\n      var index = 0;\n      return {\n        next: function() {\n          var key = _this._keys[index++];\n          return {\n            value: key !== void 0 ? key : void 0,\n            done: key !== void 0 ? false : true\n          };\n        }\n      };\n    };\n    Map.prototype.set = function(key, value) {\n      if (this._values[key]) {\n        this._values[key].v = value;\n        return this;\n      }\n      this._keys.push(key);\n      this._values[key] = { v: value, i: this._keys.length - 1 };\n      return this;\n    };\n    Map.prototype.values = function() {\n      var _this = this;\n      var index = 0;\n      return {\n        next: function() {\n          var key = _this._keys[index++];\n          return {\n            value: key !== void 0 ? _this._values[key].v : void 0,\n            done: key !== void 0 ? false : true\n          };\n        }\n      };\n    };\n    Object.defineProperty(Map.prototype, \"size\", {\n      get: function() {\n        return this._keys.length;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    return Map;\n  }();\n}\nfunction calculateObjectSize$1(object, serializeFunctions, ignoreUndefined) {\n  var totalLength = 4 + 1;\n  if (Array.isArray(object)) {\n    for (var i = 0; i < object.length; i++) {\n      totalLength += calculateElement(i.toString(), object[i], serializeFunctions, true, ignoreUndefined);\n    }\n  } else {\n    if (typeof (object === null || object === void 0 ? void 0 : object.toBSON) === \"function\") {\n      object = object.toBSON();\n    }\n    for (var key in object) {\n      totalLength += calculateElement(key, object[key], serializeFunctions, false, ignoreUndefined);\n    }\n  }\n  return totalLength;\n}\nfunction calculateElement(name, value, serializeFunctions, isArray, ignoreUndefined) {\n  if (serializeFunctions === void 0) {\n    serializeFunctions = false;\n  }\n  if (isArray === void 0) {\n    isArray = false;\n  }\n  if (ignoreUndefined === void 0) {\n    ignoreUndefined = false;\n  }\n  if (typeof (value === null || value === void 0 ? void 0 : value.toBSON) === \"function\") {\n    value = value.toBSON();\n  }\n  switch (typeof value) {\n    case \"string\":\n      return 1 + buffer_1.byteLength(name, \"utf8\") + 1 + 4 + buffer_1.byteLength(value, \"utf8\") + 1;\n    case \"number\":\n      if (Math.floor(value) === value && value >= JS_INT_MIN && value <= JS_INT_MAX) {\n        if (value >= BSON_INT32_MIN$1 && value <= BSON_INT32_MAX$1) {\n          return (name != null ? buffer_1.byteLength(name, \"utf8\") + 1 : 0) + (4 + 1);\n        } else {\n          return (name != null ? buffer_1.byteLength(name, \"utf8\") + 1 : 0) + (8 + 1);\n        }\n      } else {\n        return (name != null ? buffer_1.byteLength(name, \"utf8\") + 1 : 0) + (8 + 1);\n      }\n    case \"undefined\":\n      if (isArray || !ignoreUndefined)\n        return (name != null ? buffer_1.byteLength(name, \"utf8\") + 1 : 0) + 1;\n      return 0;\n    case \"boolean\":\n      return (name != null ? buffer_1.byteLength(name, \"utf8\") + 1 : 0) + (1 + 1);\n    case \"object\":\n      if (value == null || value[\"_bsontype\"] === \"MinKey\" || value[\"_bsontype\"] === \"MaxKey\") {\n        return (name != null ? buffer_1.byteLength(name, \"utf8\") + 1 : 0) + 1;\n      } else if (value[\"_bsontype\"] === \"ObjectId\" || value[\"_bsontype\"] === \"ObjectID\") {\n        return (name != null ? buffer_1.byteLength(name, \"utf8\") + 1 : 0) + (12 + 1);\n      } else if (value instanceof Date || isDate(value)) {\n        return (name != null ? buffer_1.byteLength(name, \"utf8\") + 1 : 0) + (8 + 1);\n      } else if (ArrayBuffer.isView(value) || value instanceof ArrayBuffer || isAnyArrayBuffer(value)) {\n        return (name != null ? buffer_1.byteLength(name, \"utf8\") + 1 : 0) + (1 + 4 + 1) + value.byteLength;\n      } else if (value[\"_bsontype\"] === \"Long\" || value[\"_bsontype\"] === \"Double\" || value[\"_bsontype\"] === \"Timestamp\") {\n        return (name != null ? buffer_1.byteLength(name, \"utf8\") + 1 : 0) + (8 + 1);\n      } else if (value[\"_bsontype\"] === \"Decimal128\") {\n        return (name != null ? buffer_1.byteLength(name, \"utf8\") + 1 : 0) + (16 + 1);\n      } else if (value[\"_bsontype\"] === \"Code\") {\n        if (value.scope != null && Object.keys(value.scope).length > 0) {\n          return (name != null ? buffer_1.byteLength(name, \"utf8\") + 1 : 0) + 1 + 4 + 4 + buffer_1.byteLength(value.code.toString(), \"utf8\") + 1 + calculateObjectSize$1(value.scope, serializeFunctions, ignoreUndefined);\n        } else {\n          return (name != null ? buffer_1.byteLength(name, \"utf8\") + 1 : 0) + 1 + 4 + buffer_1.byteLength(value.code.toString(), \"utf8\") + 1;\n        }\n      } else if (value[\"_bsontype\"] === \"Binary\") {\n        var binary = value;\n        if (binary.sub_type === Binary.SUBTYPE_BYTE_ARRAY) {\n          return (name != null ? buffer_1.byteLength(name, \"utf8\") + 1 : 0) + (binary.position + 1 + 4 + 1 + 4);\n        } else {\n          return (name != null ? buffer_1.byteLength(name, \"utf8\") + 1 : 0) + (binary.position + 1 + 4 + 1);\n        }\n      } else if (value[\"_bsontype\"] === \"Symbol\") {\n        return (name != null ? buffer_1.byteLength(name, \"utf8\") + 1 : 0) + buffer_1.byteLength(value.value, \"utf8\") + 4 + 1 + 1;\n      } else if (value[\"_bsontype\"] === \"DBRef\") {\n        var ordered_values = Object.assign({\n          $ref: value.collection,\n          $id: value.oid\n        }, value.fields);\n        if (value.db != null) {\n          ordered_values[\"$db\"] = value.db;\n        }\n        return (name != null ? buffer_1.byteLength(name, \"utf8\") + 1 : 0) + 1 + calculateObjectSize$1(ordered_values, serializeFunctions, ignoreUndefined);\n      } else if (value instanceof RegExp || isRegExp(value)) {\n        return (name != null ? buffer_1.byteLength(name, \"utf8\") + 1 : 0) + 1 + buffer_1.byteLength(value.source, \"utf8\") + 1 + (value.global ? 1 : 0) + (value.ignoreCase ? 1 : 0) + (value.multiline ? 1 : 0) + 1;\n      } else if (value[\"_bsontype\"] === \"BSONRegExp\") {\n        return (name != null ? buffer_1.byteLength(name, \"utf8\") + 1 : 0) + 1 + buffer_1.byteLength(value.pattern, \"utf8\") + 1 + buffer_1.byteLength(value.options, \"utf8\") + 1;\n      } else {\n        return (name != null ? buffer_1.byteLength(name, \"utf8\") + 1 : 0) + calculateObjectSize$1(value, serializeFunctions, ignoreUndefined) + 1;\n      }\n    case \"function\":\n      if (value instanceof RegExp || isRegExp(value) || String.call(value) === \"[object RegExp]\") {\n        return (name != null ? buffer_1.byteLength(name, \"utf8\") + 1 : 0) + 1 + buffer_1.byteLength(value.source, \"utf8\") + 1 + (value.global ? 1 : 0) + (value.ignoreCase ? 1 : 0) + (value.multiline ? 1 : 0) + 1;\n      } else {\n        if (serializeFunctions && value.scope != null && Object.keys(value.scope).length > 0) {\n          return (name != null ? buffer_1.byteLength(name, \"utf8\") + 1 : 0) + 1 + 4 + 4 + buffer_1.byteLength(normalizedFunctionString(value), \"utf8\") + 1 + calculateObjectSize$1(value.scope, serializeFunctions, ignoreUndefined);\n        } else if (serializeFunctions) {\n          return (name != null ? buffer_1.byteLength(name, \"utf8\") + 1 : 0) + 1 + 4 + buffer_1.byteLength(normalizedFunctionString(value), \"utf8\") + 1;\n        }\n      }\n  }\n  return 0;\n}\nvar FIRST_BIT = 128;\nvar FIRST_TWO_BITS = 192;\nvar FIRST_THREE_BITS = 224;\nvar FIRST_FOUR_BITS = 240;\nvar FIRST_FIVE_BITS = 248;\nvar TWO_BIT_CHAR = 192;\nvar THREE_BIT_CHAR = 224;\nvar FOUR_BIT_CHAR = 240;\nvar CONTINUING_CHAR = 128;\nfunction validateUtf8(bytes, start, end) {\n  var continuation = 0;\n  for (var i = start; i < end; i += 1) {\n    var byte = bytes[i];\n    if (continuation) {\n      if ((byte & FIRST_TWO_BITS) !== CONTINUING_CHAR) {\n        return false;\n      }\n      continuation -= 1;\n    } else if (byte & FIRST_BIT) {\n      if ((byte & FIRST_THREE_BITS) === TWO_BIT_CHAR) {\n        continuation = 1;\n      } else if ((byte & FIRST_FOUR_BITS) === THREE_BIT_CHAR) {\n        continuation = 2;\n      } else if ((byte & FIRST_FIVE_BITS) === FOUR_BIT_CHAR) {\n        continuation = 3;\n      } else {\n        return false;\n      }\n    }\n  }\n  return !continuation;\n}\nvar JS_INT_MAX_LONG = Long.fromNumber(JS_INT_MAX);\nvar JS_INT_MIN_LONG = Long.fromNumber(JS_INT_MIN);\nvar functionCache = {};\nfunction deserialize$1(buffer2, options, isArray) {\n  options = options == null ? {} : options;\n  var index = options && options.index ? options.index : 0;\n  var size = buffer2[index] | buffer2[index + 1] << 8 | buffer2[index + 2] << 16 | buffer2[index + 3] << 24;\n  if (size < 5) {\n    throw new BSONError(\"bson size must be >= 5, is \".concat(size));\n  }\n  if (options.allowObjectSmallerThanBufferSize && buffer2.length < size) {\n    throw new BSONError(\"buffer length \".concat(buffer2.length, \" must be >= bson size \").concat(size));\n  }\n  if (!options.allowObjectSmallerThanBufferSize && buffer2.length !== size) {\n    throw new BSONError(\"buffer length \".concat(buffer2.length, \" must === bson size \").concat(size));\n  }\n  if (size + index > buffer2.byteLength) {\n    throw new BSONError(\"(bson size \".concat(size, \" + options.index \").concat(index, \" must be <= buffer length \").concat(buffer2.byteLength, \")\"));\n  }\n  if (buffer2[index + size - 1] !== 0) {\n    throw new BSONError(\"One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00\");\n  }\n  return deserializeObject(buffer2, index, options, isArray);\n}\nvar allowedDBRefKeys = /^\\$ref$|^\\$id$|^\\$db$/;\nfunction deserializeObject(buffer2, index, options, isArray) {\n  if (isArray === void 0) {\n    isArray = false;\n  }\n  var evalFunctions = options[\"evalFunctions\"] == null ? false : options[\"evalFunctions\"];\n  var cacheFunctions = options[\"cacheFunctions\"] == null ? false : options[\"cacheFunctions\"];\n  var fieldsAsRaw = options[\"fieldsAsRaw\"] == null ? null : options[\"fieldsAsRaw\"];\n  var raw = options[\"raw\"] == null ? false : options[\"raw\"];\n  var bsonRegExp = typeof options[\"bsonRegExp\"] === \"boolean\" ? options[\"bsonRegExp\"] : false;\n  var promoteBuffers = options[\"promoteBuffers\"] == null ? false : options[\"promoteBuffers\"];\n  var promoteLongs = options[\"promoteLongs\"] == null ? true : options[\"promoteLongs\"];\n  var promoteValues = options[\"promoteValues\"] == null ? true : options[\"promoteValues\"];\n  var validation = options.validation == null ? { utf8: true } : options.validation;\n  var globalUTFValidation = true;\n  var validationSetting;\n  var utf8KeysSet = /* @__PURE__ */ new Set();\n  var utf8ValidatedKeys = validation.utf8;\n  if (typeof utf8ValidatedKeys === \"boolean\") {\n    validationSetting = utf8ValidatedKeys;\n  } else {\n    globalUTFValidation = false;\n    var utf8ValidationValues = Object.keys(utf8ValidatedKeys).map(function(key2) {\n      return utf8ValidatedKeys[key2];\n    });\n    if (utf8ValidationValues.length === 0) {\n      throw new BSONError(\"UTF-8 validation setting cannot be empty\");\n    }\n    if (typeof utf8ValidationValues[0] !== \"boolean\") {\n      throw new BSONError(\"Invalid UTF-8 validation option, must specify boolean values\");\n    }\n    validationSetting = utf8ValidationValues[0];\n    if (!utf8ValidationValues.every(function(item) {\n      return item === validationSetting;\n    })) {\n      throw new BSONError(\"Invalid UTF-8 validation option - keys must be all true or all false\");\n    }\n  }\n  if (!globalUTFValidation) {\n    for (var _i = 0, _a = Object.keys(utf8ValidatedKeys); _i < _a.length; _i++) {\n      var key = _a[_i];\n      utf8KeysSet.add(key);\n    }\n  }\n  var startIndex = index;\n  if (buffer2.length < 5)\n    throw new BSONError(\"corrupt bson message < 5 bytes long\");\n  var size = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;\n  if (size < 5 || size > buffer2.length)\n    throw new BSONError(\"corrupt bson message\");\n  var object = isArray ? [] : {};\n  var arrayIndex = 0;\n  var done = false;\n  var isPossibleDBRef = isArray ? false : null;\n  var dataview = new DataView(buffer2.buffer, buffer2.byteOffset, buffer2.byteLength);\n  while (!done) {\n    var elementType = buffer2[index++];\n    if (elementType === 0)\n      break;\n    var i = index;\n    while (buffer2[i] !== 0 && i < buffer2.length) {\n      i++;\n    }\n    if (i >= buffer2.byteLength)\n      throw new BSONError(\"Bad BSON Document: illegal CString\");\n    var name = isArray ? arrayIndex++ : buffer2.toString(\"utf8\", index, i);\n    var shouldValidateKey = true;\n    if (globalUTFValidation || utf8KeysSet.has(name)) {\n      shouldValidateKey = validationSetting;\n    } else {\n      shouldValidateKey = !validationSetting;\n    }\n    if (isPossibleDBRef !== false && name[0] === \"$\") {\n      isPossibleDBRef = allowedDBRefKeys.test(name);\n    }\n    var value = void 0;\n    index = i + 1;\n    if (elementType === BSON_DATA_STRING) {\n      var stringSize = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;\n      if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0) {\n        throw new BSONError(\"bad string length in bson\");\n      }\n      value = getValidatedString(buffer2, index, index + stringSize - 1, shouldValidateKey);\n      index = index + stringSize;\n    } else if (elementType === BSON_DATA_OID) {\n      var oid = buffer_1.alloc(12);\n      buffer2.copy(oid, 0, index, index + 12);\n      value = new ObjectId(oid);\n      index = index + 12;\n    } else if (elementType === BSON_DATA_INT && promoteValues === false) {\n      value = new Int32(buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24);\n    } else if (elementType === BSON_DATA_INT) {\n      value = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;\n    } else if (elementType === BSON_DATA_NUMBER && promoteValues === false) {\n      value = new Double(dataview.getFloat64(index, true));\n      index = index + 8;\n    } else if (elementType === BSON_DATA_NUMBER) {\n      value = dataview.getFloat64(index, true);\n      index = index + 8;\n    } else if (elementType === BSON_DATA_DATE) {\n      var lowBits = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;\n      var highBits = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;\n      value = new Date(new Long(lowBits, highBits).toNumber());\n    } else if (elementType === BSON_DATA_BOOLEAN) {\n      if (buffer2[index] !== 0 && buffer2[index] !== 1)\n        throw new BSONError(\"illegal boolean type value\");\n      value = buffer2[index++] === 1;\n    } else if (elementType === BSON_DATA_OBJECT) {\n      var _index = index;\n      var objectSize = buffer2[index] | buffer2[index + 1] << 8 | buffer2[index + 2] << 16 | buffer2[index + 3] << 24;\n      if (objectSize <= 0 || objectSize > buffer2.length - index)\n        throw new BSONError(\"bad embedded document length in bson\");\n      if (raw) {\n        value = buffer2.slice(index, index + objectSize);\n      } else {\n        var objectOptions = options;\n        if (!globalUTFValidation) {\n          objectOptions = _assign(_assign({}, options), { validation: { utf8: shouldValidateKey } });\n        }\n        value = deserializeObject(buffer2, _index, objectOptions, false);\n      }\n      index = index + objectSize;\n    } else if (elementType === BSON_DATA_ARRAY) {\n      var _index = index;\n      var objectSize = buffer2[index] | buffer2[index + 1] << 8 | buffer2[index + 2] << 16 | buffer2[index + 3] << 24;\n      var arrayOptions = options;\n      var stopIndex = index + objectSize;\n      if (fieldsAsRaw && fieldsAsRaw[name]) {\n        arrayOptions = {};\n        for (var n in options) {\n          arrayOptions[n] = options[n];\n        }\n        arrayOptions[\"raw\"] = true;\n      }\n      if (!globalUTFValidation) {\n        arrayOptions = _assign(_assign({}, arrayOptions), { validation: { utf8: shouldValidateKey } });\n      }\n      value = deserializeObject(buffer2, _index, arrayOptions, true);\n      index = index + objectSize;\n      if (buffer2[index - 1] !== 0)\n        throw new BSONError(\"invalid array terminator byte\");\n      if (index !== stopIndex)\n        throw new BSONError(\"corrupted array bson\");\n    } else if (elementType === BSON_DATA_UNDEFINED) {\n      value = void 0;\n    } else if (elementType === BSON_DATA_NULL) {\n      value = null;\n    } else if (elementType === BSON_DATA_LONG) {\n      var lowBits = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;\n      var highBits = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;\n      var long = new Long(lowBits, highBits);\n      if (promoteLongs && promoteValues === true) {\n        value = long.lessThanOrEqual(JS_INT_MAX_LONG) && long.greaterThanOrEqual(JS_INT_MIN_LONG) ? long.toNumber() : long;\n      } else {\n        value = long;\n      }\n    } else if (elementType === BSON_DATA_DECIMAL128) {\n      var bytes = buffer_1.alloc(16);\n      buffer2.copy(bytes, 0, index, index + 16);\n      index = index + 16;\n      var decimal128 = new Decimal128(bytes);\n      if (\"toObject\" in decimal128 && typeof decimal128.toObject === \"function\") {\n        value = decimal128.toObject();\n      } else {\n        value = decimal128;\n      }\n    } else if (elementType === BSON_DATA_BINARY) {\n      var binarySize = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;\n      var totalBinarySize = binarySize;\n      var subType = buffer2[index++];\n      if (binarySize < 0)\n        throw new BSONError(\"Negative binary type element size found\");\n      if (binarySize > buffer2.byteLength)\n        throw new BSONError(\"Binary type size larger than document size\");\n      if (buffer2[\"slice\"] != null) {\n        if (subType === Binary.SUBTYPE_BYTE_ARRAY) {\n          binarySize = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;\n          if (binarySize < 0)\n            throw new BSONError(\"Negative binary type element size found for subtype 0x02\");\n          if (binarySize > totalBinarySize - 4)\n            throw new BSONError(\"Binary type with subtype 0x02 contains too long binary size\");\n          if (binarySize < totalBinarySize - 4)\n            throw new BSONError(\"Binary type with subtype 0x02 contains too short binary size\");\n        }\n        if (promoteBuffers && promoteValues) {\n          value = buffer2.slice(index, index + binarySize);\n        } else {\n          value = new Binary(buffer2.slice(index, index + binarySize), subType);\n          if (subType === BSON_BINARY_SUBTYPE_UUID_NEW) {\n            value = value.toUUID();\n          }\n        }\n      } else {\n        var _buffer = buffer_1.alloc(binarySize);\n        if (subType === Binary.SUBTYPE_BYTE_ARRAY) {\n          binarySize = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;\n          if (binarySize < 0)\n            throw new BSONError(\"Negative binary type element size found for subtype 0x02\");\n          if (binarySize > totalBinarySize - 4)\n            throw new BSONError(\"Binary type with subtype 0x02 contains too long binary size\");\n          if (binarySize < totalBinarySize - 4)\n            throw new BSONError(\"Binary type with subtype 0x02 contains too short binary size\");\n        }\n        for (i = 0; i < binarySize; i++) {\n          _buffer[i] = buffer2[index + i];\n        }\n        if (promoteBuffers && promoteValues) {\n          value = _buffer;\n        } else if (subType === BSON_BINARY_SUBTYPE_UUID_NEW) {\n          value = new Binary(buffer2.slice(index, index + binarySize), subType).toUUID();\n        } else {\n          value = new Binary(buffer2.slice(index, index + binarySize), subType);\n        }\n      }\n      index = index + binarySize;\n    } else if (elementType === BSON_DATA_REGEXP && bsonRegExp === false) {\n      i = index;\n      while (buffer2[i] !== 0 && i < buffer2.length) {\n        i++;\n      }\n      if (i >= buffer2.length)\n        throw new BSONError(\"Bad BSON Document: illegal CString\");\n      var source = buffer2.toString(\"utf8\", index, i);\n      index = i + 1;\n      i = index;\n      while (buffer2[i] !== 0 && i < buffer2.length) {\n        i++;\n      }\n      if (i >= buffer2.length)\n        throw new BSONError(\"Bad BSON Document: illegal CString\");\n      var regExpOptions = buffer2.toString(\"utf8\", index, i);\n      index = i + 1;\n      var optionsArray = new Array(regExpOptions.length);\n      for (i = 0; i < regExpOptions.length; i++) {\n        switch (regExpOptions[i]) {\n          case \"m\":\n            optionsArray[i] = \"m\";\n            break;\n          case \"s\":\n            optionsArray[i] = \"g\";\n            break;\n          case \"i\":\n            optionsArray[i] = \"i\";\n            break;\n        }\n      }\n      value = new RegExp(source, optionsArray.join(\"\"));\n    } else if (elementType === BSON_DATA_REGEXP && bsonRegExp === true) {\n      i = index;\n      while (buffer2[i] !== 0 && i < buffer2.length) {\n        i++;\n      }\n      if (i >= buffer2.length)\n        throw new BSONError(\"Bad BSON Document: illegal CString\");\n      var source = buffer2.toString(\"utf8\", index, i);\n      index = i + 1;\n      i = index;\n      while (buffer2[i] !== 0 && i < buffer2.length) {\n        i++;\n      }\n      if (i >= buffer2.length)\n        throw new BSONError(\"Bad BSON Document: illegal CString\");\n      var regExpOptions = buffer2.toString(\"utf8\", index, i);\n      index = i + 1;\n      value = new BSONRegExp(source, regExpOptions);\n    } else if (elementType === BSON_DATA_SYMBOL) {\n      var stringSize = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;\n      if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0) {\n        throw new BSONError(\"bad string length in bson\");\n      }\n      var symbol = getValidatedString(buffer2, index, index + stringSize - 1, shouldValidateKey);\n      value = promoteValues ? symbol : new BSONSymbol(symbol);\n      index = index + stringSize;\n    } else if (elementType === BSON_DATA_TIMESTAMP) {\n      var lowBits = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;\n      var highBits = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;\n      value = new Timestamp(lowBits, highBits);\n    } else if (elementType === BSON_DATA_MIN_KEY) {\n      value = new MinKey();\n    } else if (elementType === BSON_DATA_MAX_KEY) {\n      value = new MaxKey();\n    } else if (elementType === BSON_DATA_CODE) {\n      var stringSize = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;\n      if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0) {\n        throw new BSONError(\"bad string length in bson\");\n      }\n      var functionString = getValidatedString(buffer2, index, index + stringSize - 1, shouldValidateKey);\n      if (evalFunctions) {\n        if (cacheFunctions) {\n          value = isolateEval(functionString, functionCache, object);\n        } else {\n          value = isolateEval(functionString);\n        }\n      } else {\n        value = new Code(functionString);\n      }\n      index = index + stringSize;\n    } else if (elementType === BSON_DATA_CODE_W_SCOPE) {\n      var totalSize = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;\n      if (totalSize < 4 + 4 + 4 + 1) {\n        throw new BSONError(\"code_w_scope total size shorter minimum expected length\");\n      }\n      var stringSize = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;\n      if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0) {\n        throw new BSONError(\"bad string length in bson\");\n      }\n      var functionString = getValidatedString(buffer2, index, index + stringSize - 1, shouldValidateKey);\n      index = index + stringSize;\n      var _index = index;\n      var objectSize = buffer2[index] | buffer2[index + 1] << 8 | buffer2[index + 2] << 16 | buffer2[index + 3] << 24;\n      var scopeObject = deserializeObject(buffer2, _index, options, false);\n      index = index + objectSize;\n      if (totalSize < 4 + 4 + objectSize + stringSize) {\n        throw new BSONError(\"code_w_scope total size is too short, truncating scope\");\n      }\n      if (totalSize > 4 + 4 + objectSize + stringSize) {\n        throw new BSONError(\"code_w_scope total size is too long, clips outer document\");\n      }\n      if (evalFunctions) {\n        if (cacheFunctions) {\n          value = isolateEval(functionString, functionCache, object);\n        } else {\n          value = isolateEval(functionString);\n        }\n        value.scope = scopeObject;\n      } else {\n        value = new Code(functionString, scopeObject);\n      }\n    } else if (elementType === BSON_DATA_DBPOINTER) {\n      var stringSize = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;\n      if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0)\n        throw new BSONError(\"bad string length in bson\");\n      if (validation != null && validation.utf8) {\n        if (!validateUtf8(buffer2, index, index + stringSize - 1)) {\n          throw new BSONError(\"Invalid UTF-8 string in BSON document\");\n        }\n      }\n      var namespace = buffer2.toString(\"utf8\", index, index + stringSize - 1);\n      index = index + stringSize;\n      var oidBuffer = buffer_1.alloc(12);\n      buffer2.copy(oidBuffer, 0, index, index + 12);\n      var oid = new ObjectId(oidBuffer);\n      index = index + 12;\n      value = new DBRef(namespace, oid);\n    } else {\n      throw new BSONError(\"Detected unknown BSON type \".concat(elementType.toString(16), ' for fieldname \"').concat(name, '\"'));\n    }\n    if (name === \"__proto__\") {\n      Object.defineProperty(object, name, {\n        value,\n        writable: true,\n        enumerable: true,\n        configurable: true\n      });\n    } else {\n      object[name] = value;\n    }\n  }\n  if (size !== index - startIndex) {\n    if (isArray)\n      throw new BSONError(\"corrupt array bson\");\n    throw new BSONError(\"corrupt object bson\");\n  }\n  if (!isPossibleDBRef)\n    return object;\n  if (isDBRefLike(object)) {\n    var copy = Object.assign({}, object);\n    delete copy.$ref;\n    delete copy.$id;\n    delete copy.$db;\n    return new DBRef(object.$ref, object.$id, object.$db, copy);\n  }\n  return object;\n}\nfunction isolateEval(functionString, functionCache2, object) {\n  if (!functionCache2)\n    return new Function(functionString);\n  if (functionCache2[functionString] == null) {\n    functionCache2[functionString] = new Function(functionString);\n  }\n  return functionCache2[functionString].bind(object);\n}\nfunction getValidatedString(buffer2, start, end, shouldValidateUtf8) {\n  var value = buffer2.toString(\"utf8\", start, end);\n  if (shouldValidateUtf8) {\n    for (var i = 0; i < value.length; i++) {\n      if (value.charCodeAt(i) === 65533) {\n        if (!validateUtf8(buffer2, start, end)) {\n          throw new BSONError(\"Invalid UTF-8 string in BSON document\");\n        }\n        break;\n      }\n    }\n  }\n  return value;\n}\nvar regexp = /\\x00/;\nvar ignoreKeys = /* @__PURE__ */ new Set([\"$db\", \"$ref\", \"$id\", \"$clusterTime\"]);\nfunction serializeString(buffer2, key, value, index, isArray) {\n  buffer2[index++] = BSON_DATA_STRING;\n  var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, \"utf8\") : buffer2.write(key, index, void 0, \"ascii\");\n  index = index + numberOfWrittenBytes + 1;\n  buffer2[index - 1] = 0;\n  var size = buffer2.write(value, index + 4, void 0, \"utf8\");\n  buffer2[index + 3] = size + 1 >> 24 & 255;\n  buffer2[index + 2] = size + 1 >> 16 & 255;\n  buffer2[index + 1] = size + 1 >> 8 & 255;\n  buffer2[index] = size + 1 & 255;\n  index = index + 4 + size;\n  buffer2[index++] = 0;\n  return index;\n}\nvar SPACE_FOR_FLOAT64 = new Uint8Array(8);\nvar DV_FOR_FLOAT64 = new DataView(SPACE_FOR_FLOAT64.buffer, SPACE_FOR_FLOAT64.byteOffset, SPACE_FOR_FLOAT64.byteLength);\nfunction serializeNumber(buffer2, key, value, index, isArray) {\n  if (Number.isInteger(value) && value >= BSON_INT32_MIN$1 && value <= BSON_INT32_MAX$1) {\n    buffer2[index++] = BSON_DATA_INT;\n    var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, \"utf8\") : buffer2.write(key, index, void 0, \"ascii\");\n    index = index + numberOfWrittenBytes;\n    buffer2[index++] = 0;\n    buffer2[index++] = value & 255;\n    buffer2[index++] = value >> 8 & 255;\n    buffer2[index++] = value >> 16 & 255;\n    buffer2[index++] = value >> 24 & 255;\n  } else {\n    buffer2[index++] = BSON_DATA_NUMBER;\n    var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, \"utf8\") : buffer2.write(key, index, void 0, \"ascii\");\n    index = index + numberOfWrittenBytes;\n    buffer2[index++] = 0;\n    DV_FOR_FLOAT64.setFloat64(0, value, true);\n    buffer2.set(SPACE_FOR_FLOAT64, index);\n    index = index + 8;\n  }\n  return index;\n}\nfunction serializeNull(buffer2, key, _, index, isArray) {\n  buffer2[index++] = BSON_DATA_NULL;\n  var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, \"utf8\") : buffer2.write(key, index, void 0, \"ascii\");\n  index = index + numberOfWrittenBytes;\n  buffer2[index++] = 0;\n  return index;\n}\nfunction serializeBoolean(buffer2, key, value, index, isArray) {\n  buffer2[index++] = BSON_DATA_BOOLEAN;\n  var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, \"utf8\") : buffer2.write(key, index, void 0, \"ascii\");\n  index = index + numberOfWrittenBytes;\n  buffer2[index++] = 0;\n  buffer2[index++] = value ? 1 : 0;\n  return index;\n}\nfunction serializeDate(buffer2, key, value, index, isArray) {\n  buffer2[index++] = BSON_DATA_DATE;\n  var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, \"utf8\") : buffer2.write(key, index, void 0, \"ascii\");\n  index = index + numberOfWrittenBytes;\n  buffer2[index++] = 0;\n  var dateInMilis = Long.fromNumber(value.getTime());\n  var lowBits = dateInMilis.getLowBits();\n  var highBits = dateInMilis.getHighBits();\n  buffer2[index++] = lowBits & 255;\n  buffer2[index++] = lowBits >> 8 & 255;\n  buffer2[index++] = lowBits >> 16 & 255;\n  buffer2[index++] = lowBits >> 24 & 255;\n  buffer2[index++] = highBits & 255;\n  buffer2[index++] = highBits >> 8 & 255;\n  buffer2[index++] = highBits >> 16 & 255;\n  buffer2[index++] = highBits >> 24 & 255;\n  return index;\n}\nfunction serializeRegExp(buffer2, key, value, index, isArray) {\n  buffer2[index++] = BSON_DATA_REGEXP;\n  var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, \"utf8\") : buffer2.write(key, index, void 0, \"ascii\");\n  index = index + numberOfWrittenBytes;\n  buffer2[index++] = 0;\n  if (value.source && value.source.match(regexp) != null) {\n    throw Error(\"value \" + value.source + \" must not contain null bytes\");\n  }\n  index = index + buffer2.write(value.source, index, void 0, \"utf8\");\n  buffer2[index++] = 0;\n  if (value.ignoreCase)\n    buffer2[index++] = 105;\n  if (value.global)\n    buffer2[index++] = 115;\n  if (value.multiline)\n    buffer2[index++] = 109;\n  buffer2[index++] = 0;\n  return index;\n}\nfunction serializeBSONRegExp(buffer2, key, value, index, isArray) {\n  buffer2[index++] = BSON_DATA_REGEXP;\n  var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, \"utf8\") : buffer2.write(key, index, void 0, \"ascii\");\n  index = index + numberOfWrittenBytes;\n  buffer2[index++] = 0;\n  if (value.pattern.match(regexp) != null) {\n    throw Error(\"pattern \" + value.pattern + \" must not contain null bytes\");\n  }\n  index = index + buffer2.write(value.pattern, index, void 0, \"utf8\");\n  buffer2[index++] = 0;\n  index = index + buffer2.write(value.options.split(\"\").sort().join(\"\"), index, void 0, \"utf8\");\n  buffer2[index++] = 0;\n  return index;\n}\nfunction serializeMinMax(buffer2, key, value, index, isArray) {\n  if (value === null) {\n    buffer2[index++] = BSON_DATA_NULL;\n  } else if (value._bsontype === \"MinKey\") {\n    buffer2[index++] = BSON_DATA_MIN_KEY;\n  } else {\n    buffer2[index++] = BSON_DATA_MAX_KEY;\n  }\n  var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, \"utf8\") : buffer2.write(key, index, void 0, \"ascii\");\n  index = index + numberOfWrittenBytes;\n  buffer2[index++] = 0;\n  return index;\n}\nfunction serializeObjectId(buffer2, key, value, index, isArray) {\n  buffer2[index++] = BSON_DATA_OID;\n  var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, \"utf8\") : buffer2.write(key, index, void 0, \"ascii\");\n  index = index + numberOfWrittenBytes;\n  buffer2[index++] = 0;\n  if (typeof value.id === \"string\") {\n    buffer2.write(value.id, index, void 0, \"binary\");\n  } else if (isUint8Array(value.id)) {\n    buffer2.set(value.id.subarray(0, 12), index);\n  } else {\n    throw new BSONTypeError(\"object [\" + JSON.stringify(value) + \"] is not a valid ObjectId\");\n  }\n  return index + 12;\n}\nfunction serializeBuffer(buffer2, key, value, index, isArray) {\n  buffer2[index++] = BSON_DATA_BINARY;\n  var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, \"utf8\") : buffer2.write(key, index, void 0, \"ascii\");\n  index = index + numberOfWrittenBytes;\n  buffer2[index++] = 0;\n  var size = value.length;\n  buffer2[index++] = size & 255;\n  buffer2[index++] = size >> 8 & 255;\n  buffer2[index++] = size >> 16 & 255;\n  buffer2[index++] = size >> 24 & 255;\n  buffer2[index++] = BSON_BINARY_SUBTYPE_DEFAULT;\n  buffer2.set(ensureBuffer(value), index);\n  index = index + size;\n  return index;\n}\nfunction serializeObject(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, isArray, path) {\n  if (checkKeys === void 0) {\n    checkKeys = false;\n  }\n  if (depth === void 0) {\n    depth = 0;\n  }\n  if (serializeFunctions === void 0) {\n    serializeFunctions = false;\n  }\n  if (ignoreUndefined === void 0) {\n    ignoreUndefined = true;\n  }\n  if (isArray === void 0) {\n    isArray = false;\n  }\n  if (path === void 0) {\n    path = [];\n  }\n  for (var i = 0; i < path.length; i++) {\n    if (path[i] === value)\n      throw new BSONError(\"cyclic dependency detected\");\n  }\n  path.push(value);\n  buffer2[index++] = Array.isArray(value) ? BSON_DATA_ARRAY : BSON_DATA_OBJECT;\n  var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, \"utf8\") : buffer2.write(key, index, void 0, \"ascii\");\n  index = index + numberOfWrittenBytes;\n  buffer2[index++] = 0;\n  var endIndex = serializeInto(buffer2, value, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path);\n  path.pop();\n  return endIndex;\n}\nfunction serializeDecimal128(buffer2, key, value, index, isArray) {\n  buffer2[index++] = BSON_DATA_DECIMAL128;\n  var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, \"utf8\") : buffer2.write(key, index, void 0, \"ascii\");\n  index = index + numberOfWrittenBytes;\n  buffer2[index++] = 0;\n  buffer2.set(value.bytes.subarray(0, 16), index);\n  return index + 16;\n}\nfunction serializeLong(buffer2, key, value, index, isArray) {\n  buffer2[index++] = value._bsontype === \"Long\" ? BSON_DATA_LONG : BSON_DATA_TIMESTAMP;\n  var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, \"utf8\") : buffer2.write(key, index, void 0, \"ascii\");\n  index = index + numberOfWrittenBytes;\n  buffer2[index++] = 0;\n  var lowBits = value.getLowBits();\n  var highBits = value.getHighBits();\n  buffer2[index++] = lowBits & 255;\n  buffer2[index++] = lowBits >> 8 & 255;\n  buffer2[index++] = lowBits >> 16 & 255;\n  buffer2[index++] = lowBits >> 24 & 255;\n  buffer2[index++] = highBits & 255;\n  buffer2[index++] = highBits >> 8 & 255;\n  buffer2[index++] = highBits >> 16 & 255;\n  buffer2[index++] = highBits >> 24 & 255;\n  return index;\n}\nfunction serializeInt32(buffer2, key, value, index, isArray) {\n  value = value.valueOf();\n  buffer2[index++] = BSON_DATA_INT;\n  var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, \"utf8\") : buffer2.write(key, index, void 0, \"ascii\");\n  index = index + numberOfWrittenBytes;\n  buffer2[index++] = 0;\n  buffer2[index++] = value & 255;\n  buffer2[index++] = value >> 8 & 255;\n  buffer2[index++] = value >> 16 & 255;\n  buffer2[index++] = value >> 24 & 255;\n  return index;\n}\nfunction serializeDouble(buffer2, key, value, index, isArray) {\n  buffer2[index++] = BSON_DATA_NUMBER;\n  var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, \"utf8\") : buffer2.write(key, index, void 0, \"ascii\");\n  index = index + numberOfWrittenBytes;\n  buffer2[index++] = 0;\n  DV_FOR_FLOAT64.setFloat64(0, value.value, true);\n  buffer2.set(SPACE_FOR_FLOAT64, index);\n  index = index + 8;\n  return index;\n}\nfunction serializeFunction(buffer2, key, value, index, _checkKeys, _depth, isArray) {\n  buffer2[index++] = BSON_DATA_CODE;\n  var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, \"utf8\") : buffer2.write(key, index, void 0, \"ascii\");\n  index = index + numberOfWrittenBytes;\n  buffer2[index++] = 0;\n  var functionString = normalizedFunctionString(value);\n  var size = buffer2.write(functionString, index + 4, void 0, \"utf8\") + 1;\n  buffer2[index] = size & 255;\n  buffer2[index + 1] = size >> 8 & 255;\n  buffer2[index + 2] = size >> 16 & 255;\n  buffer2[index + 3] = size >> 24 & 255;\n  index = index + 4 + size - 1;\n  buffer2[index++] = 0;\n  return index;\n}\nfunction serializeCode(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, isArray) {\n  if (checkKeys === void 0) {\n    checkKeys = false;\n  }\n  if (depth === void 0) {\n    depth = 0;\n  }\n  if (serializeFunctions === void 0) {\n    serializeFunctions = false;\n  }\n  if (ignoreUndefined === void 0) {\n    ignoreUndefined = true;\n  }\n  if (isArray === void 0) {\n    isArray = false;\n  }\n  if (value.scope && typeof value.scope === \"object\") {\n    buffer2[index++] = BSON_DATA_CODE_W_SCOPE;\n    var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, \"utf8\") : buffer2.write(key, index, void 0, \"ascii\");\n    index = index + numberOfWrittenBytes;\n    buffer2[index++] = 0;\n    var startIndex = index;\n    var functionString = typeof value.code === \"string\" ? value.code : value.code.toString();\n    index = index + 4;\n    var codeSize = buffer2.write(functionString, index + 4, void 0, \"utf8\") + 1;\n    buffer2[index] = codeSize & 255;\n    buffer2[index + 1] = codeSize >> 8 & 255;\n    buffer2[index + 2] = codeSize >> 16 & 255;\n    buffer2[index + 3] = codeSize >> 24 & 255;\n    buffer2[index + 4 + codeSize - 1] = 0;\n    index = index + codeSize + 4;\n    var endIndex = serializeInto(buffer2, value.scope, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined);\n    index = endIndex - 1;\n    var totalSize = endIndex - startIndex;\n    buffer2[startIndex++] = totalSize & 255;\n    buffer2[startIndex++] = totalSize >> 8 & 255;\n    buffer2[startIndex++] = totalSize >> 16 & 255;\n    buffer2[startIndex++] = totalSize >> 24 & 255;\n    buffer2[index++] = 0;\n  } else {\n    buffer2[index++] = BSON_DATA_CODE;\n    var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, \"utf8\") : buffer2.write(key, index, void 0, \"ascii\");\n    index = index + numberOfWrittenBytes;\n    buffer2[index++] = 0;\n    var functionString = value.code.toString();\n    var size = buffer2.write(functionString, index + 4, void 0, \"utf8\") + 1;\n    buffer2[index] = size & 255;\n    buffer2[index + 1] = size >> 8 & 255;\n    buffer2[index + 2] = size >> 16 & 255;\n    buffer2[index + 3] = size >> 24 & 255;\n    index = index + 4 + size - 1;\n    buffer2[index++] = 0;\n  }\n  return index;\n}\nfunction serializeBinary(buffer2, key, value, index, isArray) {\n  buffer2[index++] = BSON_DATA_BINARY;\n  var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, \"utf8\") : buffer2.write(key, index, void 0, \"ascii\");\n  index = index + numberOfWrittenBytes;\n  buffer2[index++] = 0;\n  var data = value.value(true);\n  var size = value.position;\n  if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY)\n    size = size + 4;\n  buffer2[index++] = size & 255;\n  buffer2[index++] = size >> 8 & 255;\n  buffer2[index++] = size >> 16 & 255;\n  buffer2[index++] = size >> 24 & 255;\n  buffer2[index++] = value.sub_type;\n  if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY) {\n    size = size - 4;\n    buffer2[index++] = size & 255;\n    buffer2[index++] = size >> 8 & 255;\n    buffer2[index++] = size >> 16 & 255;\n    buffer2[index++] = size >> 24 & 255;\n  }\n  buffer2.set(data, index);\n  index = index + value.position;\n  return index;\n}\nfunction serializeSymbol(buffer2, key, value, index, isArray) {\n  buffer2[index++] = BSON_DATA_SYMBOL;\n  var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, \"utf8\") : buffer2.write(key, index, void 0, \"ascii\");\n  index = index + numberOfWrittenBytes;\n  buffer2[index++] = 0;\n  var size = buffer2.write(value.value, index + 4, void 0, \"utf8\") + 1;\n  buffer2[index] = size & 255;\n  buffer2[index + 1] = size >> 8 & 255;\n  buffer2[index + 2] = size >> 16 & 255;\n  buffer2[index + 3] = size >> 24 & 255;\n  index = index + 4 + size - 1;\n  buffer2[index++] = 0;\n  return index;\n}\nfunction serializeDBRef(buffer2, key, value, index, depth, serializeFunctions, isArray) {\n  buffer2[index++] = BSON_DATA_OBJECT;\n  var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, \"utf8\") : buffer2.write(key, index, void 0, \"ascii\");\n  index = index + numberOfWrittenBytes;\n  buffer2[index++] = 0;\n  var startIndex = index;\n  var output = {\n    $ref: value.collection || value.namespace,\n    $id: value.oid\n  };\n  if (value.db != null) {\n    output.$db = value.db;\n  }\n  output = Object.assign(output, value.fields);\n  var endIndex = serializeInto(buffer2, output, false, index, depth + 1, serializeFunctions);\n  var size = endIndex - startIndex;\n  buffer2[startIndex++] = size & 255;\n  buffer2[startIndex++] = size >> 8 & 255;\n  buffer2[startIndex++] = size >> 16 & 255;\n  buffer2[startIndex++] = size >> 24 & 255;\n  return endIndex;\n}\nfunction serializeInto(buffer2, object, checkKeys, startingIndex, depth, serializeFunctions, ignoreUndefined, path) {\n  if (checkKeys === void 0) {\n    checkKeys = false;\n  }\n  if (startingIndex === void 0) {\n    startingIndex = 0;\n  }\n  if (depth === void 0) {\n    depth = 0;\n  }\n  if (serializeFunctions === void 0) {\n    serializeFunctions = false;\n  }\n  if (ignoreUndefined === void 0) {\n    ignoreUndefined = true;\n  }\n  if (path === void 0) {\n    path = [];\n  }\n  startingIndex = startingIndex || 0;\n  path = path || [];\n  path.push(object);\n  var index = startingIndex + 4;\n  if (Array.isArray(object)) {\n    for (var i = 0; i < object.length; i++) {\n      var key = \"\".concat(i);\n      var value = object[i];\n      if (typeof (value === null || value === void 0 ? void 0 : value.toBSON) === \"function\") {\n        value = value.toBSON();\n      }\n      if (typeof value === \"string\") {\n        index = serializeString(buffer2, key, value, index, true);\n      } else if (typeof value === \"number\") {\n        index = serializeNumber(buffer2, key, value, index, true);\n      } else if (typeof value === \"bigint\") {\n        throw new BSONTypeError(\"Unsupported type BigInt, please use Decimal128\");\n      } else if (typeof value === \"boolean\") {\n        index = serializeBoolean(buffer2, key, value, index, true);\n      } else if (value instanceof Date || isDate(value)) {\n        index = serializeDate(buffer2, key, value, index, true);\n      } else if (value === void 0) {\n        index = serializeNull(buffer2, key, value, index, true);\n      } else if (value === null) {\n        index = serializeNull(buffer2, key, value, index, true);\n      } else if (value[\"_bsontype\"] === \"ObjectId\" || value[\"_bsontype\"] === \"ObjectID\") {\n        index = serializeObjectId(buffer2, key, value, index, true);\n      } else if (isUint8Array(value)) {\n        index = serializeBuffer(buffer2, key, value, index, true);\n      } else if (value instanceof RegExp || isRegExp(value)) {\n        index = serializeRegExp(buffer2, key, value, index, true);\n      } else if (typeof value === \"object\" && value[\"_bsontype\"] == null) {\n        index = serializeObject(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, true, path);\n      } else if (typeof value === \"object\" && isBSONType(value) && value._bsontype === \"Decimal128\") {\n        index = serializeDecimal128(buffer2, key, value, index, true);\n      } else if (value[\"_bsontype\"] === \"Long\" || value[\"_bsontype\"] === \"Timestamp\") {\n        index = serializeLong(buffer2, key, value, index, true);\n      } else if (value[\"_bsontype\"] === \"Double\") {\n        index = serializeDouble(buffer2, key, value, index, true);\n      } else if (typeof value === \"function\" && serializeFunctions) {\n        index = serializeFunction(buffer2, key, value, index, checkKeys, depth, true);\n      } else if (value[\"_bsontype\"] === \"Code\") {\n        index = serializeCode(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, true);\n      } else if (value[\"_bsontype\"] === \"Binary\") {\n        index = serializeBinary(buffer2, key, value, index, true);\n      } else if (value[\"_bsontype\"] === \"Symbol\") {\n        index = serializeSymbol(buffer2, key, value, index, true);\n      } else if (value[\"_bsontype\"] === \"DBRef\") {\n        index = serializeDBRef(buffer2, key, value, index, depth, serializeFunctions, true);\n      } else if (value[\"_bsontype\"] === \"BSONRegExp\") {\n        index = serializeBSONRegExp(buffer2, key, value, index, true);\n      } else if (value[\"_bsontype\"] === \"Int32\") {\n        index = serializeInt32(buffer2, key, value, index, true);\n      } else if (value[\"_bsontype\"] === \"MinKey\" || value[\"_bsontype\"] === \"MaxKey\") {\n        index = serializeMinMax(buffer2, key, value, index, true);\n      } else if (typeof value[\"_bsontype\"] !== \"undefined\") {\n        throw new BSONTypeError(\"Unrecognized or invalid _bsontype: \".concat(String(value[\"_bsontype\"])));\n      }\n    }\n  } else if (object instanceof bsonMap || isMap(object)) {\n    var iterator = object.entries();\n    var done = false;\n    while (!done) {\n      var entry = iterator.next();\n      done = !!entry.done;\n      if (done)\n        continue;\n      var key = entry.value[0];\n      var value = entry.value[1];\n      var type = typeof value;\n      if (typeof key === \"string\" && !ignoreKeys.has(key)) {\n        if (key.match(regexp) != null) {\n          throw Error(\"key \" + key + \" must not contain null bytes\");\n        }\n        if (checkKeys) {\n          if (\"$\" === key[0]) {\n            throw Error(\"key \" + key + \" must not start with '$'\");\n          } else if (~key.indexOf(\".\")) {\n            throw Error(\"key \" + key + \" must not contain '.'\");\n          }\n        }\n      }\n      if (type === \"string\") {\n        index = serializeString(buffer2, key, value, index);\n      } else if (type === \"number\") {\n        index = serializeNumber(buffer2, key, value, index);\n      } else if (type === \"bigint\" || isBigInt64Array(value) || isBigUInt64Array(value)) {\n        throw new BSONTypeError(\"Unsupported type BigInt, please use Decimal128\");\n      } else if (type === \"boolean\") {\n        index = serializeBoolean(buffer2, key, value, index);\n      } else if (value instanceof Date || isDate(value)) {\n        index = serializeDate(buffer2, key, value, index);\n      } else if (value === null || value === void 0 && ignoreUndefined === false) {\n        index = serializeNull(buffer2, key, value, index);\n      } else if (value[\"_bsontype\"] === \"ObjectId\" || value[\"_bsontype\"] === \"ObjectID\") {\n        index = serializeObjectId(buffer2, key, value, index);\n      } else if (isUint8Array(value)) {\n        index = serializeBuffer(buffer2, key, value, index);\n      } else if (value instanceof RegExp || isRegExp(value)) {\n        index = serializeRegExp(buffer2, key, value, index);\n      } else if (type === \"object\" && value[\"_bsontype\"] == null) {\n        index = serializeObject(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, false, path);\n      } else if (type === \"object\" && value[\"_bsontype\"] === \"Decimal128\") {\n        index = serializeDecimal128(buffer2, key, value, index);\n      } else if (value[\"_bsontype\"] === \"Long\" || value[\"_bsontype\"] === \"Timestamp\") {\n        index = serializeLong(buffer2, key, value, index);\n      } else if (value[\"_bsontype\"] === \"Double\") {\n        index = serializeDouble(buffer2, key, value, index);\n      } else if (value[\"_bsontype\"] === \"Code\") {\n        index = serializeCode(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined);\n      } else if (typeof value === \"function\" && serializeFunctions) {\n        index = serializeFunction(buffer2, key, value, index, checkKeys, depth, serializeFunctions);\n      } else if (value[\"_bsontype\"] === \"Binary\") {\n        index = serializeBinary(buffer2, key, value, index);\n      } else if (value[\"_bsontype\"] === \"Symbol\") {\n        index = serializeSymbol(buffer2, key, value, index);\n      } else if (value[\"_bsontype\"] === \"DBRef\") {\n        index = serializeDBRef(buffer2, key, value, index, depth, serializeFunctions);\n      } else if (value[\"_bsontype\"] === \"BSONRegExp\") {\n        index = serializeBSONRegExp(buffer2, key, value, index);\n      } else if (value[\"_bsontype\"] === \"Int32\") {\n        index = serializeInt32(buffer2, key, value, index);\n      } else if (value[\"_bsontype\"] === \"MinKey\" || value[\"_bsontype\"] === \"MaxKey\") {\n        index = serializeMinMax(buffer2, key, value, index);\n      } else if (typeof value[\"_bsontype\"] !== \"undefined\") {\n        throw new BSONTypeError(\"Unrecognized or invalid _bsontype: \".concat(String(value[\"_bsontype\"])));\n      }\n    }\n  } else {\n    if (typeof (object === null || object === void 0 ? void 0 : object.toBSON) === \"function\") {\n      object = object.toBSON();\n      if (object != null && typeof object !== \"object\") {\n        throw new BSONTypeError(\"toBSON function did not return an object\");\n      }\n    }\n    for (var key in object) {\n      var value = object[key];\n      if (typeof (value === null || value === void 0 ? void 0 : value.toBSON) === \"function\") {\n        value = value.toBSON();\n      }\n      var type = typeof value;\n      if (typeof key === \"string\" && !ignoreKeys.has(key)) {\n        if (key.match(regexp) != null) {\n          throw Error(\"key \" + key + \" must not contain null bytes\");\n        }\n        if (checkKeys) {\n          if (\"$\" === key[0]) {\n            throw Error(\"key \" + key + \" must not start with '$'\");\n          } else if (~key.indexOf(\".\")) {\n            throw Error(\"key \" + key + \" must not contain '.'\");\n          }\n        }\n      }\n      if (type === \"string\") {\n        index = serializeString(buffer2, key, value, index);\n      } else if (type === \"number\") {\n        index = serializeNumber(buffer2, key, value, index);\n      } else if (type === \"bigint\") {\n        throw new BSONTypeError(\"Unsupported type BigInt, please use Decimal128\");\n      } else if (type === \"boolean\") {\n        index = serializeBoolean(buffer2, key, value, index);\n      } else if (value instanceof Date || isDate(value)) {\n        index = serializeDate(buffer2, key, value, index);\n      } else if (value === void 0) {\n        if (ignoreUndefined === false)\n          index = serializeNull(buffer2, key, value, index);\n      } else if (value === null) {\n        index = serializeNull(buffer2, key, value, index);\n      } else if (value[\"_bsontype\"] === \"ObjectId\" || value[\"_bsontype\"] === \"ObjectID\") {\n        index = serializeObjectId(buffer2, key, value, index);\n      } else if (isUint8Array(value)) {\n        index = serializeBuffer(buffer2, key, value, index);\n      } else if (value instanceof RegExp || isRegExp(value)) {\n        index = serializeRegExp(buffer2, key, value, index);\n      } else if (type === \"object\" && value[\"_bsontype\"] == null) {\n        index = serializeObject(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, false, path);\n      } else if (type === \"object\" && value[\"_bsontype\"] === \"Decimal128\") {\n        index = serializeDecimal128(buffer2, key, value, index);\n      } else if (value[\"_bsontype\"] === \"Long\" || value[\"_bsontype\"] === \"Timestamp\") {\n        index = serializeLong(buffer2, key, value, index);\n      } else if (value[\"_bsontype\"] === \"Double\") {\n        index = serializeDouble(buffer2, key, value, index);\n      } else if (value[\"_bsontype\"] === \"Code\") {\n        index = serializeCode(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined);\n      } else if (typeof value === \"function\" && serializeFunctions) {\n        index = serializeFunction(buffer2, key, value, index, checkKeys, depth, serializeFunctions);\n      } else if (value[\"_bsontype\"] === \"Binary\") {\n        index = serializeBinary(buffer2, key, value, index);\n      } else if (value[\"_bsontype\"] === \"Symbol\") {\n        index = serializeSymbol(buffer2, key, value, index);\n      } else if (value[\"_bsontype\"] === \"DBRef\") {\n        index = serializeDBRef(buffer2, key, value, index, depth, serializeFunctions);\n      } else if (value[\"_bsontype\"] === \"BSONRegExp\") {\n        index = serializeBSONRegExp(buffer2, key, value, index);\n      } else if (value[\"_bsontype\"] === \"Int32\") {\n        index = serializeInt32(buffer2, key, value, index);\n      } else if (value[\"_bsontype\"] === \"MinKey\" || value[\"_bsontype\"] === \"MaxKey\") {\n        index = serializeMinMax(buffer2, key, value, index);\n      } else if (typeof value[\"_bsontype\"] !== \"undefined\") {\n        throw new BSONTypeError(\"Unrecognized or invalid _bsontype: \".concat(String(value[\"_bsontype\"])));\n      }\n    }\n  }\n  path.pop();\n  buffer2[index++] = 0;\n  var size = index - startingIndex;\n  buffer2[startingIndex++] = size & 255;\n  buffer2[startingIndex++] = size >> 8 & 255;\n  buffer2[startingIndex++] = size >> 16 & 255;\n  buffer2[startingIndex++] = size >> 24 & 255;\n  return index;\n}\nvar MAXSIZE = 1024 * 1024 * 17;\nvar buffer = buffer_1.alloc(MAXSIZE);\nfunction setInternalBufferSize(size) {\n  if (buffer.length < size) {\n    buffer = buffer_1.alloc(size);\n  }\n}\nfunction serialize(object, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var checkKeys = typeof options.checkKeys === \"boolean\" ? options.checkKeys : false;\n  var serializeFunctions = typeof options.serializeFunctions === \"boolean\" ? options.serializeFunctions : false;\n  var ignoreUndefined = typeof options.ignoreUndefined === \"boolean\" ? options.ignoreUndefined : true;\n  var minInternalBufferSize = typeof options.minInternalBufferSize === \"number\" ? options.minInternalBufferSize : MAXSIZE;\n  if (buffer.length < minInternalBufferSize) {\n    buffer = buffer_1.alloc(minInternalBufferSize);\n  }\n  var serializationIndex = serializeInto(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, []);\n  var finishedBuffer = buffer_1.alloc(serializationIndex);\n  buffer.copy(finishedBuffer, 0, 0, finishedBuffer.length);\n  return finishedBuffer;\n}\nfunction serializeWithBufferAndIndex(object, finalBuffer, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var checkKeys = typeof options.checkKeys === \"boolean\" ? options.checkKeys : false;\n  var serializeFunctions = typeof options.serializeFunctions === \"boolean\" ? options.serializeFunctions : false;\n  var ignoreUndefined = typeof options.ignoreUndefined === \"boolean\" ? options.ignoreUndefined : true;\n  var startIndex = typeof options.index === \"number\" ? options.index : 0;\n  var serializationIndex = serializeInto(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined);\n  buffer.copy(finalBuffer, startIndex, 0, serializationIndex);\n  return startIndex + serializationIndex - 1;\n}\nfunction deserialize(buffer2, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return deserialize$1(buffer2 instanceof buffer_1 ? buffer2 : ensureBuffer(buffer2), options);\n}\nfunction calculateObjectSize(object, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  options = options || {};\n  var serializeFunctions = typeof options.serializeFunctions === \"boolean\" ? options.serializeFunctions : false;\n  var ignoreUndefined = typeof options.ignoreUndefined === \"boolean\" ? options.ignoreUndefined : true;\n  return calculateObjectSize$1(object, serializeFunctions, ignoreUndefined);\n}\nfunction deserializeStream(data, startIndex, numberOfDocuments, documents, docStartIndex, options) {\n  var internalOptions = Object.assign({ allowObjectSmallerThanBufferSize: true, index: 0 }, options);\n  var bufferData = ensureBuffer(data);\n  var index = startIndex;\n  for (var i = 0; i < numberOfDocuments; i++) {\n    var size = bufferData[index] | bufferData[index + 1] << 8 | bufferData[index + 2] << 16 | bufferData[index + 3] << 24;\n    internalOptions.index = index;\n    documents[docStartIndex + i] = deserialize$1(bufferData, internalOptions);\n    index = index + size;\n  }\n  return index;\n}\nvar BSON = {\n  Binary,\n  Code,\n  DBRef,\n  Decimal128,\n  Double,\n  Int32,\n  Long,\n  UUID,\n  Map: bsonMap,\n  MaxKey,\n  MinKey,\n  ObjectId,\n  ObjectID: ObjectId,\n  BSONRegExp,\n  BSONSymbol,\n  Timestamp,\n  EJSON,\n  setInternalBufferSize,\n  serialize,\n  serializeWithBufferAndIndex,\n  deserialize,\n  calculateObjectSize,\n  deserializeStream,\n  BSONError,\n  BSONTypeError\n};\nvar bson_browser_esm_default = BSON;\n\n// node_modules/realm-web/dist/bundle.dom.es.js\nvar __spreadArray = function(to, from, pack) {\n  if (pack || arguments.length === 2)\n    for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n        if (!ar)\n          ar = Array.prototype.slice.call(from, 0, i);\n        ar[i] = from[i];\n      }\n    }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar BrowserInfo = (\n  /** @class */\n  /* @__PURE__ */ function() {\n    function BrowserInfo2(name, version2, os) {\n      this.name = name;\n      this.version = version2;\n      this.os = os;\n      this.type = \"browser\";\n    }\n    return BrowserInfo2;\n  }()\n);\nvar NodeInfo = (\n  /** @class */\n  /* @__PURE__ */ function() {\n    function NodeInfo2(version2) {\n      this.version = version2;\n      this.type = \"node\";\n      this.name = \"node\";\n      this.os = process.platform;\n    }\n    return NodeInfo2;\n  }()\n);\nvar SearchBotDeviceInfo = (\n  /** @class */\n  /* @__PURE__ */ function() {\n    function SearchBotDeviceInfo2(name, version2, os, bot) {\n      this.name = name;\n      this.version = version2;\n      this.os = os;\n      this.bot = bot;\n      this.type = \"bot-device\";\n    }\n    return SearchBotDeviceInfo2;\n  }()\n);\nvar BotInfo = (\n  /** @class */\n  /* @__PURE__ */ function() {\n    function BotInfo2() {\n      this.type = \"bot\";\n      this.bot = true;\n      this.name = \"bot\";\n      this.version = null;\n      this.os = null;\n    }\n    return BotInfo2;\n  }()\n);\nvar ReactNativeInfo = (\n  /** @class */\n  /* @__PURE__ */ function() {\n    function ReactNativeInfo2() {\n      this.type = \"react-native\";\n      this.name = \"react-native\";\n      this.version = null;\n      this.os = null;\n    }\n    return ReactNativeInfo2;\n  }()\n);\nvar SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;\nvar SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\\ Jeeves\\/Teoma|ia_archiver)/;\nvar REQUIRED_VERSION_PARTS = 3;\nvar userAgentRules = [\n  [\"aol\", /AOLShield\\/([0-9\\._]+)/],\n  [\"edge\", /Edge\\/([0-9\\._]+)/],\n  [\"edge-ios\", /EdgiOS\\/([0-9\\._]+)/],\n  [\"yandexbrowser\", /YaBrowser\\/([0-9\\._]+)/],\n  [\"kakaotalk\", /KAKAOTALK\\s([0-9\\.]+)/],\n  [\"samsung\", /SamsungBrowser\\/([0-9\\.]+)/],\n  [\"silk\", /\\bSilk\\/([0-9._-]+)\\b/],\n  [\"miui\", /MiuiBrowser\\/([0-9\\.]+)$/],\n  [\"beaker\", /BeakerBrowser\\/([0-9\\.]+)/],\n  [\"edge-chromium\", /EdgA?\\/([0-9\\.]+)/],\n  [\n    \"chromium-webview\",\n    /(?!Chrom.*OPR)wv\\).*Chrom(?:e|ium)\\/([0-9\\.]+)(:?\\s|$)/\n  ],\n  [\"chrome\", /(?!Chrom.*OPR)Chrom(?:e|ium)\\/([0-9\\.]+)(:?\\s|$)/],\n  [\"phantomjs\", /PhantomJS\\/([0-9\\.]+)(:?\\s|$)/],\n  [\"crios\", /CriOS\\/([0-9\\.]+)(:?\\s|$)/],\n  [\"firefox\", /Firefox\\/([0-9\\.]+)(?:\\s|$)/],\n  [\"fxios\", /FxiOS\\/([0-9\\.]+)/],\n  [\"opera-mini\", /Opera Mini.*Version\\/([0-9\\.]+)/],\n  [\"opera\", /Opera\\/([0-9\\.]+)(?:\\s|$)/],\n  [\"opera\", /OPR\\/([0-9\\.]+)(:?\\s|$)/],\n  [\"ie\", /Trident\\/7\\.0.*rv\\:([0-9\\.]+).*\\).*Gecko$/],\n  [\"ie\", /MSIE\\s([0-9\\.]+);.*Trident\\/[4-7].0/],\n  [\"ie\", /MSIE\\s(7\\.0)/],\n  [\"bb10\", /BB10;\\sTouch.*Version\\/([0-9\\.]+)/],\n  [\"android\", /Android\\s([0-9\\.]+)/],\n  [\"ios\", /Version\\/([0-9\\._]+).*Mobile.*Safari.*/],\n  [\"safari\", /Version\\/([0-9\\._]+).*Safari/],\n  [\"facebook\", /FB[AS]V\\/([0-9\\.]+)/],\n  [\"instagram\", /Instagram\\s([0-9\\.]+)/],\n  [\"ios-webview\", /AppleWebKit\\/([0-9\\.]+).*Mobile/],\n  [\"ios-webview\", /AppleWebKit\\/([0-9\\.]+).*Gecko\\)$/],\n  [\"curl\", /^curl\\/([0-9\\.]+)$/],\n  [\"searchbot\", SEARCHBOX_UA_REGEX]\n];\nvar operatingSystemRules = [\n  [\"iOS\", /iP(hone|od|ad)/],\n  [\"Android OS\", /Android/],\n  [\"BlackBerry OS\", /BlackBerry|BB10/],\n  [\"Windows Mobile\", /IEMobile/],\n  [\"Amazon OS\", /Kindle/],\n  [\"Windows 3.11\", /Win16/],\n  [\"Windows 95\", /(Windows 95)|(Win95)|(Windows_95)/],\n  [\"Windows 98\", /(Windows 98)|(Win98)/],\n  [\"Windows 2000\", /(Windows NT 5.0)|(Windows 2000)/],\n  [\"Windows XP\", /(Windows NT 5.1)|(Windows XP)/],\n  [\"Windows Server 2003\", /(Windows NT 5.2)/],\n  [\"Windows Vista\", /(Windows NT 6.0)/],\n  [\"Windows 7\", /(Windows NT 6.1)/],\n  [\"Windows 8\", /(Windows NT 6.2)/],\n  [\"Windows 8.1\", /(Windows NT 6.3)/],\n  [\"Windows 10\", /(Windows NT 10.0)/],\n  [\"Windows ME\", /Windows ME/],\n  [\"Open BSD\", /OpenBSD/],\n  [\"Sun OS\", /SunOS/],\n  [\"Chrome OS\", /CrOS/],\n  [\"Linux\", /(Linux)|(X11)/],\n  [\"Mac OS\", /(Mac_PowerPC)|(Macintosh)/],\n  [\"QNX\", /QNX/],\n  [\"BeOS\", /BeOS/],\n  [\"OS/2\", /OS\\/2/]\n];\nfunction detect(userAgent) {\n  if (!!userAgent) {\n    return parseUserAgent(userAgent);\n  }\n  if (typeof document === \"undefined\" && typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\") {\n    return new ReactNativeInfo();\n  }\n  if (typeof navigator !== \"undefined\") {\n    return parseUserAgent(navigator.userAgent);\n  }\n  return getNodeVersion();\n}\nfunction matchUserAgent(ua) {\n  return ua !== \"\" && userAgentRules.reduce(function(matched, _a) {\n    var browser2 = _a[0], regex = _a[1];\n    if (matched) {\n      return matched;\n    }\n    var uaMatch = regex.exec(ua);\n    return !!uaMatch && [browser2, uaMatch];\n  }, false);\n}\nfunction parseUserAgent(ua) {\n  var matchedRule = matchUserAgent(ua);\n  if (!matchedRule) {\n    return null;\n  }\n  var name = matchedRule[0], match = matchedRule[1];\n  if (name === \"searchbot\") {\n    return new BotInfo();\n  }\n  var versionParts = match[1] && match[1].split(\".\").join(\"_\").split(\"_\").slice(0, 3);\n  if (versionParts) {\n    if (versionParts.length < REQUIRED_VERSION_PARTS) {\n      versionParts = __spreadArray(__spreadArray([], versionParts, true), createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length), true);\n    }\n  } else {\n    versionParts = [];\n  }\n  var version2 = versionParts.join(\".\");\n  var os = detectOS(ua);\n  var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);\n  if (searchBotMatch && searchBotMatch[1]) {\n    return new SearchBotDeviceInfo(name, version2, os, searchBotMatch[1]);\n  }\n  return new BrowserInfo(name, version2, os);\n}\nfunction detectOS(ua) {\n  for (var ii = 0, count = operatingSystemRules.length; ii < count; ii++) {\n    var _a = operatingSystemRules[ii], os = _a[0], regex = _a[1];\n    var match = regex.exec(ua);\n    if (match) {\n      return os;\n    }\n  }\n  return null;\n}\nfunction getNodeVersion() {\n  var isNode = typeof process !== \"undefined\" && process.version;\n  return isNode ? new NodeInfo(process.version.slice(1)) : null;\n}\nfunction createVersionParts(count) {\n  var output = [];\n  for (var ii = 0; ii < count; ii++) {\n    output.push(\"0\");\n  }\n  return output;\n}\nvar DefaultNetworkTransport = class _DefaultNetworkTransport {\n  constructor() {\n    if (!_DefaultNetworkTransport.fetch) {\n      throw new Error(\"DefaultNetworkTransport.fetch must be set before it's used\");\n    }\n    if (!_DefaultNetworkTransport.AbortController) {\n      throw new Error(\"DefaultNetworkTransport.AbortController must be set before it's used\");\n    }\n  }\n  fetchWithCallbacks(request, handler) {\n    this.fetch(request).then(async (response) => {\n      const decodedBody = await response.text();\n      const responseHeaders = {};\n      response.headers.forEach((value, key) => {\n        responseHeaders[key] = value;\n      });\n      return {\n        statusCode: response.status,\n        headers: responseHeaders,\n        body: decodedBody\n      };\n    }).then((r) => handler.onSuccess(r)).catch((e) => handler.onError(e));\n  }\n  async fetch(request) {\n    const { timeoutMs, url, ...rest } = request;\n    const { signal, cancelTimeout } = this.createTimeoutSignal(timeoutMs);\n    try {\n      return await _DefaultNetworkTransport.fetch(url, {\n        ..._DefaultNetworkTransport.extraFetchOptions,\n        signal,\n        ...rest\n      });\n    } finally {\n      cancelTimeout();\n    }\n  }\n  createTimeoutSignal(timeoutMs) {\n    if (typeof timeoutMs === \"number\") {\n      const controller = new _DefaultNetworkTransport.AbortController();\n      const timeout = setTimeout(() => {\n        controller.abort();\n      }, timeoutMs);\n      return {\n        signal: controller.signal,\n        cancelTimeout: () => {\n          clearTimeout(timeout);\n        }\n      };\n    } else {\n      return {\n        signal: void 0,\n        cancelTimeout: () => {\n        }\n      };\n    }\n  }\n};\nDefaultNetworkTransport.DEFAULT_HEADERS = {\n  \"Content-Type\": \"application/json\"\n};\nvar setIsDevelopmentMode = (state) => {\n};\nvar check = function(it) {\n  return it && it.Math == Math && it;\n};\nvar safeGlobalThis = (\n  // eslint-disable-next-line no-restricted-globals\n  check(typeof globalThis == \"object\" && globalThis) || check(typeof window == \"object\" && window) || // eslint-disable-next-line no-restricted-globals -- safe\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore allow `self`\n  check(typeof self == \"object\" && self) || // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore allow `global`\n  check(typeof global == \"object\" && global) || // eslint-disable-next-line no-new-func -- fallback\n  /* @__PURE__ */ function() {\n    return this;\n  }() || Function(\"return this\")()\n);\nsetIsDevelopmentMode(typeof __DEV__ !== \"undefined\" && __DEV__);\nDefaultNetworkTransport.fetch = safeGlobalThis.fetch.bind(safeGlobalThis);\nDefaultNetworkTransport.AbortController = safeGlobalThis.AbortController.bind(safeGlobalThis);\nvar version = \"3.7.2\";\nvar VERSION = version;\nvar _hasatob = typeof atob === \"function\";\nvar _hasbtoa = typeof btoa === \"function\";\nvar _hasBuffer = typeof Buffer === \"function\";\nvar _TD = typeof TextDecoder === \"function\" ? new TextDecoder() : void 0;\nvar _TE = typeof TextEncoder === \"function\" ? new TextEncoder() : void 0;\nvar b64ch = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\nvar b64chs = Array.prototype.slice.call(b64ch);\nvar b64tab = ((a) => {\n  let tab = {};\n  a.forEach((c, i) => tab[c] = i);\n  return tab;\n})(b64chs);\nvar b64re = /^(?:[A-Za-z\\d+\\/]{4})*?(?:[A-Za-z\\d+\\/]{2}(?:==)?|[A-Za-z\\d+\\/]{3}=?)?$/;\nvar _fromCC = String.fromCharCode.bind(String);\nvar _U8Afrom = typeof Uint8Array.from === \"function\" ? Uint8Array.from.bind(Uint8Array) : (it, fn = (x) => x) => new Uint8Array(Array.prototype.slice.call(it, 0).map(fn));\nvar _mkUriSafe = (src) => src.replace(/=/g, \"\").replace(/[+\\/]/g, (m0) => m0 == \"+\" ? \"-\" : \"_\");\nvar _tidyB64 = (s) => s.replace(/[^A-Za-z0-9\\+\\/]/g, \"\");\nvar btoaPolyfill = (bin) => {\n  let u32, c0, c1, c2, asc = \"\";\n  const pad = bin.length % 3;\n  for (let i = 0; i < bin.length; ) {\n    if ((c0 = bin.charCodeAt(i++)) > 255 || (c1 = bin.charCodeAt(i++)) > 255 || (c2 = bin.charCodeAt(i++)) > 255)\n      throw new TypeError(\"invalid character found\");\n    u32 = c0 << 16 | c1 << 8 | c2;\n    asc += b64chs[u32 >> 18 & 63] + b64chs[u32 >> 12 & 63] + b64chs[u32 >> 6 & 63] + b64chs[u32 & 63];\n  }\n  return pad ? asc.slice(0, pad - 3) + \"===\".substring(pad) : asc;\n};\nvar _btoa = _hasbtoa ? (bin) => btoa(bin) : _hasBuffer ? (bin) => Buffer.from(bin, \"binary\").toString(\"base64\") : btoaPolyfill;\nvar _fromUint8Array = _hasBuffer ? (u8a) => Buffer.from(u8a).toString(\"base64\") : (u8a) => {\n  const maxargs = 4096;\n  let strs = [];\n  for (let i = 0, l = u8a.length; i < l; i += maxargs) {\n    strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));\n  }\n  return _btoa(strs.join(\"\"));\n};\nvar fromUint8Array = (u8a, urlsafe = false) => urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);\nvar cb_utob = (c) => {\n  if (c.length < 2) {\n    var cc = c.charCodeAt(0);\n    return cc < 128 ? c : cc < 2048 ? _fromCC(192 | cc >>> 6) + _fromCC(128 | cc & 63) : _fromCC(224 | cc >>> 12 & 15) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);\n  } else {\n    var cc = 65536 + (c.charCodeAt(0) - 55296) * 1024 + (c.charCodeAt(1) - 56320);\n    return _fromCC(240 | cc >>> 18 & 7) + _fromCC(128 | cc >>> 12 & 63) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);\n  }\n};\nvar re_utob = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFFF]|[^\\x00-\\x7F]/g;\nvar utob = (u) => u.replace(re_utob, cb_utob);\nvar _encode = _hasBuffer ? (s) => Buffer.from(s, \"utf8\").toString(\"base64\") : _TE ? (s) => _fromUint8Array(_TE.encode(s)) : (s) => _btoa(utob(s));\nvar encode = (src, urlsafe = false) => urlsafe ? _mkUriSafe(_encode(src)) : _encode(src);\nvar encodeURI = (src) => encode(src, true);\nvar re_btou = /[\\xC0-\\xDF][\\x80-\\xBF]|[\\xE0-\\xEF][\\x80-\\xBF]{2}|[\\xF0-\\xF7][\\x80-\\xBF]{3}/g;\nvar cb_btou = (cccc) => {\n  switch (cccc.length) {\n    case 4:\n      var cp = (7 & cccc.charCodeAt(0)) << 18 | (63 & cccc.charCodeAt(1)) << 12 | (63 & cccc.charCodeAt(2)) << 6 | 63 & cccc.charCodeAt(3), offset = cp - 65536;\n      return _fromCC((offset >>> 10) + 55296) + _fromCC((offset & 1023) + 56320);\n    case 3:\n      return _fromCC((15 & cccc.charCodeAt(0)) << 12 | (63 & cccc.charCodeAt(1)) << 6 | 63 & cccc.charCodeAt(2));\n    default:\n      return _fromCC((31 & cccc.charCodeAt(0)) << 6 | 63 & cccc.charCodeAt(1));\n  }\n};\nvar btou = (b) => b.replace(re_btou, cb_btou);\nvar atobPolyfill = (asc) => {\n  asc = asc.replace(/\\s+/g, \"\");\n  if (!b64re.test(asc))\n    throw new TypeError(\"malformed base64.\");\n  asc += \"==\".slice(2 - (asc.length & 3));\n  let u24, bin = \"\", r1, r2;\n  for (let i = 0; i < asc.length; ) {\n    u24 = b64tab[asc.charAt(i++)] << 18 | b64tab[asc.charAt(i++)] << 12 | (r1 = b64tab[asc.charAt(i++)]) << 6 | (r2 = b64tab[asc.charAt(i++)]);\n    bin += r1 === 64 ? _fromCC(u24 >> 16 & 255) : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255) : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);\n  }\n  return bin;\n};\nvar _atob = _hasatob ? (asc) => atob(_tidyB64(asc)) : _hasBuffer ? (asc) => Buffer.from(asc, \"base64\").toString(\"binary\") : atobPolyfill;\nvar _toUint8Array = _hasBuffer ? (a) => _U8Afrom(Buffer.from(a, \"base64\")) : (a) => _U8Afrom(_atob(a), (c) => c.charCodeAt(0));\nvar toUint8Array = (a) => _toUint8Array(_unURI(a));\nvar _decode = _hasBuffer ? (a) => Buffer.from(a, \"base64\").toString(\"utf8\") : _TD ? (a) => _TD.decode(_toUint8Array(a)) : (a) => btou(_atob(a));\nvar _unURI = (a) => _tidyB64(a.replace(/[-_]/g, (m0) => m0 == \"-\" ? \"+\" : \"/\"));\nvar decode = (src) => _decode(_unURI(src));\nvar isValid = (src) => {\n  if (typeof src !== \"string\")\n    return false;\n  const s = src.replace(/\\s+/g, \"\").replace(/={0,2}$/, \"\");\n  return !/[^\\s0-9a-zA-Z\\+/]/.test(s) || !/[^\\s0-9a-zA-Z\\-_]/.test(s);\n};\nvar _noEnum = (v) => {\n  return {\n    value: v,\n    enumerable: false,\n    writable: true,\n    configurable: true\n  };\n};\nvar extendString = function() {\n  const _add = (name, body) => Object.defineProperty(String.prototype, name, _noEnum(body));\n  _add(\"fromBase64\", function() {\n    return decode(this);\n  });\n  _add(\"toBase64\", function(urlsafe) {\n    return encode(this, urlsafe);\n  });\n  _add(\"toBase64URI\", function() {\n    return encode(this, true);\n  });\n  _add(\"toBase64URL\", function() {\n    return encode(this, true);\n  });\n  _add(\"toUint8Array\", function() {\n    return toUint8Array(this);\n  });\n};\nvar extendUint8Array = function() {\n  const _add = (name, body) => Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));\n  _add(\"toBase64\", function(urlsafe) {\n    return fromUint8Array(this, urlsafe);\n  });\n  _add(\"toBase64URI\", function() {\n    return fromUint8Array(this, true);\n  });\n  _add(\"toBase64URL\", function() {\n    return fromUint8Array(this, true);\n  });\n};\nvar extendBuiltins = () => {\n  extendString();\n  extendUint8Array();\n};\nvar gBase64 = {\n  version,\n  VERSION,\n  atob: _atob,\n  atobPolyfill,\n  btoa: _btoa,\n  btoaPolyfill,\n  fromBase64: decode,\n  toBase64: encode,\n  encode,\n  encodeURI,\n  encodeURL: encodeURI,\n  utob,\n  btou,\n  decode,\n  isValid,\n  fromUint8Array,\n  toUint8Array,\n  extendString,\n  extendUint8Array,\n  extendBuiltins\n};\nvar SERIALIZATION_OPTIONS = {\n  relaxed: false\n  // Ensure Canonical mode\n};\nfunction serialize2(obj) {\n  return EJSON.serialize(obj, SERIALIZATION_OPTIONS);\n}\nfunction deserialize2(obj) {\n  if (Array.isArray(obj)) {\n    return obj.map((doc) => EJSON.deserialize(doc));\n  } else {\n    return EJSON.deserialize(obj);\n  }\n}\nvar UserType;\n(function(UserType2) {\n  UserType2[\"Normal\"] = \"normal\";\n  UserType2[\"Server\"] = \"server\";\n})(UserType || (UserType = {}));\nvar DataKey;\n(function(DataKey2) {\n  DataKey2[\"NAME\"] = \"name\";\n  DataKey2[\"EMAIL\"] = \"email\";\n  DataKey2[\"PICTURE\"] = \"picture\";\n  DataKey2[\"FIRST_NAME\"] = \"first_name\";\n  DataKey2[\"LAST_NAME\"] = \"last_name\";\n  DataKey2[\"GENDER\"] = \"gender\";\n  DataKey2[\"BIRTHDAY\"] = \"birthday\";\n  DataKey2[\"MIN_AGE\"] = \"min_age\";\n  DataKey2[\"MAX_AGE\"] = \"max_age\";\n})(DataKey || (DataKey = {}));\nvar DATA_MAPPING = {\n  [DataKey.NAME]: \"name\",\n  [DataKey.EMAIL]: \"email\",\n  [DataKey.PICTURE]: \"pictureUrl\",\n  [DataKey.FIRST_NAME]: \"firstName\",\n  [DataKey.LAST_NAME]: \"lastName\",\n  [DataKey.GENDER]: \"gender\",\n  [DataKey.BIRTHDAY]: \"birthday\",\n  [DataKey.MIN_AGE]: \"minAge\",\n  [DataKey.MAX_AGE]: \"maxAge\"\n};\nvar UserProfile = class {\n  /**\n   * @param response The response of a call fetching the users profile.\n   */\n  constructor(response) {\n    this.type = UserType.Normal;\n    this.identities = [];\n    if (typeof response === \"object\" && response !== null) {\n      const { type, identities, data } = response;\n      if (typeof type === \"string\") {\n        this.type = type;\n      } else {\n        throw new Error(\"Expected 'type' in the response body\");\n      }\n      if (Array.isArray(identities)) {\n        this.identities = identities.map((identity) => {\n          const { id, provider_type: providerType } = identity;\n          return { id, providerType };\n        });\n      } else {\n        throw new Error(\"Expected 'identities' in the response body\");\n      }\n      if (typeof data === \"object\" && data !== null) {\n        const mappedData = Object.fromEntries(Object.entries(data).map(([key, value]) => {\n          if (key in DATA_MAPPING) {\n            return [DATA_MAPPING[key], value];\n          } else {\n            return [key, value];\n          }\n        }));\n        this.data = deserialize2(mappedData);\n      } else {\n        throw new Error(\"Expected 'data' in the response body\");\n      }\n    } else {\n      this.data = {};\n    }\n  }\n};\nvar PrefixedStorage = class _PrefixedStorage {\n  /**\n   * Construct a `Storage` which will prefix a key part to every operation.\n   *\n   * @param storage The underlying storage to use for operations.\n   * @param keyPart The part of the key to prefix when performing operations.\n   */\n  constructor(storage, keyPart) {\n    this.storage = storage;\n    this.keyPart = keyPart;\n  }\n  /** @inheritdoc */\n  get(key) {\n    return this.storage.get(this.keyPart + _PrefixedStorage.PART_SEPARATOR + key);\n  }\n  /** @inheritdoc */\n  set(key, value) {\n    return this.storage.set(this.keyPart + _PrefixedStorage.PART_SEPARATOR + key, value);\n  }\n  /** @inheritdoc */\n  remove(key) {\n    return this.storage.remove(this.keyPart + _PrefixedStorage.PART_SEPARATOR + key);\n  }\n  /** @inheritdoc */\n  prefix(keyPart) {\n    return new _PrefixedStorage(this, keyPart);\n  }\n  /** @inheritdoc */\n  clear(prefix = \"\") {\n    return this.storage.clear(this.keyPart + _PrefixedStorage.PART_SEPARATOR + prefix);\n  }\n  /** @inheritdoc */\n  addListener(listener) {\n    return this.storage.addListener(listener);\n  }\n  /** @inheritdoc */\n  removeListener(listener) {\n    return this.storage.addListener(listener);\n  }\n};\nPrefixedStorage.PART_SEPARATOR = \":\";\nvar MemoryStorage = class {\n  constructor() {\n    this.storage = {};\n    this.listeners = /* @__PURE__ */ new Set();\n  }\n  /** @inheritdoc */\n  get(key) {\n    if (key in this.storage) {\n      return this.storage[key];\n    } else {\n      return null;\n    }\n  }\n  /** @inheritdoc */\n  set(key, value) {\n    this.storage[key] = value;\n    this.fireListeners();\n  }\n  /** @inheritdoc */\n  remove(key) {\n    delete this.storage[key];\n    this.fireListeners();\n  }\n  /** @inheritdoc */\n  prefix(keyPart) {\n    return new PrefixedStorage(this, keyPart);\n  }\n  /** @inheritdoc */\n  clear(prefix) {\n    for (const key of Object.keys(this.storage)) {\n      if (!prefix || key.startsWith(prefix)) {\n        delete this.storage[key];\n      }\n    }\n    this.fireListeners();\n  }\n  /** @inheritdoc */\n  addListener(listener) {\n    this.listeners.add(listener);\n  }\n  /** @inheritdoc */\n  removeListener(listener) {\n    this.listeners.delete(listener);\n  }\n  /**\n   * Tell the listeners that a change occurred.\n   */\n  fireListeners() {\n    this.listeners.forEach((listener) => listener());\n  }\n};\nvar ACCESS_TOKEN_STORAGE_KEY = \"accessToken\";\nvar REFRESH_TOKEN_STORAGE_KEY = \"refreshToken\";\nvar PROFILE_STORAGE_KEY = \"profile\";\nvar PROVIDER_TYPE_STORAGE_KEY = \"providerType\";\nvar UserStorage = class extends PrefixedStorage {\n  /**\n   * Construct a storage for a `User`.\n   *\n   * @param storage The underlying storage to wrap.\n   * @param userId The id of the user.\n   */\n  constructor(storage, userId) {\n    super(storage, `user(${userId})`);\n  }\n  /**\n   * Get the access token from storage.\n   *\n   * @returns Access token (null if unknown).\n   */\n  get accessToken() {\n    return this.get(ACCESS_TOKEN_STORAGE_KEY);\n  }\n  /**\n   * Set the access token in storage.\n   *\n   * @param value Access token (null if unknown).\n   */\n  set accessToken(value) {\n    if (value === null) {\n      this.remove(ACCESS_TOKEN_STORAGE_KEY);\n    } else {\n      this.set(ACCESS_TOKEN_STORAGE_KEY, value);\n    }\n  }\n  /**\n   * Get the refresh token from storage.\n   *\n   * @returns Refresh token (null if unknown and user is logged out).\n   */\n  get refreshToken() {\n    return this.get(REFRESH_TOKEN_STORAGE_KEY);\n  }\n  /**\n   * Set the refresh token in storage.\n   *\n   * @param value Refresh token (null if unknown and user is logged out).\n   */\n  set refreshToken(value) {\n    if (value === null) {\n      this.remove(REFRESH_TOKEN_STORAGE_KEY);\n    } else {\n      this.set(REFRESH_TOKEN_STORAGE_KEY, value);\n    }\n  }\n  /**\n   * Get the user profile from storage.\n   *\n   * @returns User profile (undefined if its unknown).\n   */\n  get profile() {\n    const value = this.get(PROFILE_STORAGE_KEY);\n    if (value) {\n      const profile = new UserProfile();\n      Object.assign(profile, JSON.parse(value));\n      return profile;\n    }\n  }\n  /**\n   * Set the user profile in storage.\n   *\n   * @param value User profile (undefined if its unknown).\n   */\n  set profile(value) {\n    if (value) {\n      this.set(PROFILE_STORAGE_KEY, JSON.stringify(value));\n    } else {\n      this.remove(PROFILE_STORAGE_KEY);\n    }\n  }\n  /**\n   * Get the type of authentication provider used to authenticate\n   *\n   * @returns User profile (undefined if its unknown).\n   */\n  get providerType() {\n    const value = this.get(PROVIDER_TYPE_STORAGE_KEY);\n    if (value) {\n      return value;\n    }\n  }\n  /**\n   * Set the type of authentication provider used to authenticate\n   *\n   * @param value Type of authentication provider.\n   */\n  set providerType(value) {\n    if (value) {\n      this.set(PROVIDER_TYPE_STORAGE_KEY, value);\n    } else {\n      this.remove(PROVIDER_TYPE_STORAGE_KEY);\n    }\n  }\n};\nfunction removeKeysWithUndefinedValues(obj) {\n  return Object.fromEntries(Object.entries(obj).filter((entry) => typeof entry[1] !== \"undefined\"));\n}\nfunction generateRandomString(length, alphabet) {\n  let result = \"\";\n  for (let i = 0; i < length; i++) {\n    result += alphabet[Math.floor(Math.random() * alphabet.length)];\n  }\n  return result;\n}\nfunction encodeQueryString(params, prefixed = true) {\n  const cleanedParams = removeKeysWithUndefinedValues(params);\n  const prefix = prefixed && Object.keys(cleanedParams).length > 0 ? \"?\" : \"\";\n  return prefix + Object.entries(cleanedParams).map(([k, v]) => `${k}=${encodeURIComponent(v)}`).join(\"&\");\n}\nfunction decodeQueryString(str) {\n  const cleanStr = str[0] === \"?\" ? str.substr(1) : str;\n  return Object.fromEntries(cleanStr.split(\"&\").filter((s) => s.length > 0).map((kvp) => kvp.split(\"=\")).map(([k, v]) => [k, decodeURIComponent(v)]));\n}\nvar RESERVED_NAMES = [\n  \"inspect\",\n  \"callFunction\",\n  \"callFunctionStreaming\",\n  // Methods defined on the Object.prototype might be \"typeof probed\" and called by libraries and runtime environments.\n  ...Object.getOwnPropertyNames(Object.prototype)\n];\nfunction cleanArgs(args) {\n  for (const arg of args) {\n    if (typeof arg === \"object\" && arg) {\n      for (const [key, value] of Object.entries(arg)) {\n        if (value === void 0) {\n          delete arg[key];\n        }\n      }\n    }\n  }\n  return args;\n}\nfunction cleanArgsAndSerialize(args) {\n  const cleaned = cleanArgs(args);\n  return cleaned.map((arg) => typeof arg === \"object\" ? serialize2(arg) : arg);\n}\nvar FunctionsFactory = class _FunctionsFactory {\n  /**\n   * @param fetcher The underlying fetcher to use when sending requests.\n   * @param config Additional configuration parameters.\n   */\n  constructor(fetcher, config = {}) {\n    this.fetcher = fetcher;\n    this.serviceName = config.serviceName;\n    this.argsTransformation = config.argsTransformation || cleanArgsAndSerialize;\n  }\n  /**\n   * Create a factory of functions, wrapped in a Proxy that returns bound copies of `callFunction` on any property.\n   *\n   * @param fetcher The underlying fetcher to use when requesting.\n   * @param config Additional configuration parameters.\n   * @returns The newly created factory of functions.\n   */\n  static create(fetcher, config = {}) {\n    const factory = new _FunctionsFactory(fetcher, config);\n    return new Proxy(factory, {\n      get(target, p, receiver) {\n        if (typeof p === \"string\" && RESERVED_NAMES.indexOf(p) === -1) {\n          return target.callFunction.bind(target, p);\n        } else {\n          const prop = Reflect.get(target, p, receiver);\n          return typeof prop === \"function\" ? prop.bind(target) : prop;\n        }\n      }\n    });\n  }\n  /**\n   * Call a remote function by it's name.\n   *\n   * @param name Name of the remote function.\n   * @param args Arguments to pass to the remote function.\n   * @returns A promise of the value returned when executing the remote function.\n   */\n  async callFunction(name, ...args) {\n    const body = {\n      name,\n      arguments: this.argsTransformation ? this.argsTransformation(args) : args\n    };\n    if (this.serviceName) {\n      body.service = this.serviceName;\n    }\n    const appRoute = this.fetcher.appRoute;\n    return this.fetcher.fetchJSON({\n      method: \"POST\",\n      path: appRoute.functionsCall().path,\n      body\n    });\n  }\n  /**\n   * Call a remote function by it's name.\n   *\n   * @param name Name of the remote function.\n   * @param args Arguments to pass to the remote function.\n   * @returns A promise of the value returned when executing the remote function.\n   */\n  callFunctionStreaming(name, ...args) {\n    const body = {\n      name,\n      arguments: this.argsTransformation ? this.argsTransformation(args) : args\n    };\n    if (this.serviceName) {\n      body.service = this.serviceName;\n    }\n    const appRoute = this.fetcher.appRoute;\n    const qs = encodeQueryString({\n      [\"baas_request\"]: gBase64.encode(JSON.stringify(body))\n    });\n    return this.fetcher.fetchStream({\n      method: \"GET\",\n      path: appRoute.functionsCall().path + qs\n    });\n  }\n};\nvar EmailPasswordAuth = class {\n  /**\n   * Construct an interface to the email / password authentication provider.\n   *\n   * @param fetcher The underlying fetcher used to request the services.\n   * @param providerName Optional custom name of the authentication provider.\n   */\n  constructor(fetcher, providerName = \"local-userpass\") {\n    this.fetcher = fetcher;\n    this.providerName = providerName;\n  }\n  /** @inheritdoc */\n  async registerUser(details) {\n    const appRoute = this.fetcher.appRoute;\n    await this.fetcher.fetchJSON({\n      method: \"POST\",\n      path: appRoute.emailPasswordAuth(this.providerName).register().path,\n      body: details\n    });\n  }\n  /** @inheritdoc */\n  async confirmUser(details) {\n    const appRoute = this.fetcher.appRoute;\n    await this.fetcher.fetchJSON({\n      method: \"POST\",\n      path: appRoute.emailPasswordAuth(this.providerName).confirm().path,\n      body: details\n    });\n  }\n  /** @inheritdoc */\n  async resendConfirmationEmail(details) {\n    const appRoute = this.fetcher.appRoute;\n    await this.fetcher.fetchJSON({\n      method: \"POST\",\n      path: appRoute.emailPasswordAuth(this.providerName).confirmSend().path,\n      body: details\n    });\n  }\n  /** @inheritdoc */\n  async retryCustomConfirmation(details) {\n    const appRoute = this.fetcher.appRoute;\n    await this.fetcher.fetchJSON({\n      method: \"POST\",\n      path: appRoute.emailPasswordAuth(this.providerName).confirmCall().path,\n      body: details\n    });\n  }\n  /** @inheritdoc */\n  async resetPassword(details) {\n    const appRoute = this.fetcher.appRoute;\n    await this.fetcher.fetchJSON({\n      method: \"POST\",\n      path: appRoute.emailPasswordAuth(this.providerName).reset().path,\n      body: details\n    });\n  }\n  /** @inheritdoc */\n  async sendResetPasswordEmail(details) {\n    const appRoute = this.fetcher.appRoute;\n    await this.fetcher.fetchJSON({\n      method: \"POST\",\n      path: appRoute.emailPasswordAuth(this.providerName).resetSend().path,\n      body: details\n    });\n  }\n  /** @inheritdoc */\n  async callResetPasswordFunction(details, ...args) {\n    const appRoute = this.fetcher.appRoute;\n    await this.fetcher.fetchJSON({\n      method: \"POST\",\n      path: appRoute.emailPasswordAuth(this.providerName).resetCall().path,\n      body: { ...details, arguments: args }\n    });\n  }\n};\nfunction api() {\n  return {\n    path: \"/api/client/v2.0\",\n    /**\n     * @param appId The id of the app.\n     * @returns The URL of the app endpoint.\n     */\n    app(appId) {\n      return {\n        path: this.path + `/app/${appId}`,\n        /**\n         * @returns The URL of the app location endpoint.\n         */\n        location() {\n          return {\n            path: this.path + \"/location\"\n          };\n        },\n        /**\n         * @param providerName The name of the provider.\n         * @returns The app url concatinated with the /auth/providers/{providerName}\n         */\n        authProvider(providerName) {\n          return {\n            path: this.path + `/auth/providers/${providerName}`,\n            /**\n             * @returns Get the URL of an authentication provider.\n             */\n            login() {\n              return { path: this.path + \"/login\" };\n            }\n          };\n        },\n        /**\n         * @param providerName The name of the provider.\n         * @returns The app url concatinated with the /auth/providers/{providerName}\n         */\n        emailPasswordAuth(providerName) {\n          const authProviderRoutes = this.authProvider(providerName);\n          return {\n            ...authProviderRoutes,\n            register() {\n              return { path: this.path + \"/register\" };\n            },\n            confirm() {\n              return { path: this.path + \"/confirm\" };\n            },\n            confirmSend() {\n              return { path: this.path + \"/confirm/send\" };\n            },\n            confirmCall() {\n              return { path: this.path + \"/confirm/call\" };\n            },\n            reset() {\n              return { path: this.path + \"/reset\" };\n            },\n            resetSend() {\n              return { path: this.path + \"/reset/send\" };\n            },\n            resetCall() {\n              return { path: this.path + \"/reset/call\" };\n            }\n          };\n        },\n        functionsCall() {\n          return {\n            path: this.path + \"/functions/call\"\n          };\n        }\n      };\n    },\n    auth() {\n      return {\n        path: this.path + \"/auth\",\n        apiKeys() {\n          return {\n            path: this.path + \"/api_keys\",\n            key(id) {\n              return {\n                path: this.path + `/${id}`,\n                enable() {\n                  return { path: this.path + \"/enable\" };\n                },\n                disable() {\n                  return { path: this.path + \"/disable\" };\n                }\n              };\n            }\n          };\n        },\n        profile() {\n          return { path: this.path + \"/profile\" };\n        },\n        session() {\n          return { path: this.path + \"/session\" };\n        },\n        delete() {\n          return { path: this.path + \"/delete\" };\n        }\n      };\n    }\n  };\n}\nvar routes = { api };\nvar ApiKeyAuth = class {\n  /**\n   * Construct an interface to the API-key authentication provider.\n   *\n   * @param fetcher The fetcher used to send requests to services.\n   */\n  constructor(fetcher) {\n    this.fetcher = fetcher;\n  }\n  /** @inheritdoc */\n  create(name) {\n    return this.fetcher.fetchJSON({\n      method: \"POST\",\n      body: { name },\n      path: routes.api().auth().apiKeys().path,\n      tokenType: \"refresh\"\n    });\n  }\n  /** @inheritdoc */\n  fetch(keyId) {\n    return this.fetcher.fetchJSON({\n      method: \"GET\",\n      path: routes.api().auth().apiKeys().key(keyId).path,\n      tokenType: \"refresh\"\n    });\n  }\n  /** @inheritdoc */\n  fetchAll() {\n    return this.fetcher.fetchJSON({\n      method: \"GET\",\n      tokenType: \"refresh\",\n      path: routes.api().auth().apiKeys().path\n    });\n  }\n  /** @inheritdoc */\n  async delete(keyId) {\n    await this.fetcher.fetchJSON({\n      method: \"DELETE\",\n      path: routes.api().auth().apiKeys().key(keyId).path,\n      tokenType: \"refresh\"\n    });\n  }\n  /** @inheritdoc */\n  async enable(keyId) {\n    await this.fetcher.fetchJSON({\n      method: \"PUT\",\n      path: routes.api().auth().apiKeys().key(keyId).enable().path,\n      tokenType: \"refresh\"\n    });\n  }\n  /** @inheritdoc */\n  async disable(keyId) {\n    await this.fetcher.fetchJSON({\n      method: \"PUT\",\n      path: routes.api().auth().apiKeys().key(keyId).disable().path,\n      tokenType: \"refresh\"\n    });\n  }\n};\nvar environment = null;\nfunction setEnvironment(e) {\n  environment = e;\n}\nfunction getEnvironment() {\n  if (environment) {\n    return environment;\n  } else {\n    throw new Error(\"Cannot get environment before it's set\");\n  }\n}\nvar WatchError = class extends Error {\n  constructor({ message, code: code2 }) {\n    super(message);\n    this.name = \"WatchError\";\n    this.code = code2;\n  }\n};\nvar WatchStreamState;\n(function(WatchStreamState2) {\n  WatchStreamState2[\"NEED_DATA\"] = \"NEED_DATA\";\n  WatchStreamState2[\"HAVE_EVENT\"] = \"HAVE_EVENT\";\n  WatchStreamState2[\"HAVE_ERROR\"] = \"HAVE_ERROR\";\n})(WatchStreamState || (WatchStreamState = {}));\nvar WatchStream = class {\n  constructor() {\n    this._state = WatchStreamState.NEED_DATA;\n    this._error = null;\n    this._textDecoder = new (getEnvironment()).TextDecoder();\n    this._buffer = \"\";\n    this._bufferOffset = 0;\n    this._eventType = \"\";\n    this._dataBuffer = \"\";\n  }\n  // Call these when you have data, in whatever shape is easiest for your SDK to get.\n  // Pick one, mixing and matching on a single instance isn't supported.\n  // These can only be called in NEED_DATA state, which is the initial state.\n  feedBuffer(buffer2) {\n    this.assertState(WatchStreamState.NEED_DATA);\n    this._buffer += this._textDecoder.decode(buffer2, { stream: true });\n    this.advanceBufferState();\n  }\n  feedLine(line) {\n    this.assertState(WatchStreamState.NEED_DATA);\n    if (line.endsWith(\"\\n\"))\n      line = line.substr(0, line.length - 1);\n    if (line.endsWith(\"\\r\"))\n      line = line.substr(0, line.length - 1);\n    if (line.length === 0) {\n      if (this._dataBuffer.length === 0) {\n        this._eventType = \"\";\n        return;\n      }\n      if (this._dataBuffer.endsWith(\"\\n\"))\n        this._dataBuffer = this._dataBuffer.substr(0, this._dataBuffer.length - 1);\n      this.feedSse({\n        data: this._dataBuffer,\n        eventType: this._eventType\n      });\n      this._dataBuffer = \"\";\n      this._eventType = \"\";\n    }\n    if (line[0] === \":\")\n      return;\n    const colon = line.indexOf(\":\");\n    const field = line.substr(0, colon);\n    let value = colon === -1 ? \"\" : line.substr(colon + 1);\n    if (value.startsWith(\" \"))\n      value = value.substr(1);\n    if (field === \"event\") {\n      this._eventType = value;\n    } else if (field === \"data\") {\n      this._dataBuffer += value;\n      this._dataBuffer += \"\\n\";\n    } else\n      ;\n  }\n  feedSse(sse) {\n    this.assertState(WatchStreamState.NEED_DATA);\n    const firstPercentIndex = sse.data.indexOf(\"%\");\n    if (firstPercentIndex !== -1) {\n      let buffer2 = \"\";\n      let start = 0;\n      for (let percentIndex = firstPercentIndex; percentIndex !== -1; percentIndex = sse.data.indexOf(\"%\", start)) {\n        buffer2 += sse.data.substr(start, percentIndex - start);\n        const encoded = sse.data.substr(percentIndex, 3);\n        if (encoded === \"%25\") {\n          buffer2 += \"%\";\n        } else if (encoded === \"%0A\") {\n          buffer2 += \"\\n\";\n        } else if (encoded === \"%0D\") {\n          buffer2 += \"\\r\";\n        } else {\n          buffer2 += encoded;\n        }\n        start = percentIndex + encoded.length;\n      }\n      buffer2 += sse.data.substr(start);\n      sse.data = buffer2;\n    }\n    if (!sse.eventType || sse.eventType === \"message\") {\n      try {\n        const parsed = EJSON.parse(sse.data);\n        if (typeof parsed === \"object\") {\n          this._nextEvent = parsed;\n          this._state = WatchStreamState.HAVE_EVENT;\n          return;\n        }\n      } catch {\n      }\n      this._state = WatchStreamState.HAVE_ERROR;\n      this._error = new WatchError({\n        message: \"server returned malformed event: \" + sse.data,\n        code: \"bad bson parse\"\n      });\n    } else if (sse.eventType === \"error\") {\n      this._state = WatchStreamState.HAVE_ERROR;\n      this._error = new WatchError({\n        message: sse.data,\n        code: \"unknown\"\n      });\n      try {\n        const { error_code: errorCode, error } = EJSON.parse(sse.data);\n        if (typeof errorCode !== \"string\")\n          return;\n        if (typeof error !== \"string\")\n          return;\n        this._error = new WatchError({\n          message: error,\n          code: errorCode\n        });\n      } catch {\n        return;\n      }\n    } else\n      ;\n  }\n  get state() {\n    return this._state;\n  }\n  // Consumes the returned event. If you used feedBuffer(), there may be another event or error after this one,\n  // so you need to call state() again to see what to do next.\n  nextEvent() {\n    this.assertState(WatchStreamState.HAVE_EVENT);\n    const out = this._nextEvent;\n    this._state = WatchStreamState.NEED_DATA;\n    this.advanceBufferState();\n    return out;\n  }\n  // Once this enters the error state, it stays that way. You should not feed any more data.\n  get error() {\n    return this._error;\n  }\n  ////////////////////////////////////////////\n  advanceBufferState() {\n    this.assertState(WatchStreamState.NEED_DATA);\n    while (this.state === WatchStreamState.NEED_DATA) {\n      if (this._bufferOffset === this._buffer.length) {\n        this._buffer = \"\";\n        this._bufferOffset = 0;\n        return;\n      }\n      const nextNewlineIndex = this._buffer.indexOf(\"\\n\", this._bufferOffset);\n      if (nextNewlineIndex === -1) {\n        if (this._bufferOffset !== 0) {\n          this._buffer = this._buffer.substr(this._bufferOffset, this._buffer.length - this._bufferOffset);\n          this._bufferOffset = 0;\n        }\n        return;\n      }\n      this.feedLine(this._buffer.substr(this._bufferOffset, nextNewlineIndex - this._bufferOffset));\n      this._bufferOffset = nextNewlineIndex + 1;\n    }\n  }\n  assertState(state) {\n    if (this._state !== state) {\n      throw Error(`Expected WatchStream to be in state ${state}, but in state ${this._state}`);\n    }\n  }\n};\nvar MongoDBCollection = class {\n  /**\n   * Construct a remote collection of documents.\n   *\n   * @param fetcher The fetcher to use when requesting the service.\n   * @param serviceName The name of the remote service.\n   * @param databaseName The name of the database.\n   * @param collectionName The name of the remote collection.\n   */\n  constructor(fetcher, serviceName, databaseName, collectionName) {\n    this.functions = FunctionsFactory.create(fetcher, {\n      serviceName\n    });\n    this.databaseName = databaseName;\n    this.collectionName = collectionName;\n    this.serviceName = serviceName;\n    this.fetcher = fetcher;\n  }\n  /** @inheritdoc */\n  find(filter = {}, options = {}) {\n    return this.functions.find({\n      database: this.databaseName,\n      collection: this.collectionName,\n      query: filter,\n      project: options.projection,\n      sort: options.sort,\n      limit: options.limit\n    });\n  }\n  /** @inheritdoc */\n  findOne(filter = {}, options = {}) {\n    return this.functions.findOne({\n      database: this.databaseName,\n      collection: this.collectionName,\n      query: filter,\n      project: options.projection,\n      sort: options.sort\n    });\n  }\n  /** @inheritdoc */\n  findOneAndUpdate(filter = {}, update, options = {}) {\n    return this.functions.findOneAndUpdate({\n      database: this.databaseName,\n      collection: this.collectionName,\n      filter,\n      update,\n      sort: options.sort,\n      projection: options.projection,\n      upsert: options.upsert,\n      returnNewDocument: options.returnNewDocument\n    });\n  }\n  /** @inheritdoc */\n  findOneAndReplace(filter = {}, replacement, options = {}) {\n    return this.functions.findOneAndReplace({\n      database: this.databaseName,\n      collection: this.collectionName,\n      filter,\n      update: replacement,\n      sort: options.sort,\n      projection: options.projection,\n      upsert: options.upsert,\n      returnNewDocument: options.returnNewDocument\n    });\n  }\n  /** @inheritdoc */\n  findOneAndDelete(filter = {}, options = {}) {\n    return this.functions.findOneAndReplace({\n      database: this.databaseName,\n      collection: this.collectionName,\n      filter,\n      sort: options.sort,\n      projection: options.projection\n    });\n  }\n  /** @inheritdoc */\n  aggregate(pipeline) {\n    return this.functions.aggregate({\n      database: this.databaseName,\n      collection: this.collectionName,\n      pipeline\n    });\n  }\n  /** @inheritdoc */\n  count(filter = {}, options = {}) {\n    return this.functions.count({\n      database: this.databaseName,\n      collection: this.collectionName,\n      query: filter,\n      limit: options.limit\n    });\n  }\n  /** @inheritdoc */\n  insertOne(document2) {\n    return this.functions.insertOne({\n      database: this.databaseName,\n      collection: this.collectionName,\n      document: document2\n    });\n  }\n  /** @inheritdoc */\n  insertMany(documents) {\n    return this.functions.insertMany({\n      database: this.databaseName,\n      collection: this.collectionName,\n      documents\n    });\n  }\n  /** @inheritdoc */\n  deleteOne(filter = {}) {\n    return this.functions.deleteOne({\n      database: this.databaseName,\n      collection: this.collectionName,\n      query: filter\n    });\n  }\n  /** @inheritdoc */\n  deleteMany(filter = {}) {\n    return this.functions.deleteMany({\n      database: this.databaseName,\n      collection: this.collectionName,\n      query: filter\n    });\n  }\n  /** @inheritdoc */\n  updateOne(filter, update, options = {}) {\n    return this.functions.updateOne({\n      database: this.databaseName,\n      collection: this.collectionName,\n      query: filter,\n      update,\n      upsert: options.upsert,\n      arrayFilters: options.arrayFilters\n    });\n  }\n  /** @inheritdoc */\n  updateMany(filter, update, options = {}) {\n    return this.functions.updateMany({\n      database: this.databaseName,\n      collection: this.collectionName,\n      query: filter,\n      update,\n      upsert: options.upsert,\n      arrayFilters: options.arrayFilters\n    });\n  }\n  watch({ ids, filter } = {}) {\n    const iterable = this.functions.callFunctionStreaming(\"watch\", {\n      database: this.databaseName,\n      collection: this.collectionName,\n      ids,\n      filter\n    });\n    const iterator = iterable.then((i) => i[Symbol.asyncIterator]());\n    const stream = this.watchImpl(iterator);\n    const originalReturn = stream.return;\n    return Object.assign(stream, {\n      return(value) {\n        iterator.then((i) => i.return ? i.return(value) : void 0);\n        return originalReturn.call(stream, value);\n      }\n    });\n  }\n  /**\n   * @param iterator An async iterator of the response body of a watch request.\n   * @yields Change events.\n   * Note: We had to split this from the `watch` method above to enable manually calling `return` on the response body iterator.\n   */\n  async *watchImpl(iterator) {\n    const watchStream = new WatchStream();\n    const iterable = iterator.then((i) => ({ [Symbol.asyncIterator]: () => i }));\n    for await (const chunk of await iterable) {\n      if (!chunk)\n        continue;\n      watchStream.feedBuffer(chunk);\n      while (watchStream.state == WatchStreamState.HAVE_EVENT) {\n        yield watchStream.nextEvent();\n      }\n      if (watchStream.state == WatchStreamState.HAVE_ERROR)\n        throw watchStream.error;\n    }\n  }\n};\nfunction createCollection(fetcher, serviceName, databaseName, collectionName) {\n  return new MongoDBCollection(fetcher, serviceName, databaseName, collectionName);\n}\nfunction createDatabase(fetcher, serviceName, databaseName) {\n  return {\n    collection: createCollection.bind(null, fetcher, serviceName, databaseName)\n  };\n}\nfunction createService(fetcher, serviceName = \"mongo-db\") {\n  return { db: createDatabase.bind(null, fetcher, serviceName) };\n}\nvar DEFAULT_DEVICE_ID = \"000000000000000000000000\";\nvar UserState;\n(function(UserState2) {\n  UserState2[\"Active\"] = \"active\";\n  UserState2[\"LoggedOut\"] = \"logged-out\";\n  UserState2[\"Removed\"] = \"removed\";\n})(UserState || (UserState = {}));\nvar UserType$1;\n(function(UserType2) {\n  UserType2[\"Normal\"] = \"normal\";\n  UserType2[\"Server\"] = \"server\";\n})(UserType$1 || (UserType$1 = {}));\nvar User = class {\n  /**\n   * @param parameters Parameters of the user.\n   */\n  constructor(parameters) {\n    this.app = parameters.app;\n    this.id = parameters.id;\n    this.storage = new UserStorage(this.app.storage, this.id);\n    if (\"accessToken\" in parameters && \"refreshToken\" in parameters && \"providerType\" in parameters) {\n      this._accessToken = parameters.accessToken;\n      this._refreshToken = parameters.refreshToken;\n      this.providerType = parameters.providerType;\n      this.storage.accessToken = parameters.accessToken;\n      this.storage.refreshToken = parameters.refreshToken;\n      this.storage.providerType = parameters.providerType;\n    } else {\n      this._accessToken = this.storage.accessToken;\n      this._refreshToken = this.storage.refreshToken;\n      const providerType = this.storage.providerType;\n      this._profile = this.storage.profile;\n      if (providerType) {\n        this.providerType = providerType;\n      } else {\n        throw new Error(\"Storage is missing a provider type\");\n      }\n    }\n    this.fetcher = this.app.fetcher.clone({\n      userContext: { currentUser: this }\n    });\n    this.apiKeys = new ApiKeyAuth(this.fetcher);\n    this.functions = FunctionsFactory.create(this.fetcher);\n  }\n  /**\n   * @returns The access token used to authenticate the user towards Atlas App Services.\n   */\n  get accessToken() {\n    return this._accessToken;\n  }\n  /**\n   * @param token The new access token.\n   */\n  set accessToken(token) {\n    this._accessToken = token;\n    this.storage.accessToken = token;\n  }\n  /**\n   * @returns The refresh token used to issue new access tokens.\n   */\n  get refreshToken() {\n    return this._refreshToken;\n  }\n  /**\n   * @param token The new refresh token.\n   */\n  set refreshToken(token) {\n    this._refreshToken = token;\n    this.storage.refreshToken = token;\n  }\n  /**\n   * @returns The current state of the user.\n   */\n  get state() {\n    if (this.id in this.app.allUsers) {\n      return this.refreshToken === null ? UserState.LoggedOut : UserState.Active;\n    } else {\n      return UserState.Removed;\n    }\n  }\n  /**\n   * @returns The logged in state of the user.\n   */\n  get isLoggedIn() {\n    return this.state === UserState.Active;\n  }\n  get customData() {\n    if (this.accessToken) {\n      const decodedToken = this.decodeAccessToken();\n      return decodedToken.userData;\n    } else {\n      throw new Error(\"Cannot read custom data without an access token\");\n    }\n  }\n  /**\n   * @returns Profile containing detailed information about the user.\n   */\n  get profile() {\n    if (this._profile) {\n      return this._profile.data;\n    } else {\n      throw new Error(\"A profile was never fetched for this user\");\n    }\n  }\n  get identities() {\n    if (this._profile) {\n      return this._profile.identities;\n    } else {\n      throw new Error(\"A profile was never fetched for this user\");\n    }\n  }\n  get deviceId() {\n    if (this.accessToken) {\n      const payload = this.accessToken.split(\".\")[1];\n      if (payload) {\n        const parsedPayload = JSON.parse(gBase64.decode(payload));\n        const deviceId = parsedPayload[\"baas_device_id\"];\n        if (typeof deviceId === \"string\" && deviceId !== DEFAULT_DEVICE_ID) {\n          return deviceId;\n        }\n      }\n    }\n    return null;\n  }\n  /**\n   * Refresh the users profile data.\n   */\n  async refreshProfile() {\n    const response = await this.fetcher.fetchJSON({\n      method: \"GET\",\n      path: routes.api().auth().profile().path\n    });\n    this._profile = new UserProfile(response);\n    this.storage.profile = this._profile;\n  }\n  /**\n   * Log out the user, invalidating the session (and its refresh token).\n   */\n  async logOut() {\n    try {\n      if (this._refreshToken !== null) {\n        await this.fetcher.fetchJSON({\n          method: \"DELETE\",\n          path: routes.api().auth().session().path,\n          tokenType: \"refresh\"\n        });\n      }\n    } catch (err) {\n      if (!(err instanceof Error) || !err.message.includes(\"failed to find refresh token\")) {\n        throw err;\n      }\n    } finally {\n      this.accessToken = null;\n      this.refreshToken = null;\n    }\n  }\n  /** @inheritdoc */\n  async linkCredentials(credentials) {\n    const response = await this.app.authenticator.authenticate(credentials, this);\n    if (this.id !== response.userId) {\n      const details = `got user id ${response.userId} expected ${this.id}`;\n      throw new Error(`Link response ment for another user (${details})`);\n    }\n    this.accessToken = response.accessToken;\n    await this.refreshProfile();\n  }\n  /**\n   * Request a new access token, using the refresh token.\n   */\n  async refreshAccessToken() {\n    const response = await this.fetcher.fetchJSON({\n      method: \"POST\",\n      path: routes.api().auth().session().path,\n      tokenType: \"refresh\"\n    });\n    const { access_token: accessToken } = response;\n    if (typeof accessToken === \"string\") {\n      this.accessToken = accessToken;\n    } else {\n      throw new Error(\"Expected an 'access_token' in the response\");\n    }\n  }\n  /** @inheritdoc */\n  async refreshCustomData() {\n    await this.refreshAccessToken();\n    return this.customData;\n  }\n  /**\n   * @inheritdoc\n   */\n  addListener() {\n    throw new Error(\"Not yet implemented\");\n  }\n  /**\n   * @inheritdoc\n   */\n  removeListener() {\n    throw new Error(\"Not yet implemented\");\n  }\n  /**\n   * @inheritdoc\n   */\n  removeAllListeners() {\n    throw new Error(\"Not yet implemented\");\n  }\n  /** @inheritdoc */\n  callFunction(name, ...args) {\n    return this.functions.callFunction(name, ...args);\n  }\n  /**\n   * @returns A plain ol' JavaScript object representation of the user.\n   */\n  toJSON() {\n    return {\n      id: this.id,\n      accessToken: this.accessToken,\n      refreshToken: this.refreshToken,\n      profile: this._profile,\n      state: this.state,\n      customData: this.customData\n    };\n  }\n  /** @inheritdoc */\n  push() {\n    throw new Error(\"Not yet implemented\");\n  }\n  /** @inheritdoc */\n  mongoClient(serviceName) {\n    return createService(this.fetcher, serviceName);\n  }\n  decodeAccessToken() {\n    if (this.accessToken) {\n      const parts = this.accessToken.split(\".\");\n      if (parts.length !== 3) {\n        throw new Error(\"Expected an access token with three parts\");\n      }\n      const encodedPayload = parts[1];\n      const decodedPayload = gBase64.decode(encodedPayload);\n      const parsedPayload = JSON.parse(decodedPayload);\n      const { exp: expires, iat: issuedAt, sub: subject, user_data: userData = {} } = parsedPayload;\n      if (typeof expires !== \"number\") {\n        throw new Error(\"Failed to decode access token 'exp'\");\n      } else if (typeof issuedAt !== \"number\") {\n        throw new Error(\"Failed to decode access token 'iat'\");\n      }\n      return { expires, issuedAt, subject, userData };\n    } else {\n      throw new Error(\"Missing an access token\");\n    }\n  }\n};\nvar Credentials = class _Credentials {\n  /**\n   * Constructs an instance of credentials.\n   *\n   * @param providerName The name of the authentication provider used when authenticating.\n   * @param providerType The type of the authentication provider used when authenticating.\n   * @param payload The data being sent to the service when authenticating.\n   */\n  constructor(providerName, providerType, payload) {\n    this.providerName = providerName;\n    this.providerType = providerType;\n    this.payload = payload;\n  }\n  /**\n   * Creates credentials that logs in using the [Anonymous Provider](https://docs.mongodb.com/realm/authentication/anonymous/).\n   *\n   * @returns The credentials instance, which can be passed to `app.logIn`.\n   */\n  static anonymous() {\n    return new _Credentials(\"anon-user\", \"anon-user\", {});\n  }\n  /**\n   * Creates credentials that logs in using the [API Key Provider](https://docs.mongodb.com/realm/authentication/api-key/).\n   *\n   * @param key The secret content of the API key.\n   * @returns The credentials instance, which can be passed to `app.logIn`.\n   */\n  static apiKey(key) {\n    return new _Credentials(\"api-key\", \"api-key\", { key });\n  }\n  /**\n   * Creates credentials that logs in using the [Email/Password Provider](https://docs.mongodb.com/realm/authentication/email-password/).\n   * Note: This was formerly known as the \"Username/Password\" provider.\n   *\n   * @param email The end-users email address.\n   * @param password The end-users password.\n   * @returns The credentials instance, which can be passed to `app.logIn`.\n   */\n  static emailPassword(email, password) {\n    return new _Credentials(\"local-userpass\", \"local-userpass\", {\n      username: email,\n      password\n    });\n  }\n  /**\n   * Creates credentials that logs in using the [Custom Function Provider](https://docs.mongodb.com/realm/authentication/custom-function/).\n   *\n   * @param payload The custom payload as expected by the server.\n   * @returns The credentials instance, which can be passed to `app.logIn`.\n   */\n  static function(payload) {\n    return new _Credentials(\"custom-function\", \"custom-function\", payload);\n  }\n  /**\n   * Creates credentials that logs in using the [Custom JWT Provider](https://docs.mongodb.com/realm/authentication/custom-jwt/).\n   *\n   * @param token The JSON Web Token (JWT).\n   * @returns The credentials instance, which can be passed to `app.logIn`.\n   */\n  static jwt(token) {\n    return new _Credentials(\"custom-token\", \"custom-token\", {\n      token\n    });\n  }\n  /**\n   * Creates credentials that logs in using the [Google Provider](https://docs.mongodb.com/realm/authentication/google/).\n   *\n   * @param payload The URL that users should be redirected to, the auth code or id token from Google.\n   * @returns The credentials instance, which can be passed to `app.logIn`.\n   */\n  static google(payload) {\n    return new _Credentials(\"oauth2-google\", \"oauth2-google\", _Credentials.derivePayload(payload));\n  }\n  /**\n   * @param payload The payload string.\n   * @returns A payload object based on the string.\n   */\n  static derivePayload(payload) {\n    if (typeof payload === \"string\") {\n      throw new Error(\"`google(<tokenString>)` has been deprecated.  Please use `google(<authCodeObject>).\");\n    } else if (Object.keys(payload).length === 1) {\n      if (\"authCode\" in payload || \"redirectUrl\" in payload) {\n        return payload;\n      } else if (\"idToken\" in payload) {\n        return { id_token: payload.idToken };\n      } else {\n        throw new Error(\"Unexpected payload: \" + JSON.stringify(payload));\n      }\n    } else {\n      throw new Error(\"Expected only one property in payload, got \" + JSON.stringify(payload));\n    }\n  }\n  /**\n   * Creates credentials that logs in using the [Facebook Provider](https://docs.mongodb.com/realm/authentication/facebook/).\n   *\n   * @param redirectUrlOrAccessToken The URL that users should be redirected to or the auth code returned from Facebook.\n   * @returns The credentials instance, which can be passed to `app.logIn`.\n   */\n  static facebook(redirectUrlOrAccessToken) {\n    return new _Credentials(\"oauth2-facebook\", \"oauth2-facebook\", redirectUrlOrAccessToken.includes(\"://\") ? { redirectUrl: redirectUrlOrAccessToken } : { accessToken: redirectUrlOrAccessToken });\n  }\n  /**\n   * Creates credentials that logs in using the [Apple ID Provider](https://docs.mongodb.com/realm/authentication/apple/).\n   *\n   * @param redirectUrlOrIdToken The URL that users should be redirected to or the id_token returned from Apple.\n   * @returns The credentials instance, which can be passed to `app.logIn`.\n   */\n  static apple(redirectUrlOrIdToken) {\n    return new _Credentials(\"oauth2-apple\", \"oauth2-apple\", redirectUrlOrIdToken.includes(\"://\") ? { redirectUrl: redirectUrlOrIdToken } : { id_token: redirectUrlOrIdToken });\n  }\n};\nvar USER_IDS_STORAGE_KEY = \"userIds\";\nvar DEVICE_ID_STORAGE_KEY = \"deviceId\";\nvar AppStorage = class extends PrefixedStorage {\n  /**\n   * @param storage The underlying storage to wrap.\n   * @param appId The id of the app.\n   */\n  constructor(storage, appId) {\n    super(storage, `app(${appId})`);\n  }\n  /**\n   * Reads out the list of user ids from storage.\n   *\n   * @returns A list of user ids.\n   */\n  getUserIds() {\n    const userIdsString = this.get(USER_IDS_STORAGE_KEY);\n    const userIds = userIdsString ? JSON.parse(userIdsString) : [];\n    if (Array.isArray(userIds)) {\n      return [...new Set(userIds)];\n    } else {\n      throw new Error(\"Expected the user ids to be an array\");\n    }\n  }\n  /**\n   * Sets the list of ids in storage.\n   * Optionally merging with existing ids stored in the storage, by prepending these while voiding duplicates.\n   *\n   * @param userIds The list of ids to store.\n   * @param mergeWithExisting Prepend existing ids to avoid data-races with other apps using this storage.\n   */\n  setUserIds(userIds, mergeWithExisting) {\n    if (mergeWithExisting) {\n      const existingIds = this.getUserIds();\n      for (const id of existingIds) {\n        if (userIds.indexOf(id) === -1) {\n          userIds.push(id);\n        }\n      }\n    }\n    this.set(USER_IDS_STORAGE_KEY, JSON.stringify(userIds));\n  }\n  /**\n   * Remove an id from the list of ids.\n   *\n   * @param userId The id of a User to be removed.\n   */\n  removeUserId(userId) {\n    const existingIds = this.getUserIds();\n    const userIds = existingIds.filter((id) => id !== userId);\n    this.setUserIds(userIds, false);\n  }\n  /**\n   * @returns id of this device (if any exists)\n   */\n  getDeviceId() {\n    return this.get(DEVICE_ID_STORAGE_KEY);\n  }\n  /**\n   * @param deviceId The id of this device, to send on subsequent authentication requests.\n   */\n  setDeviceId(deviceId) {\n    this.set(DEVICE_ID_STORAGE_KEY, deviceId);\n  }\n};\nvar LOWERCASE_LETTERS = \"abcdefghijklmnopqrstuvwxyz\";\nvar CLOSE_CHECK_INTERVAL = 100;\nvar REDIRECT_HASH_TO_RESULT = {\n  _stitch_client_app_id: \"appId\",\n  _baas_client_app_id: \"appId\",\n  _stitch_ua: \"userAuth\",\n  _baas_ua: \"userAuth\",\n  _stitch_link: \"link\",\n  _baas_link: \"link\",\n  _stitch_error: \"error\",\n  _baas_error: \"error\",\n  _stitch_state: \"state\",\n  _baas_state: \"state\"\n};\nvar OAuth2Helper = class _OAuth2Helper {\n  /**\n   * @param storage The underlying storage to use when storing and retriving secrets.\n   * @param openWindow An optional function called when a browser window needs to open.\n   */\n  constructor(storage, openWindow2 = getEnvironment().openWindow) {\n    this.storage = storage.prefix(\"oauth2\");\n    this.openWindow = openWindow2;\n  }\n  /**\n   * Parses the query string from the final step of the OAuth flow.\n   *\n   * @param queryString The query string passed through in location.hash.\n   * @returns The result of the OAuth flow.\n   */\n  static parseRedirectLocation(queryString) {\n    const params = decodeQueryString(queryString);\n    const result = {};\n    for (const [p, r] of Object.entries(REDIRECT_HASH_TO_RESULT)) {\n      const value = params[p];\n      if (value) {\n        result[r] = value;\n      }\n    }\n    return result;\n  }\n  /**\n   * Handle the redirect querystring by parsing it and storing it for others to consume.\n   *\n   * @param queryString The query string containing the encoded result from the OAuth provider.\n   * @param storage The underlying storage used to persist the result.\n   */\n  static handleRedirect(queryString, storage = getEnvironment().defaultStorage) {\n    const result = _OAuth2Helper.parseRedirectLocation(queryString);\n    const { state, error } = result;\n    if (typeof state === \"string\") {\n      const oauth2Storage = storage.prefix(\"oauth2\");\n      const stateStorage = _OAuth2Helper.getStateStorage(oauth2Storage, state);\n      stateStorage.set(\"result\", JSON.stringify(result));\n    } else if (error) {\n      throw new Error(`Failed to handle OAuth 2.0 redirect: ${error}`);\n    } else {\n      throw new Error(\"Failed to handle OAuth 2.0 redirect.\");\n    }\n  }\n  /**\n   * Decodes the authInfo string into its seperate parts.\n   *\n   * @param authInfo An authInfo string returned from the server.\n   * @returns An object containing the separate parts of the authInfo string.\n   */\n  static decodeAuthInfo(authInfo) {\n    const parts = (authInfo || \"\").split(\"$\");\n    if (parts.length === 4) {\n      const [accessToken, refreshToken, userId, deviceId] = parts;\n      return { accessToken, refreshToken, userId, deviceId };\n    } else {\n      throw new Error(\"Failed to decode 'authInfo' into ids and tokens\");\n    }\n  }\n  /**\n   * Get the storage key associated of an secret associated with a state.\n   *\n   * @param storage The root storage used to derive a \"state namespaced\" storage.\n   * @param state The random state.\n   * @returns The storage associated with a particular state.\n   */\n  static getStateStorage(storage, state) {\n    return storage.prefix(`state(${state})`);\n  }\n  /**\n   * Open a window and wait for the redirect to be handled.\n   *\n   * @param url The URL to open.\n   * @param state The state which will be used to listen for storage updates.\n   * @returns The result passed through the redirect.\n   */\n  openWindowAndWaitForRedirect(url, state) {\n    const stateStorage = _OAuth2Helper.getStateStorage(this.storage, state);\n    return new Promise((resolve, reject) => {\n      let redirectWindow = null;\n      let windowClosedInterval;\n      const handleStorageUpdate = () => {\n        const result = stateStorage.get(\"result\");\n        if (result) {\n          const parsedResult = JSON.parse(result);\n          stateStorage.removeListener(handleStorageUpdate);\n          stateStorage.clear();\n          try {\n            if (redirectWindow) {\n              clearInterval(windowClosedInterval);\n              redirectWindow.close();\n            }\n          } catch (err) {\n            console.warn(`Failed closing redirect window: ${err}`);\n          } finally {\n            resolve(parsedResult);\n          }\n        }\n      };\n      stateStorage.addListener(handleStorageUpdate);\n      redirectWindow = this.openWindow(url);\n      windowClosedInterval = setInterval(() => {\n        if (!redirectWindow) {\n          clearInterval(windowClosedInterval);\n        } else if (redirectWindow.closed) {\n          clearInterval(windowClosedInterval);\n          stateStorage.removeListener(handleStorageUpdate);\n          const err = new Error(\"Window closed\");\n          reject(err);\n        }\n      }, CLOSE_CHECK_INTERVAL);\n    });\n  }\n  /**\n   * Generate a random state string.\n   *\n   * @returns The random state string.\n   */\n  generateState() {\n    return generateRandomString(12, LOWERCASE_LETTERS);\n  }\n};\nvar REDIRECT_LOCATION_HEADER = \"x-baas-location\";\nvar Authenticator = class {\n  /**\n   * @param fetcher The fetcher used to fetch responses from the server.\n   * @param storage The storage used when completing OAuth 2.0 flows (should not be scoped to a specific app).\n   * @param getDeviceInformation Called to get device information to be sent to the server.\n   */\n  constructor(fetcher, storage, getDeviceInformation) {\n    this.fetcher = fetcher;\n    this.oauth2 = new OAuth2Helper(storage);\n    this.getDeviceInformation = getDeviceInformation;\n  }\n  /**\n   * @param credentials Credentials to use when logging in.\n   * @param linkingUser A user requesting to link.\n   * @returns A promise resolving to the response from the server.\n   */\n  async authenticate(credentials, linkingUser) {\n    const deviceInformation = this.getDeviceInformation();\n    const isLinking = typeof linkingUser === \"object\";\n    if (credentials.providerType.startsWith(\"oauth2\") && typeof credentials.payload.redirectUrl === \"string\") {\n      const state = this.oauth2.generateState();\n      const url = await this.getLogInUrl(credentials, isLinking, {\n        state,\n        redirect: credentials.payload.redirectUrl,\n        // Ensure redirects are communicated in a header different from \"Location\" and status remains 200 OK\n        providerRedirectHeader: isLinking ? true : void 0,\n        // Add the device information, only if we're not linking - since that request won't have a body of its own.\n        device: !isLinking ? deviceInformation.encode() : void 0\n      });\n      if (isLinking) {\n        const response = await this.fetcher.fetch({\n          method: \"GET\",\n          url,\n          tokenType: isLinking ? \"access\" : \"none\",\n          user: linkingUser,\n          // The response will set a cookie that we need to tell the browser to store\n          mode: \"cors\",\n          credentials: \"include\"\n        });\n        const redirectUrl = response.headers.get(REDIRECT_LOCATION_HEADER);\n        if (redirectUrl) {\n          return this.openWindowAndWaitForAuthResponse(redirectUrl, state);\n        } else {\n          throw new Error(`Missing ${REDIRECT_LOCATION_HEADER} header`);\n        }\n      } else {\n        return this.openWindowAndWaitForAuthResponse(url, state);\n      }\n    } else {\n      const logInUrl = await this.getLogInUrl(credentials, isLinking);\n      const response = await this.fetcher.fetchJSON({\n        method: \"POST\",\n        url: logInUrl,\n        body: {\n          ...credentials.payload,\n          options: {\n            device: deviceInformation.toJSON()\n          }\n        },\n        tokenType: isLinking ? \"access\" : \"none\",\n        user: linkingUser\n      });\n      const { user_id: userId, access_token: accessToken, refresh_token: refreshToken = null, device_id: deviceId } = response;\n      if (typeof userId !== \"string\") {\n        throw new Error(\"Expected a user id in the response\");\n      }\n      if (typeof accessToken !== \"string\") {\n        throw new Error(\"Expected an access token in the response\");\n      }\n      if (typeof refreshToken !== \"string\" && refreshToken !== null) {\n        throw new Error(\"Expected refresh token to be a string or null\");\n      }\n      if (typeof deviceId !== \"string\") {\n        throw new Error(\"Expected device id to be a string\");\n      }\n      return { userId, accessToken, refreshToken, deviceId };\n    }\n  }\n  /**\n   * @param credentials Credentials to use when logging in.\n   * @param link Should the request link with the current user?\n   * @param extraQueryParams Any extra parameters to include in the query string\n   * @returns A promise resolving to the url to be used when logging in.\n   */\n  async getLogInUrl(credentials, link = false, extraQueryParams = {}) {\n    const appRoute = this.fetcher.appRoute;\n    const loginRoute = appRoute.authProvider(credentials.providerName).login();\n    const qs = encodeQueryString({\n      link: link ? \"true\" : void 0,\n      ...extraQueryParams\n    });\n    const locationUrl = await this.fetcher.locationUrl;\n    return locationUrl + loginRoute.path + qs;\n  }\n  async openWindowAndWaitForAuthResponse(redirectUrl, state) {\n    const redirectResult = await this.oauth2.openWindowAndWaitForRedirect(redirectUrl, state);\n    return OAuth2Helper.decodeAuthInfo(redirectResult.userAuth);\n  }\n};\nvar MongoDBRealmError = class _MongoDBRealmError extends Error {\n  constructor(method, url, statusCode, statusText, error, errorCode, link) {\n    const summary = statusText ? `status ${statusCode} ${statusText}` : `status ${statusCode}`;\n    if (typeof error === \"string\") {\n      super(`Request failed (${method} ${url}): ${error} (${summary})`);\n    } else {\n      super(`Request failed (${method} ${url}): (${summary})`);\n    }\n    this.method = method;\n    this.url = url;\n    this.statusText = statusText;\n    this.statusCode = statusCode;\n    this.error = error;\n    this.errorCode = errorCode;\n    this.link = link;\n  }\n  /**\n   * Constructs and returns an error from a request and a response.\n   * Note: The caller must throw this error themselves.\n   *\n   * @param request The request sent to the server.\n   * @param response A raw response, as returned from the server.\n   * @returns An error from a request and a response.\n   */\n  static async fromRequestAndResponse(request, response) {\n    var _a;\n    const { url, method } = request;\n    const { status, statusText } = response;\n    if ((_a = response.headers.get(\"content-type\")) === null || _a === void 0 ? void 0 : _a.startsWith(\"application/json\")) {\n      const body = await response.json();\n      if (typeof body === \"object\" && body) {\n        const { error, error_code: errorCode, link } = body;\n        return new _MongoDBRealmError(method, url, status, statusText, typeof error === \"string\" ? error : void 0, typeof errorCode === \"string\" ? errorCode : void 0, typeof link === \"string\" ? link : void 0);\n      }\n    }\n    return new _MongoDBRealmError(method, url, status, statusText);\n  }\n};\nfunction asyncIteratorFromResponseBody(body) {\n  if (typeof body !== \"object\" || body === null) {\n    throw new Error(\"Expected a non-null object\");\n  } else if (Symbol.asyncIterator in body) {\n    return body;\n  } else if (\"getReader\" in body) {\n    const stream = body;\n    return {\n      [Symbol.asyncIterator]() {\n        const reader = stream.getReader();\n        return {\n          next() {\n            return reader.read();\n          },\n          async return() {\n            await reader.cancel();\n            return { done: true, value: null };\n          }\n        };\n      }\n    };\n  } else {\n    throw new Error(\"Expected an AsyncIterable or a ReadableStream\");\n  }\n}\nvar Fetcher = class _Fetcher {\n  /**\n   * @param config A configuration of the fetcher.\n   * @param config.appId The application id.\n   * @param config.transport The transport used when fetching.\n   * @param config.userContext An object used to determine the requesting user.\n   * @param config.locationUrlContext An object used to determine the location / base URL.\n   */\n  constructor({ appId, transport, userContext, locationUrlContext }) {\n    this.appId = appId;\n    this.transport = transport;\n    this.userContext = userContext;\n    this.locationUrlContext = locationUrlContext;\n  }\n  /**\n   * @param user An optional user to generate the header for.\n   * @param tokenType The type of token (access or refresh).\n   * @returns An object containing the user's token as \"Authorization\" header or undefined if no user is given.\n   */\n  static buildAuthorizationHeader(user, tokenType) {\n    if (!user || tokenType === \"none\") {\n      return {};\n    } else if (tokenType === \"access\") {\n      return { Authorization: `Bearer ${user.accessToken}` };\n    } else if (tokenType === \"refresh\") {\n      return { Authorization: `Bearer ${user.refreshToken}` };\n    } else {\n      throw new Error(`Unexpected token type (${tokenType})`);\n    }\n  }\n  /**\n   * @param body The body string or object passed from a request.\n   * @returns An object optionally specifying the \"Content-Type\" header.\n   */\n  static buildBody(body) {\n    if (!body) {\n      return;\n    } else if (typeof body === \"object\" && body !== null) {\n      return JSON.stringify(serialize2(body));\n    } else if (typeof body === \"string\") {\n      return body;\n    } else {\n      console.log(\"body is\", body);\n      throw new Error(\"Unexpected type of body\");\n    }\n  }\n  /**\n   * @param body The body string or object passed from a request.\n   * @returns An object optionally specifying the \"Content-Type\" header.\n   */\n  static buildJsonHeader(body) {\n    if (body && body.length > 0) {\n      return { \"Content-Type\": \"application/json\" };\n    } else {\n      return {};\n    }\n  }\n  clone(config) {\n    return new _Fetcher({\n      appId: this.appId,\n      transport: this.transport,\n      userContext: this.userContext,\n      locationUrlContext: this.locationUrlContext,\n      ...config\n    });\n  }\n  /**\n   * Fetch a network resource as an authenticated user.\n   *\n   * @param request The request which should be sent to the server.\n   * @returns The response from the server.\n   */\n  async fetch(request) {\n    const { path, url, tokenType = \"access\", user = this.userContext.currentUser, ...restOfRequest } = request;\n    if (typeof path === \"string\" && typeof url === \"string\") {\n      throw new Error(\"Use of 'url' and 'path' mutually exclusive\");\n    } else if (typeof path === \"string\") {\n      const url2 = await this.locationUrlContext.locationUrl + path;\n      return this.fetch({ ...request, path: void 0, url: url2 });\n    } else if (typeof url === \"string\") {\n      const response = await this.transport.fetch({\n        ...restOfRequest,\n        url,\n        headers: {\n          ..._Fetcher.buildAuthorizationHeader(user, tokenType),\n          ...request.headers\n        }\n      });\n      if (response.ok) {\n        return response;\n      } else if (user && response.status === 401 && tokenType === \"access\") {\n        await user.refreshAccessToken();\n        return this.fetch({ ...request, user });\n      } else {\n        if (user && response.status === 401 && tokenType === \"refresh\") {\n          user.accessToken = null;\n          user.refreshToken = null;\n        }\n        throw await MongoDBRealmError.fromRequestAndResponse(request, response);\n      }\n    } else {\n      throw new Error(\"Expected either 'url' or 'path'\");\n    }\n  }\n  /**\n   * Fetch a network resource as an authenticated user and parse the result as extended JSON.\n   *\n   * @param request The request which should be sent to the server.\n   * @returns The response from the server, parsed as extended JSON.\n   */\n  async fetchJSON(request) {\n    const { body } = request;\n    const serializedBody = _Fetcher.buildBody(body);\n    const contentTypeHeaders = _Fetcher.buildJsonHeader(serializedBody);\n    const response = await this.fetch({\n      ...request,\n      body: serializedBody,\n      headers: {\n        Accept: \"application/json\",\n        ...contentTypeHeaders,\n        ...request.headers\n      }\n    });\n    const contentType = response.headers.get(\"content-type\");\n    if (contentType === null || contentType === void 0 ? void 0 : contentType.startsWith(\"application/json\")) {\n      const responseBody = await response.json();\n      return deserialize2(responseBody);\n    } else if (contentType === null) {\n      return null;\n    } else {\n      throw new Error(`Expected JSON response, got \"${contentType}\"`);\n    }\n  }\n  /**\n   * Fetch an \"event-stream\" resource as an authenticated user.\n   *\n   * @param request The request which should be sent to the server.\n   * @returns An async iterator over the response body.\n   */\n  async fetchStream(request) {\n    const { body } = await this.fetch({\n      ...request,\n      headers: {\n        Accept: \"text/event-stream\",\n        ...request.headers\n      }\n    });\n    return asyncIteratorFromResponseBody(body);\n  }\n  /**\n   * @returns The path of the app route.\n   */\n  get appRoute() {\n    return routes.api().app(this.appId);\n  }\n  /**\n   * @returns A promise of the location URL of the app.\n   */\n  get locationUrl() {\n    return this.locationUrlContext.locationUrl;\n  }\n};\nvar DEVICE_ID_STORAGE_KEY$1 = \"deviceId\";\nvar DeviceFields;\n(function(DeviceFields2) {\n  DeviceFields2[\"DEVICE_ID\"] = \"deviceId\";\n  DeviceFields2[\"APP_ID\"] = \"appId\";\n  DeviceFields2[\"APP_VERSION\"] = \"appVersion\";\n  DeviceFields2[\"PLATFORM\"] = \"platform\";\n  DeviceFields2[\"PLATFORM_VERSION\"] = \"platformVersion\";\n  DeviceFields2[\"SDK_VERSION\"] = \"sdkVersion\";\n})(DeviceFields || (DeviceFields = {}));\nvar DeviceInformation = class {\n  /**\n   * @param params Construct the device information from these parameters.\n   * @param params.appId A user-defined application id.\n   * @param params.appVersion A user-defined application version.\n   * @param params.deviceId An unique id for the end-users device.\n   */\n  constructor({ appId, appVersion, deviceId }) {\n    this.sdkVersion = \"2.0.0\";\n    const environment2 = getEnvironment();\n    this.platform = environment2.platform;\n    this.platformVersion = environment2.platformVersion;\n    this.appId = appId;\n    this.appVersion = appVersion;\n    this.deviceId = deviceId;\n  }\n  /**\n   * @returns An base64 URI encoded representation of the device information.\n   */\n  encode() {\n    const obj = removeKeysWithUndefinedValues(this);\n    return gBase64.encode(JSON.stringify(obj));\n  }\n  /**\n   * @returns The defaults\n   */\n  toJSON() {\n    return removeKeysWithUndefinedValues(this);\n  }\n};\nvar DEFAULT_BASE_URL = \"https://realm.mongodb.com\";\nvar App = class _App {\n  /**\n   * Construct a Realm App, either from the Realm App id visible from the Atlas App Services UI or a configuration.\n   *\n   * @param idOrConfiguration The Realm App id or a configuration to use for this app.\n   */\n  constructor(idOrConfiguration) {\n    this.users = [];\n    this._locationUrl = null;\n    const configuration = typeof idOrConfiguration === \"string\" ? { id: idOrConfiguration } : idOrConfiguration;\n    if (typeof configuration === \"object\" && typeof configuration.id === \"string\") {\n      this.id = configuration.id;\n    } else {\n      throw new Error(\"Missing an Atlas App Services app-id\");\n    }\n    this.baseUrl = configuration.baseUrl || DEFAULT_BASE_URL;\n    if (configuration.skipLocationRequest) {\n      this._locationUrl = Promise.resolve(this.baseUrl);\n    }\n    this.localApp = configuration.app;\n    const { storage, transport = new DefaultNetworkTransport() } = configuration;\n    this.fetcher = new Fetcher({\n      appId: this.id,\n      userContext: this,\n      locationUrlContext: this,\n      transport\n    });\n    this.emailPasswordAuth = new EmailPasswordAuth(this.fetcher);\n    const baseStorage = storage || getEnvironment().defaultStorage;\n    this.storage = new AppStorage(baseStorage, this.id);\n    this.authenticator = new Authenticator(this.fetcher, baseStorage, () => this.deviceInformation);\n    try {\n      this.hydrate();\n    } catch (err) {\n      this.storage.clear();\n      console.warn(\"Realm app hydration failed:\", err instanceof Error ? err.message : err);\n    }\n  }\n  /**\n   * Get or create a singleton Realm App from an id.\n   * Calling this function multiple times with the same id will return the same instance.\n   *\n   * @param id The Realm App id visible from the Atlas App Services UI or a configuration.\n   * @returns The Realm App instance.\n   */\n  static getApp(id) {\n    if (id in _App.appCache) {\n      return _App.appCache[id];\n    } else {\n      const instance = new _App(id);\n      _App.appCache[id] = instance;\n      return instance;\n    }\n  }\n  /**\n   * Switch user.\n   *\n   * @param nextUser The user or id of the user to switch to.\n   */\n  switchUser(nextUser) {\n    const index = this.users.findIndex((u) => u === nextUser);\n    if (index === -1) {\n      throw new Error(\"The user was never logged into this app\");\n    }\n    const [user] = this.users.splice(index, 1);\n    this.users.unshift(user);\n  }\n  /**\n   * Log in a user.\n   *\n   * @param credentials Credentials to use when logging in.\n   * @param fetchProfile Should the users profile be fetched? (default: true)\n   * @returns A promise resolving to the newly logged in user.\n   */\n  async logIn(credentials, fetchProfile = true) {\n    const response = await this.authenticator.authenticate(credentials);\n    const user = this.createOrUpdateUser(response, credentials.providerType);\n    this.switchUser(user);\n    if (fetchProfile) {\n      await user.refreshProfile();\n    }\n    this.storage.setUserIds(this.users.map((u) => u.id), true);\n    const deviceId = response.deviceId;\n    if (deviceId && deviceId !== \"000000000000000000000000\") {\n      this.storage.set(DEVICE_ID_STORAGE_KEY$1, deviceId);\n    }\n    return user;\n  }\n  /**\n   * @inheritdoc\n   */\n  async removeUser(user) {\n    const index = this.users.findIndex((u) => u === user);\n    if (index === -1) {\n      throw new Error(\"The user was never logged into this app\");\n    }\n    this.users.splice(index, 1);\n    await user.logOut();\n    this.storage.remove(`user(${user.id}):profile`);\n    this.storage.removeUserId(user.id);\n  }\n  /**\n   * @inheritdoc\n   */\n  async deleteUser(user) {\n    await this.fetcher.fetchJSON({\n      method: \"DELETE\",\n      path: routes.api().auth().delete().path\n    });\n    await this.removeUser(user);\n  }\n  /**\n   * @inheritdoc\n   */\n  addListener() {\n    throw new Error(\"Not yet implemented\");\n  }\n  /**\n   * @inheritdoc\n   */\n  removeListener() {\n    throw new Error(\"Not yet implemented\");\n  }\n  /**\n   * @inheritdoc\n   */\n  removeAllListeners() {\n    throw new Error(\"Not yet implemented\");\n  }\n  /**\n   * The currently active user (or null if no active users exists).\n   *\n   * @returns the currently active user or null.\n   */\n  get currentUser() {\n    const activeUsers = this.users.filter((user) => user.state === UserState.Active);\n    if (activeUsers.length === 0) {\n      return null;\n    } else {\n      return activeUsers[0];\n    }\n  }\n  /**\n   * All active and logged-out users:\n   *  - First in the list are active users (ordered by most recent call to switchUser or login)\n   *  - Followed by logged out users (also ordered by most recent call to switchUser or login).\n   *\n   * @returns An array of users active or logged out users (current user being the first).\n   */\n  get allUsers() {\n    return Object.fromEntries(this.users.map((user) => [user.id, user]));\n  }\n  /**\n   * @returns A promise of the app URL, with the app location resolved.\n   */\n  get locationUrl() {\n    if (!this._locationUrl) {\n      const path = routes.api().app(this.id).location().path;\n      this._locationUrl = this.fetcher.fetchJSON({\n        method: \"GET\",\n        url: this.baseUrl + path,\n        tokenType: \"none\"\n      }).then((body) => {\n        if (typeof body !== \"object\") {\n          throw new Error(\"Expected response body be an object\");\n        } else {\n          return body;\n        }\n      }).then(({ hostname }) => {\n        if (typeof hostname !== \"string\") {\n          throw new Error(\"Expected response to contain a 'hostname'\");\n        } else {\n          return hostname;\n        }\n      }).catch((err) => {\n        this._locationUrl = null;\n        throw err;\n      });\n    }\n    return this._locationUrl;\n  }\n  /**\n   * @returns Information about the current device, sent to the server when authenticating.\n   */\n  get deviceInformation() {\n    const deviceIdStr = this.storage.getDeviceId();\n    const deviceId = typeof deviceIdStr === \"string\" && deviceIdStr !== \"000000000000000000000000\" ? new ObjectId(deviceIdStr) : void 0;\n    return new DeviceInformation({\n      appId: this.localApp ? this.localApp.name : void 0,\n      appVersion: this.localApp ? this.localApp.version : void 0,\n      deviceId\n    });\n  }\n  /**\n   * Create (and store) a new user or update an existing user's access and refresh tokens.\n   * This helps de-duplicating users in the list of users known to the app.\n   *\n   * @param response A response from the Authenticator.\n   * @param providerType The type of the authentication provider used.\n   * @returns A new or an existing user.\n   */\n  createOrUpdateUser(response, providerType) {\n    const existingUser = this.users.find((u) => u.id === response.userId);\n    if (existingUser) {\n      existingUser.accessToken = response.accessToken;\n      existingUser.refreshToken = response.refreshToken;\n      return existingUser;\n    } else {\n      if (!response.refreshToken) {\n        throw new Error(\"No refresh token in response from server\");\n      }\n      const user = new User({\n        app: this,\n        id: response.userId,\n        accessToken: response.accessToken,\n        refreshToken: response.refreshToken,\n        providerType\n      });\n      this.users.unshift(user);\n      return user;\n    }\n  }\n  /**\n   * Restores the state of the app (active and logged-out users) from the storage\n   */\n  hydrate() {\n    const userIds = this.storage.getUserIds();\n    this.users = userIds.map((id) => new User({ app: this, id }));\n  }\n};\nApp.appCache = {};\nApp.Credentials = Credentials;\nfunction getApp(id) {\n  return App.getApp(id);\n}\nvar setIsDevelopmentMode$1 = (state) => {\n};\nvar check$1 = function(it) {\n  return it && it.Math == Math && it;\n};\nvar safeGlobalThis$1 = (\n  // eslint-disable-next-line no-restricted-globals\n  check$1(typeof globalThis == \"object\" && globalThis) || check$1(typeof window == \"object\" && window) || // eslint-disable-next-line no-restricted-globals -- safe\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore allow `self`\n  check$1(typeof self == \"object\" && self) || // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore allow `global`\n  check$1(typeof global == \"object\" && global) || // eslint-disable-next-line no-new-func -- fallback\n  /* @__PURE__ */ function() {\n    return this;\n  }() || Function(\"return this\")()\n);\nsetIsDevelopmentMode$1(typeof __DEV__ !== \"undefined\" && __DEV__);\nvar LocalStorage = class {\n  /**\n   * Constructs a LocalStorage using the global window.\n   */\n  constructor() {\n    if (typeof safeGlobalThis$1.localStorage === \"object\") {\n      this.global = safeGlobalThis$1;\n    } else {\n      throw new Error(\"Cannot use LocalStorage without a global localStorage object\");\n    }\n  }\n  /** @inheritdoc */\n  get(key) {\n    return this.global.localStorage.getItem(key);\n  }\n  /** @inheritdoc */\n  set(key, value) {\n    return this.global.localStorage.setItem(key, value);\n  }\n  /** @inheritdoc */\n  remove(key) {\n    return this.global.localStorage.removeItem(key);\n  }\n  /** @inheritdoc */\n  prefix(keyPart) {\n    return new PrefixedStorage(this, keyPart);\n  }\n  /** @inheritdoc */\n  clear(prefix) {\n    const keys = [];\n    for (let i = 0; i < this.global.localStorage.length; i++) {\n      const key = this.global.localStorage.key(i);\n      if (key && (!prefix || key.startsWith(prefix))) {\n        keys.push(key);\n      }\n    }\n    for (const key of keys) {\n      this.global.localStorage.removeItem(key);\n    }\n  }\n  /** @inheritdoc */\n  addListener(listener) {\n    return this.global.addEventListener(\"storage\", listener);\n  }\n  /** @inheritdoc */\n  removeListener(listener) {\n    return this.global.removeEventListener(\"storage\", listener);\n  }\n};\nvar browser = detect();\nvar DefaultStorage = \"localStorage\" in safeGlobalThis$1 ? LocalStorage : MemoryStorage;\nfunction openWindow(url) {\n  if (typeof safeGlobalThis$1.open === \"function\") {\n    return safeGlobalThis$1.open(url);\n  } else {\n    console.log(`Please open ${url}`);\n    return null;\n  }\n}\nvar environment$1 = {\n  defaultStorage: new DefaultStorage().prefix(\"realm-web\"),\n  openWindow,\n  platform: (browser === null || browser === void 0 ? void 0 : browser.name) || \"web\",\n  platformVersion: (browser === null || browser === void 0 ? void 0 : browser.version) || \"0.0.0\",\n  TextDecoder\n};\nsetEnvironment(environment$1);\nfunction handleAuthRedirect(location = safeGlobalThis$1.location, storage = environment$1.defaultStorage) {\n  try {\n    const queryString = location.hash.substr(1);\n    OAuth2Helper.handleRedirect(queryString, storage);\n  } catch (err) {\n    console.warn(err);\n  }\n}\nexport {\n  App,\n  bson_browser_esm_exports as BSON,\n  Credentials,\n  DEFAULT_BASE_URL,\n  LocalStorage,\n  MongoDBRealmError,\n  User,\n  UserState,\n  UserType$1 as UserType,\n  getApp,\n  getEnvironment,\n  handleAuthRedirect,\n  setEnvironment\n};\n/*! Bundled license information:\n\nbson/dist/bson.browser.esm.js:\n  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)\n  (*! *****************************************************************************\n  Copyright (c) Microsoft Corporation.\n  \n  Permission to use, copy, modify, and/or distribute this software for any\n  purpose with or without fee is hereby granted.\n  \n  THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n  PERFORMANCE OF THIS SOFTWARE.\n  ***************************************************************************** *)\n*/\n//# sourceMappingURL=realm-web.js.map\n",
      "start": 1703474738740,
      "end": 1703474742337,
      "sourcemaps": null
    },
    {
      "name": "vite:react-babel",
      "start": 1703474742337,
      "end": 1703474742337,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1703474742337,
      "end": 1703474742337,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1703474742337,
      "end": 1703474742337,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1703474742337,
      "end": 1703474742337,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1703474742337,
      "end": 1703474742337,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1703474742337,
      "end": 1703474742337,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1703474742337,
      "end": 1703474742337,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1703474742337,
      "end": 1703474742337,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1703474742337,
      "end": 1703474742337,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1703474742337,
      "end": 1703474742337,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1703474742337,
      "end": 1703474742337,
      "order": "normal"
    },
    {
      "name": "vite:client-inject",
      "start": 1703474742337,
      "end": 1703474742337,
      "order": "normal"
    },
    {
      "name": "vite:import-analysis",
      "result": "\"use strict\";\n(() => {\n  var __create = Object.create;\n  var __defProp = Object.defineProperty;\n  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n  var __getOwnPropNames = Object.getOwnPropertyNames;\n  var __getProtoOf = Object.getPrototypeOf;\n  var __hasOwnProp = Object.prototype.hasOwnProperty;\n  var __esm = (fn, res) => function __init() {\n    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;\n  };\n  var __commonJS = (cb, mod) => function __require() {\n    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n  };\n  var __copyProps = (to, from, except, desc) => {\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n      for (let key of __getOwnPropNames(from))\n        if (!__hasOwnProp.call(to, key) && key !== except)\n          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n    }\n    return to;\n  };\n  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n    // If the importer is in node compatibility mode or this is not an ESM\n    // file that has been converted to a CommonJS file using a Babel-\n    // compatible transform (i.e. \"__esModule\" has not been set), then set\n    // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n    isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n    mod\n  ));\n\n  // node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js\n  var require_base64_js = __commonJS({\n    \"node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js\"(exports) {\n      \"use strict\";\n      init_dist();\n      exports.byteLength = byteLength;\n      exports.toByteArray = toByteArray;\n      exports.fromByteArray = fromByteArray;\n      var lookup = [];\n      var revLookup = [];\n      var Arr = typeof Uint8Array !== \"undefined\" ? Uint8Array : Array;\n      var code = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n      for (i = 0, len = code.length; i < len; ++i) {\n        lookup[i] = code[i];\n        revLookup[code.charCodeAt(i)] = i;\n      }\n      var i;\n      var len;\n      revLookup[\"-\".charCodeAt(0)] = 62;\n      revLookup[\"_\".charCodeAt(0)] = 63;\n      function getLens(b64) {\n        var len2 = b64.length;\n        if (len2 % 4 > 0) {\n          throw new Error(\"Invalid string. Length must be a multiple of 4\");\n        }\n        var validLen = b64.indexOf(\"=\");\n        if (validLen === -1)\n          validLen = len2;\n        var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;\n        return [validLen, placeHoldersLen];\n      }\n      function byteLength(b64) {\n        var lens = getLens(b64);\n        var validLen = lens[0];\n        var placeHoldersLen = lens[1];\n        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n      }\n      function _byteLength(b64, validLen, placeHoldersLen) {\n        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n      }\n      function toByteArray(b64) {\n        var tmp;\n        var lens = getLens(b64);\n        var validLen = lens[0];\n        var placeHoldersLen = lens[1];\n        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n        var curByte = 0;\n        var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;\n        var i2;\n        for (i2 = 0; i2 < len2; i2 += 4) {\n          tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];\n          arr[curByte++] = tmp >> 16 & 255;\n          arr[curByte++] = tmp >> 8 & 255;\n          arr[curByte++] = tmp & 255;\n        }\n        if (placeHoldersLen === 2) {\n          tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;\n          arr[curByte++] = tmp & 255;\n        }\n        if (placeHoldersLen === 1) {\n          tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;\n          arr[curByte++] = tmp >> 8 & 255;\n          arr[curByte++] = tmp & 255;\n        }\n        return arr;\n      }\n      function tripletToBase64(num) {\n        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];\n      }\n      function encodeChunk(uint8, start, end) {\n        var tmp;\n        var output = [];\n        for (var i2 = start; i2 < end; i2 += 3) {\n          tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);\n          output.push(tripletToBase64(tmp));\n        }\n        return output.join(\"\");\n      }\n      function fromByteArray(uint8) {\n        var tmp;\n        var len2 = uint8.length;\n        var extraBytes = len2 % 3;\n        var parts = [];\n        var maxChunkLength = 16383;\n        for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {\n          parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));\n        }\n        if (extraBytes === 1) {\n          tmp = uint8[len2 - 1];\n          parts.push(\n            lookup[tmp >> 2] + lookup[tmp << 4 & 63] + \"==\"\n          );\n        } else if (extraBytes === 2) {\n          tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];\n          parts.push(\n            lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + \"=\"\n          );\n        }\n        return parts.join(\"\");\n      }\n    }\n  });\n\n  // node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js\n  var require_ieee754 = __commonJS({\n    \"node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js\"(exports) {\n      init_dist();\n      exports.read = function(buffer, offset, isLE, mLen, nBytes) {\n        var e, m;\n        var eLen = nBytes * 8 - mLen - 1;\n        var eMax = (1 << eLen) - 1;\n        var eBias = eMax >> 1;\n        var nBits = -7;\n        var i = isLE ? nBytes - 1 : 0;\n        var d = isLE ? -1 : 1;\n        var s2 = buffer[offset + i];\n        i += d;\n        e = s2 & (1 << -nBits) - 1;\n        s2 >>= -nBits;\n        nBits += eLen;\n        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {\n        }\n        m = e & (1 << -nBits) - 1;\n        e >>= -nBits;\n        nBits += mLen;\n        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {\n        }\n        if (e === 0) {\n          e = 1 - eBias;\n        } else if (e === eMax) {\n          return m ? NaN : (s2 ? -1 : 1) * Infinity;\n        } else {\n          m = m + Math.pow(2, mLen);\n          e = e - eBias;\n        }\n        return (s2 ? -1 : 1) * m * Math.pow(2, e - mLen);\n      };\n      exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {\n        var e, m, c;\n        var eLen = nBytes * 8 - mLen - 1;\n        var eMax = (1 << eLen) - 1;\n        var eBias = eMax >> 1;\n        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n        var i = isLE ? 0 : nBytes - 1;\n        var d = isLE ? 1 : -1;\n        var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n        value = Math.abs(value);\n        if (isNaN(value) || value === Infinity) {\n          m = isNaN(value) ? 1 : 0;\n          e = eMax;\n        } else {\n          e = Math.floor(Math.log(value) / Math.LN2);\n          if (value * (c = Math.pow(2, -e)) < 1) {\n            e--;\n            c *= 2;\n          }\n          if (e + eBias >= 1) {\n            value += rt / c;\n          } else {\n            value += rt * Math.pow(2, 1 - eBias);\n          }\n          if (value * c >= 2) {\n            e++;\n            c /= 2;\n          }\n          if (e + eBias >= eMax) {\n            m = 0;\n            e = eMax;\n          } else if (e + eBias >= 1) {\n            m = (value * c - 1) * Math.pow(2, mLen);\n            e = e + eBias;\n          } else {\n            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n            e = 0;\n          }\n        }\n        for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {\n        }\n        e = e << mLen | m;\n        eLen += mLen;\n        for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {\n        }\n        buffer[offset + i - d] |= s2 * 128;\n      };\n    }\n  });\n\n  // node_modules/.pnpm/buffer@6.0.3_patch_hash=zkkuxompt5d553skpnegwi5wuy/node_modules/buffer/index.js\n  var require_buffer = __commonJS({\n    \"node_modules/.pnpm/buffer@6.0.3_patch_hash=zkkuxompt5d553skpnegwi5wuy/node_modules/buffer/index.js\"(exports) {\n      \"use strict\";\n      init_dist();\n      var base64 = require_base64_js();\n      var ieee754 = require_ieee754();\n      var customInspectSymbol = typeof Symbol === \"function\" && typeof Symbol[\"for\"] === \"function\" ? Symbol[\"for\"](\"nodejs.util.inspect.custom\") : null;\n      exports.Buffer = Buffer2;\n      exports.SlowBuffer = SlowBuffer;\n      exports.INSPECT_MAX_BYTES = 50;\n      var K_MAX_LENGTH = 2147483647;\n      exports.kMaxLength = K_MAX_LENGTH;\n      var { Uint8Array: GlobalUint8Array, ArrayBuffer: GlobalArrayBuffer, SharedArrayBuffer: GlobalSharedArrayBuffer } = globalThis;\n      Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();\n      if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== \"undefined\" && typeof console.error === \"function\") {\n        console.error(\n          \"This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.\"\n        );\n      }\n      function typedArraySupport() {\n        try {\n          const arr = new GlobalUint8Array(1);\n          const proto = { foo: function() {\n            return 42;\n          } };\n          Object.setPrototypeOf(proto, GlobalUint8Array.prototype);\n          Object.setPrototypeOf(arr, proto);\n          return arr.foo() === 42;\n        } catch (e) {\n          return false;\n        }\n      }\n      Object.defineProperty(Buffer2.prototype, \"parent\", {\n        enumerable: true,\n        get: function() {\n          if (!Buffer2.isBuffer(this))\n            return void 0;\n          return this.buffer;\n        }\n      });\n      Object.defineProperty(Buffer2.prototype, \"offset\", {\n        enumerable: true,\n        get: function() {\n          if (!Buffer2.isBuffer(this))\n            return void 0;\n          return this.byteOffset;\n        }\n      });\n      function createBuffer(length) {\n        if (length > K_MAX_LENGTH) {\n          throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"');\n        }\n        const buf = new GlobalUint8Array(length);\n        Object.setPrototypeOf(buf, Buffer2.prototype);\n        return buf;\n      }\n      function Buffer2(arg, encodingOrOffset, length) {\n        if (typeof arg === \"number\") {\n          if (typeof encodingOrOffset === \"string\") {\n            throw new TypeError(\n              'The \"string\" argument must be of type string. Received type number'\n            );\n          }\n          return allocUnsafe(arg);\n        }\n        return from(arg, encodingOrOffset, length);\n      }\n      Buffer2.poolSize = 8192;\n      function from(value, encodingOrOffset, length) {\n        if (typeof value === \"string\") {\n          return fromString(value, encodingOrOffset);\n        }\n        if (GlobalArrayBuffer.isView(value)) {\n          return fromArrayView(value);\n        }\n        if (value == null) {\n          throw new TypeError(\n            \"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value\n          );\n        }\n        if (isInstance(value, GlobalArrayBuffer) || value && isInstance(value.buffer, GlobalArrayBuffer)) {\n          return fromArrayBuffer(value, encodingOrOffset, length);\n        }\n        if (typeof GlobalSharedArrayBuffer !== \"undefined\" && (isInstance(value, GlobalSharedArrayBuffer) || value && isInstance(value.buffer, GlobalSharedArrayBuffer))) {\n          return fromArrayBuffer(value, encodingOrOffset, length);\n        }\n        if (typeof value === \"number\") {\n          throw new TypeError(\n            'The \"value\" argument must not be of type number. Received type number'\n          );\n        }\n        const valueOf = value.valueOf && value.valueOf();\n        if (valueOf != null && valueOf !== value) {\n          return Buffer2.from(valueOf, encodingOrOffset, length);\n        }\n        const b = fromObject(value);\n        if (b)\n          return b;\n        if (typeof Symbol !== \"undefined\" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === \"function\") {\n          return Buffer2.from(value[Symbol.toPrimitive](\"string\"), encodingOrOffset, length);\n        }\n        throw new TypeError(\n          \"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value\n        );\n      }\n      Buffer2.from = function(value, encodingOrOffset, length) {\n        return from(value, encodingOrOffset, length);\n      };\n      Object.setPrototypeOf(Buffer2.prototype, GlobalUint8Array.prototype);\n      Object.setPrototypeOf(Buffer2, GlobalUint8Array);\n      function assertSize(size) {\n        if (typeof size !== \"number\") {\n          throw new TypeError('\"size\" argument must be of type number');\n        } else if (size < 0) {\n          throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"');\n        }\n      }\n      function alloc(size, fill, encoding) {\n        assertSize(size);\n        if (size <= 0) {\n          return createBuffer(size);\n        }\n        if (fill !== void 0) {\n          return typeof encoding === \"string\" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);\n        }\n        return createBuffer(size);\n      }\n      Buffer2.alloc = function(size, fill, encoding) {\n        return alloc(size, fill, encoding);\n      };\n      function allocUnsafe(size) {\n        assertSize(size);\n        return createBuffer(size < 0 ? 0 : checked(size) | 0);\n      }\n      Buffer2.allocUnsafe = function(size) {\n        return allocUnsafe(size);\n      };\n      Buffer2.allocUnsafeSlow = function(size) {\n        return allocUnsafe(size);\n      };\n      function fromString(string, encoding) {\n        if (typeof encoding !== \"string\" || encoding === \"\") {\n          encoding = \"utf8\";\n        }\n        if (!Buffer2.isEncoding(encoding)) {\n          throw new TypeError(\"Unknown encoding: \" + encoding);\n        }\n        const length = byteLength(string, encoding) | 0;\n        let buf = createBuffer(length);\n        const actual = buf.write(string, encoding);\n        if (actual !== length) {\n          buf = buf.slice(0, actual);\n        }\n        return buf;\n      }\n      function fromArrayLike(array) {\n        const length = array.length < 0 ? 0 : checked(array.length) | 0;\n        const buf = createBuffer(length);\n        for (let i = 0; i < length; i += 1) {\n          buf[i] = array[i] & 255;\n        }\n        return buf;\n      }\n      function fromArrayView(arrayView) {\n        if (isInstance(arrayView, GlobalUint8Array)) {\n          const copy = new GlobalUint8Array(arrayView);\n          return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);\n        }\n        return fromArrayLike(arrayView);\n      }\n      function fromArrayBuffer(array, byteOffset, length) {\n        if (byteOffset < 0 || array.byteLength < byteOffset) {\n          throw new RangeError('\"offset\" is outside of buffer bounds');\n        }\n        if (array.byteLength < byteOffset + (length || 0)) {\n          throw new RangeError('\"length\" is outside of buffer bounds');\n        }\n        let buf;\n        if (byteOffset === void 0 && length === void 0) {\n          buf = new GlobalUint8Array(array);\n        } else if (length === void 0) {\n          buf = new GlobalUint8Array(array, byteOffset);\n        } else {\n          buf = new GlobalUint8Array(array, byteOffset, length);\n        }\n        Object.setPrototypeOf(buf, Buffer2.prototype);\n        return buf;\n      }\n      function fromObject(obj) {\n        if (Buffer2.isBuffer(obj)) {\n          const len = checked(obj.length) | 0;\n          const buf = createBuffer(len);\n          if (buf.length === 0) {\n            return buf;\n          }\n          obj.copy(buf, 0, 0, len);\n          return buf;\n        }\n        if (obj.length !== void 0) {\n          if (typeof obj.length !== \"number\" || numberIsNaN(obj.length)) {\n            return createBuffer(0);\n          }\n          return fromArrayLike(obj);\n        }\n        if (obj.type === \"Buffer\" && Array.isArray(obj.data)) {\n          return fromArrayLike(obj.data);\n        }\n      }\n      function checked(length) {\n        if (length >= K_MAX_LENGTH) {\n          throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\" + K_MAX_LENGTH.toString(16) + \" bytes\");\n        }\n        return length | 0;\n      }\n      function SlowBuffer(length) {\n        if (+length != length) {\n          length = 0;\n        }\n        return Buffer2.alloc(+length);\n      }\n      Buffer2.isBuffer = function isBuffer(b) {\n        return b != null && b._isBuffer === true && b !== Buffer2.prototype;\n      };\n      Buffer2.compare = function compare(a, b) {\n        if (isInstance(a, GlobalUint8Array))\n          a = Buffer2.from(a, a.offset, a.byteLength);\n        if (isInstance(b, GlobalUint8Array))\n          b = Buffer2.from(b, b.offset, b.byteLength);\n        if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {\n          throw new TypeError(\n            'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n          );\n        }\n        if (a === b)\n          return 0;\n        let x = a.length;\n        let y = b.length;\n        for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n          if (a[i] !== b[i]) {\n            x = a[i];\n            y = b[i];\n            break;\n          }\n        }\n        if (x < y)\n          return -1;\n        if (y < x)\n          return 1;\n        return 0;\n      };\n      Buffer2.isEncoding = function isEncoding(encoding) {\n        switch (String(encoding).toLowerCase()) {\n          case \"hex\":\n          case \"utf8\":\n          case \"utf-8\":\n          case \"ascii\":\n          case \"latin1\":\n          case \"binary\":\n          case \"base64\":\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return true;\n          default:\n            return false;\n        }\n      };\n      Buffer2.concat = function concat(list, length) {\n        if (!Array.isArray(list)) {\n          throw new TypeError('\"list\" argument must be an Array of Buffers');\n        }\n        if (list.length === 0) {\n          return Buffer2.alloc(0);\n        }\n        let i;\n        if (length === void 0) {\n          length = 0;\n          for (i = 0; i < list.length; ++i) {\n            length += list[i].length;\n          }\n        }\n        const buffer = Buffer2.allocUnsafe(length);\n        let pos = 0;\n        for (i = 0; i < list.length; ++i) {\n          let buf = list[i];\n          if (isInstance(buf, GlobalUint8Array)) {\n            if (pos + buf.length > buffer.length) {\n              if (!Buffer2.isBuffer(buf))\n                buf = Buffer2.from(buf);\n              buf.copy(buffer, pos);\n            } else {\n              GlobalUint8Array.prototype.set.call(\n                buffer,\n                buf,\n                pos\n              );\n            }\n          } else if (!Buffer2.isBuffer(buf)) {\n            throw new TypeError('\"list\" argument must be an Array of Buffers');\n          } else {\n            buf.copy(buffer, pos);\n          }\n          pos += buf.length;\n        }\n        return buffer;\n      };\n      function byteLength(string, encoding) {\n        if (Buffer2.isBuffer(string)) {\n          return string.length;\n        }\n        if (GlobalArrayBuffer.isView(string) || isInstance(string, GlobalArrayBuffer)) {\n          return string.byteLength;\n        }\n        if (typeof string !== \"string\") {\n          throw new TypeError(\n            'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string\n          );\n        }\n        const len = string.length;\n        const mustMatch = arguments.length > 2 && arguments[2] === true;\n        if (!mustMatch && len === 0)\n          return 0;\n        let loweredCase = false;\n        for (; ; ) {\n          switch (encoding) {\n            case \"ascii\":\n            case \"latin1\":\n            case \"binary\":\n              return len;\n            case \"utf8\":\n            case \"utf-8\":\n              return utf8ToBytes(string).length;\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n              return len * 2;\n            case \"hex\":\n              return len >>> 1;\n            case \"base64\":\n              return base64ToBytes(string).length;\n            default:\n              if (loweredCase) {\n                return mustMatch ? -1 : utf8ToBytes(string).length;\n              }\n              encoding = (\"\" + encoding).toLowerCase();\n              loweredCase = true;\n          }\n        }\n      }\n      Buffer2.byteLength = byteLength;\n      function slowToString(encoding, start, end) {\n        let loweredCase = false;\n        if (start === void 0 || start < 0) {\n          start = 0;\n        }\n        if (start > this.length) {\n          return \"\";\n        }\n        if (end === void 0 || end > this.length) {\n          end = this.length;\n        }\n        if (end <= 0) {\n          return \"\";\n        }\n        end >>>= 0;\n        start >>>= 0;\n        if (end <= start) {\n          return \"\";\n        }\n        if (!encoding)\n          encoding = \"utf8\";\n        while (true) {\n          switch (encoding) {\n            case \"hex\":\n              return hexSlice(this, start, end);\n            case \"utf8\":\n            case \"utf-8\":\n              return utf8Slice(this, start, end);\n            case \"ascii\":\n              return asciiSlice(this, start, end);\n            case \"latin1\":\n            case \"binary\":\n              return latin1Slice(this, start, end);\n            case \"base64\":\n              return base64Slice(this, start, end);\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n              return utf16leSlice(this, start, end);\n            default:\n              if (loweredCase)\n                throw new TypeError(\"Unknown encoding: \" + encoding);\n              encoding = (encoding + \"\").toLowerCase();\n              loweredCase = true;\n          }\n        }\n      }\n      Buffer2.prototype._isBuffer = true;\n      function swap(b, n, m) {\n        const i = b[n];\n        b[n] = b[m];\n        b[m] = i;\n      }\n      Buffer2.prototype.swap16 = function swap16() {\n        const len = this.length;\n        if (len % 2 !== 0) {\n          throw new RangeError(\"Buffer size must be a multiple of 16-bits\");\n        }\n        for (let i = 0; i < len; i += 2) {\n          swap(this, i, i + 1);\n        }\n        return this;\n      };\n      Buffer2.prototype.swap32 = function swap32() {\n        const len = this.length;\n        if (len % 4 !== 0) {\n          throw new RangeError(\"Buffer size must be a multiple of 32-bits\");\n        }\n        for (let i = 0; i < len; i += 4) {\n          swap(this, i, i + 3);\n          swap(this, i + 1, i + 2);\n        }\n        return this;\n      };\n      Buffer2.prototype.swap64 = function swap64() {\n        const len = this.length;\n        if (len % 8 !== 0) {\n          throw new RangeError(\"Buffer size must be a multiple of 64-bits\");\n        }\n        for (let i = 0; i < len; i += 8) {\n          swap(this, i, i + 7);\n          swap(this, i + 1, i + 6);\n          swap(this, i + 2, i + 5);\n          swap(this, i + 3, i + 4);\n        }\n        return this;\n      };\n      Buffer2.prototype.toString = function toString() {\n        const length = this.length;\n        if (length === 0)\n          return \"\";\n        if (arguments.length === 0)\n          return utf8Slice(this, 0, length);\n        return slowToString.apply(this, arguments);\n      };\n      Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;\n      Buffer2.prototype.equals = function equals(b) {\n        if (!Buffer2.isBuffer(b))\n          throw new TypeError(\"Argument must be a Buffer\");\n        if (this === b)\n          return true;\n        return Buffer2.compare(this, b) === 0;\n      };\n      Buffer2.prototype.inspect = function inspect() {\n        let str = \"\";\n        const max = exports.INSPECT_MAX_BYTES;\n        str = this.toString(\"hex\", 0, max).replace(/(.{2})/g, \"$1 \").trim();\n        if (this.length > max)\n          str += \" ... \";\n        return \"<Buffer \" + str + \">\";\n      };\n      if (customInspectSymbol) {\n        Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;\n      }\n      Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n        if (isInstance(target, GlobalUint8Array)) {\n          target = Buffer2.from(target, target.offset, target.byteLength);\n        }\n        if (!Buffer2.isBuffer(target)) {\n          throw new TypeError(\n            'The \"target\" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target\n          );\n        }\n        if (start === void 0) {\n          start = 0;\n        }\n        if (end === void 0) {\n          end = target ? target.length : 0;\n        }\n        if (thisStart === void 0) {\n          thisStart = 0;\n        }\n        if (thisEnd === void 0) {\n          thisEnd = this.length;\n        }\n        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n          throw new RangeError(\"out of range index\");\n        }\n        if (thisStart >= thisEnd && start >= end) {\n          return 0;\n        }\n        if (thisStart >= thisEnd) {\n          return -1;\n        }\n        if (start >= end) {\n          return 1;\n        }\n        start >>>= 0;\n        end >>>= 0;\n        thisStart >>>= 0;\n        thisEnd >>>= 0;\n        if (this === target)\n          return 0;\n        let x = thisEnd - thisStart;\n        let y = end - start;\n        const len = Math.min(x, y);\n        const thisCopy = this.slice(thisStart, thisEnd);\n        const targetCopy = target.slice(start, end);\n        for (let i = 0; i < len; ++i) {\n          if (thisCopy[i] !== targetCopy[i]) {\n            x = thisCopy[i];\n            y = targetCopy[i];\n            break;\n          }\n        }\n        if (x < y)\n          return -1;\n        if (y < x)\n          return 1;\n        return 0;\n      };\n      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n        if (buffer.length === 0)\n          return -1;\n        if (typeof byteOffset === \"string\") {\n          encoding = byteOffset;\n          byteOffset = 0;\n        } else if (byteOffset > 2147483647) {\n          byteOffset = 2147483647;\n        } else if (byteOffset < -2147483648) {\n          byteOffset = -2147483648;\n        }\n        byteOffset = +byteOffset;\n        if (numberIsNaN(byteOffset)) {\n          byteOffset = dir ? 0 : buffer.length - 1;\n        }\n        if (byteOffset < 0)\n          byteOffset = buffer.length + byteOffset;\n        if (byteOffset >= buffer.length) {\n          if (dir)\n            return -1;\n          else\n            byteOffset = buffer.length - 1;\n        } else if (byteOffset < 0) {\n          if (dir)\n            byteOffset = 0;\n          else\n            return -1;\n        }\n        if (typeof val === \"string\") {\n          val = Buffer2.from(val, encoding);\n        }\n        if (Buffer2.isBuffer(val)) {\n          if (val.length === 0) {\n            return -1;\n          }\n          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n        } else if (typeof val === \"number\") {\n          val = val & 255;\n          if (typeof GlobalUint8Array.prototype.indexOf === \"function\") {\n            if (dir) {\n              return GlobalUint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n            } else {\n              return GlobalUint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n            }\n          }\n          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);\n        }\n        throw new TypeError(\"val must be string, number or Buffer\");\n      }\n      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n        let indexSize = 1;\n        let arrLength = arr.length;\n        let valLength = val.length;\n        if (encoding !== void 0) {\n          encoding = String(encoding).toLowerCase();\n          if (encoding === \"ucs2\" || encoding === \"ucs-2\" || encoding === \"utf16le\" || encoding === \"utf-16le\") {\n            if (arr.length < 2 || val.length < 2) {\n              return -1;\n            }\n            indexSize = 2;\n            arrLength /= 2;\n            valLength /= 2;\n            byteOffset /= 2;\n          }\n        }\n        function read(buf, i2) {\n          if (indexSize === 1) {\n            return buf[i2];\n          } else {\n            return buf.readUInt16BE(i2 * indexSize);\n          }\n        }\n        let i;\n        if (dir) {\n          let foundIndex = -1;\n          for (i = byteOffset; i < arrLength; i++) {\n            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n              if (foundIndex === -1)\n                foundIndex = i;\n              if (i - foundIndex + 1 === valLength)\n                return foundIndex * indexSize;\n            } else {\n              if (foundIndex !== -1)\n                i -= i - foundIndex;\n              foundIndex = -1;\n            }\n          }\n        } else {\n          if (byteOffset + valLength > arrLength)\n            byteOffset = arrLength - valLength;\n          for (i = byteOffset; i >= 0; i--) {\n            let found = true;\n            for (let j = 0; j < valLength; j++) {\n              if (read(arr, i + j) !== read(val, j)) {\n                found = false;\n                break;\n              }\n            }\n            if (found)\n              return i;\n          }\n        }\n        return -1;\n      }\n      Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {\n        return this.indexOf(val, byteOffset, encoding) !== -1;\n      };\n      Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n      };\n      Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n      };\n      function hexWrite(buf, string, offset, length) {\n        offset = Number(offset) || 0;\n        const remaining = buf.length - offset;\n        if (!length) {\n          length = remaining;\n        } else {\n          length = Number(length);\n          if (length > remaining) {\n            length = remaining;\n          }\n        }\n        const strLen = string.length;\n        if (length > strLen / 2) {\n          length = strLen / 2;\n        }\n        let i;\n        for (i = 0; i < length; ++i) {\n          const parsed = parseInt(string.substr(i * 2, 2), 16);\n          if (numberIsNaN(parsed))\n            return i;\n          buf[offset + i] = parsed;\n        }\n        return i;\n      }\n      function utf8Write(buf, string, offset, length) {\n        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n      }\n      function asciiWrite(buf, string, offset, length) {\n        return blitBuffer(asciiToBytes(string), buf, offset, length);\n      }\n      function base64Write(buf, string, offset, length) {\n        return blitBuffer(base64ToBytes(string), buf, offset, length);\n      }\n      function ucs2Write(buf, string, offset, length) {\n        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n      }\n      Buffer2.prototype.write = function write(string, offset, length, encoding) {\n        if (offset === void 0) {\n          encoding = \"utf8\";\n          length = this.length;\n          offset = 0;\n        } else if (length === void 0 && typeof offset === \"string\") {\n          encoding = offset;\n          length = this.length;\n          offset = 0;\n        } else if (isFinite(offset)) {\n          offset = offset >>> 0;\n          if (isFinite(length)) {\n            length = length >>> 0;\n            if (encoding === void 0)\n              encoding = \"utf8\";\n          } else {\n            encoding = length;\n            length = void 0;\n          }\n        } else {\n          throw new Error(\n            \"Buffer.write(string, encoding, offset[, length]) is no longer supported\"\n          );\n        }\n        const remaining = this.length - offset;\n        if (length === void 0 || length > remaining)\n          length = remaining;\n        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n          throw new RangeError(\"Attempt to write outside buffer bounds\");\n        }\n        if (!encoding)\n          encoding = \"utf8\";\n        let loweredCase = false;\n        for (; ; ) {\n          switch (encoding) {\n            case \"hex\":\n              return hexWrite(this, string, offset, length);\n            case \"utf8\":\n            case \"utf-8\":\n              return utf8Write(this, string, offset, length);\n            case \"ascii\":\n            case \"latin1\":\n            case \"binary\":\n              return asciiWrite(this, string, offset, length);\n            case \"base64\":\n              return base64Write(this, string, offset, length);\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n              return ucs2Write(this, string, offset, length);\n            default:\n              if (loweredCase)\n                throw new TypeError(\"Unknown encoding: \" + encoding);\n              encoding = (\"\" + encoding).toLowerCase();\n              loweredCase = true;\n          }\n        }\n      };\n      Buffer2.prototype.toJSON = function toJSON() {\n        return {\n          type: \"Buffer\",\n          data: Array.prototype.slice.call(this._arr || this, 0)\n        };\n      };\n      function base64Slice(buf, start, end) {\n        if (start === 0 && end === buf.length) {\n          return base64.fromByteArray(buf);\n        } else {\n          return base64.fromByteArray(buf.slice(start, end));\n        }\n      }\n      function utf8Slice(buf, start, end) {\n        end = Math.min(buf.length, end);\n        const res = [];\n        let i = start;\n        while (i < end) {\n          const firstByte = buf[i];\n          let codePoint = null;\n          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;\n          if (i + bytesPerSequence <= end) {\n            let secondByte, thirdByte, fourthByte, tempCodePoint;\n            switch (bytesPerSequence) {\n              case 1:\n                if (firstByte < 128) {\n                  codePoint = firstByte;\n                }\n                break;\n              case 2:\n                secondByte = buf[i + 1];\n                if ((secondByte & 192) === 128) {\n                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;\n                  if (tempCodePoint > 127) {\n                    codePoint = tempCodePoint;\n                  }\n                }\n                break;\n              case 3:\n                secondByte = buf[i + 1];\n                thirdByte = buf[i + 2];\n                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {\n                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;\n                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {\n                    codePoint = tempCodePoint;\n                  }\n                }\n                break;\n              case 4:\n                secondByte = buf[i + 1];\n                thirdByte = buf[i + 2];\n                fourthByte = buf[i + 3];\n                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {\n                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;\n                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {\n                    codePoint = tempCodePoint;\n                  }\n                }\n            }\n          }\n          if (codePoint === null) {\n            codePoint = 65533;\n            bytesPerSequence = 1;\n          } else if (codePoint > 65535) {\n            codePoint -= 65536;\n            res.push(codePoint >>> 10 & 1023 | 55296);\n            codePoint = 56320 | codePoint & 1023;\n          }\n          res.push(codePoint);\n          i += bytesPerSequence;\n        }\n        return decodeCodePointsArray(res);\n      }\n      var MAX_ARGUMENTS_LENGTH = 4096;\n      function decodeCodePointsArray(codePoints) {\n        const len = codePoints.length;\n        if (len <= MAX_ARGUMENTS_LENGTH) {\n          return String.fromCharCode.apply(String, codePoints);\n        }\n        let res = \"\";\n        let i = 0;\n        while (i < len) {\n          res += String.fromCharCode.apply(\n            String,\n            codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n          );\n        }\n        return res;\n      }\n      function asciiSlice(buf, start, end) {\n        let ret = \"\";\n        end = Math.min(buf.length, end);\n        for (let i = start; i < end; ++i) {\n          ret += String.fromCharCode(buf[i] & 127);\n        }\n        return ret;\n      }\n      function latin1Slice(buf, start, end) {\n        let ret = \"\";\n        end = Math.min(buf.length, end);\n        for (let i = start; i < end; ++i) {\n          ret += String.fromCharCode(buf[i]);\n        }\n        return ret;\n      }\n      function hexSlice(buf, start, end) {\n        const len = buf.length;\n        if (!start || start < 0)\n          start = 0;\n        if (!end || end < 0 || end > len)\n          end = len;\n        let out = \"\";\n        for (let i = start; i < end; ++i) {\n          out += hexSliceLookupTable[buf[i]];\n        }\n        return out;\n      }\n      function utf16leSlice(buf, start, end) {\n        const bytes = buf.slice(start, end);\n        let res = \"\";\n        for (let i = 0; i < bytes.length - 1; i += 2) {\n          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n        }\n        return res;\n      }\n      Buffer2.prototype.slice = function slice(start, end) {\n        const len = this.length;\n        start = ~~start;\n        end = end === void 0 ? len : ~~end;\n        if (start < 0) {\n          start += len;\n          if (start < 0)\n            start = 0;\n        } else if (start > len) {\n          start = len;\n        }\n        if (end < 0) {\n          end += len;\n          if (end < 0)\n            end = 0;\n        } else if (end > len) {\n          end = len;\n        }\n        if (end < start)\n          end = start;\n        const newBuf = this.subarray(start, end);\n        Object.setPrototypeOf(newBuf, Buffer2.prototype);\n        return newBuf;\n      };\n      function checkOffset(offset, ext, length) {\n        if (offset % 1 !== 0 || offset < 0)\n          throw new RangeError(\"offset is not uint\");\n        if (offset + ext > length)\n          throw new RangeError(\"Trying to access beyond buffer length\");\n      }\n      Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert)\n          checkOffset(offset, byteLength2, this.length);\n        let val = this[offset];\n        let mul = 1;\n        let i = 0;\n        while (++i < byteLength2 && (mul *= 256)) {\n          val += this[offset + i] * mul;\n        }\n        return val;\n      };\n      Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert) {\n          checkOffset(offset, byteLength2, this.length);\n        }\n        let val = this[offset + --byteLength2];\n        let mul = 1;\n        while (byteLength2 > 0 && (mul *= 256)) {\n          val += this[offset + --byteLength2] * mul;\n        }\n        return val;\n      };\n      Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 1, this.length);\n        return this[offset];\n      };\n      Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 2, this.length);\n        return this[offset] | this[offset + 1] << 8;\n      };\n      Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 2, this.length);\n        return this[offset] << 8 | this[offset + 1];\n      };\n      Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;\n      };\n      Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n      };\n      Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {\n        offset = offset >>> 0;\n        validateNumber(offset, \"offset\");\n        const first = this[offset];\n        const last = this[offset + 7];\n        if (first === void 0 || last === void 0) {\n          boundsError(offset, this.length - 8);\n        }\n        const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;\n        const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;\n        return BigInt(lo) + (BigInt(hi) << BigInt(32));\n      });\n      Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {\n        offset = offset >>> 0;\n        validateNumber(offset, \"offset\");\n        const first = this[offset];\n        const last = this[offset + 7];\n        if (first === void 0 || last === void 0) {\n          boundsError(offset, this.length - 8);\n        }\n        const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];\n        const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;\n        return (BigInt(hi) << BigInt(32)) + BigInt(lo);\n      });\n      Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert)\n          checkOffset(offset, byteLength2, this.length);\n        let val = this[offset];\n        let mul = 1;\n        let i = 0;\n        while (++i < byteLength2 && (mul *= 256)) {\n          val += this[offset + i] * mul;\n        }\n        mul *= 128;\n        if (val >= mul)\n          val -= Math.pow(2, 8 * byteLength2);\n        return val;\n      };\n      Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert)\n          checkOffset(offset, byteLength2, this.length);\n        let i = byteLength2;\n        let mul = 1;\n        let val = this[offset + --i];\n        while (i > 0 && (mul *= 256)) {\n          val += this[offset + --i] * mul;\n        }\n        mul *= 128;\n        if (val >= mul)\n          val -= Math.pow(2, 8 * byteLength2);\n        return val;\n      };\n      Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 1, this.length);\n        if (!(this[offset] & 128))\n          return this[offset];\n        return (255 - this[offset] + 1) * -1;\n      };\n      Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 2, this.length);\n        const val = this[offset] | this[offset + 1] << 8;\n        return val & 32768 ? val | 4294901760 : val;\n      };\n      Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 2, this.length);\n        const val = this[offset + 1] | this[offset] << 8;\n        return val & 32768 ? val | 4294901760 : val;\n      };\n      Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n      };\n      Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n      };\n      Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {\n        offset = offset >>> 0;\n        validateNumber(offset, \"offset\");\n        const first = this[offset];\n        const last = this[offset + 7];\n        if (first === void 0 || last === void 0) {\n          boundsError(offset, this.length - 8);\n        }\n        const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);\n        return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);\n      });\n      Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {\n        offset = offset >>> 0;\n        validateNumber(offset, \"offset\");\n        const first = this[offset];\n        const last = this[offset + 7];\n        if (first === void 0 || last === void 0) {\n          boundsError(offset, this.length - 8);\n        }\n        const val = (first << 24) + // Overflow\n        this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];\n        return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);\n      });\n      Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return ieee754.read(this, offset, true, 23, 4);\n      };\n      Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return ieee754.read(this, offset, false, 23, 4);\n      };\n      Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 8, this.length);\n        return ieee754.read(this, offset, true, 52, 8);\n      };\n      Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 8, this.length);\n        return ieee754.read(this, offset, false, 52, 8);\n      };\n      function checkInt(buf, value, offset, ext, max, min) {\n        if (!Buffer2.isBuffer(buf))\n          throw new TypeError('\"buffer\" argument must be a Buffer instance');\n        if (value > max || value < min)\n          throw new RangeError('\"value\" argument is out of bounds');\n        if (offset + ext > buf.length)\n          throw new RangeError(\"Index out of range\");\n      }\n      Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert) {\n          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;\n          checkInt(this, value, offset, byteLength2, maxBytes, 0);\n        }\n        let mul = 1;\n        let i = 0;\n        this[offset] = value & 255;\n        while (++i < byteLength2 && (mul *= 256)) {\n          this[offset + i] = value / mul & 255;\n        }\n        return offset + byteLength2;\n      };\n      Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert) {\n          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;\n          checkInt(this, value, offset, byteLength2, maxBytes, 0);\n        }\n        let i = byteLength2 - 1;\n        let mul = 1;\n        this[offset + i] = value & 255;\n        while (--i >= 0 && (mul *= 256)) {\n          this[offset + i] = value / mul & 255;\n        }\n        return offset + byteLength2;\n      };\n      Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 1, 255, 0);\n        this[offset] = value & 255;\n        return offset + 1;\n      };\n      Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 2, 65535, 0);\n        this[offset] = value & 255;\n        this[offset + 1] = value >>> 8;\n        return offset + 2;\n      };\n      Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 2, 65535, 0);\n        this[offset] = value >>> 8;\n        this[offset + 1] = value & 255;\n        return offset + 2;\n      };\n      Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 4, 4294967295, 0);\n        this[offset + 3] = value >>> 24;\n        this[offset + 2] = value >>> 16;\n        this[offset + 1] = value >>> 8;\n        this[offset] = value & 255;\n        return offset + 4;\n      };\n      Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 4, 4294967295, 0);\n        this[offset] = value >>> 24;\n        this[offset + 1] = value >>> 16;\n        this[offset + 2] = value >>> 8;\n        this[offset + 3] = value & 255;\n        return offset + 4;\n      };\n      function wrtBigUInt64LE(buf, value, offset, min, max) {\n        checkIntBI(value, min, max, buf, offset, 7);\n        let lo = Number(value & BigInt(4294967295));\n        buf[offset++] = lo;\n        lo = lo >> 8;\n        buf[offset++] = lo;\n        lo = lo >> 8;\n        buf[offset++] = lo;\n        lo = lo >> 8;\n        buf[offset++] = lo;\n        let hi = Number(value >> BigInt(32) & BigInt(4294967295));\n        buf[offset++] = hi;\n        hi = hi >> 8;\n        buf[offset++] = hi;\n        hi = hi >> 8;\n        buf[offset++] = hi;\n        hi = hi >> 8;\n        buf[offset++] = hi;\n        return offset;\n      }\n      function wrtBigUInt64BE(buf, value, offset, min, max) {\n        checkIntBI(value, min, max, buf, offset, 7);\n        let lo = Number(value & BigInt(4294967295));\n        buf[offset + 7] = lo;\n        lo = lo >> 8;\n        buf[offset + 6] = lo;\n        lo = lo >> 8;\n        buf[offset + 5] = lo;\n        lo = lo >> 8;\n        buf[offset + 4] = lo;\n        let hi = Number(value >> BigInt(32) & BigInt(4294967295));\n        buf[offset + 3] = hi;\n        hi = hi >> 8;\n        buf[offset + 2] = hi;\n        hi = hi >> 8;\n        buf[offset + 1] = hi;\n        hi = hi >> 8;\n        buf[offset] = hi;\n        return offset + 8;\n      }\n      Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {\n        return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n      });\n      Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {\n        return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n      });\n      Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          const limit = Math.pow(2, 8 * byteLength2 - 1);\n          checkInt(this, value, offset, byteLength2, limit - 1, -limit);\n        }\n        let i = 0;\n        let mul = 1;\n        let sub = 0;\n        this[offset] = value & 255;\n        while (++i < byteLength2 && (mul *= 256)) {\n          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n            sub = 1;\n          }\n          this[offset + i] = (value / mul >> 0) - sub & 255;\n        }\n        return offset + byteLength2;\n      };\n      Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          const limit = Math.pow(2, 8 * byteLength2 - 1);\n          checkInt(this, value, offset, byteLength2, limit - 1, -limit);\n        }\n        let i = byteLength2 - 1;\n        let mul = 1;\n        let sub = 0;\n        this[offset + i] = value & 255;\n        while (--i >= 0 && (mul *= 256)) {\n          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n            sub = 1;\n          }\n          this[offset + i] = (value / mul >> 0) - sub & 255;\n        }\n        return offset + byteLength2;\n      };\n      Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 1, 127, -128);\n        if (value < 0)\n          value = 255 + value + 1;\n        this[offset] = value & 255;\n        return offset + 1;\n      };\n      Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 2, 32767, -32768);\n        this[offset] = value & 255;\n        this[offset + 1] = value >>> 8;\n        return offset + 2;\n      };\n      Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 2, 32767, -32768);\n        this[offset] = value >>> 8;\n        this[offset + 1] = value & 255;\n        return offset + 2;\n      };\n      Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 4, 2147483647, -2147483648);\n        this[offset] = value & 255;\n        this[offset + 1] = value >>> 8;\n        this[offset + 2] = value >>> 16;\n        this[offset + 3] = value >>> 24;\n        return offset + 4;\n      };\n      Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 4, 2147483647, -2147483648);\n        if (value < 0)\n          value = 4294967295 + value + 1;\n        this[offset] = value >>> 24;\n        this[offset + 1] = value >>> 16;\n        this[offset + 2] = value >>> 8;\n        this[offset + 3] = value & 255;\n        return offset + 4;\n      };\n      Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {\n        return wrtBigUInt64LE(this, value, offset, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n      });\n      Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {\n        return wrtBigUInt64BE(this, value, offset, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n      });\n      function checkIEEE754(buf, value, offset, ext, max, min) {\n        if (offset + ext > buf.length)\n          throw new RangeError(\"Index out of range\");\n        if (offset < 0)\n          throw new RangeError(\"Index out of range\");\n      }\n      function writeFloat(buf, value, offset, littleEndian, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);\n        }\n        ieee754.write(buf, value, offset, littleEndian, 23, 4);\n        return offset + 4;\n      }\n      Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n        return writeFloat(this, value, offset, true, noAssert);\n      };\n      Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n        return writeFloat(this, value, offset, false, noAssert);\n      };\n      function writeDouble(buf, value, offset, littleEndian, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);\n        }\n        ieee754.write(buf, value, offset, littleEndian, 52, 8);\n        return offset + 8;\n      }\n      Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n        return writeDouble(this, value, offset, true, noAssert);\n      };\n      Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n        return writeDouble(this, value, offset, false, noAssert);\n      };\n      Buffer2.prototype.copy = function copy(target, targetStart, start, end) {\n        if (!Buffer2.isBuffer(target))\n          throw new TypeError(\"argument should be a Buffer\");\n        if (!start)\n          start = 0;\n        if (!end && end !== 0)\n          end = this.length;\n        if (targetStart >= target.length)\n          targetStart = target.length;\n        if (!targetStart)\n          targetStart = 0;\n        if (end > 0 && end < start)\n          end = start;\n        if (end === start)\n          return 0;\n        if (target.length === 0 || this.length === 0)\n          return 0;\n        if (targetStart < 0) {\n          throw new RangeError(\"targetStart out of bounds\");\n        }\n        if (start < 0 || start >= this.length)\n          throw new RangeError(\"Index out of range\");\n        if (end < 0)\n          throw new RangeError(\"sourceEnd out of bounds\");\n        if (end > this.length)\n          end = this.length;\n        if (target.length - targetStart < end - start) {\n          end = target.length - targetStart + start;\n        }\n        const len = end - start;\n        if (this === target && typeof GlobalUint8Array.prototype.copyWithin === \"function\") {\n          this.copyWithin(targetStart, start, end);\n        } else {\n          GlobalUint8Array.prototype.set.call(\n            target,\n            this.subarray(start, end),\n            targetStart\n          );\n        }\n        return len;\n      };\n      Buffer2.prototype.fill = function fill(val, start, end, encoding) {\n        if (typeof val === \"string\") {\n          if (typeof start === \"string\") {\n            encoding = start;\n            start = 0;\n            end = this.length;\n          } else if (typeof end === \"string\") {\n            encoding = end;\n            end = this.length;\n          }\n          if (encoding !== void 0 && typeof encoding !== \"string\") {\n            throw new TypeError(\"encoding must be a string\");\n          }\n          if (typeof encoding === \"string\" && !Buffer2.isEncoding(encoding)) {\n            throw new TypeError(\"Unknown encoding: \" + encoding);\n          }\n          if (val.length === 1) {\n            const code = val.charCodeAt(0);\n            if (encoding === \"utf8\" && code < 128 || encoding === \"latin1\") {\n              val = code;\n            }\n          }\n        } else if (typeof val === \"number\") {\n          val = val & 255;\n        } else if (typeof val === \"boolean\") {\n          val = Number(val);\n        }\n        if (start < 0 || this.length < start || this.length < end) {\n          throw new RangeError(\"Out of range index\");\n        }\n        if (end <= start) {\n          return this;\n        }\n        start = start >>> 0;\n        end = end === void 0 ? this.length : end >>> 0;\n        if (!val)\n          val = 0;\n        let i;\n        if (typeof val === \"number\") {\n          for (i = start; i < end; ++i) {\n            this[i] = val;\n          }\n        } else {\n          const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);\n          const len = bytes.length;\n          if (len === 0) {\n            throw new TypeError('The value \"' + val + '\" is invalid for argument \"value\"');\n          }\n          for (i = 0; i < end - start; ++i) {\n            this[i + start] = bytes[i % len];\n          }\n        }\n        return this;\n      };\n      var errors = {};\n      function E(sym, getMessage, Base) {\n        errors[sym] = class NodeError extends Base {\n          constructor() {\n            super();\n            Object.defineProperty(this, \"message\", {\n              value: getMessage.apply(this, arguments),\n              writable: true,\n              configurable: true\n            });\n            this.name = `${this.name} [${sym}]`;\n            this.stack;\n            delete this.name;\n          }\n          get code() {\n            return sym;\n          }\n          set code(value) {\n            Object.defineProperty(this, \"code\", {\n              configurable: true,\n              enumerable: true,\n              value,\n              writable: true\n            });\n          }\n          toString() {\n            return `${this.name} [${sym}]: ${this.message}`;\n          }\n        };\n      }\n      E(\n        \"ERR_BUFFER_OUT_OF_BOUNDS\",\n        function(name) {\n          if (name) {\n            return `${name} is outside of buffer bounds`;\n          }\n          return \"Attempt to access memory outside buffer bounds\";\n        },\n        RangeError\n      );\n      E(\n        \"ERR_INVALID_ARG_TYPE\",\n        function(name, actual) {\n          return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`;\n        },\n        TypeError\n      );\n      E(\n        \"ERR_OUT_OF_RANGE\",\n        function(str, range, input) {\n          let msg = `The value of \"${str}\" is out of range.`;\n          let received = input;\n          if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n            received = addNumericalSeparator(String(input));\n          } else if (typeof input === \"bigint\") {\n            received = String(input);\n            if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n              received = addNumericalSeparator(received);\n            }\n            received += \"n\";\n          }\n          msg += ` It must be ${range}. Received ${received}`;\n          return msg;\n        },\n        RangeError\n      );\n      function addNumericalSeparator(val) {\n        let res = \"\";\n        let i = val.length;\n        const start = val[0] === \"-\" ? 1 : 0;\n        for (; i >= start + 4; i -= 3) {\n          res = `_${val.slice(i - 3, i)}${res}`;\n        }\n        return `${val.slice(0, i)}${res}`;\n      }\n      function checkBounds(buf, offset, byteLength2) {\n        validateNumber(offset, \"offset\");\n        if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {\n          boundsError(offset, buf.length - (byteLength2 + 1));\n        }\n      }\n      function checkIntBI(value, min, max, buf, offset, byteLength2) {\n        if (value > max || value < min) {\n          const n = typeof min === \"bigint\" ? \"n\" : \"\";\n          let range;\n          if (byteLength2 > 3) {\n            if (min === 0 || min === BigInt(0)) {\n              range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;\n            } else {\n              range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;\n            }\n          } else {\n            range = `>= ${min}${n} and <= ${max}${n}`;\n          }\n          throw new errors.ERR_OUT_OF_RANGE(\"value\", range, value);\n        }\n        checkBounds(buf, offset, byteLength2);\n      }\n      function validateNumber(value, name) {\n        if (typeof value !== \"number\") {\n          throw new errors.ERR_INVALID_ARG_TYPE(name, \"number\", value);\n        }\n      }\n      function boundsError(value, length, type) {\n        if (Math.floor(value) !== value) {\n          validateNumber(value, type);\n          throw new errors.ERR_OUT_OF_RANGE(type || \"offset\", \"an integer\", value);\n        }\n        if (length < 0) {\n          throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();\n        }\n        throw new errors.ERR_OUT_OF_RANGE(\n          type || \"offset\",\n          `>= ${type ? 1 : 0} and <= ${length}`,\n          value\n        );\n      }\n      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;\n      function base64clean(str) {\n        str = str.split(\"=\")[0];\n        str = str.trim().replace(INVALID_BASE64_RE, \"\");\n        if (str.length < 2)\n          return \"\";\n        while (str.length % 4 !== 0) {\n          str = str + \"=\";\n        }\n        return str;\n      }\n      function utf8ToBytes(string, units) {\n        units = units || Infinity;\n        let codePoint;\n        const length = string.length;\n        let leadSurrogate = null;\n        const bytes = [];\n        for (let i = 0; i < length; ++i) {\n          codePoint = string.charCodeAt(i);\n          if (codePoint > 55295 && codePoint < 57344) {\n            if (!leadSurrogate) {\n              if (codePoint > 56319) {\n                if ((units -= 3) > -1)\n                  bytes.push(239, 191, 189);\n                continue;\n              } else if (i + 1 === length) {\n                if ((units -= 3) > -1)\n                  bytes.push(239, 191, 189);\n                continue;\n              }\n              leadSurrogate = codePoint;\n              continue;\n            }\n            if (codePoint < 56320) {\n              if ((units -= 3) > -1)\n                bytes.push(239, 191, 189);\n              leadSurrogate = codePoint;\n              continue;\n            }\n            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;\n          } else if (leadSurrogate) {\n            if ((units -= 3) > -1)\n              bytes.push(239, 191, 189);\n          }\n          leadSurrogate = null;\n          if (codePoint < 128) {\n            if ((units -= 1) < 0)\n              break;\n            bytes.push(codePoint);\n          } else if (codePoint < 2048) {\n            if ((units -= 2) < 0)\n              break;\n            bytes.push(\n              codePoint >> 6 | 192,\n              codePoint & 63 | 128\n            );\n          } else if (codePoint < 65536) {\n            if ((units -= 3) < 0)\n              break;\n            bytes.push(\n              codePoint >> 12 | 224,\n              codePoint >> 6 & 63 | 128,\n              codePoint & 63 | 128\n            );\n          } else if (codePoint < 1114112) {\n            if ((units -= 4) < 0)\n              break;\n            bytes.push(\n              codePoint >> 18 | 240,\n              codePoint >> 12 & 63 | 128,\n              codePoint >> 6 & 63 | 128,\n              codePoint & 63 | 128\n            );\n          } else {\n            throw new Error(\"Invalid code point\");\n          }\n        }\n        return bytes;\n      }\n      function asciiToBytes(str) {\n        const byteArray = [];\n        for (let i = 0; i < str.length; ++i) {\n          byteArray.push(str.charCodeAt(i) & 255);\n        }\n        return byteArray;\n      }\n      function utf16leToBytes(str, units) {\n        let c, hi, lo;\n        const byteArray = [];\n        for (let i = 0; i < str.length; ++i) {\n          if ((units -= 2) < 0)\n            break;\n          c = str.charCodeAt(i);\n          hi = c >> 8;\n          lo = c % 256;\n          byteArray.push(lo);\n          byteArray.push(hi);\n        }\n        return byteArray;\n      }\n      function base64ToBytes(str) {\n        return base64.toByteArray(base64clean(str));\n      }\n      function blitBuffer(src, dst, offset, length) {\n        let i;\n        for (i = 0; i < length; ++i) {\n          if (i + offset >= dst.length || i >= src.length)\n            break;\n          dst[i + offset] = src[i];\n        }\n        return i;\n      }\n      function isInstance(obj, type) {\n        return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;\n      }\n      function numberIsNaN(obj) {\n        return obj !== obj;\n      }\n      var hexSliceLookupTable = function() {\n        const alphabet = \"0123456789abcdef\";\n        const table = new Array(256);\n        for (let i = 0; i < 16; ++i) {\n          const i16 = i * 16;\n          for (let j = 0; j < 16; ++j) {\n            table[i16 + j] = alphabet[i] + alphabet[j];\n          }\n        }\n        return table;\n      }();\n      function defineBigIntMethod(fn) {\n        return typeof BigInt === \"undefined\" ? BufferBigIntNotDefined : fn;\n      }\n      function BufferBigIntNotDefined() {\n        throw new Error(\"BigInt not supported\");\n      }\n    }\n  });\n\n  // node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js\n  var require_browser = __commonJS({\n    \"node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js\"(exports, module) {\n      init_dist();\n      var process = module.exports = {};\n      var cachedSetTimeout;\n      var cachedClearTimeout;\n      function defaultSetTimout() {\n        throw new Error(\"setTimeout has not been defined\");\n      }\n      function defaultClearTimeout() {\n        throw new Error(\"clearTimeout has not been defined\");\n      }\n      (function() {\n        try {\n          if (typeof setTimeout === \"function\") {\n            cachedSetTimeout = setTimeout;\n          } else {\n            cachedSetTimeout = defaultSetTimout;\n          }\n        } catch (e) {\n          cachedSetTimeout = defaultSetTimout;\n        }\n        try {\n          if (typeof clearTimeout === \"function\") {\n            cachedClearTimeout = clearTimeout;\n          } else {\n            cachedClearTimeout = defaultClearTimeout;\n          }\n        } catch (e) {\n          cachedClearTimeout = defaultClearTimeout;\n        }\n      })();\n      function runTimeout(fun) {\n        if (cachedSetTimeout === setTimeout) {\n          return setTimeout(fun, 0);\n        }\n        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n          cachedSetTimeout = setTimeout;\n          return setTimeout(fun, 0);\n        }\n        try {\n          return cachedSetTimeout(fun, 0);\n        } catch (e) {\n          try {\n            return cachedSetTimeout.call(null, fun, 0);\n          } catch (e2) {\n            return cachedSetTimeout.call(this, fun, 0);\n          }\n        }\n      }\n      function runClearTimeout(marker) {\n        if (cachedClearTimeout === clearTimeout) {\n          return clearTimeout(marker);\n        }\n        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n          cachedClearTimeout = clearTimeout;\n          return clearTimeout(marker);\n        }\n        try {\n          return cachedClearTimeout(marker);\n        } catch (e) {\n          try {\n            return cachedClearTimeout.call(null, marker);\n          } catch (e2) {\n            return cachedClearTimeout.call(this, marker);\n          }\n        }\n      }\n      var queue = [];\n      var draining = false;\n      var currentQueue;\n      var queueIndex = -1;\n      function cleanUpNextTick() {\n        if (!draining || !currentQueue) {\n          return;\n        }\n        draining = false;\n        if (currentQueue.length) {\n          queue = currentQueue.concat(queue);\n        } else {\n          queueIndex = -1;\n        }\n        if (queue.length) {\n          drainQueue();\n        }\n      }\n      function drainQueue() {\n        if (draining) {\n          return;\n        }\n        var timeout = runTimeout(cleanUpNextTick);\n        draining = true;\n        var len = queue.length;\n        while (len) {\n          currentQueue = queue;\n          queue = [];\n          while (++queueIndex < len) {\n            if (currentQueue) {\n              currentQueue[queueIndex].run();\n            }\n          }\n          queueIndex = -1;\n          len = queue.length;\n        }\n        currentQueue = null;\n        draining = false;\n        runClearTimeout(timeout);\n      }\n      process.nextTick = function(fun) {\n        var args = new Array(arguments.length - 1);\n        if (arguments.length > 1) {\n          for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n          }\n        }\n        queue.push(new Item(fun, args));\n        if (queue.length === 1 && !draining) {\n          runTimeout(drainQueue);\n        }\n      };\n      function Item(fun, array) {\n        this.fun = fun;\n        this.array = array;\n      }\n      Item.prototype.run = function() {\n        this.fun.apply(null, this.array);\n      };\n      process.title = \"browser\";\n      process.browser = true;\n      process.env = {};\n      process.argv = [];\n      process.version = \"\";\n      process.versions = {};\n      function noop() {\n      }\n      process.on = noop;\n      process.addListener = noop;\n      process.once = noop;\n      process.off = noop;\n      process.removeListener = noop;\n      process.removeAllListeners = noop;\n      process.emit = noop;\n      process.prependListener = noop;\n      process.prependOnceListener = noop;\n      process.listeners = function(name) {\n        return [];\n      };\n      process.binding = function(name) {\n        throw new Error(\"process.binding is not supported\");\n      };\n      process.cwd = function() {\n        return \"/\";\n      };\n      process.chdir = function(dir) {\n        throw new Error(\"process.chdir is not supported\");\n      };\n      process.umask = function() {\n        return 0;\n      };\n    }\n  });\n\n  // shims/dist/index.js\n  var import_buffer_polyfill, import_process, o;\n  var init_dist = __esm({\n    \"shims/dist/index.js\"() {\n      \"use strict\";\n      import_buffer_polyfill = __toESM(require_buffer(), 1);\n      import_process = __toESM(require_browser(), 1);\n      o = globalThis || void 0 || self;\n    }\n  });\n\n  // shims/banner/index.cjs\n  var require_banner = __commonJS({\n    \"shims/banner/index.cjs\"() {\n      init_dist();\n      globalThis.Buffer = globalThis.Buffer || import_buffer_polyfill.Buffer;\n      globalThis.global = globalThis.global || o;\n      globalThis.process = globalThis.process || import_process.default;\n    }\n  });\n  require_banner();\n})();\n/*! Bundled license information:\n\nieee754/index.js:\n  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)\n\nbuffer/index.js:\n  (*!\n   * The buffer module from node.js, for the browser.\n   *\n   * @author   Feross Aboukhadijeh <https://feross.org>\n   * @license  MIT\n   *)\n*/\n\nimport {\n  __export,\n  __toESM,\n  require_dist\n} from \"/node_modules/.vite/deps/chunk-4KAQPM64.js?v=988c63e5\";\n\n// node_modules/realm-web/dist/bundle.dom.es.js\nvar import_dist2 = __toESM(require_dist());\n\n// node_modules/realm-web/node_modules/bson/dist/bson.browser.esm.js\nvar bson_browser_esm_exports = {};\n__export(bson_browser_esm_exports, {\n  BSONError: () => BSONError,\n  BSONRegExp: () => BSONRegExp,\n  BSONSymbol: () => BSONSymbol,\n  BSONTypeError: () => BSONTypeError,\n  BSON_BINARY_SUBTYPE_BYTE_ARRAY: () => BSON_BINARY_SUBTYPE_BYTE_ARRAY,\n  BSON_BINARY_SUBTYPE_COLUMN: () => BSON_BINARY_SUBTYPE_COLUMN,\n  BSON_BINARY_SUBTYPE_DEFAULT: () => BSON_BINARY_SUBTYPE_DEFAULT,\n  BSON_BINARY_SUBTYPE_ENCRYPTED: () => BSON_BINARY_SUBTYPE_ENCRYPTED,\n  BSON_BINARY_SUBTYPE_FUNCTION: () => BSON_BINARY_SUBTYPE_FUNCTION,\n  BSON_BINARY_SUBTYPE_MD5: () => BSON_BINARY_SUBTYPE_MD5,\n  BSON_BINARY_SUBTYPE_USER_DEFINED: () => BSON_BINARY_SUBTYPE_USER_DEFINED,\n  BSON_BINARY_SUBTYPE_UUID: () => BSON_BINARY_SUBTYPE_UUID,\n  BSON_BINARY_SUBTYPE_UUID_NEW: () => BSON_BINARY_SUBTYPE_UUID_NEW,\n  BSON_DATA_ARRAY: () => BSON_DATA_ARRAY,\n  BSON_DATA_BINARY: () => BSON_DATA_BINARY,\n  BSON_DATA_BOOLEAN: () => BSON_DATA_BOOLEAN,\n  BSON_DATA_CODE: () => BSON_DATA_CODE,\n  BSON_DATA_CODE_W_SCOPE: () => BSON_DATA_CODE_W_SCOPE,\n  BSON_DATA_DATE: () => BSON_DATA_DATE,\n  BSON_DATA_DBPOINTER: () => BSON_DATA_DBPOINTER,\n  BSON_DATA_DECIMAL128: () => BSON_DATA_DECIMAL128,\n  BSON_DATA_INT: () => BSON_DATA_INT,\n  BSON_DATA_LONG: () => BSON_DATA_LONG,\n  BSON_DATA_MAX_KEY: () => BSON_DATA_MAX_KEY,\n  BSON_DATA_MIN_KEY: () => BSON_DATA_MIN_KEY,\n  BSON_DATA_NULL: () => BSON_DATA_NULL,\n  BSON_DATA_NUMBER: () => BSON_DATA_NUMBER,\n  BSON_DATA_OBJECT: () => BSON_DATA_OBJECT,\n  BSON_DATA_OID: () => BSON_DATA_OID,\n  BSON_DATA_REGEXP: () => BSON_DATA_REGEXP,\n  BSON_DATA_STRING: () => BSON_DATA_STRING,\n  BSON_DATA_SYMBOL: () => BSON_DATA_SYMBOL,\n  BSON_DATA_TIMESTAMP: () => BSON_DATA_TIMESTAMP,\n  BSON_DATA_UNDEFINED: () => BSON_DATA_UNDEFINED,\n  BSON_INT32_MAX: () => BSON_INT32_MAX$1,\n  BSON_INT32_MIN: () => BSON_INT32_MIN$1,\n  BSON_INT64_MAX: () => BSON_INT64_MAX$1,\n  BSON_INT64_MIN: () => BSON_INT64_MIN$1,\n  Binary: () => Binary,\n  Code: () => Code,\n  DBRef: () => DBRef,\n  Decimal128: () => Decimal128,\n  Double: () => Double,\n  EJSON: () => EJSON,\n  Int32: () => Int32,\n  Long: () => Long,\n  LongWithoutOverridesClass: () => LongWithoutOverridesClass,\n  Map: () => bsonMap,\n  MaxKey: () => MaxKey,\n  MinKey: () => MinKey,\n  ObjectID: () => ObjectId,\n  ObjectId: () => ObjectId,\n  Timestamp: () => Timestamp,\n  UUID: () => UUID,\n  calculateObjectSize: () => calculateObjectSize,\n  default: () => bson_browser_esm_default,\n  deserialize: () => deserialize,\n  deserializeStream: () => deserializeStream,\n  serialize: () => serialize,\n  serializeWithBufferAndIndex: () => serializeWithBufferAndIndex,\n  setInternalBufferSize: () => setInternalBufferSize\n});\nvar import_dist = __toESM(require_dist());\nfunction createCommonjsModule(fn, module) {\n  return module = { exports: {} }, fn(module, module.exports), module.exports;\n}\nvar byteLength_1 = byteLength;\nvar toByteArray_1 = toByteArray;\nvar fromByteArray_1 = fromByteArray;\nvar lookup = [];\nvar revLookup = [];\nvar Arr = typeof Uint8Array !== \"undefined\" ? Uint8Array : Array;\nvar code = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nfor (i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i];\n  revLookup[code.charCodeAt(i)] = i;\n}\nvar i;\nvar len;\nrevLookup[\"-\".charCodeAt(0)] = 62;\nrevLookup[\"_\".charCodeAt(0)] = 63;\nfunction getLens(b64) {\n  var len = b64.length;\n  if (len % 4 > 0) {\n    throw new Error(\"Invalid string. Length must be a multiple of 4\");\n  }\n  var validLen = b64.indexOf(\"=\");\n  if (validLen === -1)\n    validLen = len;\n  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;\n  return [validLen, placeHoldersLen];\n}\nfunction byteLength(b64) {\n  var lens = getLens(b64);\n  var validLen = lens[0];\n  var placeHoldersLen = lens[1];\n  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n}\nfunction _byteLength(b64, validLen, placeHoldersLen) {\n  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n}\nfunction toByteArray(b64) {\n  var tmp;\n  var lens = getLens(b64);\n  var validLen = lens[0];\n  var placeHoldersLen = lens[1];\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n  var curByte = 0;\n  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;\n  var i;\n  for (i = 0; i < len; i += 4) {\n    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n    arr[curByte++] = tmp >> 16 & 255;\n    arr[curByte++] = tmp >> 8 & 255;\n    arr[curByte++] = tmp & 255;\n  }\n  if (placeHoldersLen === 2) {\n    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n    arr[curByte++] = tmp & 255;\n  }\n  if (placeHoldersLen === 1) {\n    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n    arr[curByte++] = tmp >> 8 & 255;\n    arr[curByte++] = tmp & 255;\n  }\n  return arr;\n}\nfunction tripletToBase64(num) {\n  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];\n}\nfunction encodeChunk(uint8, start, end) {\n  var tmp;\n  var output = [];\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (uint8[i + 2] & 255);\n    output.push(tripletToBase64(tmp));\n  }\n  return output.join(\"\");\n}\nfunction fromByteArray(uint8) {\n  var tmp;\n  var len = uint8.length;\n  var extraBytes = len % 3;\n  var parts = [];\n  var maxChunkLength = 16383;\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));\n  }\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1];\n    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + \"==\");\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + \"=\");\n  }\n  return parts.join(\"\");\n}\nvar base64Js = {\n  byteLength: byteLength_1,\n  toByteArray: toByteArray_1,\n  fromByteArray: fromByteArray_1\n};\nvar read = function read2(buffer2, offset, isLE, mLen, nBytes) {\n  var e, m;\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var nBits = -7;\n  var i = isLE ? nBytes - 1 : 0;\n  var d = isLE ? -1 : 1;\n  var s = buffer2[offset + i];\n  i += d;\n  e = s & (1 << -nBits) - 1;\n  s >>= -nBits;\n  nBits += eLen;\n  for (; nBits > 0; e = e * 256 + buffer2[offset + i], i += d, nBits -= 8) {\n  }\n  m = e & (1 << -nBits) - 1;\n  e >>= -nBits;\n  nBits += mLen;\n  for (; nBits > 0; m = m * 256 + buffer2[offset + i], i += d, nBits -= 8) {\n  }\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : (s ? -1 : 1) * Infinity;\n  } else {\n    m = m + Math.pow(2, mLen);\n    e = e - eBias;\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n};\nvar write = function write2(buffer2, value, offset, isLE, mLen, nBytes) {\n  var e, m, c;\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n  var i = isLE ? 0 : nBytes - 1;\n  var d = isLE ? 1 : -1;\n  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n  value = Math.abs(value);\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0;\n    e = eMax;\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2);\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * Math.pow(2, 1 - eBias);\n    }\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n      e = 0;\n    }\n  }\n  for (; mLen >= 8; buffer2[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {\n  }\n  e = e << mLen | m;\n  eLen += mLen;\n  for (; eLen > 0; buffer2[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {\n  }\n  buffer2[offset + i - d] |= s * 128;\n};\nvar ieee754 = {\n  read,\n  write\n};\nvar buffer$1 = createCommonjsModule(function(module, exports) {\n  var customInspectSymbol = typeof Symbol === \"function\" && typeof Symbol[\"for\"] === \"function\" ? (\n    // eslint-disable-line dot-notation\n    Symbol[\"for\"](\"nodejs.util.inspect.custom\")\n  ) : null;\n  exports.Buffer = Buffer2;\n  exports.SlowBuffer = SlowBuffer;\n  exports.INSPECT_MAX_BYTES = 50;\n  var K_MAX_LENGTH = 2147483647;\n  exports.kMaxLength = K_MAX_LENGTH;\n  Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();\n  if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== \"undefined\" && typeof console.error === \"function\") {\n    console.error(\"This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.\");\n  }\n  function typedArraySupport() {\n    try {\n      var arr = new Uint8Array(1);\n      var proto = {\n        foo: function foo() {\n          return 42;\n        }\n      };\n      Object.setPrototypeOf(proto, Uint8Array.prototype);\n      Object.setPrototypeOf(arr, proto);\n      return arr.foo() === 42;\n    } catch (e) {\n      return false;\n    }\n  }\n  Object.defineProperty(Buffer2.prototype, \"parent\", {\n    enumerable: true,\n    get: function get() {\n      if (!Buffer2.isBuffer(this))\n        return void 0;\n      return this.buffer;\n    }\n  });\n  Object.defineProperty(Buffer2.prototype, \"offset\", {\n    enumerable: true,\n    get: function get() {\n      if (!Buffer2.isBuffer(this))\n        return void 0;\n      return this.byteOffset;\n    }\n  });\n  function createBuffer(length) {\n    if (length > K_MAX_LENGTH) {\n      throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"');\n    }\n    var buf = new Uint8Array(length);\n    Object.setPrototypeOf(buf, Buffer2.prototype);\n    return buf;\n  }\n  function Buffer2(arg, encodingOrOffset, length) {\n    if (typeof arg === \"number\") {\n      if (typeof encodingOrOffset === \"string\") {\n        throw new TypeError('The \"string\" argument must be of type string. Received type number');\n      }\n      return allocUnsafe(arg);\n    }\n    return from(arg, encodingOrOffset, length);\n  }\n  Buffer2.poolSize = 8192;\n  function from(value, encodingOrOffset, length) {\n    if (typeof value === \"string\") {\n      return fromString(value, encodingOrOffset);\n    }\n    if (ArrayBuffer.isView(value)) {\n      return fromArrayView(value);\n    }\n    if (value == null) {\n      throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + babelHelpers[\"typeof\"](value));\n    }\n    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {\n      return fromArrayBuffer(value, encodingOrOffset, length);\n    }\n    if (typeof SharedArrayBuffer !== \"undefined\" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {\n      return fromArrayBuffer(value, encodingOrOffset, length);\n    }\n    if (typeof value === \"number\") {\n      throw new TypeError('The \"value\" argument must not be of type number. Received type number');\n    }\n    var valueOf = value.valueOf && value.valueOf();\n    if (valueOf != null && valueOf !== value) {\n      return Buffer2.from(valueOf, encodingOrOffset, length);\n    }\n    var b = fromObject(value);\n    if (b)\n      return b;\n    if (typeof Symbol !== \"undefined\" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === \"function\") {\n      return Buffer2.from(value[Symbol.toPrimitive](\"string\"), encodingOrOffset, length);\n    }\n    throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + babelHelpers[\"typeof\"](value));\n  }\n  Buffer2.from = function(value, encodingOrOffset, length) {\n    return from(value, encodingOrOffset, length);\n  };\n  Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);\n  Object.setPrototypeOf(Buffer2, Uint8Array);\n  function assertSize(size) {\n    if (typeof size !== \"number\") {\n      throw new TypeError('\"size\" argument must be of type number');\n    } else if (size < 0) {\n      throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"');\n    }\n  }\n  function alloc(size, fill, encoding) {\n    assertSize(size);\n    if (size <= 0) {\n      return createBuffer(size);\n    }\n    if (fill !== void 0) {\n      return typeof encoding === \"string\" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);\n    }\n    return createBuffer(size);\n  }\n  Buffer2.alloc = function(size, fill, encoding) {\n    return alloc(size, fill, encoding);\n  };\n  function allocUnsafe(size) {\n    assertSize(size);\n    return createBuffer(size < 0 ? 0 : checked(size) | 0);\n  }\n  Buffer2.allocUnsafe = function(size) {\n    return allocUnsafe(size);\n  };\n  Buffer2.allocUnsafeSlow = function(size) {\n    return allocUnsafe(size);\n  };\n  function fromString(string, encoding) {\n    if (typeof encoding !== \"string\" || encoding === \"\") {\n      encoding = \"utf8\";\n    }\n    if (!Buffer2.isEncoding(encoding)) {\n      throw new TypeError(\"Unknown encoding: \" + encoding);\n    }\n    var length = byteLength2(string, encoding) | 0;\n    var buf = createBuffer(length);\n    var actual = buf.write(string, encoding);\n    if (actual !== length) {\n      buf = buf.slice(0, actual);\n    }\n    return buf;\n  }\n  function fromArrayLike(array) {\n    var length = array.length < 0 ? 0 : checked(array.length) | 0;\n    var buf = createBuffer(length);\n    for (var i = 0; i < length; i += 1) {\n      buf[i] = array[i] & 255;\n    }\n    return buf;\n  }\n  function fromArrayView(arrayView) {\n    if (isInstance(arrayView, Uint8Array)) {\n      var copy = new Uint8Array(arrayView);\n      return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);\n    }\n    return fromArrayLike(arrayView);\n  }\n  function fromArrayBuffer(array, byteOffset, length) {\n    if (byteOffset < 0 || array.byteLength < byteOffset) {\n      throw new RangeError('\"offset\" is outside of buffer bounds');\n    }\n    if (array.byteLength < byteOffset + (length || 0)) {\n      throw new RangeError('\"length\" is outside of buffer bounds');\n    }\n    var buf;\n    if (byteOffset === void 0 && length === void 0) {\n      buf = new Uint8Array(array);\n    } else if (length === void 0) {\n      buf = new Uint8Array(array, byteOffset);\n    } else {\n      buf = new Uint8Array(array, byteOffset, length);\n    }\n    Object.setPrototypeOf(buf, Buffer2.prototype);\n    return buf;\n  }\n  function fromObject(obj) {\n    if (Buffer2.isBuffer(obj)) {\n      var len = checked(obj.length) | 0;\n      var buf = createBuffer(len);\n      if (buf.length === 0) {\n        return buf;\n      }\n      obj.copy(buf, 0, 0, len);\n      return buf;\n    }\n    if (obj.length !== void 0) {\n      if (typeof obj.length !== \"number\" || numberIsNaN(obj.length)) {\n        return createBuffer(0);\n      }\n      return fromArrayLike(obj);\n    }\n    if (obj.type === \"Buffer\" && Array.isArray(obj.data)) {\n      return fromArrayLike(obj.data);\n    }\n  }\n  function checked(length) {\n    if (length >= K_MAX_LENGTH) {\n      throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\" + K_MAX_LENGTH.toString(16) + \" bytes\");\n    }\n    return length | 0;\n  }\n  function SlowBuffer(length) {\n    if (+length != length) {\n      length = 0;\n    }\n    return Buffer2.alloc(+length);\n  }\n  Buffer2.isBuffer = function isBuffer(b) {\n    return b != null && b._isBuffer === true && b !== Buffer2.prototype;\n  };\n  Buffer2.compare = function compare(a, b) {\n    if (isInstance(a, Uint8Array))\n      a = Buffer2.from(a, a.offset, a.byteLength);\n    if (isInstance(b, Uint8Array))\n      b = Buffer2.from(b, b.offset, b.byteLength);\n    if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {\n      throw new TypeError('The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array');\n    }\n    if (a === b)\n      return 0;\n    var x = a.length;\n    var y = b.length;\n    for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n      if (a[i] !== b[i]) {\n        x = a[i];\n        y = b[i];\n        break;\n      }\n    }\n    if (x < y)\n      return -1;\n    if (y < x)\n      return 1;\n    return 0;\n  };\n  Buffer2.isEncoding = function isEncoding(encoding) {\n    switch (String(encoding).toLowerCase()) {\n      case \"hex\":\n      case \"utf8\":\n      case \"utf-8\":\n      case \"ascii\":\n      case \"latin1\":\n      case \"binary\":\n      case \"base64\":\n      case \"ucs2\":\n      case \"ucs-2\":\n      case \"utf16le\":\n      case \"utf-16le\":\n        return true;\n      default:\n        return false;\n    }\n  };\n  Buffer2.concat = function concat(list, length) {\n    if (!Array.isArray(list)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers');\n    }\n    if (list.length === 0) {\n      return Buffer2.alloc(0);\n    }\n    var i;\n    if (length === void 0) {\n      length = 0;\n      for (i = 0; i < list.length; ++i) {\n        length += list[i].length;\n      }\n    }\n    var buffer2 = Buffer2.allocUnsafe(length);\n    var pos = 0;\n    for (i = 0; i < list.length; ++i) {\n      var buf = list[i];\n      if (isInstance(buf, Uint8Array)) {\n        if (pos + buf.length > buffer2.length) {\n          Buffer2.from(buf).copy(buffer2, pos);\n        } else {\n          Uint8Array.prototype.set.call(buffer2, buf, pos);\n        }\n      } else if (!Buffer2.isBuffer(buf)) {\n        throw new TypeError('\"list\" argument must be an Array of Buffers');\n      } else {\n        buf.copy(buffer2, pos);\n      }\n      pos += buf.length;\n    }\n    return buffer2;\n  };\n  function byteLength2(string, encoding) {\n    if (Buffer2.isBuffer(string)) {\n      return string.length;\n    }\n    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n      return string.byteLength;\n    }\n    if (typeof string !== \"string\") {\n      throw new TypeError('The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + babelHelpers[\"typeof\"](string));\n    }\n    var len = string.length;\n    var mustMatch = arguments.length > 2 && arguments[2] === true;\n    if (!mustMatch && len === 0)\n      return 0;\n    var loweredCase = false;\n    for (; ; ) {\n      switch (encoding) {\n        case \"ascii\":\n        case \"latin1\":\n        case \"binary\":\n          return len;\n        case \"utf8\":\n        case \"utf-8\":\n          return utf8ToBytes(string).length;\n        case \"ucs2\":\n        case \"ucs-2\":\n        case \"utf16le\":\n        case \"utf-16le\":\n          return len * 2;\n        case \"hex\":\n          return len >>> 1;\n        case \"base64\":\n          return base64ToBytes(string).length;\n        default:\n          if (loweredCase) {\n            return mustMatch ? -1 : utf8ToBytes(string).length;\n          }\n          encoding = (\"\" + encoding).toLowerCase();\n          loweredCase = true;\n      }\n    }\n  }\n  Buffer2.byteLength = byteLength2;\n  function slowToString(encoding, start, end) {\n    var loweredCase = false;\n    if (start === void 0 || start < 0) {\n      start = 0;\n    }\n    if (start > this.length) {\n      return \"\";\n    }\n    if (end === void 0 || end > this.length) {\n      end = this.length;\n    }\n    if (end <= 0) {\n      return \"\";\n    }\n    end >>>= 0;\n    start >>>= 0;\n    if (end <= start) {\n      return \"\";\n    }\n    if (!encoding)\n      encoding = \"utf8\";\n    while (true) {\n      switch (encoding) {\n        case \"hex\":\n          return hexSlice(this, start, end);\n        case \"utf8\":\n        case \"utf-8\":\n          return utf8Slice(this, start, end);\n        case \"ascii\":\n          return asciiSlice(this, start, end);\n        case \"latin1\":\n        case \"binary\":\n          return latin1Slice(this, start, end);\n        case \"base64\":\n          return base64Slice(this, start, end);\n        case \"ucs2\":\n        case \"ucs-2\":\n        case \"utf16le\":\n        case \"utf-16le\":\n          return utf16leSlice(this, start, end);\n        default:\n          if (loweredCase)\n            throw new TypeError(\"Unknown encoding: \" + encoding);\n          encoding = (encoding + \"\").toLowerCase();\n          loweredCase = true;\n      }\n    }\n  }\n  Buffer2.prototype._isBuffer = true;\n  function swap(b, n, m) {\n    var i = b[n];\n    b[n] = b[m];\n    b[m] = i;\n  }\n  Buffer2.prototype.swap16 = function swap16() {\n    var len = this.length;\n    if (len % 2 !== 0) {\n      throw new RangeError(\"Buffer size must be a multiple of 16-bits\");\n    }\n    for (var i = 0; i < len; i += 2) {\n      swap(this, i, i + 1);\n    }\n    return this;\n  };\n  Buffer2.prototype.swap32 = function swap32() {\n    var len = this.length;\n    if (len % 4 !== 0) {\n      throw new RangeError(\"Buffer size must be a multiple of 32-bits\");\n    }\n    for (var i = 0; i < len; i += 4) {\n      swap(this, i, i + 3);\n      swap(this, i + 1, i + 2);\n    }\n    return this;\n  };\n  Buffer2.prototype.swap64 = function swap64() {\n    var len = this.length;\n    if (len % 8 !== 0) {\n      throw new RangeError(\"Buffer size must be a multiple of 64-bits\");\n    }\n    for (var i = 0; i < len; i += 8) {\n      swap(this, i, i + 7);\n      swap(this, i + 1, i + 6);\n      swap(this, i + 2, i + 5);\n      swap(this, i + 3, i + 4);\n    }\n    return this;\n  };\n  Buffer2.prototype.toString = function toString() {\n    var length = this.length;\n    if (length === 0)\n      return \"\";\n    if (arguments.length === 0)\n      return utf8Slice(this, 0, length);\n    return slowToString.apply(this, arguments);\n  };\n  Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;\n  Buffer2.prototype.equals = function equals(b) {\n    if (!Buffer2.isBuffer(b))\n      throw new TypeError(\"Argument must be a Buffer\");\n    if (this === b)\n      return true;\n    return Buffer2.compare(this, b) === 0;\n  };\n  Buffer2.prototype.inspect = function inspect() {\n    var str = \"\";\n    var max = exports.INSPECT_MAX_BYTES;\n    str = this.toString(\"hex\", 0, max).replace(/(.{2})/g, \"$1 \").trim();\n    if (this.length > max)\n      str += \" ... \";\n    return \"<Buffer \" + str + \">\";\n  };\n  if (customInspectSymbol) {\n    Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;\n  }\n  Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n    if (isInstance(target, Uint8Array)) {\n      target = Buffer2.from(target, target.offset, target.byteLength);\n    }\n    if (!Buffer2.isBuffer(target)) {\n      throw new TypeError('The \"target\" argument must be one of type Buffer or Uint8Array. Received type ' + babelHelpers[\"typeof\"](target));\n    }\n    if (start === void 0) {\n      start = 0;\n    }\n    if (end === void 0) {\n      end = target ? target.length : 0;\n    }\n    if (thisStart === void 0) {\n      thisStart = 0;\n    }\n    if (thisEnd === void 0) {\n      thisEnd = this.length;\n    }\n    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n      throw new RangeError(\"out of range index\");\n    }\n    if (thisStart >= thisEnd && start >= end) {\n      return 0;\n    }\n    if (thisStart >= thisEnd) {\n      return -1;\n    }\n    if (start >= end) {\n      return 1;\n    }\n    start >>>= 0;\n    end >>>= 0;\n    thisStart >>>= 0;\n    thisEnd >>>= 0;\n    if (this === target)\n      return 0;\n    var x = thisEnd - thisStart;\n    var y = end - start;\n    var len = Math.min(x, y);\n    var thisCopy = this.slice(thisStart, thisEnd);\n    var targetCopy = target.slice(start, end);\n    for (var i = 0; i < len; ++i) {\n      if (thisCopy[i] !== targetCopy[i]) {\n        x = thisCopy[i];\n        y = targetCopy[i];\n        break;\n      }\n    }\n    if (x < y)\n      return -1;\n    if (y < x)\n      return 1;\n    return 0;\n  };\n  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {\n    if (buffer2.length === 0)\n      return -1;\n    if (typeof byteOffset === \"string\") {\n      encoding = byteOffset;\n      byteOffset = 0;\n    } else if (byteOffset > 2147483647) {\n      byteOffset = 2147483647;\n    } else if (byteOffset < -2147483648) {\n      byteOffset = -2147483648;\n    }\n    byteOffset = +byteOffset;\n    if (numberIsNaN(byteOffset)) {\n      byteOffset = dir ? 0 : buffer2.length - 1;\n    }\n    if (byteOffset < 0)\n      byteOffset = buffer2.length + byteOffset;\n    if (byteOffset >= buffer2.length) {\n      if (dir)\n        return -1;\n      else\n        byteOffset = buffer2.length - 1;\n    } else if (byteOffset < 0) {\n      if (dir)\n        byteOffset = 0;\n      else\n        return -1;\n    }\n    if (typeof val === \"string\") {\n      val = Buffer2.from(val, encoding);\n    }\n    if (Buffer2.isBuffer(val)) {\n      if (val.length === 0) {\n        return -1;\n      }\n      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);\n    } else if (typeof val === \"number\") {\n      val = val & 255;\n      if (typeof Uint8Array.prototype.indexOf === \"function\") {\n        if (dir) {\n          return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);\n        } else {\n          return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);\n        }\n      }\n      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);\n    }\n    throw new TypeError(\"val must be string, number or Buffer\");\n  }\n  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n    var indexSize = 1;\n    var arrLength = arr.length;\n    var valLength = val.length;\n    if (encoding !== void 0) {\n      encoding = String(encoding).toLowerCase();\n      if (encoding === \"ucs2\" || encoding === \"ucs-2\" || encoding === \"utf16le\" || encoding === \"utf-16le\") {\n        if (arr.length < 2 || val.length < 2) {\n          return -1;\n        }\n        indexSize = 2;\n        arrLength /= 2;\n        valLength /= 2;\n        byteOffset /= 2;\n      }\n    }\n    function read3(buf, i2) {\n      if (indexSize === 1) {\n        return buf[i2];\n      } else {\n        return buf.readUInt16BE(i2 * indexSize);\n      }\n    }\n    var i;\n    if (dir) {\n      var foundIndex = -1;\n      for (i = byteOffset; i < arrLength; i++) {\n        if (read3(arr, i) === read3(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n          if (foundIndex === -1)\n            foundIndex = i;\n          if (i - foundIndex + 1 === valLength)\n            return foundIndex * indexSize;\n        } else {\n          if (foundIndex !== -1)\n            i -= i - foundIndex;\n          foundIndex = -1;\n        }\n      }\n    } else {\n      if (byteOffset + valLength > arrLength)\n        byteOffset = arrLength - valLength;\n      for (i = byteOffset; i >= 0; i--) {\n        var found = true;\n        for (var j = 0; j < valLength; j++) {\n          if (read3(arr, i + j) !== read3(val, j)) {\n            found = false;\n            break;\n          }\n        }\n        if (found)\n          return i;\n      }\n    }\n    return -1;\n  }\n  Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {\n    return this.indexOf(val, byteOffset, encoding) !== -1;\n  };\n  Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n  };\n  Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n  };\n  function hexWrite(buf, string, offset, length) {\n    offset = Number(offset) || 0;\n    var remaining = buf.length - offset;\n    if (!length) {\n      length = remaining;\n    } else {\n      length = Number(length);\n      if (length > remaining) {\n        length = remaining;\n      }\n    }\n    var strLen = string.length;\n    if (length > strLen / 2) {\n      length = strLen / 2;\n    }\n    for (var i = 0; i < length; ++i) {\n      var parsed = parseInt(string.substr(i * 2, 2), 16);\n      if (numberIsNaN(parsed))\n        return i;\n      buf[offset + i] = parsed;\n    }\n    return i;\n  }\n  function utf8Write(buf, string, offset, length) {\n    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n  }\n  function asciiWrite(buf, string, offset, length) {\n    return blitBuffer(asciiToBytes(string), buf, offset, length);\n  }\n  function base64Write(buf, string, offset, length) {\n    return blitBuffer(base64ToBytes(string), buf, offset, length);\n  }\n  function ucs2Write(buf, string, offset, length) {\n    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n  }\n  Buffer2.prototype.write = function write3(string, offset, length, encoding) {\n    if (offset === void 0) {\n      encoding = \"utf8\";\n      length = this.length;\n      offset = 0;\n    } else if (length === void 0 && typeof offset === \"string\") {\n      encoding = offset;\n      length = this.length;\n      offset = 0;\n    } else if (isFinite(offset)) {\n      offset = offset >>> 0;\n      if (isFinite(length)) {\n        length = length >>> 0;\n        if (encoding === void 0)\n          encoding = \"utf8\";\n      } else {\n        encoding = length;\n        length = void 0;\n      }\n    } else {\n      throw new Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\");\n    }\n    var remaining = this.length - offset;\n    if (length === void 0 || length > remaining)\n      length = remaining;\n    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n      throw new RangeError(\"Attempt to write outside buffer bounds\");\n    }\n    if (!encoding)\n      encoding = \"utf8\";\n    var loweredCase = false;\n    for (; ; ) {\n      switch (encoding) {\n        case \"hex\":\n          return hexWrite(this, string, offset, length);\n        case \"utf8\":\n        case \"utf-8\":\n          return utf8Write(this, string, offset, length);\n        case \"ascii\":\n        case \"latin1\":\n        case \"binary\":\n          return asciiWrite(this, string, offset, length);\n        case \"base64\":\n          return base64Write(this, string, offset, length);\n        case \"ucs2\":\n        case \"ucs-2\":\n        case \"utf16le\":\n        case \"utf-16le\":\n          return ucs2Write(this, string, offset, length);\n        default:\n          if (loweredCase)\n            throw new TypeError(\"Unknown encoding: \" + encoding);\n          encoding = (\"\" + encoding).toLowerCase();\n          loweredCase = true;\n      }\n    }\n  };\n  Buffer2.prototype.toJSON = function toJSON() {\n    return {\n      type: \"Buffer\",\n      data: Array.prototype.slice.call(this._arr || this, 0)\n    };\n  };\n  function base64Slice(buf, start, end) {\n    if (start === 0 && end === buf.length) {\n      return base64Js.fromByteArray(buf);\n    } else {\n      return base64Js.fromByteArray(buf.slice(start, end));\n    }\n  }\n  function utf8Slice(buf, start, end) {\n    end = Math.min(buf.length, end);\n    var res = [];\n    var i = start;\n    while (i < end) {\n      var firstByte = buf[i];\n      var codePoint = null;\n      var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;\n      if (i + bytesPerSequence <= end) {\n        var secondByte, thirdByte, fourthByte, tempCodePoint;\n        switch (bytesPerSequence) {\n          case 1:\n            if (firstByte < 128) {\n              codePoint = firstByte;\n            }\n            break;\n          case 2:\n            secondByte = buf[i + 1];\n            if ((secondByte & 192) === 128) {\n              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;\n              if (tempCodePoint > 127) {\n                codePoint = tempCodePoint;\n              }\n            }\n            break;\n          case 3:\n            secondByte = buf[i + 1];\n            thirdByte = buf[i + 2];\n            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {\n              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;\n              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {\n                codePoint = tempCodePoint;\n              }\n            }\n            break;\n          case 4:\n            secondByte = buf[i + 1];\n            thirdByte = buf[i + 2];\n            fourthByte = buf[i + 3];\n            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {\n              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;\n              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {\n                codePoint = tempCodePoint;\n              }\n            }\n        }\n      }\n      if (codePoint === null) {\n        codePoint = 65533;\n        bytesPerSequence = 1;\n      } else if (codePoint > 65535) {\n        codePoint -= 65536;\n        res.push(codePoint >>> 10 & 1023 | 55296);\n        codePoint = 56320 | codePoint & 1023;\n      }\n      res.push(codePoint);\n      i += bytesPerSequence;\n    }\n    return decodeCodePointsArray(res);\n  }\n  var MAX_ARGUMENTS_LENGTH = 4096;\n  function decodeCodePointsArray(codePoints) {\n    var len = codePoints.length;\n    if (len <= MAX_ARGUMENTS_LENGTH) {\n      return String.fromCharCode.apply(String, codePoints);\n    }\n    var res = \"\";\n    var i = 0;\n    while (i < len) {\n      res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\n    }\n    return res;\n  }\n  function asciiSlice(buf, start, end) {\n    var ret = \"\";\n    end = Math.min(buf.length, end);\n    for (var i = start; i < end; ++i) {\n      ret += String.fromCharCode(buf[i] & 127);\n    }\n    return ret;\n  }\n  function latin1Slice(buf, start, end) {\n    var ret = \"\";\n    end = Math.min(buf.length, end);\n    for (var i = start; i < end; ++i) {\n      ret += String.fromCharCode(buf[i]);\n    }\n    return ret;\n  }\n  function hexSlice(buf, start, end) {\n    var len = buf.length;\n    if (!start || start < 0)\n      start = 0;\n    if (!end || end < 0 || end > len)\n      end = len;\n    var out = \"\";\n    for (var i = start; i < end; ++i) {\n      out += hexSliceLookupTable[buf[i]];\n    }\n    return out;\n  }\n  function utf16leSlice(buf, start, end) {\n    var bytes = buf.slice(start, end);\n    var res = \"\";\n    for (var i = 0; i < bytes.length - 1; i += 2) {\n      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n    }\n    return res;\n  }\n  Buffer2.prototype.slice = function slice(start, end) {\n    var len = this.length;\n    start = ~~start;\n    end = end === void 0 ? len : ~~end;\n    if (start < 0) {\n      start += len;\n      if (start < 0)\n        start = 0;\n    } else if (start > len) {\n      start = len;\n    }\n    if (end < 0) {\n      end += len;\n      if (end < 0)\n        end = 0;\n    } else if (end > len) {\n      end = len;\n    }\n    if (end < start)\n      end = start;\n    var newBuf = this.subarray(start, end);\n    Object.setPrototypeOf(newBuf, Buffer2.prototype);\n    return newBuf;\n  };\n  function checkOffset(offset, ext, length) {\n    if (offset % 1 !== 0 || offset < 0)\n      throw new RangeError(\"offset is not uint\");\n    if (offset + ext > length)\n      throw new RangeError(\"Trying to access beyond buffer length\");\n  }\n  Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {\n    offset = offset >>> 0;\n    byteLength3 = byteLength3 >>> 0;\n    if (!noAssert)\n      checkOffset(offset, byteLength3, this.length);\n    var val = this[offset];\n    var mul = 1;\n    var i = 0;\n    while (++i < byteLength3 && (mul *= 256)) {\n      val += this[offset + i] * mul;\n    }\n    return val;\n  };\n  Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {\n    offset = offset >>> 0;\n    byteLength3 = byteLength3 >>> 0;\n    if (!noAssert) {\n      checkOffset(offset, byteLength3, this.length);\n    }\n    var val = this[offset + --byteLength3];\n    var mul = 1;\n    while (byteLength3 > 0 && (mul *= 256)) {\n      val += this[offset + --byteLength3] * mul;\n    }\n    return val;\n  };\n  Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkOffset(offset, 1, this.length);\n    return this[offset];\n  };\n  Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkOffset(offset, 2, this.length);\n    return this[offset] | this[offset + 1] << 8;\n  };\n  Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkOffset(offset, 2, this.length);\n    return this[offset] << 8 | this[offset + 1];\n  };\n  Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkOffset(offset, 4, this.length);\n    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;\n  };\n  Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkOffset(offset, 4, this.length);\n    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n  };\n  Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {\n    offset = offset >>> 0;\n    byteLength3 = byteLength3 >>> 0;\n    if (!noAssert)\n      checkOffset(offset, byteLength3, this.length);\n    var val = this[offset];\n    var mul = 1;\n    var i = 0;\n    while (++i < byteLength3 && (mul *= 256)) {\n      val += this[offset + i] * mul;\n    }\n    mul *= 128;\n    if (val >= mul)\n      val -= Math.pow(2, 8 * byteLength3);\n    return val;\n  };\n  Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {\n    offset = offset >>> 0;\n    byteLength3 = byteLength3 >>> 0;\n    if (!noAssert)\n      checkOffset(offset, byteLength3, this.length);\n    var i = byteLength3;\n    var mul = 1;\n    var val = this[offset + --i];\n    while (i > 0 && (mul *= 256)) {\n      val += this[offset + --i] * mul;\n    }\n    mul *= 128;\n    if (val >= mul)\n      val -= Math.pow(2, 8 * byteLength3);\n    return val;\n  };\n  Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkOffset(offset, 1, this.length);\n    if (!(this[offset] & 128))\n      return this[offset];\n    return (255 - this[offset] + 1) * -1;\n  };\n  Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkOffset(offset, 2, this.length);\n    var val = this[offset] | this[offset + 1] << 8;\n    return val & 32768 ? val | 4294901760 : val;\n  };\n  Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkOffset(offset, 2, this.length);\n    var val = this[offset + 1] | this[offset] << 8;\n    return val & 32768 ? val | 4294901760 : val;\n  };\n  Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkOffset(offset, 4, this.length);\n    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n  };\n  Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkOffset(offset, 4, this.length);\n    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n  };\n  Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkOffset(offset, 4, this.length);\n    return ieee754.read(this, offset, true, 23, 4);\n  };\n  Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkOffset(offset, 4, this.length);\n    return ieee754.read(this, offset, false, 23, 4);\n  };\n  Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkOffset(offset, 8, this.length);\n    return ieee754.read(this, offset, true, 52, 8);\n  };\n  Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkOffset(offset, 8, this.length);\n    return ieee754.read(this, offset, false, 52, 8);\n  };\n  function checkInt(buf, value, offset, ext, max, min) {\n    if (!Buffer2.isBuffer(buf))\n      throw new TypeError('\"buffer\" argument must be a Buffer instance');\n    if (value > max || value < min)\n      throw new RangeError('\"value\" argument is out of bounds');\n    if (offset + ext > buf.length)\n      throw new RangeError(\"Index out of range\");\n  }\n  Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    byteLength3 = byteLength3 >>> 0;\n    if (!noAssert) {\n      var maxBytes = Math.pow(2, 8 * byteLength3) - 1;\n      checkInt(this, value, offset, byteLength3, maxBytes, 0);\n    }\n    var mul = 1;\n    var i = 0;\n    this[offset] = value & 255;\n    while (++i < byteLength3 && (mul *= 256)) {\n      this[offset + i] = value / mul & 255;\n    }\n    return offset + byteLength3;\n  };\n  Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    byteLength3 = byteLength3 >>> 0;\n    if (!noAssert) {\n      var maxBytes = Math.pow(2, 8 * byteLength3) - 1;\n      checkInt(this, value, offset, byteLength3, maxBytes, 0);\n    }\n    var i = byteLength3 - 1;\n    var mul = 1;\n    this[offset + i] = value & 255;\n    while (--i >= 0 && (mul *= 256)) {\n      this[offset + i] = value / mul & 255;\n    }\n    return offset + byteLength3;\n  };\n  Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkInt(this, value, offset, 1, 255, 0);\n    this[offset] = value & 255;\n    return offset + 1;\n  };\n  Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkInt(this, value, offset, 2, 65535, 0);\n    this[offset] = value & 255;\n    this[offset + 1] = value >>> 8;\n    return offset + 2;\n  };\n  Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkInt(this, value, offset, 2, 65535, 0);\n    this[offset] = value >>> 8;\n    this[offset + 1] = value & 255;\n    return offset + 2;\n  };\n  Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkInt(this, value, offset, 4, 4294967295, 0);\n    this[offset + 3] = value >>> 24;\n    this[offset + 2] = value >>> 16;\n    this[offset + 1] = value >>> 8;\n    this[offset] = value & 255;\n    return offset + 4;\n  };\n  Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkInt(this, value, offset, 4, 4294967295, 0);\n    this[offset] = value >>> 24;\n    this[offset + 1] = value >>> 16;\n    this[offset + 2] = value >>> 8;\n    this[offset + 3] = value & 255;\n    return offset + 4;\n  };\n  Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) {\n      var limit = Math.pow(2, 8 * byteLength3 - 1);\n      checkInt(this, value, offset, byteLength3, limit - 1, -limit);\n    }\n    var i = 0;\n    var mul = 1;\n    var sub = 0;\n    this[offset] = value & 255;\n    while (++i < byteLength3 && (mul *= 256)) {\n      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n        sub = 1;\n      }\n      this[offset + i] = (value / mul >> 0) - sub & 255;\n    }\n    return offset + byteLength3;\n  };\n  Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) {\n      var limit = Math.pow(2, 8 * byteLength3 - 1);\n      checkInt(this, value, offset, byteLength3, limit - 1, -limit);\n    }\n    var i = byteLength3 - 1;\n    var mul = 1;\n    var sub = 0;\n    this[offset + i] = value & 255;\n    while (--i >= 0 && (mul *= 256)) {\n      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n        sub = 1;\n      }\n      this[offset + i] = (value / mul >> 0) - sub & 255;\n    }\n    return offset + byteLength3;\n  };\n  Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkInt(this, value, offset, 1, 127, -128);\n    if (value < 0)\n      value = 255 + value + 1;\n    this[offset] = value & 255;\n    return offset + 1;\n  };\n  Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkInt(this, value, offset, 2, 32767, -32768);\n    this[offset] = value & 255;\n    this[offset + 1] = value >>> 8;\n    return offset + 2;\n  };\n  Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkInt(this, value, offset, 2, 32767, -32768);\n    this[offset] = value >>> 8;\n    this[offset + 1] = value & 255;\n    return offset + 2;\n  };\n  Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkInt(this, value, offset, 4, 2147483647, -2147483648);\n    this[offset] = value & 255;\n    this[offset + 1] = value >>> 8;\n    this[offset + 2] = value >>> 16;\n    this[offset + 3] = value >>> 24;\n    return offset + 4;\n  };\n  Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkInt(this, value, offset, 4, 2147483647, -2147483648);\n    if (value < 0)\n      value = 4294967295 + value + 1;\n    this[offset] = value >>> 24;\n    this[offset + 1] = value >>> 16;\n    this[offset + 2] = value >>> 8;\n    this[offset + 3] = value & 255;\n    return offset + 4;\n  };\n  function checkIEEE754(buf, value, offset, ext, max, min) {\n    if (offset + ext > buf.length)\n      throw new RangeError(\"Index out of range\");\n    if (offset < 0)\n      throw new RangeError(\"Index out of range\");\n  }\n  function writeFloat(buf, value, offset, littleEndian, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) {\n      checkIEEE754(buf, value, offset, 4);\n    }\n    ieee754.write(buf, value, offset, littleEndian, 23, 4);\n    return offset + 4;\n  }\n  Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n    return writeFloat(this, value, offset, true, noAssert);\n  };\n  Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n    return writeFloat(this, value, offset, false, noAssert);\n  };\n  function writeDouble(buf, value, offset, littleEndian, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) {\n      checkIEEE754(buf, value, offset, 8);\n    }\n    ieee754.write(buf, value, offset, littleEndian, 52, 8);\n    return offset + 8;\n  }\n  Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n    return writeDouble(this, value, offset, true, noAssert);\n  };\n  Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n    return writeDouble(this, value, offset, false, noAssert);\n  };\n  Buffer2.prototype.copy = function copy(target, targetStart, start, end) {\n    if (!Buffer2.isBuffer(target))\n      throw new TypeError(\"argument should be a Buffer\");\n    if (!start)\n      start = 0;\n    if (!end && end !== 0)\n      end = this.length;\n    if (targetStart >= target.length)\n      targetStart = target.length;\n    if (!targetStart)\n      targetStart = 0;\n    if (end > 0 && end < start)\n      end = start;\n    if (end === start)\n      return 0;\n    if (target.length === 0 || this.length === 0)\n      return 0;\n    if (targetStart < 0) {\n      throw new RangeError(\"targetStart out of bounds\");\n    }\n    if (start < 0 || start >= this.length)\n      throw new RangeError(\"Index out of range\");\n    if (end < 0)\n      throw new RangeError(\"sourceEnd out of bounds\");\n    if (end > this.length)\n      end = this.length;\n    if (target.length - targetStart < end - start) {\n      end = target.length - targetStart + start;\n    }\n    var len = end - start;\n    if (this === target && typeof Uint8Array.prototype.copyWithin === \"function\") {\n      this.copyWithin(targetStart, start, end);\n    } else {\n      Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);\n    }\n    return len;\n  };\n  Buffer2.prototype.fill = function fill(val, start, end, encoding) {\n    if (typeof val === \"string\") {\n      if (typeof start === \"string\") {\n        encoding = start;\n        start = 0;\n        end = this.length;\n      } else if (typeof end === \"string\") {\n        encoding = end;\n        end = this.length;\n      }\n      if (encoding !== void 0 && typeof encoding !== \"string\") {\n        throw new TypeError(\"encoding must be a string\");\n      }\n      if (typeof encoding === \"string\" && !Buffer2.isEncoding(encoding)) {\n        throw new TypeError(\"Unknown encoding: \" + encoding);\n      }\n      if (val.length === 1) {\n        var code2 = val.charCodeAt(0);\n        if (encoding === \"utf8\" && code2 < 128 || encoding === \"latin1\") {\n          val = code2;\n        }\n      }\n    } else if (typeof val === \"number\") {\n      val = val & 255;\n    } else if (typeof val === \"boolean\") {\n      val = Number(val);\n    }\n    if (start < 0 || this.length < start || this.length < end) {\n      throw new RangeError(\"Out of range index\");\n    }\n    if (end <= start) {\n      return this;\n    }\n    start = start >>> 0;\n    end = end === void 0 ? this.length : end >>> 0;\n    if (!val)\n      val = 0;\n    var i;\n    if (typeof val === \"number\") {\n      for (i = start; i < end; ++i) {\n        this[i] = val;\n      }\n    } else {\n      var bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);\n      var len = bytes.length;\n      if (len === 0) {\n        throw new TypeError('The value \"' + val + '\" is invalid for argument \"value\"');\n      }\n      for (i = 0; i < end - start; ++i) {\n        this[i + start] = bytes[i % len];\n      }\n    }\n    return this;\n  };\n  var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;\n  function base64clean(str) {\n    str = str.split(\"=\")[0];\n    str = str.trim().replace(INVALID_BASE64_RE, \"\");\n    if (str.length < 2)\n      return \"\";\n    while (str.length % 4 !== 0) {\n      str = str + \"=\";\n    }\n    return str;\n  }\n  function utf8ToBytes(string, units) {\n    units = units || Infinity;\n    var codePoint;\n    var length = string.length;\n    var leadSurrogate = null;\n    var bytes = [];\n    for (var i = 0; i < length; ++i) {\n      codePoint = string.charCodeAt(i);\n      if (codePoint > 55295 && codePoint < 57344) {\n        if (!leadSurrogate) {\n          if (codePoint > 56319) {\n            if ((units -= 3) > -1)\n              bytes.push(239, 191, 189);\n            continue;\n          } else if (i + 1 === length) {\n            if ((units -= 3) > -1)\n              bytes.push(239, 191, 189);\n            continue;\n          }\n          leadSurrogate = codePoint;\n          continue;\n        }\n        if (codePoint < 56320) {\n          if ((units -= 3) > -1)\n            bytes.push(239, 191, 189);\n          leadSurrogate = codePoint;\n          continue;\n        }\n        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;\n      } else if (leadSurrogate) {\n        if ((units -= 3) > -1)\n          bytes.push(239, 191, 189);\n      }\n      leadSurrogate = null;\n      if (codePoint < 128) {\n        if ((units -= 1) < 0)\n          break;\n        bytes.push(codePoint);\n      } else if (codePoint < 2048) {\n        if ((units -= 2) < 0)\n          break;\n        bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);\n      } else if (codePoint < 65536) {\n        if ((units -= 3) < 0)\n          break;\n        bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);\n      } else if (codePoint < 1114112) {\n        if ((units -= 4) < 0)\n          break;\n        bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);\n      } else {\n        throw new Error(\"Invalid code point\");\n      }\n    }\n    return bytes;\n  }\n  function asciiToBytes(str) {\n    var byteArray = [];\n    for (var i = 0; i < str.length; ++i) {\n      byteArray.push(str.charCodeAt(i) & 255);\n    }\n    return byteArray;\n  }\n  function utf16leToBytes(str, units) {\n    var c, hi, lo;\n    var byteArray = [];\n    for (var i = 0; i < str.length; ++i) {\n      if ((units -= 2) < 0)\n        break;\n      c = str.charCodeAt(i);\n      hi = c >> 8;\n      lo = c % 256;\n      byteArray.push(lo);\n      byteArray.push(hi);\n    }\n    return byteArray;\n  }\n  function base64ToBytes(str) {\n    return base64Js.toByteArray(base64clean(str));\n  }\n  function blitBuffer(src, dst, offset, length) {\n    for (var i = 0; i < length; ++i) {\n      if (i + offset >= dst.length || i >= src.length)\n        break;\n      dst[i + offset] = src[i];\n    }\n    return i;\n  }\n  function isInstance(obj, type) {\n    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;\n  }\n  function numberIsNaN(obj) {\n    return obj !== obj;\n  }\n  var hexSliceLookupTable = function() {\n    var alphabet = \"0123456789abcdef\";\n    var table = new Array(256);\n    for (var i = 0; i < 16; ++i) {\n      var i16 = i * 16;\n      for (var j = 0; j < 16; ++j) {\n        table[i16 + j] = alphabet[i] + alphabet[j];\n      }\n    }\n    return table;\n  }();\n});\nvar buffer_1 = buffer$1.Buffer;\nbuffer$1.SlowBuffer;\nbuffer$1.INSPECT_MAX_BYTES;\nbuffer$1.kMaxLength;\nvar _extendStatics = function extendStatics(d, b) {\n  _extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function(d2, b2) {\n    d2.__proto__ = b2;\n  } || function(d2, b2) {\n    for (var p in b2) {\n      if (b2.hasOwnProperty(p))\n        d2[p] = b2[p];\n    }\n  };\n  return _extendStatics(d, b);\n};\nfunction __extends(d, b) {\n  _extendStatics(d, b);\n  function __() {\n    this.constructor = d;\n  }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nvar _assign = function __assign() {\n  _assign = Object.assign || function __assign2(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p))\n          t[p] = s[p];\n      }\n    }\n    return t;\n  };\n  return _assign.apply(this, arguments);\n};\nvar BSONError = (\n  /** @class */\n  function(_super) {\n    __extends(BSONError2, _super);\n    function BSONError2(message) {\n      var _this = _super.call(this, message) || this;\n      Object.setPrototypeOf(_this, BSONError2.prototype);\n      return _this;\n    }\n    Object.defineProperty(BSONError2.prototype, \"name\", {\n      get: function() {\n        return \"BSONError\";\n      },\n      enumerable: false,\n      configurable: true\n    });\n    return BSONError2;\n  }(Error)\n);\nvar BSONTypeError = (\n  /** @class */\n  function(_super) {\n    __extends(BSONTypeError2, _super);\n    function BSONTypeError2(message) {\n      var _this = _super.call(this, message) || this;\n      Object.setPrototypeOf(_this, BSONTypeError2.prototype);\n      return _this;\n    }\n    Object.defineProperty(BSONTypeError2.prototype, \"name\", {\n      get: function() {\n        return \"BSONTypeError\";\n      },\n      enumerable: false,\n      configurable: true\n    });\n    return BSONTypeError2;\n  }(TypeError)\n);\nfunction checkForMath(potentialGlobal) {\n  return potentialGlobal && potentialGlobal.Math == Math && potentialGlobal;\n}\nfunction getGlobal() {\n  return checkForMath(typeof globalThis === \"object\" && globalThis) || checkForMath(typeof window === \"object\" && window) || checkForMath(typeof self === \"object\" && self) || checkForMath(typeof global === \"object\" && global) || // eslint-disable-next-line @typescript-eslint/no-implied-eval\n  Function(\"return this\")();\n}\nfunction normalizedFunctionString(fn) {\n  return fn.toString().replace(\"function(\", \"function (\");\n}\nfunction isReactNative() {\n  var g = getGlobal();\n  return typeof g.navigator === \"object\" && g.navigator.product === \"ReactNative\";\n}\nvar insecureRandomBytes = function insecureRandomBytes2(size) {\n  var insecureWarning = isReactNative() ? \"BSON: For React Native please polyfill crypto.getRandomValues, e.g. using: https://www.npmjs.com/package/react-native-get-random-values.\" : \"BSON: No cryptographic implementation for random bytes present, falling back to a less secure implementation.\";\n  console.warn(insecureWarning);\n  var result = buffer_1.alloc(size);\n  for (var i = 0; i < size; ++i)\n    result[i] = Math.floor(Math.random() * 256);\n  return result;\n};\nvar detectRandomBytes = function() {\n  {\n    if (typeof window !== \"undefined\") {\n      var target_1 = window.crypto || window.msCrypto;\n      if (target_1 && target_1.getRandomValues) {\n        return function(size) {\n          return target_1.getRandomValues(buffer_1.alloc(size));\n        };\n      }\n    }\n    if (typeof global !== \"undefined\" && global.crypto && global.crypto.getRandomValues) {\n      return function(size) {\n        return global.crypto.getRandomValues(buffer_1.alloc(size));\n      };\n    }\n    return insecureRandomBytes;\n  }\n};\nvar randomBytes = detectRandomBytes();\nfunction isAnyArrayBuffer(value) {\n  return [\"[object ArrayBuffer]\", \"[object SharedArrayBuffer]\"].includes(Object.prototype.toString.call(value));\n}\nfunction isUint8Array(value) {\n  return Object.prototype.toString.call(value) === \"[object Uint8Array]\";\n}\nfunction isBigInt64Array(value) {\n  return Object.prototype.toString.call(value) === \"[object BigInt64Array]\";\n}\nfunction isBigUInt64Array(value) {\n  return Object.prototype.toString.call(value) === \"[object BigUint64Array]\";\n}\nfunction isRegExp(d) {\n  return Object.prototype.toString.call(d) === \"[object RegExp]\";\n}\nfunction isMap(d) {\n  return Object.prototype.toString.call(d) === \"[object Map]\";\n}\nfunction isDate(d) {\n  return isObjectLike(d) && Object.prototype.toString.call(d) === \"[object Date]\";\n}\nfunction isObjectLike(candidate) {\n  return typeof candidate === \"object\" && candidate !== null;\n}\nfunction deprecate(fn, message) {\n  var warned = false;\n  function deprecated() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    if (!warned) {\n      console.warn(message);\n      warned = true;\n    }\n    return fn.apply(this, args);\n  }\n  return deprecated;\n}\nfunction ensureBuffer(potentialBuffer) {\n  if (ArrayBuffer.isView(potentialBuffer)) {\n    return buffer_1.from(potentialBuffer.buffer, potentialBuffer.byteOffset, potentialBuffer.byteLength);\n  }\n  if (isAnyArrayBuffer(potentialBuffer)) {\n    return buffer_1.from(potentialBuffer);\n  }\n  throw new BSONTypeError(\"Must use either Buffer or TypedArray\");\n}\nvar VALIDATION_REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|[0-9a-f]{12}4[0-9a-f]{3}[89ab][0-9a-f]{15})$/i;\nvar uuidValidateString = function(str) {\n  return typeof str === \"string\" && VALIDATION_REGEX.test(str);\n};\nvar uuidHexStringToBuffer = function(hexString) {\n  if (!uuidValidateString(hexString)) {\n    throw new BSONTypeError('UUID string representations must be a 32 or 36 character hex string (dashes excluded/included). Format: \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\" or \"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\".');\n  }\n  var sanitizedHexString = hexString.replace(/-/g, \"\");\n  return buffer_1.from(sanitizedHexString, \"hex\");\n};\nvar bufferToUuidHexString = function(buffer2, includeDashes) {\n  if (includeDashes === void 0) {\n    includeDashes = true;\n  }\n  return includeDashes ? buffer2.toString(\"hex\", 0, 4) + \"-\" + buffer2.toString(\"hex\", 4, 6) + \"-\" + buffer2.toString(\"hex\", 6, 8) + \"-\" + buffer2.toString(\"hex\", 8, 10) + \"-\" + buffer2.toString(\"hex\", 10, 16) : buffer2.toString(\"hex\");\n};\nvar BSON_INT32_MAX$1 = 2147483647;\nvar BSON_INT32_MIN$1 = -2147483648;\nvar BSON_INT64_MAX$1 = Math.pow(2, 63) - 1;\nvar BSON_INT64_MIN$1 = -Math.pow(2, 63);\nvar JS_INT_MAX = Math.pow(2, 53);\nvar JS_INT_MIN = -Math.pow(2, 53);\nvar BSON_DATA_NUMBER = 1;\nvar BSON_DATA_STRING = 2;\nvar BSON_DATA_OBJECT = 3;\nvar BSON_DATA_ARRAY = 4;\nvar BSON_DATA_BINARY = 5;\nvar BSON_DATA_UNDEFINED = 6;\nvar BSON_DATA_OID = 7;\nvar BSON_DATA_BOOLEAN = 8;\nvar BSON_DATA_DATE = 9;\nvar BSON_DATA_NULL = 10;\nvar BSON_DATA_REGEXP = 11;\nvar BSON_DATA_DBPOINTER = 12;\nvar BSON_DATA_CODE = 13;\nvar BSON_DATA_SYMBOL = 14;\nvar BSON_DATA_CODE_W_SCOPE = 15;\nvar BSON_DATA_INT = 16;\nvar BSON_DATA_TIMESTAMP = 17;\nvar BSON_DATA_LONG = 18;\nvar BSON_DATA_DECIMAL128 = 19;\nvar BSON_DATA_MIN_KEY = 255;\nvar BSON_DATA_MAX_KEY = 127;\nvar BSON_BINARY_SUBTYPE_DEFAULT = 0;\nvar BSON_BINARY_SUBTYPE_FUNCTION = 1;\nvar BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;\nvar BSON_BINARY_SUBTYPE_UUID = 3;\nvar BSON_BINARY_SUBTYPE_UUID_NEW = 4;\nvar BSON_BINARY_SUBTYPE_MD5 = 5;\nvar BSON_BINARY_SUBTYPE_ENCRYPTED = 6;\nvar BSON_BINARY_SUBTYPE_COLUMN = 7;\nvar BSON_BINARY_SUBTYPE_USER_DEFINED = 128;\nvar Binary = (\n  /** @class */\n  function() {\n    function Binary2(buffer2, subType) {\n      if (!(this instanceof Binary2))\n        return new Binary2(buffer2, subType);\n      if (!(buffer2 == null) && !(typeof buffer2 === \"string\") && !ArrayBuffer.isView(buffer2) && !(buffer2 instanceof ArrayBuffer) && !Array.isArray(buffer2)) {\n        throw new BSONTypeError(\"Binary can only be constructed from string, Buffer, TypedArray, or Array<number>\");\n      }\n      this.sub_type = subType !== null && subType !== void 0 ? subType : Binary2.BSON_BINARY_SUBTYPE_DEFAULT;\n      if (buffer2 == null) {\n        this.buffer = buffer_1.alloc(Binary2.BUFFER_SIZE);\n        this.position = 0;\n      } else {\n        if (typeof buffer2 === \"string\") {\n          this.buffer = buffer_1.from(buffer2, \"binary\");\n        } else if (Array.isArray(buffer2)) {\n          this.buffer = buffer_1.from(buffer2);\n        } else {\n          this.buffer = ensureBuffer(buffer2);\n        }\n        this.position = this.buffer.byteLength;\n      }\n    }\n    Binary2.prototype.put = function(byteValue) {\n      if (typeof byteValue === \"string\" && byteValue.length !== 1) {\n        throw new BSONTypeError(\"only accepts single character String\");\n      } else if (typeof byteValue !== \"number\" && byteValue.length !== 1)\n        throw new BSONTypeError(\"only accepts single character Uint8Array or Array\");\n      var decodedByte;\n      if (typeof byteValue === \"string\") {\n        decodedByte = byteValue.charCodeAt(0);\n      } else if (typeof byteValue === \"number\") {\n        decodedByte = byteValue;\n      } else {\n        decodedByte = byteValue[0];\n      }\n      if (decodedByte < 0 || decodedByte > 255) {\n        throw new BSONTypeError(\"only accepts number in a valid unsigned byte range 0-255\");\n      }\n      if (this.buffer.length > this.position) {\n        this.buffer[this.position++] = decodedByte;\n      } else {\n        var buffer2 = buffer_1.alloc(Binary2.BUFFER_SIZE + this.buffer.length);\n        this.buffer.copy(buffer2, 0, 0, this.buffer.length);\n        this.buffer = buffer2;\n        this.buffer[this.position++] = decodedByte;\n      }\n    };\n    Binary2.prototype.write = function(sequence, offset) {\n      offset = typeof offset === \"number\" ? offset : this.position;\n      if (this.buffer.length < offset + sequence.length) {\n        var buffer2 = buffer_1.alloc(this.buffer.length + sequence.length);\n        this.buffer.copy(buffer2, 0, 0, this.buffer.length);\n        this.buffer = buffer2;\n      }\n      if (ArrayBuffer.isView(sequence)) {\n        this.buffer.set(ensureBuffer(sequence), offset);\n        this.position = offset + sequence.byteLength > this.position ? offset + sequence.length : this.position;\n      } else if (typeof sequence === \"string\") {\n        this.buffer.write(sequence, offset, sequence.length, \"binary\");\n        this.position = offset + sequence.length > this.position ? offset + sequence.length : this.position;\n      }\n    };\n    Binary2.prototype.read = function(position, length) {\n      length = length && length > 0 ? length : this.position;\n      return this.buffer.slice(position, position + length);\n    };\n    Binary2.prototype.value = function(asRaw) {\n      asRaw = !!asRaw;\n      if (asRaw && this.buffer.length === this.position) {\n        return this.buffer;\n      }\n      if (asRaw) {\n        return this.buffer.slice(0, this.position);\n      }\n      return this.buffer.toString(\"binary\", 0, this.position);\n    };\n    Binary2.prototype.length = function() {\n      return this.position;\n    };\n    Binary2.prototype.toJSON = function() {\n      return this.buffer.toString(\"base64\");\n    };\n    Binary2.prototype.toString = function(format) {\n      return this.buffer.toString(format);\n    };\n    Binary2.prototype.toExtendedJSON = function(options) {\n      options = options || {};\n      var base64String = this.buffer.toString(\"base64\");\n      var subType = Number(this.sub_type).toString(16);\n      if (options.legacy) {\n        return {\n          $binary: base64String,\n          $type: subType.length === 1 ? \"0\" + subType : subType\n        };\n      }\n      return {\n        $binary: {\n          base64: base64String,\n          subType: subType.length === 1 ? \"0\" + subType : subType\n        }\n      };\n    };\n    Binary2.prototype.toUUID = function() {\n      if (this.sub_type === Binary2.SUBTYPE_UUID) {\n        return new UUID(this.buffer.slice(0, this.position));\n      }\n      throw new BSONError('Binary sub_type \"'.concat(this.sub_type, '\" is not supported for converting to UUID. Only \"').concat(Binary2.SUBTYPE_UUID, '\" is currently supported.'));\n    };\n    Binary2.fromExtendedJSON = function(doc, options) {\n      options = options || {};\n      var data;\n      var type;\n      if (\"$binary\" in doc) {\n        if (options.legacy && typeof doc.$binary === \"string\" && \"$type\" in doc) {\n          type = doc.$type ? parseInt(doc.$type, 16) : 0;\n          data = buffer_1.from(doc.$binary, \"base64\");\n        } else {\n          if (typeof doc.$binary !== \"string\") {\n            type = doc.$binary.subType ? parseInt(doc.$binary.subType, 16) : 0;\n            data = buffer_1.from(doc.$binary.base64, \"base64\");\n          }\n        }\n      } else if (\"$uuid\" in doc) {\n        type = 4;\n        data = uuidHexStringToBuffer(doc.$uuid);\n      }\n      if (!data) {\n        throw new BSONTypeError(\"Unexpected Binary Extended JSON format \".concat(JSON.stringify(doc)));\n      }\n      return type === BSON_BINARY_SUBTYPE_UUID_NEW ? new UUID(data) : new Binary2(data, type);\n    };\n    Binary2.prototype[Symbol.for(\"nodejs.util.inspect.custom\")] = function() {\n      return this.inspect();\n    };\n    Binary2.prototype.inspect = function() {\n      var asBuffer = this.value(true);\n      return 'new Binary(Buffer.from(\"'.concat(asBuffer.toString(\"hex\"), '\", \"hex\"), ').concat(this.sub_type, \")\");\n    };\n    Binary2.BSON_BINARY_SUBTYPE_DEFAULT = 0;\n    Binary2.BUFFER_SIZE = 256;\n    Binary2.SUBTYPE_DEFAULT = 0;\n    Binary2.SUBTYPE_FUNCTION = 1;\n    Binary2.SUBTYPE_BYTE_ARRAY = 2;\n    Binary2.SUBTYPE_UUID_OLD = 3;\n    Binary2.SUBTYPE_UUID = 4;\n    Binary2.SUBTYPE_MD5 = 5;\n    Binary2.SUBTYPE_ENCRYPTED = 6;\n    Binary2.SUBTYPE_COLUMN = 7;\n    Binary2.SUBTYPE_USER_DEFINED = 128;\n    return Binary2;\n  }()\n);\nObject.defineProperty(Binary.prototype, \"_bsontype\", { value: \"Binary\" });\nvar UUID_BYTE_LENGTH = 16;\nvar UUID = (\n  /** @class */\n  function(_super) {\n    __extends(UUID2, _super);\n    function UUID2(input) {\n      var _this = this;\n      var bytes;\n      var hexStr;\n      if (input == null) {\n        bytes = UUID2.generate();\n      } else if (input instanceof UUID2) {\n        bytes = buffer_1.from(input.buffer);\n        hexStr = input.__id;\n      } else if (ArrayBuffer.isView(input) && input.byteLength === UUID_BYTE_LENGTH) {\n        bytes = ensureBuffer(input);\n      } else if (typeof input === \"string\") {\n        bytes = uuidHexStringToBuffer(input);\n      } else {\n        throw new BSONTypeError(\"Argument passed in UUID constructor must be a UUID, a 16 byte Buffer or a 32/36 character hex string (dashes excluded/included, format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx).\");\n      }\n      _this = _super.call(this, bytes, BSON_BINARY_SUBTYPE_UUID_NEW) || this;\n      _this.__id = hexStr;\n      return _this;\n    }\n    Object.defineProperty(UUID2.prototype, \"id\", {\n      /**\n       * The UUID bytes\n       * @readonly\n       */\n      get: function() {\n        return this.buffer;\n      },\n      set: function(value) {\n        this.buffer = value;\n        if (UUID2.cacheHexString) {\n          this.__id = bufferToUuidHexString(value);\n        }\n      },\n      enumerable: false,\n      configurable: true\n    });\n    UUID2.prototype.toHexString = function(includeDashes) {\n      if (includeDashes === void 0) {\n        includeDashes = true;\n      }\n      if (UUID2.cacheHexString && this.__id) {\n        return this.__id;\n      }\n      var uuidHexString = bufferToUuidHexString(this.id, includeDashes);\n      if (UUID2.cacheHexString) {\n        this.__id = uuidHexString;\n      }\n      return uuidHexString;\n    };\n    UUID2.prototype.toString = function(encoding) {\n      return encoding ? this.id.toString(encoding) : this.toHexString();\n    };\n    UUID2.prototype.toJSON = function() {\n      return this.toHexString();\n    };\n    UUID2.prototype.equals = function(otherId) {\n      if (!otherId) {\n        return false;\n      }\n      if (otherId instanceof UUID2) {\n        return otherId.id.equals(this.id);\n      }\n      try {\n        return new UUID2(otherId).id.equals(this.id);\n      } catch (_a) {\n        return false;\n      }\n    };\n    UUID2.prototype.toBinary = function() {\n      return new Binary(this.id, Binary.SUBTYPE_UUID);\n    };\n    UUID2.generate = function() {\n      var bytes = randomBytes(UUID_BYTE_LENGTH);\n      bytes[6] = bytes[6] & 15 | 64;\n      bytes[8] = bytes[8] & 63 | 128;\n      return buffer_1.from(bytes);\n    };\n    UUID2.isValid = function(input) {\n      if (!input) {\n        return false;\n      }\n      if (input instanceof UUID2) {\n        return true;\n      }\n      if (typeof input === \"string\") {\n        return uuidValidateString(input);\n      }\n      if (isUint8Array(input)) {\n        if (input.length !== UUID_BYTE_LENGTH) {\n          return false;\n        }\n        return (input[6] & 240) === 64 && (input[8] & 128) === 128;\n      }\n      return false;\n    };\n    UUID2.createFromHexString = function(hexString) {\n      var buffer2 = uuidHexStringToBuffer(hexString);\n      return new UUID2(buffer2);\n    };\n    UUID2.prototype[Symbol.for(\"nodejs.util.inspect.custom\")] = function() {\n      return this.inspect();\n    };\n    UUID2.prototype.inspect = function() {\n      return 'new UUID(\"'.concat(this.toHexString(), '\")');\n    };\n    return UUID2;\n  }(Binary)\n);\nvar Code = (\n  /** @class */\n  function() {\n    function Code2(code2, scope) {\n      if (!(this instanceof Code2))\n        return new Code2(code2, scope);\n      this.code = code2;\n      this.scope = scope;\n    }\n    Code2.prototype.toJSON = function() {\n      return { code: this.code, scope: this.scope };\n    };\n    Code2.prototype.toExtendedJSON = function() {\n      if (this.scope) {\n        return { $code: this.code, $scope: this.scope };\n      }\n      return { $code: this.code };\n    };\n    Code2.fromExtendedJSON = function(doc) {\n      return new Code2(doc.$code, doc.$scope);\n    };\n    Code2.prototype[Symbol.for(\"nodejs.util.inspect.custom\")] = function() {\n      return this.inspect();\n    };\n    Code2.prototype.inspect = function() {\n      var codeJson = this.toJSON();\n      return 'new Code(\"'.concat(String(codeJson.code), '\"').concat(codeJson.scope ? \", \".concat(JSON.stringify(codeJson.scope)) : \"\", \")\");\n    };\n    return Code2;\n  }()\n);\nObject.defineProperty(Code.prototype, \"_bsontype\", { value: \"Code\" });\nfunction isDBRefLike(value) {\n  return isObjectLike(value) && value.$id != null && typeof value.$ref === \"string\" && (value.$db == null || typeof value.$db === \"string\");\n}\nvar DBRef = (\n  /** @class */\n  function() {\n    function DBRef2(collection, oid, db, fields) {\n      if (!(this instanceof DBRef2))\n        return new DBRef2(collection, oid, db, fields);\n      var parts = collection.split(\".\");\n      if (parts.length === 2) {\n        db = parts.shift();\n        collection = parts.shift();\n      }\n      this.collection = collection;\n      this.oid = oid;\n      this.db = db;\n      this.fields = fields || {};\n    }\n    Object.defineProperty(DBRef2.prototype, \"namespace\", {\n      // Property provided for compatibility with the 1.x parser\n      // the 1.x parser used a \"namespace\" property, while 4.x uses \"collection\"\n      /** @internal */\n      get: function() {\n        return this.collection;\n      },\n      set: function(value) {\n        this.collection = value;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    DBRef2.prototype.toJSON = function() {\n      var o = Object.assign({\n        $ref: this.collection,\n        $id: this.oid\n      }, this.fields);\n      if (this.db != null)\n        o.$db = this.db;\n      return o;\n    };\n    DBRef2.prototype.toExtendedJSON = function(options) {\n      options = options || {};\n      var o = {\n        $ref: this.collection,\n        $id: this.oid\n      };\n      if (options.legacy) {\n        return o;\n      }\n      if (this.db)\n        o.$db = this.db;\n      o = Object.assign(o, this.fields);\n      return o;\n    };\n    DBRef2.fromExtendedJSON = function(doc) {\n      var copy = Object.assign({}, doc);\n      delete copy.$ref;\n      delete copy.$id;\n      delete copy.$db;\n      return new DBRef2(doc.$ref, doc.$id, doc.$db, copy);\n    };\n    DBRef2.prototype[Symbol.for(\"nodejs.util.inspect.custom\")] = function() {\n      return this.inspect();\n    };\n    DBRef2.prototype.inspect = function() {\n      var oid = this.oid === void 0 || this.oid.toString === void 0 ? this.oid : this.oid.toString();\n      return 'new DBRef(\"'.concat(this.namespace, '\", new ObjectId(\"').concat(String(oid), '\")').concat(this.db ? ', \"'.concat(this.db, '\"') : \"\", \")\");\n    };\n    return DBRef2;\n  }()\n);\nObject.defineProperty(DBRef.prototype, \"_bsontype\", { value: \"DBRef\" });\nvar wasm = void 0;\ntry {\n  wasm = new WebAssembly.Instance(new WebAssembly.Module(\n    // prettier-ignore\n    new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])\n  ), {}).exports;\n} catch (_a) {\n}\nvar TWO_PWR_16_DBL = 1 << 16;\nvar TWO_PWR_24_DBL = 1 << 24;\nvar TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\nvar TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\nvar TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\nvar INT_CACHE = {};\nvar UINT_CACHE = {};\nvar Long = (\n  /** @class */\n  function() {\n    function Long2(low, high, unsigned) {\n      if (low === void 0) {\n        low = 0;\n      }\n      if (!(this instanceof Long2))\n        return new Long2(low, high, unsigned);\n      if (typeof low === \"bigint\") {\n        Object.assign(this, Long2.fromBigInt(low, !!high));\n      } else if (typeof low === \"string\") {\n        Object.assign(this, Long2.fromString(low, !!high));\n      } else {\n        this.low = low | 0;\n        this.high = high | 0;\n        this.unsigned = !!unsigned;\n      }\n      Object.defineProperty(this, \"__isLong__\", {\n        value: true,\n        configurable: false,\n        writable: false,\n        enumerable: false\n      });\n    }\n    Long2.fromBits = function(lowBits, highBits, unsigned) {\n      return new Long2(lowBits, highBits, unsigned);\n    };\n    Long2.fromInt = function(value, unsigned) {\n      var obj, cachedObj, cache;\n      if (unsigned) {\n        value >>>= 0;\n        if (cache = 0 <= value && value < 256) {\n          cachedObj = UINT_CACHE[value];\n          if (cachedObj)\n            return cachedObj;\n        }\n        obj = Long2.fromBits(value, (value | 0) < 0 ? -1 : 0, true);\n        if (cache)\n          UINT_CACHE[value] = obj;\n        return obj;\n      } else {\n        value |= 0;\n        if (cache = -128 <= value && value < 128) {\n          cachedObj = INT_CACHE[value];\n          if (cachedObj)\n            return cachedObj;\n        }\n        obj = Long2.fromBits(value, value < 0 ? -1 : 0, false);\n        if (cache)\n          INT_CACHE[value] = obj;\n        return obj;\n      }\n    };\n    Long2.fromNumber = function(value, unsigned) {\n      if (isNaN(value))\n        return unsigned ? Long2.UZERO : Long2.ZERO;\n      if (unsigned) {\n        if (value < 0)\n          return Long2.UZERO;\n        if (value >= TWO_PWR_64_DBL)\n          return Long2.MAX_UNSIGNED_VALUE;\n      } else {\n        if (value <= -TWO_PWR_63_DBL)\n          return Long2.MIN_VALUE;\n        if (value + 1 >= TWO_PWR_63_DBL)\n          return Long2.MAX_VALUE;\n      }\n      if (value < 0)\n        return Long2.fromNumber(-value, unsigned).neg();\n      return Long2.fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);\n    };\n    Long2.fromBigInt = function(value, unsigned) {\n      return Long2.fromString(value.toString(), unsigned);\n    };\n    Long2.fromString = function(str, unsigned, radix) {\n      if (str.length === 0)\n        throw Error(\"empty string\");\n      if (str === \"NaN\" || str === \"Infinity\" || str === \"+Infinity\" || str === \"-Infinity\")\n        return Long2.ZERO;\n      if (typeof unsigned === \"number\") {\n        radix = unsigned, unsigned = false;\n      } else {\n        unsigned = !!unsigned;\n      }\n      radix = radix || 10;\n      if (radix < 2 || 36 < radix)\n        throw RangeError(\"radix\");\n      var p;\n      if ((p = str.indexOf(\"-\")) > 0)\n        throw Error(\"interior hyphen\");\n      else if (p === 0) {\n        return Long2.fromString(str.substring(1), unsigned, radix).neg();\n      }\n      var radixToPower = Long2.fromNumber(Math.pow(radix, 8));\n      var result = Long2.ZERO;\n      for (var i = 0; i < str.length; i += 8) {\n        var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);\n        if (size < 8) {\n          var power = Long2.fromNumber(Math.pow(radix, size));\n          result = result.mul(power).add(Long2.fromNumber(value));\n        } else {\n          result = result.mul(radixToPower);\n          result = result.add(Long2.fromNumber(value));\n        }\n      }\n      result.unsigned = unsigned;\n      return result;\n    };\n    Long2.fromBytes = function(bytes, unsigned, le) {\n      return le ? Long2.fromBytesLE(bytes, unsigned) : Long2.fromBytesBE(bytes, unsigned);\n    };\n    Long2.fromBytesLE = function(bytes, unsigned) {\n      return new Long2(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);\n    };\n    Long2.fromBytesBE = function(bytes, unsigned) {\n      return new Long2(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);\n    };\n    Long2.isLong = function(value) {\n      return isObjectLike(value) && value[\"__isLong__\"] === true;\n    };\n    Long2.fromValue = function(val, unsigned) {\n      if (typeof val === \"number\")\n        return Long2.fromNumber(val, unsigned);\n      if (typeof val === \"string\")\n        return Long2.fromString(val, unsigned);\n      return Long2.fromBits(val.low, val.high, typeof unsigned === \"boolean\" ? unsigned : val.unsigned);\n    };\n    Long2.prototype.add = function(addend) {\n      if (!Long2.isLong(addend))\n        addend = Long2.fromValue(addend);\n      var a48 = this.high >>> 16;\n      var a32 = this.high & 65535;\n      var a16 = this.low >>> 16;\n      var a00 = this.low & 65535;\n      var b48 = addend.high >>> 16;\n      var b32 = addend.high & 65535;\n      var b16 = addend.low >>> 16;\n      var b00 = addend.low & 65535;\n      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n      c00 += a00 + b00;\n      c16 += c00 >>> 16;\n      c00 &= 65535;\n      c16 += a16 + b16;\n      c32 += c16 >>> 16;\n      c16 &= 65535;\n      c32 += a32 + b32;\n      c48 += c32 >>> 16;\n      c32 &= 65535;\n      c48 += a48 + b48;\n      c48 &= 65535;\n      return Long2.fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);\n    };\n    Long2.prototype.and = function(other) {\n      if (!Long2.isLong(other))\n        other = Long2.fromValue(other);\n      return Long2.fromBits(this.low & other.low, this.high & other.high, this.unsigned);\n    };\n    Long2.prototype.compare = function(other) {\n      if (!Long2.isLong(other))\n        other = Long2.fromValue(other);\n      if (this.eq(other))\n        return 0;\n      var thisNeg = this.isNegative(), otherNeg = other.isNegative();\n      if (thisNeg && !otherNeg)\n        return -1;\n      if (!thisNeg && otherNeg)\n        return 1;\n      if (!this.unsigned)\n        return this.sub(other).isNegative() ? -1 : 1;\n      return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;\n    };\n    Long2.prototype.comp = function(other) {\n      return this.compare(other);\n    };\n    Long2.prototype.divide = function(divisor) {\n      if (!Long2.isLong(divisor))\n        divisor = Long2.fromValue(divisor);\n      if (divisor.isZero())\n        throw Error(\"division by zero\");\n      if (wasm) {\n        if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {\n          return this;\n        }\n        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(this.low, this.high, divisor.low, divisor.high);\n        return Long2.fromBits(low, wasm.get_high(), this.unsigned);\n      }\n      if (this.isZero())\n        return this.unsigned ? Long2.UZERO : Long2.ZERO;\n      var approx, rem, res;\n      if (!this.unsigned) {\n        if (this.eq(Long2.MIN_VALUE)) {\n          if (divisor.eq(Long2.ONE) || divisor.eq(Long2.NEG_ONE))\n            return Long2.MIN_VALUE;\n          else if (divisor.eq(Long2.MIN_VALUE))\n            return Long2.ONE;\n          else {\n            var halfThis = this.shr(1);\n            approx = halfThis.div(divisor).shl(1);\n            if (approx.eq(Long2.ZERO)) {\n              return divisor.isNegative() ? Long2.ONE : Long2.NEG_ONE;\n            } else {\n              rem = this.sub(divisor.mul(approx));\n              res = approx.add(rem.div(divisor));\n              return res;\n            }\n          }\n        } else if (divisor.eq(Long2.MIN_VALUE))\n          return this.unsigned ? Long2.UZERO : Long2.ZERO;\n        if (this.isNegative()) {\n          if (divisor.isNegative())\n            return this.neg().div(divisor.neg());\n          return this.neg().div(divisor).neg();\n        } else if (divisor.isNegative())\n          return this.div(divisor.neg()).neg();\n        res = Long2.ZERO;\n      } else {\n        if (!divisor.unsigned)\n          divisor = divisor.toUnsigned();\n        if (divisor.gt(this))\n          return Long2.UZERO;\n        if (divisor.gt(this.shru(1)))\n          return Long2.UONE;\n        res = Long2.UZERO;\n      }\n      rem = this;\n      while (rem.gte(divisor)) {\n        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));\n        var log2 = Math.ceil(Math.log(approx) / Math.LN2);\n        var delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);\n        var approxRes = Long2.fromNumber(approx);\n        var approxRem = approxRes.mul(divisor);\n        while (approxRem.isNegative() || approxRem.gt(rem)) {\n          approx -= delta;\n          approxRes = Long2.fromNumber(approx, this.unsigned);\n          approxRem = approxRes.mul(divisor);\n        }\n        if (approxRes.isZero())\n          approxRes = Long2.ONE;\n        res = res.add(approxRes);\n        rem = rem.sub(approxRem);\n      }\n      return res;\n    };\n    Long2.prototype.div = function(divisor) {\n      return this.divide(divisor);\n    };\n    Long2.prototype.equals = function(other) {\n      if (!Long2.isLong(other))\n        other = Long2.fromValue(other);\n      if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)\n        return false;\n      return this.high === other.high && this.low === other.low;\n    };\n    Long2.prototype.eq = function(other) {\n      return this.equals(other);\n    };\n    Long2.prototype.getHighBits = function() {\n      return this.high;\n    };\n    Long2.prototype.getHighBitsUnsigned = function() {\n      return this.high >>> 0;\n    };\n    Long2.prototype.getLowBits = function() {\n      return this.low;\n    };\n    Long2.prototype.getLowBitsUnsigned = function() {\n      return this.low >>> 0;\n    };\n    Long2.prototype.getNumBitsAbs = function() {\n      if (this.isNegative()) {\n        return this.eq(Long2.MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\n      }\n      var val = this.high !== 0 ? this.high : this.low;\n      var bit;\n      for (bit = 31; bit > 0; bit--)\n        if ((val & 1 << bit) !== 0)\n          break;\n      return this.high !== 0 ? bit + 33 : bit + 1;\n    };\n    Long2.prototype.greaterThan = function(other) {\n      return this.comp(other) > 0;\n    };\n    Long2.prototype.gt = function(other) {\n      return this.greaterThan(other);\n    };\n    Long2.prototype.greaterThanOrEqual = function(other) {\n      return this.comp(other) >= 0;\n    };\n    Long2.prototype.gte = function(other) {\n      return this.greaterThanOrEqual(other);\n    };\n    Long2.prototype.ge = function(other) {\n      return this.greaterThanOrEqual(other);\n    };\n    Long2.prototype.isEven = function() {\n      return (this.low & 1) === 0;\n    };\n    Long2.prototype.isNegative = function() {\n      return !this.unsigned && this.high < 0;\n    };\n    Long2.prototype.isOdd = function() {\n      return (this.low & 1) === 1;\n    };\n    Long2.prototype.isPositive = function() {\n      return this.unsigned || this.high >= 0;\n    };\n    Long2.prototype.isZero = function() {\n      return this.high === 0 && this.low === 0;\n    };\n    Long2.prototype.lessThan = function(other) {\n      return this.comp(other) < 0;\n    };\n    Long2.prototype.lt = function(other) {\n      return this.lessThan(other);\n    };\n    Long2.prototype.lessThanOrEqual = function(other) {\n      return this.comp(other) <= 0;\n    };\n    Long2.prototype.lte = function(other) {\n      return this.lessThanOrEqual(other);\n    };\n    Long2.prototype.modulo = function(divisor) {\n      if (!Long2.isLong(divisor))\n        divisor = Long2.fromValue(divisor);\n      if (wasm) {\n        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(this.low, this.high, divisor.low, divisor.high);\n        return Long2.fromBits(low, wasm.get_high(), this.unsigned);\n      }\n      return this.sub(this.div(divisor).mul(divisor));\n    };\n    Long2.prototype.mod = function(divisor) {\n      return this.modulo(divisor);\n    };\n    Long2.prototype.rem = function(divisor) {\n      return this.modulo(divisor);\n    };\n    Long2.prototype.multiply = function(multiplier) {\n      if (this.isZero())\n        return Long2.ZERO;\n      if (!Long2.isLong(multiplier))\n        multiplier = Long2.fromValue(multiplier);\n      if (wasm) {\n        var low = wasm.mul(this.low, this.high, multiplier.low, multiplier.high);\n        return Long2.fromBits(low, wasm.get_high(), this.unsigned);\n      }\n      if (multiplier.isZero())\n        return Long2.ZERO;\n      if (this.eq(Long2.MIN_VALUE))\n        return multiplier.isOdd() ? Long2.MIN_VALUE : Long2.ZERO;\n      if (multiplier.eq(Long2.MIN_VALUE))\n        return this.isOdd() ? Long2.MIN_VALUE : Long2.ZERO;\n      if (this.isNegative()) {\n        if (multiplier.isNegative())\n          return this.neg().mul(multiplier.neg());\n        else\n          return this.neg().mul(multiplier).neg();\n      } else if (multiplier.isNegative())\n        return this.mul(multiplier.neg()).neg();\n      if (this.lt(Long2.TWO_PWR_24) && multiplier.lt(Long2.TWO_PWR_24))\n        return Long2.fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);\n      var a48 = this.high >>> 16;\n      var a32 = this.high & 65535;\n      var a16 = this.low >>> 16;\n      var a00 = this.low & 65535;\n      var b48 = multiplier.high >>> 16;\n      var b32 = multiplier.high & 65535;\n      var b16 = multiplier.low >>> 16;\n      var b00 = multiplier.low & 65535;\n      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n      c00 += a00 * b00;\n      c16 += c00 >>> 16;\n      c00 &= 65535;\n      c16 += a16 * b00;\n      c32 += c16 >>> 16;\n      c16 &= 65535;\n      c16 += a00 * b16;\n      c32 += c16 >>> 16;\n      c16 &= 65535;\n      c32 += a32 * b00;\n      c48 += c32 >>> 16;\n      c32 &= 65535;\n      c32 += a16 * b16;\n      c48 += c32 >>> 16;\n      c32 &= 65535;\n      c32 += a00 * b32;\n      c48 += c32 >>> 16;\n      c32 &= 65535;\n      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n      c48 &= 65535;\n      return Long2.fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);\n    };\n    Long2.prototype.mul = function(multiplier) {\n      return this.multiply(multiplier);\n    };\n    Long2.prototype.negate = function() {\n      if (!this.unsigned && this.eq(Long2.MIN_VALUE))\n        return Long2.MIN_VALUE;\n      return this.not().add(Long2.ONE);\n    };\n    Long2.prototype.neg = function() {\n      return this.negate();\n    };\n    Long2.prototype.not = function() {\n      return Long2.fromBits(~this.low, ~this.high, this.unsigned);\n    };\n    Long2.prototype.notEquals = function(other) {\n      return !this.equals(other);\n    };\n    Long2.prototype.neq = function(other) {\n      return this.notEquals(other);\n    };\n    Long2.prototype.ne = function(other) {\n      return this.notEquals(other);\n    };\n    Long2.prototype.or = function(other) {\n      if (!Long2.isLong(other))\n        other = Long2.fromValue(other);\n      return Long2.fromBits(this.low | other.low, this.high | other.high, this.unsigned);\n    };\n    Long2.prototype.shiftLeft = function(numBits) {\n      if (Long2.isLong(numBits))\n        numBits = numBits.toInt();\n      if ((numBits &= 63) === 0)\n        return this;\n      else if (numBits < 32)\n        return Long2.fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);\n      else\n        return Long2.fromBits(0, this.low << numBits - 32, this.unsigned);\n    };\n    Long2.prototype.shl = function(numBits) {\n      return this.shiftLeft(numBits);\n    };\n    Long2.prototype.shiftRight = function(numBits) {\n      if (Long2.isLong(numBits))\n        numBits = numBits.toInt();\n      if ((numBits &= 63) === 0)\n        return this;\n      else if (numBits < 32)\n        return Long2.fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);\n      else\n        return Long2.fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);\n    };\n    Long2.prototype.shr = function(numBits) {\n      return this.shiftRight(numBits);\n    };\n    Long2.prototype.shiftRightUnsigned = function(numBits) {\n      if (Long2.isLong(numBits))\n        numBits = numBits.toInt();\n      numBits &= 63;\n      if (numBits === 0)\n        return this;\n      else {\n        var high = this.high;\n        if (numBits < 32) {\n          var low = this.low;\n          return Long2.fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);\n        } else if (numBits === 32)\n          return Long2.fromBits(high, 0, this.unsigned);\n        else\n          return Long2.fromBits(high >>> numBits - 32, 0, this.unsigned);\n      }\n    };\n    Long2.prototype.shr_u = function(numBits) {\n      return this.shiftRightUnsigned(numBits);\n    };\n    Long2.prototype.shru = function(numBits) {\n      return this.shiftRightUnsigned(numBits);\n    };\n    Long2.prototype.subtract = function(subtrahend) {\n      if (!Long2.isLong(subtrahend))\n        subtrahend = Long2.fromValue(subtrahend);\n      return this.add(subtrahend.neg());\n    };\n    Long2.prototype.sub = function(subtrahend) {\n      return this.subtract(subtrahend);\n    };\n    Long2.prototype.toInt = function() {\n      return this.unsigned ? this.low >>> 0 : this.low;\n    };\n    Long2.prototype.toNumber = function() {\n      if (this.unsigned)\n        return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);\n      return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\n    };\n    Long2.prototype.toBigInt = function() {\n      return BigInt(this.toString());\n    };\n    Long2.prototype.toBytes = function(le) {\n      return le ? this.toBytesLE() : this.toBytesBE();\n    };\n    Long2.prototype.toBytesLE = function() {\n      var hi = this.high, lo = this.low;\n      return [\n        lo & 255,\n        lo >>> 8 & 255,\n        lo >>> 16 & 255,\n        lo >>> 24,\n        hi & 255,\n        hi >>> 8 & 255,\n        hi >>> 16 & 255,\n        hi >>> 24\n      ];\n    };\n    Long2.prototype.toBytesBE = function() {\n      var hi = this.high, lo = this.low;\n      return [\n        hi >>> 24,\n        hi >>> 16 & 255,\n        hi >>> 8 & 255,\n        hi & 255,\n        lo >>> 24,\n        lo >>> 16 & 255,\n        lo >>> 8 & 255,\n        lo & 255\n      ];\n    };\n    Long2.prototype.toSigned = function() {\n      if (!this.unsigned)\n        return this;\n      return Long2.fromBits(this.low, this.high, false);\n    };\n    Long2.prototype.toString = function(radix) {\n      radix = radix || 10;\n      if (radix < 2 || 36 < radix)\n        throw RangeError(\"radix\");\n      if (this.isZero())\n        return \"0\";\n      if (this.isNegative()) {\n        if (this.eq(Long2.MIN_VALUE)) {\n          var radixLong = Long2.fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);\n          return div.toString(radix) + rem1.toInt().toString(radix);\n        } else\n          return \"-\" + this.neg().toString(radix);\n      }\n      var radixToPower = Long2.fromNumber(Math.pow(radix, 6), this.unsigned);\n      var rem = this;\n      var result = \"\";\n      while (true) {\n        var remDiv = rem.div(radixToPower);\n        var intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0;\n        var digits = intval.toString(radix);\n        rem = remDiv;\n        if (rem.isZero()) {\n          return digits + result;\n        } else {\n          while (digits.length < 6)\n            digits = \"0\" + digits;\n          result = \"\" + digits + result;\n        }\n      }\n    };\n    Long2.prototype.toUnsigned = function() {\n      if (this.unsigned)\n        return this;\n      return Long2.fromBits(this.low, this.high, true);\n    };\n    Long2.prototype.xor = function(other) {\n      if (!Long2.isLong(other))\n        other = Long2.fromValue(other);\n      return Long2.fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\n    };\n    Long2.prototype.eqz = function() {\n      return this.isZero();\n    };\n    Long2.prototype.le = function(other) {\n      return this.lessThanOrEqual(other);\n    };\n    Long2.prototype.toExtendedJSON = function(options) {\n      if (options && options.relaxed)\n        return this.toNumber();\n      return { $numberLong: this.toString() };\n    };\n    Long2.fromExtendedJSON = function(doc, options) {\n      var result = Long2.fromString(doc.$numberLong);\n      return options && options.relaxed ? result.toNumber() : result;\n    };\n    Long2.prototype[Symbol.for(\"nodejs.util.inspect.custom\")] = function() {\n      return this.inspect();\n    };\n    Long2.prototype.inspect = function() {\n      return 'new Long(\"'.concat(this.toString(), '\"').concat(this.unsigned ? \", true\" : \"\", \")\");\n    };\n    Long2.TWO_PWR_24 = Long2.fromInt(TWO_PWR_24_DBL);\n    Long2.MAX_UNSIGNED_VALUE = Long2.fromBits(4294967295 | 0, 4294967295 | 0, true);\n    Long2.ZERO = Long2.fromInt(0);\n    Long2.UZERO = Long2.fromInt(0, true);\n    Long2.ONE = Long2.fromInt(1);\n    Long2.UONE = Long2.fromInt(1, true);\n    Long2.NEG_ONE = Long2.fromInt(-1);\n    Long2.MAX_VALUE = Long2.fromBits(4294967295 | 0, 2147483647 | 0, false);\n    Long2.MIN_VALUE = Long2.fromBits(0, 2147483648 | 0, false);\n    return Long2;\n  }()\n);\nObject.defineProperty(Long.prototype, \"__isLong__\", { value: true });\nObject.defineProperty(Long.prototype, \"_bsontype\", { value: \"Long\" });\nvar PARSE_STRING_REGEXP = /^(\\+|-)?(\\d+|(\\d*\\.\\d*))?(E|e)?([-+])?(\\d+)?$/;\nvar PARSE_INF_REGEXP = /^(\\+|-)?(Infinity|inf)$/i;\nvar PARSE_NAN_REGEXP = /^(\\+|-)?NaN$/i;\nvar EXPONENT_MAX = 6111;\nvar EXPONENT_MIN = -6176;\nvar EXPONENT_BIAS = 6176;\nvar MAX_DIGITS = 34;\nvar NAN_BUFFER = [\n  124,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0\n].reverse();\nvar INF_NEGATIVE_BUFFER = [\n  248,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0\n].reverse();\nvar INF_POSITIVE_BUFFER = [\n  120,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0\n].reverse();\nvar EXPONENT_REGEX = /^([-+])?(\\d+)?$/;\nvar COMBINATION_MASK = 31;\nvar EXPONENT_MASK = 16383;\nvar COMBINATION_INFINITY = 30;\nvar COMBINATION_NAN = 31;\nfunction isDigit(value) {\n  return !isNaN(parseInt(value, 10));\n}\nfunction divideu128(value) {\n  var DIVISOR = Long.fromNumber(1e3 * 1e3 * 1e3);\n  var _rem = Long.fromNumber(0);\n  if (!value.parts[0] && !value.parts[1] && !value.parts[2] && !value.parts[3]) {\n    return { quotient: value, rem: _rem };\n  }\n  for (var i = 0; i <= 3; i++) {\n    _rem = _rem.shiftLeft(32);\n    _rem = _rem.add(new Long(value.parts[i], 0));\n    value.parts[i] = _rem.div(DIVISOR).low;\n    _rem = _rem.modulo(DIVISOR);\n  }\n  return { quotient: value, rem: _rem };\n}\nfunction multiply64x2(left, right) {\n  if (!left && !right) {\n    return { high: Long.fromNumber(0), low: Long.fromNumber(0) };\n  }\n  var leftHigh = left.shiftRightUnsigned(32);\n  var leftLow = new Long(left.getLowBits(), 0);\n  var rightHigh = right.shiftRightUnsigned(32);\n  var rightLow = new Long(right.getLowBits(), 0);\n  var productHigh = leftHigh.multiply(rightHigh);\n  var productMid = leftHigh.multiply(rightLow);\n  var productMid2 = leftLow.multiply(rightHigh);\n  var productLow = leftLow.multiply(rightLow);\n  productHigh = productHigh.add(productMid.shiftRightUnsigned(32));\n  productMid = new Long(productMid.getLowBits(), 0).add(productMid2).add(productLow.shiftRightUnsigned(32));\n  productHigh = productHigh.add(productMid.shiftRightUnsigned(32));\n  productLow = productMid.shiftLeft(32).add(new Long(productLow.getLowBits(), 0));\n  return { high: productHigh, low: productLow };\n}\nfunction lessThan(left, right) {\n  var uhleft = left.high >>> 0;\n  var uhright = right.high >>> 0;\n  if (uhleft < uhright) {\n    return true;\n  } else if (uhleft === uhright) {\n    var ulleft = left.low >>> 0;\n    var ulright = right.low >>> 0;\n    if (ulleft < ulright)\n      return true;\n  }\n  return false;\n}\nfunction invalidErr(string, message) {\n  throw new BSONTypeError('\"'.concat(string, '\" is not a valid Decimal128 string - ').concat(message));\n}\nvar Decimal128 = (\n  /** @class */\n  function() {\n    function Decimal1282(bytes) {\n      if (!(this instanceof Decimal1282))\n        return new Decimal1282(bytes);\n      if (typeof bytes === \"string\") {\n        this.bytes = Decimal1282.fromString(bytes).bytes;\n      } else if (isUint8Array(bytes)) {\n        if (bytes.byteLength !== 16) {\n          throw new BSONTypeError(\"Decimal128 must take a Buffer of 16 bytes\");\n        }\n        this.bytes = bytes;\n      } else {\n        throw new BSONTypeError(\"Decimal128 must take a Buffer or string\");\n      }\n    }\n    Decimal1282.fromString = function(representation) {\n      var isNegative = false;\n      var sawRadix = false;\n      var foundNonZero = false;\n      var significantDigits = 0;\n      var nDigitsRead = 0;\n      var nDigits = 0;\n      var radixPosition = 0;\n      var firstNonZero = 0;\n      var digits = [0];\n      var nDigitsStored = 0;\n      var digitsInsert = 0;\n      var firstDigit = 0;\n      var lastDigit = 0;\n      var exponent = 0;\n      var i = 0;\n      var significandHigh = new Long(0, 0);\n      var significandLow = new Long(0, 0);\n      var biasedExponent = 0;\n      var index = 0;\n      if (representation.length >= 7e3) {\n        throw new BSONTypeError(\"\" + representation + \" not a valid Decimal128 string\");\n      }\n      var stringMatch = representation.match(PARSE_STRING_REGEXP);\n      var infMatch = representation.match(PARSE_INF_REGEXP);\n      var nanMatch = representation.match(PARSE_NAN_REGEXP);\n      if (!stringMatch && !infMatch && !nanMatch || representation.length === 0) {\n        throw new BSONTypeError(\"\" + representation + \" not a valid Decimal128 string\");\n      }\n      if (stringMatch) {\n        var unsignedNumber = stringMatch[2];\n        var e = stringMatch[4];\n        var expSign = stringMatch[5];\n        var expNumber = stringMatch[6];\n        if (e && expNumber === void 0)\n          invalidErr(representation, \"missing exponent power\");\n        if (e && unsignedNumber === void 0)\n          invalidErr(representation, \"missing exponent base\");\n        if (e === void 0 && (expSign || expNumber)) {\n          invalidErr(representation, \"missing e before exponent\");\n        }\n      }\n      if (representation[index] === \"+\" || representation[index] === \"-\") {\n        isNegative = representation[index++] === \"-\";\n      }\n      if (!isDigit(representation[index]) && representation[index] !== \".\") {\n        if (representation[index] === \"i\" || representation[index] === \"I\") {\n          return new Decimal1282(buffer_1.from(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER));\n        } else if (representation[index] === \"N\") {\n          return new Decimal1282(buffer_1.from(NAN_BUFFER));\n        }\n      }\n      while (isDigit(representation[index]) || representation[index] === \".\") {\n        if (representation[index] === \".\") {\n          if (sawRadix)\n            invalidErr(representation, \"contains multiple periods\");\n          sawRadix = true;\n          index = index + 1;\n          continue;\n        }\n        if (nDigitsStored < 34) {\n          if (representation[index] !== \"0\" || foundNonZero) {\n            if (!foundNonZero) {\n              firstNonZero = nDigitsRead;\n            }\n            foundNonZero = true;\n            digits[digitsInsert++] = parseInt(representation[index], 10);\n            nDigitsStored = nDigitsStored + 1;\n          }\n        }\n        if (foundNonZero)\n          nDigits = nDigits + 1;\n        if (sawRadix)\n          radixPosition = radixPosition + 1;\n        nDigitsRead = nDigitsRead + 1;\n        index = index + 1;\n      }\n      if (sawRadix && !nDigitsRead)\n        throw new BSONTypeError(\"\" + representation + \" not a valid Decimal128 string\");\n      if (representation[index] === \"e\" || representation[index] === \"E\") {\n        var match = representation.substr(++index).match(EXPONENT_REGEX);\n        if (!match || !match[2])\n          return new Decimal1282(buffer_1.from(NAN_BUFFER));\n        exponent = parseInt(match[0], 10);\n        index = index + match[0].length;\n      }\n      if (representation[index])\n        return new Decimal1282(buffer_1.from(NAN_BUFFER));\n      firstDigit = 0;\n      if (!nDigitsStored) {\n        firstDigit = 0;\n        lastDigit = 0;\n        digits[0] = 0;\n        nDigits = 1;\n        nDigitsStored = 1;\n        significantDigits = 0;\n      } else {\n        lastDigit = nDigitsStored - 1;\n        significantDigits = nDigits;\n        if (significantDigits !== 1) {\n          while (digits[firstNonZero + significantDigits - 1] === 0) {\n            significantDigits = significantDigits - 1;\n          }\n        }\n      }\n      if (exponent <= radixPosition && radixPosition - exponent > 1 << 14) {\n        exponent = EXPONENT_MIN;\n      } else {\n        exponent = exponent - radixPosition;\n      }\n      while (exponent > EXPONENT_MAX) {\n        lastDigit = lastDigit + 1;\n        if (lastDigit - firstDigit > MAX_DIGITS) {\n          var digitsString = digits.join(\"\");\n          if (digitsString.match(/^0+$/)) {\n            exponent = EXPONENT_MAX;\n            break;\n          }\n          invalidErr(representation, \"overflow\");\n        }\n        exponent = exponent - 1;\n      }\n      while (exponent < EXPONENT_MIN || nDigitsStored < nDigits) {\n        if (lastDigit === 0 && significantDigits < nDigitsStored) {\n          exponent = EXPONENT_MIN;\n          significantDigits = 0;\n          break;\n        }\n        if (nDigitsStored < nDigits) {\n          nDigits = nDigits - 1;\n        } else {\n          lastDigit = lastDigit - 1;\n        }\n        if (exponent < EXPONENT_MAX) {\n          exponent = exponent + 1;\n        } else {\n          var digitsString = digits.join(\"\");\n          if (digitsString.match(/^0+$/)) {\n            exponent = EXPONENT_MAX;\n            break;\n          }\n          invalidErr(representation, \"overflow\");\n        }\n      }\n      if (lastDigit - firstDigit + 1 < significantDigits) {\n        var endOfString = nDigitsRead;\n        if (sawRadix) {\n          firstNonZero = firstNonZero + 1;\n          endOfString = endOfString + 1;\n        }\n        if (isNegative) {\n          firstNonZero = firstNonZero + 1;\n          endOfString = endOfString + 1;\n        }\n        var roundDigit = parseInt(representation[firstNonZero + lastDigit + 1], 10);\n        var roundBit = 0;\n        if (roundDigit >= 5) {\n          roundBit = 1;\n          if (roundDigit === 5) {\n            roundBit = digits[lastDigit] % 2 === 1 ? 1 : 0;\n            for (i = firstNonZero + lastDigit + 2; i < endOfString; i++) {\n              if (parseInt(representation[i], 10)) {\n                roundBit = 1;\n                break;\n              }\n            }\n          }\n        }\n        if (roundBit) {\n          var dIdx = lastDigit;\n          for (; dIdx >= 0; dIdx--) {\n            if (++digits[dIdx] > 9) {\n              digits[dIdx] = 0;\n              if (dIdx === 0) {\n                if (exponent < EXPONENT_MAX) {\n                  exponent = exponent + 1;\n                  digits[dIdx] = 1;\n                } else {\n                  return new Decimal1282(buffer_1.from(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER));\n                }\n              }\n            }\n          }\n        }\n      }\n      significandHigh = Long.fromNumber(0);\n      significandLow = Long.fromNumber(0);\n      if (significantDigits === 0) {\n        significandHigh = Long.fromNumber(0);\n        significandLow = Long.fromNumber(0);\n      } else if (lastDigit - firstDigit < 17) {\n        var dIdx = firstDigit;\n        significandLow = Long.fromNumber(digits[dIdx++]);\n        significandHigh = new Long(0, 0);\n        for (; dIdx <= lastDigit; dIdx++) {\n          significandLow = significandLow.multiply(Long.fromNumber(10));\n          significandLow = significandLow.add(Long.fromNumber(digits[dIdx]));\n        }\n      } else {\n        var dIdx = firstDigit;\n        significandHigh = Long.fromNumber(digits[dIdx++]);\n        for (; dIdx <= lastDigit - 17; dIdx++) {\n          significandHigh = significandHigh.multiply(Long.fromNumber(10));\n          significandHigh = significandHigh.add(Long.fromNumber(digits[dIdx]));\n        }\n        significandLow = Long.fromNumber(digits[dIdx++]);\n        for (; dIdx <= lastDigit; dIdx++) {\n          significandLow = significandLow.multiply(Long.fromNumber(10));\n          significandLow = significandLow.add(Long.fromNumber(digits[dIdx]));\n        }\n      }\n      var significand = multiply64x2(significandHigh, Long.fromString(\"100000000000000000\"));\n      significand.low = significand.low.add(significandLow);\n      if (lessThan(significand.low, significandLow)) {\n        significand.high = significand.high.add(Long.fromNumber(1));\n      }\n      biasedExponent = exponent + EXPONENT_BIAS;\n      var dec = { low: Long.fromNumber(0), high: Long.fromNumber(0) };\n      if (significand.high.shiftRightUnsigned(49).and(Long.fromNumber(1)).equals(Long.fromNumber(1))) {\n        dec.high = dec.high.or(Long.fromNumber(3).shiftLeft(61));\n        dec.high = dec.high.or(Long.fromNumber(biasedExponent).and(Long.fromNumber(16383).shiftLeft(47)));\n        dec.high = dec.high.or(significand.high.and(Long.fromNumber(140737488355327)));\n      } else {\n        dec.high = dec.high.or(Long.fromNumber(biasedExponent & 16383).shiftLeft(49));\n        dec.high = dec.high.or(significand.high.and(Long.fromNumber(562949953421311)));\n      }\n      dec.low = significand.low;\n      if (isNegative) {\n        dec.high = dec.high.or(Long.fromString(\"9223372036854775808\"));\n      }\n      var buffer2 = buffer_1.alloc(16);\n      index = 0;\n      buffer2[index++] = dec.low.low & 255;\n      buffer2[index++] = dec.low.low >> 8 & 255;\n      buffer2[index++] = dec.low.low >> 16 & 255;\n      buffer2[index++] = dec.low.low >> 24 & 255;\n      buffer2[index++] = dec.low.high & 255;\n      buffer2[index++] = dec.low.high >> 8 & 255;\n      buffer2[index++] = dec.low.high >> 16 & 255;\n      buffer2[index++] = dec.low.high >> 24 & 255;\n      buffer2[index++] = dec.high.low & 255;\n      buffer2[index++] = dec.high.low >> 8 & 255;\n      buffer2[index++] = dec.high.low >> 16 & 255;\n      buffer2[index++] = dec.high.low >> 24 & 255;\n      buffer2[index++] = dec.high.high & 255;\n      buffer2[index++] = dec.high.high >> 8 & 255;\n      buffer2[index++] = dec.high.high >> 16 & 255;\n      buffer2[index++] = dec.high.high >> 24 & 255;\n      return new Decimal1282(buffer2);\n    };\n    Decimal1282.prototype.toString = function() {\n      var biased_exponent;\n      var significand_digits = 0;\n      var significand = new Array(36);\n      for (var i = 0; i < significand.length; i++)\n        significand[i] = 0;\n      var index = 0;\n      var is_zero = false;\n      var significand_msb;\n      var significand128 = { parts: [0, 0, 0, 0] };\n      var j, k;\n      var string = [];\n      index = 0;\n      var buffer2 = this.bytes;\n      var low = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;\n      var midl = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;\n      var midh = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;\n      var high = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;\n      index = 0;\n      var dec = {\n        low: new Long(low, midl),\n        high: new Long(midh, high)\n      };\n      if (dec.high.lessThan(Long.ZERO)) {\n        string.push(\"-\");\n      }\n      var combination = high >> 26 & COMBINATION_MASK;\n      if (combination >> 3 === 3) {\n        if (combination === COMBINATION_INFINITY) {\n          return string.join(\"\") + \"Infinity\";\n        } else if (combination === COMBINATION_NAN) {\n          return \"NaN\";\n        } else {\n          biased_exponent = high >> 15 & EXPONENT_MASK;\n          significand_msb = 8 + (high >> 14 & 1);\n        }\n      } else {\n        significand_msb = high >> 14 & 7;\n        biased_exponent = high >> 17 & EXPONENT_MASK;\n      }\n      var exponent = biased_exponent - EXPONENT_BIAS;\n      significand128.parts[0] = (high & 16383) + ((significand_msb & 15) << 14);\n      significand128.parts[1] = midh;\n      significand128.parts[2] = midl;\n      significand128.parts[3] = low;\n      if (significand128.parts[0] === 0 && significand128.parts[1] === 0 && significand128.parts[2] === 0 && significand128.parts[3] === 0) {\n        is_zero = true;\n      } else {\n        for (k = 3; k >= 0; k--) {\n          var least_digits = 0;\n          var result = divideu128(significand128);\n          significand128 = result.quotient;\n          least_digits = result.rem.low;\n          if (!least_digits)\n            continue;\n          for (j = 8; j >= 0; j--) {\n            significand[k * 9 + j] = least_digits % 10;\n            least_digits = Math.floor(least_digits / 10);\n          }\n        }\n      }\n      if (is_zero) {\n        significand_digits = 1;\n        significand[index] = 0;\n      } else {\n        significand_digits = 36;\n        while (!significand[index]) {\n          significand_digits = significand_digits - 1;\n          index = index + 1;\n        }\n      }\n      var scientific_exponent = significand_digits - 1 + exponent;\n      if (scientific_exponent >= 34 || scientific_exponent <= -7 || exponent > 0) {\n        if (significand_digits > 34) {\n          string.push(\"\".concat(0));\n          if (exponent > 0)\n            string.push(\"E+\".concat(exponent));\n          else if (exponent < 0)\n            string.push(\"E\".concat(exponent));\n          return string.join(\"\");\n        }\n        string.push(\"\".concat(significand[index++]));\n        significand_digits = significand_digits - 1;\n        if (significand_digits) {\n          string.push(\".\");\n        }\n        for (var i = 0; i < significand_digits; i++) {\n          string.push(\"\".concat(significand[index++]));\n        }\n        string.push(\"E\");\n        if (scientific_exponent > 0) {\n          string.push(\"+\".concat(scientific_exponent));\n        } else {\n          string.push(\"\".concat(scientific_exponent));\n        }\n      } else {\n        if (exponent >= 0) {\n          for (var i = 0; i < significand_digits; i++) {\n            string.push(\"\".concat(significand[index++]));\n          }\n        } else {\n          var radix_position = significand_digits + exponent;\n          if (radix_position > 0) {\n            for (var i = 0; i < radix_position; i++) {\n              string.push(\"\".concat(significand[index++]));\n            }\n          } else {\n            string.push(\"0\");\n          }\n          string.push(\".\");\n          while (radix_position++ < 0) {\n            string.push(\"0\");\n          }\n          for (var i = 0; i < significand_digits - Math.max(radix_position - 1, 0); i++) {\n            string.push(\"\".concat(significand[index++]));\n          }\n        }\n      }\n      return string.join(\"\");\n    };\n    Decimal1282.prototype.toJSON = function() {\n      return { $numberDecimal: this.toString() };\n    };\n    Decimal1282.prototype.toExtendedJSON = function() {\n      return { $numberDecimal: this.toString() };\n    };\n    Decimal1282.fromExtendedJSON = function(doc) {\n      return Decimal1282.fromString(doc.$numberDecimal);\n    };\n    Decimal1282.prototype[Symbol.for(\"nodejs.util.inspect.custom\")] = function() {\n      return this.inspect();\n    };\n    Decimal1282.prototype.inspect = function() {\n      return 'new Decimal128(\"'.concat(this.toString(), '\")');\n    };\n    return Decimal1282;\n  }()\n);\nObject.defineProperty(Decimal128.prototype, \"_bsontype\", { value: \"Decimal128\" });\nvar Double = (\n  /** @class */\n  function() {\n    function Double2(value) {\n      if (!(this instanceof Double2))\n        return new Double2(value);\n      if (value instanceof Number) {\n        value = value.valueOf();\n      }\n      this.value = +value;\n    }\n    Double2.prototype.valueOf = function() {\n      return this.value;\n    };\n    Double2.prototype.toJSON = function() {\n      return this.value;\n    };\n    Double2.prototype.toString = function(radix) {\n      return this.value.toString(radix);\n    };\n    Double2.prototype.toExtendedJSON = function(options) {\n      if (options && (options.legacy || options.relaxed && isFinite(this.value))) {\n        return this.value;\n      }\n      if (Object.is(Math.sign(this.value), -0)) {\n        return { $numberDouble: \"-\".concat(this.value.toFixed(1)) };\n      }\n      return {\n        $numberDouble: Number.isInteger(this.value) ? this.value.toFixed(1) : this.value.toString()\n      };\n    };\n    Double2.fromExtendedJSON = function(doc, options) {\n      var doubleValue = parseFloat(doc.$numberDouble);\n      return options && options.relaxed ? doubleValue : new Double2(doubleValue);\n    };\n    Double2.prototype[Symbol.for(\"nodejs.util.inspect.custom\")] = function() {\n      return this.inspect();\n    };\n    Double2.prototype.inspect = function() {\n      var eJSON = this.toExtendedJSON();\n      return \"new Double(\".concat(eJSON.$numberDouble, \")\");\n    };\n    return Double2;\n  }()\n);\nObject.defineProperty(Double.prototype, \"_bsontype\", { value: \"Double\" });\nvar Int32 = (\n  /** @class */\n  function() {\n    function Int322(value) {\n      if (!(this instanceof Int322))\n        return new Int322(value);\n      if (value instanceof Number) {\n        value = value.valueOf();\n      }\n      this.value = +value | 0;\n    }\n    Int322.prototype.valueOf = function() {\n      return this.value;\n    };\n    Int322.prototype.toString = function(radix) {\n      return this.value.toString(radix);\n    };\n    Int322.prototype.toJSON = function() {\n      return this.value;\n    };\n    Int322.prototype.toExtendedJSON = function(options) {\n      if (options && (options.relaxed || options.legacy))\n        return this.value;\n      return { $numberInt: this.value.toString() };\n    };\n    Int322.fromExtendedJSON = function(doc, options) {\n      return options && options.relaxed ? parseInt(doc.$numberInt, 10) : new Int322(doc.$numberInt);\n    };\n    Int322.prototype[Symbol.for(\"nodejs.util.inspect.custom\")] = function() {\n      return this.inspect();\n    };\n    Int322.prototype.inspect = function() {\n      return \"new Int32(\".concat(this.valueOf(), \")\");\n    };\n    return Int322;\n  }()\n);\nObject.defineProperty(Int32.prototype, \"_bsontype\", { value: \"Int32\" });\nvar MaxKey = (\n  /** @class */\n  function() {\n    function MaxKey2() {\n      if (!(this instanceof MaxKey2))\n        return new MaxKey2();\n    }\n    MaxKey2.prototype.toExtendedJSON = function() {\n      return { $maxKey: 1 };\n    };\n    MaxKey2.fromExtendedJSON = function() {\n      return new MaxKey2();\n    };\n    MaxKey2.prototype[Symbol.for(\"nodejs.util.inspect.custom\")] = function() {\n      return this.inspect();\n    };\n    MaxKey2.prototype.inspect = function() {\n      return \"new MaxKey()\";\n    };\n    return MaxKey2;\n  }()\n);\nObject.defineProperty(MaxKey.prototype, \"_bsontype\", { value: \"MaxKey\" });\nvar MinKey = (\n  /** @class */\n  function() {\n    function MinKey2() {\n      if (!(this instanceof MinKey2))\n        return new MinKey2();\n    }\n    MinKey2.prototype.toExtendedJSON = function() {\n      return { $minKey: 1 };\n    };\n    MinKey2.fromExtendedJSON = function() {\n      return new MinKey2();\n    };\n    MinKey2.prototype[Symbol.for(\"nodejs.util.inspect.custom\")] = function() {\n      return this.inspect();\n    };\n    MinKey2.prototype.inspect = function() {\n      return \"new MinKey()\";\n    };\n    return MinKey2;\n  }()\n);\nObject.defineProperty(MinKey.prototype, \"_bsontype\", { value: \"MinKey\" });\nvar checkForHexRegExp = new RegExp(\"^[0-9a-fA-F]{24}$\");\nvar PROCESS_UNIQUE = null;\nvar kId = Symbol(\"id\");\nvar ObjectId = (\n  /** @class */\n  function() {\n    function ObjectId2(inputId) {\n      if (!(this instanceof ObjectId2))\n        return new ObjectId2(inputId);\n      var workingId;\n      if (typeof inputId === \"object\" && inputId && \"id\" in inputId) {\n        if (typeof inputId.id !== \"string\" && !ArrayBuffer.isView(inputId.id)) {\n          throw new BSONTypeError(\"Argument passed in must have an id that is of type string or Buffer\");\n        }\n        if (\"toHexString\" in inputId && typeof inputId.toHexString === \"function\") {\n          workingId = buffer_1.from(inputId.toHexString(), \"hex\");\n        } else {\n          workingId = inputId.id;\n        }\n      } else {\n        workingId = inputId;\n      }\n      if (workingId == null || typeof workingId === \"number\") {\n        this[kId] = ObjectId2.generate(typeof workingId === \"number\" ? workingId : void 0);\n      } else if (ArrayBuffer.isView(workingId) && workingId.byteLength === 12) {\n        this[kId] = workingId instanceof buffer_1 ? workingId : ensureBuffer(workingId);\n      } else if (typeof workingId === \"string\") {\n        if (workingId.length === 12) {\n          var bytes = buffer_1.from(workingId);\n          if (bytes.byteLength === 12) {\n            this[kId] = bytes;\n          } else {\n            throw new BSONTypeError(\"Argument passed in must be a string of 12 bytes\");\n          }\n        } else if (workingId.length === 24 && checkForHexRegExp.test(workingId)) {\n          this[kId] = buffer_1.from(workingId, \"hex\");\n        } else {\n          throw new BSONTypeError(\"Argument passed in must be a string of 12 bytes or a string of 24 hex characters or an integer\");\n        }\n      } else {\n        throw new BSONTypeError(\"Argument passed in does not match the accepted types\");\n      }\n      if (ObjectId2.cacheHexString) {\n        this.__id = this.id.toString(\"hex\");\n      }\n    }\n    Object.defineProperty(ObjectId2.prototype, \"id\", {\n      /**\n       * The ObjectId bytes\n       * @readonly\n       */\n      get: function() {\n        return this[kId];\n      },\n      set: function(value) {\n        this[kId] = value;\n        if (ObjectId2.cacheHexString) {\n          this.__id = value.toString(\"hex\");\n        }\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(ObjectId2.prototype, \"generationTime\", {\n      /**\n       * The generation time of this ObjectId instance\n       * @deprecated Please use getTimestamp / createFromTime which returns an int32 epoch\n       */\n      get: function() {\n        return this.id.readInt32BE(0);\n      },\n      set: function(value) {\n        this.id.writeUInt32BE(value, 0);\n      },\n      enumerable: false,\n      configurable: true\n    });\n    ObjectId2.prototype.toHexString = function() {\n      if (ObjectId2.cacheHexString && this.__id) {\n        return this.__id;\n      }\n      var hexString = this.id.toString(\"hex\");\n      if (ObjectId2.cacheHexString && !this.__id) {\n        this.__id = hexString;\n      }\n      return hexString;\n    };\n    ObjectId2.getInc = function() {\n      return ObjectId2.index = (ObjectId2.index + 1) % 16777215;\n    };\n    ObjectId2.generate = function(time) {\n      if (\"number\" !== typeof time) {\n        time = Math.floor(Date.now() / 1e3);\n      }\n      var inc = ObjectId2.getInc();\n      var buffer2 = buffer_1.alloc(12);\n      buffer2.writeUInt32BE(time, 0);\n      if (PROCESS_UNIQUE === null) {\n        PROCESS_UNIQUE = randomBytes(5);\n      }\n      buffer2[4] = PROCESS_UNIQUE[0];\n      buffer2[5] = PROCESS_UNIQUE[1];\n      buffer2[6] = PROCESS_UNIQUE[2];\n      buffer2[7] = PROCESS_UNIQUE[3];\n      buffer2[8] = PROCESS_UNIQUE[4];\n      buffer2[11] = inc & 255;\n      buffer2[10] = inc >> 8 & 255;\n      buffer2[9] = inc >> 16 & 255;\n      return buffer2;\n    };\n    ObjectId2.prototype.toString = function(format) {\n      if (format)\n        return this.id.toString(format);\n      return this.toHexString();\n    };\n    ObjectId2.prototype.toJSON = function() {\n      return this.toHexString();\n    };\n    ObjectId2.prototype.equals = function(otherId) {\n      if (otherId === void 0 || otherId === null) {\n        return false;\n      }\n      if (otherId instanceof ObjectId2) {\n        return this[kId][11] === otherId[kId][11] && this[kId].equals(otherId[kId]);\n      }\n      if (typeof otherId === \"string\" && ObjectId2.isValid(otherId) && otherId.length === 12 && isUint8Array(this.id)) {\n        return otherId === buffer_1.prototype.toString.call(this.id, \"latin1\");\n      }\n      if (typeof otherId === \"string\" && ObjectId2.isValid(otherId) && otherId.length === 24) {\n        return otherId.toLowerCase() === this.toHexString();\n      }\n      if (typeof otherId === \"string\" && ObjectId2.isValid(otherId) && otherId.length === 12) {\n        return buffer_1.from(otherId).equals(this.id);\n      }\n      if (typeof otherId === \"object\" && \"toHexString\" in otherId && typeof otherId.toHexString === \"function\") {\n        var otherIdString = otherId.toHexString();\n        var thisIdString = this.toHexString().toLowerCase();\n        return typeof otherIdString === \"string\" && otherIdString.toLowerCase() === thisIdString;\n      }\n      return false;\n    };\n    ObjectId2.prototype.getTimestamp = function() {\n      var timestamp = /* @__PURE__ */ new Date();\n      var time = this.id.readUInt32BE(0);\n      timestamp.setTime(Math.floor(time) * 1e3);\n      return timestamp;\n    };\n    ObjectId2.createPk = function() {\n      return new ObjectId2();\n    };\n    ObjectId2.createFromTime = function(time) {\n      var buffer2 = buffer_1.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n      buffer2.writeUInt32BE(time, 0);\n      return new ObjectId2(buffer2);\n    };\n    ObjectId2.createFromHexString = function(hexString) {\n      if (typeof hexString === \"undefined\" || hexString != null && hexString.length !== 24) {\n        throw new BSONTypeError(\"Argument passed in must be a single String of 12 bytes or a string of 24 hex characters\");\n      }\n      return new ObjectId2(buffer_1.from(hexString, \"hex\"));\n    };\n    ObjectId2.isValid = function(id) {\n      if (id == null)\n        return false;\n      try {\n        new ObjectId2(id);\n        return true;\n      } catch (_a) {\n        return false;\n      }\n    };\n    ObjectId2.prototype.toExtendedJSON = function() {\n      if (this.toHexString)\n        return { $oid: this.toHexString() };\n      return { $oid: this.toString(\"hex\") };\n    };\n    ObjectId2.fromExtendedJSON = function(doc) {\n      return new ObjectId2(doc.$oid);\n    };\n    ObjectId2.prototype[Symbol.for(\"nodejs.util.inspect.custom\")] = function() {\n      return this.inspect();\n    };\n    ObjectId2.prototype.inspect = function() {\n      return 'new ObjectId(\"'.concat(this.toHexString(), '\")');\n    };\n    ObjectId2.index = Math.floor(Math.random() * 16777215);\n    return ObjectId2;\n  }()\n);\nObject.defineProperty(ObjectId.prototype, \"generate\", {\n  value: deprecate(function(time) {\n    return ObjectId.generate(time);\n  }, \"Please use the static `ObjectId.generate(time)` instead\")\n});\nObject.defineProperty(ObjectId.prototype, \"getInc\", {\n  value: deprecate(function() {\n    return ObjectId.getInc();\n  }, \"Please use the static `ObjectId.getInc()` instead\")\n});\nObject.defineProperty(ObjectId.prototype, \"get_inc\", {\n  value: deprecate(function() {\n    return ObjectId.getInc();\n  }, \"Please use the static `ObjectId.getInc()` instead\")\n});\nObject.defineProperty(ObjectId, \"get_inc\", {\n  value: deprecate(function() {\n    return ObjectId.getInc();\n  }, \"Please use the static `ObjectId.getInc()` instead\")\n});\nObject.defineProperty(ObjectId.prototype, \"_bsontype\", { value: \"ObjectID\" });\nfunction alphabetize(str) {\n  return str.split(\"\").sort().join(\"\");\n}\nvar BSONRegExp = (\n  /** @class */\n  function() {\n    function BSONRegExp2(pattern, options) {\n      if (!(this instanceof BSONRegExp2))\n        return new BSONRegExp2(pattern, options);\n      this.pattern = pattern;\n      this.options = alphabetize(options !== null && options !== void 0 ? options : \"\");\n      if (this.pattern.indexOf(\"\\0\") !== -1) {\n        throw new BSONError(\"BSON Regex patterns cannot contain null bytes, found: \".concat(JSON.stringify(this.pattern)));\n      }\n      if (this.options.indexOf(\"\\0\") !== -1) {\n        throw new BSONError(\"BSON Regex options cannot contain null bytes, found: \".concat(JSON.stringify(this.options)));\n      }\n      for (var i = 0; i < this.options.length; i++) {\n        if (!(this.options[i] === \"i\" || this.options[i] === \"m\" || this.options[i] === \"x\" || this.options[i] === \"l\" || this.options[i] === \"s\" || this.options[i] === \"u\")) {\n          throw new BSONError(\"The regular expression option [\".concat(this.options[i], \"] is not supported\"));\n        }\n      }\n    }\n    BSONRegExp2.parseOptions = function(options) {\n      return options ? options.split(\"\").sort().join(\"\") : \"\";\n    };\n    BSONRegExp2.prototype.toExtendedJSON = function(options) {\n      options = options || {};\n      if (options.legacy) {\n        return { $regex: this.pattern, $options: this.options };\n      }\n      return { $regularExpression: { pattern: this.pattern, options: this.options } };\n    };\n    BSONRegExp2.fromExtendedJSON = function(doc) {\n      if (\"$regex\" in doc) {\n        if (typeof doc.$regex !== \"string\") {\n          if (doc.$regex._bsontype === \"BSONRegExp\") {\n            return doc;\n          }\n        } else {\n          return new BSONRegExp2(doc.$regex, BSONRegExp2.parseOptions(doc.$options));\n        }\n      }\n      if (\"$regularExpression\" in doc) {\n        return new BSONRegExp2(doc.$regularExpression.pattern, BSONRegExp2.parseOptions(doc.$regularExpression.options));\n      }\n      throw new BSONTypeError(\"Unexpected BSONRegExp EJSON object form: \".concat(JSON.stringify(doc)));\n    };\n    return BSONRegExp2;\n  }()\n);\nObject.defineProperty(BSONRegExp.prototype, \"_bsontype\", { value: \"BSONRegExp\" });\nvar BSONSymbol = (\n  /** @class */\n  function() {\n    function BSONSymbol2(value) {\n      if (!(this instanceof BSONSymbol2))\n        return new BSONSymbol2(value);\n      this.value = value;\n    }\n    BSONSymbol2.prototype.valueOf = function() {\n      return this.value;\n    };\n    BSONSymbol2.prototype.toString = function() {\n      return this.value;\n    };\n    BSONSymbol2.prototype.inspect = function() {\n      return 'new BSONSymbol(\"'.concat(this.value, '\")');\n    };\n    BSONSymbol2.prototype.toJSON = function() {\n      return this.value;\n    };\n    BSONSymbol2.prototype.toExtendedJSON = function() {\n      return { $symbol: this.value };\n    };\n    BSONSymbol2.fromExtendedJSON = function(doc) {\n      return new BSONSymbol2(doc.$symbol);\n    };\n    BSONSymbol2.prototype[Symbol.for(\"nodejs.util.inspect.custom\")] = function() {\n      return this.inspect();\n    };\n    return BSONSymbol2;\n  }()\n);\nObject.defineProperty(BSONSymbol.prototype, \"_bsontype\", { value: \"Symbol\" });\nvar LongWithoutOverridesClass = Long;\nvar Timestamp = (\n  /** @class */\n  function(_super) {\n    __extends(Timestamp2, _super);\n    function Timestamp2(low, high) {\n      var _this = this;\n      if (!(_this instanceof Timestamp2))\n        return new Timestamp2(low, high);\n      if (Long.isLong(low)) {\n        _this = _super.call(this, low.low, low.high, true) || this;\n      } else if (isObjectLike(low) && typeof low.t !== \"undefined\" && typeof low.i !== \"undefined\") {\n        _this = _super.call(this, low.i, low.t, true) || this;\n      } else {\n        _this = _super.call(this, low, high, true) || this;\n      }\n      Object.defineProperty(_this, \"_bsontype\", {\n        value: \"Timestamp\",\n        writable: false,\n        configurable: false,\n        enumerable: false\n      });\n      return _this;\n    }\n    Timestamp2.prototype.toJSON = function() {\n      return {\n        $timestamp: this.toString()\n      };\n    };\n    Timestamp2.fromInt = function(value) {\n      return new Timestamp2(Long.fromInt(value, true));\n    };\n    Timestamp2.fromNumber = function(value) {\n      return new Timestamp2(Long.fromNumber(value, true));\n    };\n    Timestamp2.fromBits = function(lowBits, highBits) {\n      return new Timestamp2(lowBits, highBits);\n    };\n    Timestamp2.fromString = function(str, optRadix) {\n      return new Timestamp2(Long.fromString(str, true, optRadix));\n    };\n    Timestamp2.prototype.toExtendedJSON = function() {\n      return { $timestamp: { t: this.high >>> 0, i: this.low >>> 0 } };\n    };\n    Timestamp2.fromExtendedJSON = function(doc) {\n      return new Timestamp2(doc.$timestamp);\n    };\n    Timestamp2.prototype[Symbol.for(\"nodejs.util.inspect.custom\")] = function() {\n      return this.inspect();\n    };\n    Timestamp2.prototype.inspect = function() {\n      return \"new Timestamp({ t: \".concat(this.getHighBits(), \", i: \").concat(this.getLowBits(), \" })\");\n    };\n    Timestamp2.MAX_VALUE = Long.MAX_UNSIGNED_VALUE;\n    return Timestamp2;\n  }(LongWithoutOverridesClass)\n);\nfunction isBSONType(value) {\n  return isObjectLike(value) && Reflect.has(value, \"_bsontype\") && typeof value._bsontype === \"string\";\n}\nvar BSON_INT32_MAX = 2147483647;\nvar BSON_INT32_MIN = -2147483648;\nvar BSON_INT64_MAX = 9223372036854776e3;\nvar BSON_INT64_MIN = -9223372036854776e3;\nvar keysToCodecs = {\n  $oid: ObjectId,\n  $binary: Binary,\n  $uuid: Binary,\n  $symbol: BSONSymbol,\n  $numberInt: Int32,\n  $numberDecimal: Decimal128,\n  $numberDouble: Double,\n  $numberLong: Long,\n  $minKey: MinKey,\n  $maxKey: MaxKey,\n  $regex: BSONRegExp,\n  $regularExpression: BSONRegExp,\n  $timestamp: Timestamp\n};\nfunction deserializeValue(value, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  if (typeof value === \"number\") {\n    if (options.relaxed || options.legacy) {\n      return value;\n    }\n    if (Math.floor(value) === value) {\n      if (value >= BSON_INT32_MIN && value <= BSON_INT32_MAX)\n        return new Int32(value);\n      if (value >= BSON_INT64_MIN && value <= BSON_INT64_MAX)\n        return Long.fromNumber(value);\n    }\n    return new Double(value);\n  }\n  if (value == null || typeof value !== \"object\")\n    return value;\n  if (value.$undefined)\n    return null;\n  var keys = Object.keys(value).filter(function(k) {\n    return k.startsWith(\"$\") && value[k] != null;\n  });\n  for (var i = 0; i < keys.length; i++) {\n    var c = keysToCodecs[keys[i]];\n    if (c)\n      return c.fromExtendedJSON(value, options);\n  }\n  if (value.$date != null) {\n    var d = value.$date;\n    var date = /* @__PURE__ */ new Date();\n    if (options.legacy) {\n      if (typeof d === \"number\")\n        date.setTime(d);\n      else if (typeof d === \"string\")\n        date.setTime(Date.parse(d));\n    } else {\n      if (typeof d === \"string\")\n        date.setTime(Date.parse(d));\n      else if (Long.isLong(d))\n        date.setTime(d.toNumber());\n      else if (typeof d === \"number\" && options.relaxed)\n        date.setTime(d);\n    }\n    return date;\n  }\n  if (value.$code != null) {\n    var copy = Object.assign({}, value);\n    if (value.$scope) {\n      copy.$scope = deserializeValue(value.$scope);\n    }\n    return Code.fromExtendedJSON(value);\n  }\n  if (isDBRefLike(value) || value.$dbPointer) {\n    var v = value.$ref ? value : value.$dbPointer;\n    if (v instanceof DBRef)\n      return v;\n    var dollarKeys = Object.keys(v).filter(function(k) {\n      return k.startsWith(\"$\");\n    });\n    var valid_1 = true;\n    dollarKeys.forEach(function(k) {\n      if ([\"$ref\", \"$id\", \"$db\"].indexOf(k) === -1)\n        valid_1 = false;\n    });\n    if (valid_1)\n      return DBRef.fromExtendedJSON(v);\n  }\n  return value;\n}\nfunction serializeArray(array, options) {\n  return array.map(function(v, index) {\n    options.seenObjects.push({ propertyName: \"index \".concat(index), obj: null });\n    try {\n      return serializeValue(v, options);\n    } finally {\n      options.seenObjects.pop();\n    }\n  });\n}\nfunction getISOString(date) {\n  var isoStr = date.toISOString();\n  return date.getUTCMilliseconds() !== 0 ? isoStr : isoStr.slice(0, -5) + \"Z\";\n}\nfunction serializeValue(value, options) {\n  if ((typeof value === \"object\" || typeof value === \"function\") && value !== null) {\n    var index = options.seenObjects.findIndex(function(entry) {\n      return entry.obj === value;\n    });\n    if (index !== -1) {\n      var props = options.seenObjects.map(function(entry) {\n        return entry.propertyName;\n      });\n      var leadingPart = props.slice(0, index).map(function(prop) {\n        return \"\".concat(prop, \" -> \");\n      }).join(\"\");\n      var alreadySeen = props[index];\n      var circularPart = \" -> \" + props.slice(index + 1, props.length - 1).map(function(prop) {\n        return \"\".concat(prop, \" -> \");\n      }).join(\"\");\n      var current = props[props.length - 1];\n      var leadingSpace = \" \".repeat(leadingPart.length + alreadySeen.length / 2);\n      var dashes = \"-\".repeat(circularPart.length + (alreadySeen.length + current.length) / 2 - 1);\n      throw new BSONTypeError(\"Converting circular structure to EJSON:\\n\" + \"    \".concat(leadingPart).concat(alreadySeen).concat(circularPart).concat(current, \"\\n\") + \"    \".concat(leadingSpace, \"\\\\\").concat(dashes, \"/\"));\n    }\n    options.seenObjects[options.seenObjects.length - 1].obj = value;\n  }\n  if (Array.isArray(value))\n    return serializeArray(value, options);\n  if (value === void 0)\n    return null;\n  if (value instanceof Date || isDate(value)) {\n    var dateNum = value.getTime(), inRange = dateNum > -1 && dateNum < 2534023188e5;\n    if (options.legacy) {\n      return options.relaxed && inRange ? { $date: value.getTime() } : { $date: getISOString(value) };\n    }\n    return options.relaxed && inRange ? { $date: getISOString(value) } : { $date: { $numberLong: value.getTime().toString() } };\n  }\n  if (typeof value === \"number\" && (!options.relaxed || !isFinite(value))) {\n    if (Math.floor(value) === value) {\n      var int32Range = value >= BSON_INT32_MIN && value <= BSON_INT32_MAX, int64Range = value >= BSON_INT64_MIN && value <= BSON_INT64_MAX;\n      if (int32Range)\n        return { $numberInt: value.toString() };\n      if (int64Range)\n        return { $numberLong: value.toString() };\n    }\n    return { $numberDouble: value.toString() };\n  }\n  if (value instanceof RegExp || isRegExp(value)) {\n    var flags = value.flags;\n    if (flags === void 0) {\n      var match = value.toString().match(/[gimuy]*$/);\n      if (match) {\n        flags = match[0];\n      }\n    }\n    var rx = new BSONRegExp(value.source, flags);\n    return rx.toExtendedJSON(options);\n  }\n  if (value != null && typeof value === \"object\")\n    return serializeDocument(value, options);\n  return value;\n}\nvar BSON_TYPE_MAPPINGS = {\n  Binary: function(o) {\n    return new Binary(o.value(), o.sub_type);\n  },\n  Code: function(o) {\n    return new Code(o.code, o.scope);\n  },\n  DBRef: function(o) {\n    return new DBRef(o.collection || o.namespace, o.oid, o.db, o.fields);\n  },\n  Decimal128: function(o) {\n    return new Decimal128(o.bytes);\n  },\n  Double: function(o) {\n    return new Double(o.value);\n  },\n  Int32: function(o) {\n    return new Int32(o.value);\n  },\n  Long: function(o) {\n    return Long.fromBits(\n      // underscore variants for 1.x backwards compatibility\n      o.low != null ? o.low : o.low_,\n      o.low != null ? o.high : o.high_,\n      o.low != null ? o.unsigned : o.unsigned_\n    );\n  },\n  MaxKey: function() {\n    return new MaxKey();\n  },\n  MinKey: function() {\n    return new MinKey();\n  },\n  ObjectID: function(o) {\n    return new ObjectId(o);\n  },\n  ObjectId: function(o) {\n    return new ObjectId(o);\n  },\n  BSONRegExp: function(o) {\n    return new BSONRegExp(o.pattern, o.options);\n  },\n  Symbol: function(o) {\n    return new BSONSymbol(o.value);\n  },\n  Timestamp: function(o) {\n    return Timestamp.fromBits(o.low, o.high);\n  }\n};\nfunction serializeDocument(doc, options) {\n  if (doc == null || typeof doc !== \"object\")\n    throw new BSONError(\"not an object instance\");\n  var bsontype = doc._bsontype;\n  if (typeof bsontype === \"undefined\") {\n    var _doc = {};\n    for (var name in doc) {\n      options.seenObjects.push({ propertyName: name, obj: null });\n      try {\n        var value = serializeValue(doc[name], options);\n        if (name === \"__proto__\") {\n          Object.defineProperty(_doc, name, {\n            value,\n            writable: true,\n            enumerable: true,\n            configurable: true\n          });\n        } else {\n          _doc[name] = value;\n        }\n      } finally {\n        options.seenObjects.pop();\n      }\n    }\n    return _doc;\n  } else if (isBSONType(doc)) {\n    var outDoc = doc;\n    if (typeof outDoc.toExtendedJSON !== \"function\") {\n      var mapper = BSON_TYPE_MAPPINGS[doc._bsontype];\n      if (!mapper) {\n        throw new BSONTypeError(\"Unrecognized or invalid _bsontype: \" + doc._bsontype);\n      }\n      outDoc = mapper(outDoc);\n    }\n    if (bsontype === \"Code\" && outDoc.scope) {\n      outDoc = new Code(outDoc.code, serializeValue(outDoc.scope, options));\n    } else if (bsontype === \"DBRef\" && outDoc.oid) {\n      outDoc = new DBRef(serializeValue(outDoc.collection, options), serializeValue(outDoc.oid, options), serializeValue(outDoc.db, options), serializeValue(outDoc.fields, options));\n    }\n    return outDoc.toExtendedJSON(options);\n  } else {\n    throw new BSONError(\"_bsontype must be a string, but was: \" + typeof bsontype);\n  }\n}\nvar EJSON;\n(function(EJSON2) {\n  function parse(text, options) {\n    var finalOptions = Object.assign({}, { relaxed: true, legacy: false }, options);\n    if (typeof finalOptions.relaxed === \"boolean\")\n      finalOptions.strict = !finalOptions.relaxed;\n    if (typeof finalOptions.strict === \"boolean\")\n      finalOptions.relaxed = !finalOptions.strict;\n    return JSON.parse(text, function(key, value) {\n      if (key.indexOf(\"\\0\") !== -1) {\n        throw new BSONError(\"BSON Document field names cannot contain null bytes, found: \".concat(JSON.stringify(key)));\n      }\n      return deserializeValue(value, finalOptions);\n    });\n  }\n  EJSON2.parse = parse;\n  function stringify(value, replacer, space, options) {\n    if (space != null && typeof space === \"object\") {\n      options = space;\n      space = 0;\n    }\n    if (replacer != null && typeof replacer === \"object\" && !Array.isArray(replacer)) {\n      options = replacer;\n      replacer = void 0;\n      space = 0;\n    }\n    var serializeOptions = Object.assign({ relaxed: true, legacy: false }, options, {\n      seenObjects: [{ propertyName: \"(root)\", obj: null }]\n    });\n    var doc = serializeValue(value, serializeOptions);\n    return JSON.stringify(doc, replacer, space);\n  }\n  EJSON2.stringify = stringify;\n  function serialize3(value, options) {\n    options = options || {};\n    return JSON.parse(stringify(value, options));\n  }\n  EJSON2.serialize = serialize3;\n  function deserialize3(ejson, options) {\n    options = options || {};\n    return parse(JSON.stringify(ejson), options);\n  }\n  EJSON2.deserialize = deserialize3;\n})(EJSON || (EJSON = {}));\nvar bsonMap;\nvar bsonGlobal = getGlobal();\nif (bsonGlobal.Map) {\n  bsonMap = bsonGlobal.Map;\n} else {\n  bsonMap = /** @class */\n  function() {\n    function Map(array) {\n      if (array === void 0) {\n        array = [];\n      }\n      this._keys = [];\n      this._values = {};\n      for (var i = 0; i < array.length; i++) {\n        if (array[i] == null)\n          continue;\n        var entry = array[i];\n        var key = entry[0];\n        var value = entry[1];\n        this._keys.push(key);\n        this._values[key] = { v: value, i: this._keys.length - 1 };\n      }\n    }\n    Map.prototype.clear = function() {\n      this._keys = [];\n      this._values = {};\n    };\n    Map.prototype.delete = function(key) {\n      var value = this._values[key];\n      if (value == null)\n        return false;\n      delete this._values[key];\n      this._keys.splice(value.i, 1);\n      return true;\n    };\n    Map.prototype.entries = function() {\n      var _this = this;\n      var index = 0;\n      return {\n        next: function() {\n          var key = _this._keys[index++];\n          return {\n            value: key !== void 0 ? [key, _this._values[key].v] : void 0,\n            done: key !== void 0 ? false : true\n          };\n        }\n      };\n    };\n    Map.prototype.forEach = function(callback, self2) {\n      self2 = self2 || this;\n      for (var i = 0; i < this._keys.length; i++) {\n        var key = this._keys[i];\n        callback.call(self2, this._values[key].v, key, self2);\n      }\n    };\n    Map.prototype.get = function(key) {\n      return this._values[key] ? this._values[key].v : void 0;\n    };\n    Map.prototype.has = function(key) {\n      return this._values[key] != null;\n    };\n    Map.prototype.keys = function() {\n      var _this = this;\n      var index = 0;\n      return {\n        next: function() {\n          var key = _this._keys[index++];\n          return {\n            value: key !== void 0 ? key : void 0,\n            done: key !== void 0 ? false : true\n          };\n        }\n      };\n    };\n    Map.prototype.set = function(key, value) {\n      if (this._values[key]) {\n        this._values[key].v = value;\n        return this;\n      }\n      this._keys.push(key);\n      this._values[key] = { v: value, i: this._keys.length - 1 };\n      return this;\n    };\n    Map.prototype.values = function() {\n      var _this = this;\n      var index = 0;\n      return {\n        next: function() {\n          var key = _this._keys[index++];\n          return {\n            value: key !== void 0 ? _this._values[key].v : void 0,\n            done: key !== void 0 ? false : true\n          };\n        }\n      };\n    };\n    Object.defineProperty(Map.prototype, \"size\", {\n      get: function() {\n        return this._keys.length;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    return Map;\n  }();\n}\nfunction calculateObjectSize$1(object, serializeFunctions, ignoreUndefined) {\n  var totalLength = 4 + 1;\n  if (Array.isArray(object)) {\n    for (var i = 0; i < object.length; i++) {\n      totalLength += calculateElement(i.toString(), object[i], serializeFunctions, true, ignoreUndefined);\n    }\n  } else {\n    if (typeof (object === null || object === void 0 ? void 0 : object.toBSON) === \"function\") {\n      object = object.toBSON();\n    }\n    for (var key in object) {\n      totalLength += calculateElement(key, object[key], serializeFunctions, false, ignoreUndefined);\n    }\n  }\n  return totalLength;\n}\nfunction calculateElement(name, value, serializeFunctions, isArray, ignoreUndefined) {\n  if (serializeFunctions === void 0) {\n    serializeFunctions = false;\n  }\n  if (isArray === void 0) {\n    isArray = false;\n  }\n  if (ignoreUndefined === void 0) {\n    ignoreUndefined = false;\n  }\n  if (typeof (value === null || value === void 0 ? void 0 : value.toBSON) === \"function\") {\n    value = value.toBSON();\n  }\n  switch (typeof value) {\n    case \"string\":\n      return 1 + buffer_1.byteLength(name, \"utf8\") + 1 + 4 + buffer_1.byteLength(value, \"utf8\") + 1;\n    case \"number\":\n      if (Math.floor(value) === value && value >= JS_INT_MIN && value <= JS_INT_MAX) {\n        if (value >= BSON_INT32_MIN$1 && value <= BSON_INT32_MAX$1) {\n          return (name != null ? buffer_1.byteLength(name, \"utf8\") + 1 : 0) + (4 + 1);\n        } else {\n          return (name != null ? buffer_1.byteLength(name, \"utf8\") + 1 : 0) + (8 + 1);\n        }\n      } else {\n        return (name != null ? buffer_1.byteLength(name, \"utf8\") + 1 : 0) + (8 + 1);\n      }\n    case \"undefined\":\n      if (isArray || !ignoreUndefined)\n        return (name != null ? buffer_1.byteLength(name, \"utf8\") + 1 : 0) + 1;\n      return 0;\n    case \"boolean\":\n      return (name != null ? buffer_1.byteLength(name, \"utf8\") + 1 : 0) + (1 + 1);\n    case \"object\":\n      if (value == null || value[\"_bsontype\"] === \"MinKey\" || value[\"_bsontype\"] === \"MaxKey\") {\n        return (name != null ? buffer_1.byteLength(name, \"utf8\") + 1 : 0) + 1;\n      } else if (value[\"_bsontype\"] === \"ObjectId\" || value[\"_bsontype\"] === \"ObjectID\") {\n        return (name != null ? buffer_1.byteLength(name, \"utf8\") + 1 : 0) + (12 + 1);\n      } else if (value instanceof Date || isDate(value)) {\n        return (name != null ? buffer_1.byteLength(name, \"utf8\") + 1 : 0) + (8 + 1);\n      } else if (ArrayBuffer.isView(value) || value instanceof ArrayBuffer || isAnyArrayBuffer(value)) {\n        return (name != null ? buffer_1.byteLength(name, \"utf8\") + 1 : 0) + (1 + 4 + 1) + value.byteLength;\n      } else if (value[\"_bsontype\"] === \"Long\" || value[\"_bsontype\"] === \"Double\" || value[\"_bsontype\"] === \"Timestamp\") {\n        return (name != null ? buffer_1.byteLength(name, \"utf8\") + 1 : 0) + (8 + 1);\n      } else if (value[\"_bsontype\"] === \"Decimal128\") {\n        return (name != null ? buffer_1.byteLength(name, \"utf8\") + 1 : 0) + (16 + 1);\n      } else if (value[\"_bsontype\"] === \"Code\") {\n        if (value.scope != null && Object.keys(value.scope).length > 0) {\n          return (name != null ? buffer_1.byteLength(name, \"utf8\") + 1 : 0) + 1 + 4 + 4 + buffer_1.byteLength(value.code.toString(), \"utf8\") + 1 + calculateObjectSize$1(value.scope, serializeFunctions, ignoreUndefined);\n        } else {\n          return (name != null ? buffer_1.byteLength(name, \"utf8\") + 1 : 0) + 1 + 4 + buffer_1.byteLength(value.code.toString(), \"utf8\") + 1;\n        }\n      } else if (value[\"_bsontype\"] === \"Binary\") {\n        var binary = value;\n        if (binary.sub_type === Binary.SUBTYPE_BYTE_ARRAY) {\n          return (name != null ? buffer_1.byteLength(name, \"utf8\") + 1 : 0) + (binary.position + 1 + 4 + 1 + 4);\n        } else {\n          return (name != null ? buffer_1.byteLength(name, \"utf8\") + 1 : 0) + (binary.position + 1 + 4 + 1);\n        }\n      } else if (value[\"_bsontype\"] === \"Symbol\") {\n        return (name != null ? buffer_1.byteLength(name, \"utf8\") + 1 : 0) + buffer_1.byteLength(value.value, \"utf8\") + 4 + 1 + 1;\n      } else if (value[\"_bsontype\"] === \"DBRef\") {\n        var ordered_values = Object.assign({\n          $ref: value.collection,\n          $id: value.oid\n        }, value.fields);\n        if (value.db != null) {\n          ordered_values[\"$db\"] = value.db;\n        }\n        return (name != null ? buffer_1.byteLength(name, \"utf8\") + 1 : 0) + 1 + calculateObjectSize$1(ordered_values, serializeFunctions, ignoreUndefined);\n      } else if (value instanceof RegExp || isRegExp(value)) {\n        return (name != null ? buffer_1.byteLength(name, \"utf8\") + 1 : 0) + 1 + buffer_1.byteLength(value.source, \"utf8\") + 1 + (value.global ? 1 : 0) + (value.ignoreCase ? 1 : 0) + (value.multiline ? 1 : 0) + 1;\n      } else if (value[\"_bsontype\"] === \"BSONRegExp\") {\n        return (name != null ? buffer_1.byteLength(name, \"utf8\") + 1 : 0) + 1 + buffer_1.byteLength(value.pattern, \"utf8\") + 1 + buffer_1.byteLength(value.options, \"utf8\") + 1;\n      } else {\n        return (name != null ? buffer_1.byteLength(name, \"utf8\") + 1 : 0) + calculateObjectSize$1(value, serializeFunctions, ignoreUndefined) + 1;\n      }\n    case \"function\":\n      if (value instanceof RegExp || isRegExp(value) || String.call(value) === \"[object RegExp]\") {\n        return (name != null ? buffer_1.byteLength(name, \"utf8\") + 1 : 0) + 1 + buffer_1.byteLength(value.source, \"utf8\") + 1 + (value.global ? 1 : 0) + (value.ignoreCase ? 1 : 0) + (value.multiline ? 1 : 0) + 1;\n      } else {\n        if (serializeFunctions && value.scope != null && Object.keys(value.scope).length > 0) {\n          return (name != null ? buffer_1.byteLength(name, \"utf8\") + 1 : 0) + 1 + 4 + 4 + buffer_1.byteLength(normalizedFunctionString(value), \"utf8\") + 1 + calculateObjectSize$1(value.scope, serializeFunctions, ignoreUndefined);\n        } else if (serializeFunctions) {\n          return (name != null ? buffer_1.byteLength(name, \"utf8\") + 1 : 0) + 1 + 4 + buffer_1.byteLength(normalizedFunctionString(value), \"utf8\") + 1;\n        }\n      }\n  }\n  return 0;\n}\nvar FIRST_BIT = 128;\nvar FIRST_TWO_BITS = 192;\nvar FIRST_THREE_BITS = 224;\nvar FIRST_FOUR_BITS = 240;\nvar FIRST_FIVE_BITS = 248;\nvar TWO_BIT_CHAR = 192;\nvar THREE_BIT_CHAR = 224;\nvar FOUR_BIT_CHAR = 240;\nvar CONTINUING_CHAR = 128;\nfunction validateUtf8(bytes, start, end) {\n  var continuation = 0;\n  for (var i = start; i < end; i += 1) {\n    var byte = bytes[i];\n    if (continuation) {\n      if ((byte & FIRST_TWO_BITS) !== CONTINUING_CHAR) {\n        return false;\n      }\n      continuation -= 1;\n    } else if (byte & FIRST_BIT) {\n      if ((byte & FIRST_THREE_BITS) === TWO_BIT_CHAR) {\n        continuation = 1;\n      } else if ((byte & FIRST_FOUR_BITS) === THREE_BIT_CHAR) {\n        continuation = 2;\n      } else if ((byte & FIRST_FIVE_BITS) === FOUR_BIT_CHAR) {\n        continuation = 3;\n      } else {\n        return false;\n      }\n    }\n  }\n  return !continuation;\n}\nvar JS_INT_MAX_LONG = Long.fromNumber(JS_INT_MAX);\nvar JS_INT_MIN_LONG = Long.fromNumber(JS_INT_MIN);\nvar functionCache = {};\nfunction deserialize$1(buffer2, options, isArray) {\n  options = options == null ? {} : options;\n  var index = options && options.index ? options.index : 0;\n  var size = buffer2[index] | buffer2[index + 1] << 8 | buffer2[index + 2] << 16 | buffer2[index + 3] << 24;\n  if (size < 5) {\n    throw new BSONError(\"bson size must be >= 5, is \".concat(size));\n  }\n  if (options.allowObjectSmallerThanBufferSize && buffer2.length < size) {\n    throw new BSONError(\"buffer length \".concat(buffer2.length, \" must be >= bson size \").concat(size));\n  }\n  if (!options.allowObjectSmallerThanBufferSize && buffer2.length !== size) {\n    throw new BSONError(\"buffer length \".concat(buffer2.length, \" must === bson size \").concat(size));\n  }\n  if (size + index > buffer2.byteLength) {\n    throw new BSONError(\"(bson size \".concat(size, \" + options.index \").concat(index, \" must be <= buffer length \").concat(buffer2.byteLength, \")\"));\n  }\n  if (buffer2[index + size - 1] !== 0) {\n    throw new BSONError(\"One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00\");\n  }\n  return deserializeObject(buffer2, index, options, isArray);\n}\nvar allowedDBRefKeys = /^\\$ref$|^\\$id$|^\\$db$/;\nfunction deserializeObject(buffer2, index, options, isArray) {\n  if (isArray === void 0) {\n    isArray = false;\n  }\n  var evalFunctions = options[\"evalFunctions\"] == null ? false : options[\"evalFunctions\"];\n  var cacheFunctions = options[\"cacheFunctions\"] == null ? false : options[\"cacheFunctions\"];\n  var fieldsAsRaw = options[\"fieldsAsRaw\"] == null ? null : options[\"fieldsAsRaw\"];\n  var raw = options[\"raw\"] == null ? false : options[\"raw\"];\n  var bsonRegExp = typeof options[\"bsonRegExp\"] === \"boolean\" ? options[\"bsonRegExp\"] : false;\n  var promoteBuffers = options[\"promoteBuffers\"] == null ? false : options[\"promoteBuffers\"];\n  var promoteLongs = options[\"promoteLongs\"] == null ? true : options[\"promoteLongs\"];\n  var promoteValues = options[\"promoteValues\"] == null ? true : options[\"promoteValues\"];\n  var validation = options.validation == null ? { utf8: true } : options.validation;\n  var globalUTFValidation = true;\n  var validationSetting;\n  var utf8KeysSet = /* @__PURE__ */ new Set();\n  var utf8ValidatedKeys = validation.utf8;\n  if (typeof utf8ValidatedKeys === \"boolean\") {\n    validationSetting = utf8ValidatedKeys;\n  } else {\n    globalUTFValidation = false;\n    var utf8ValidationValues = Object.keys(utf8ValidatedKeys).map(function(key2) {\n      return utf8ValidatedKeys[key2];\n    });\n    if (utf8ValidationValues.length === 0) {\n      throw new BSONError(\"UTF-8 validation setting cannot be empty\");\n    }\n    if (typeof utf8ValidationValues[0] !== \"boolean\") {\n      throw new BSONError(\"Invalid UTF-8 validation option, must specify boolean values\");\n    }\n    validationSetting = utf8ValidationValues[0];\n    if (!utf8ValidationValues.every(function(item) {\n      return item === validationSetting;\n    })) {\n      throw new BSONError(\"Invalid UTF-8 validation option - keys must be all true or all false\");\n    }\n  }\n  if (!globalUTFValidation) {\n    for (var _i = 0, _a = Object.keys(utf8ValidatedKeys); _i < _a.length; _i++) {\n      var key = _a[_i];\n      utf8KeysSet.add(key);\n    }\n  }\n  var startIndex = index;\n  if (buffer2.length < 5)\n    throw new BSONError(\"corrupt bson message < 5 bytes long\");\n  var size = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;\n  if (size < 5 || size > buffer2.length)\n    throw new BSONError(\"corrupt bson message\");\n  var object = isArray ? [] : {};\n  var arrayIndex = 0;\n  var done = false;\n  var isPossibleDBRef = isArray ? false : null;\n  var dataview = new DataView(buffer2.buffer, buffer2.byteOffset, buffer2.byteLength);\n  while (!done) {\n    var elementType = buffer2[index++];\n    if (elementType === 0)\n      break;\n    var i = index;\n    while (buffer2[i] !== 0 && i < buffer2.length) {\n      i++;\n    }\n    if (i >= buffer2.byteLength)\n      throw new BSONError(\"Bad BSON Document: illegal CString\");\n    var name = isArray ? arrayIndex++ : buffer2.toString(\"utf8\", index, i);\n    var shouldValidateKey = true;\n    if (globalUTFValidation || utf8KeysSet.has(name)) {\n      shouldValidateKey = validationSetting;\n    } else {\n      shouldValidateKey = !validationSetting;\n    }\n    if (isPossibleDBRef !== false && name[0] === \"$\") {\n      isPossibleDBRef = allowedDBRefKeys.test(name);\n    }\n    var value = void 0;\n    index = i + 1;\n    if (elementType === BSON_DATA_STRING) {\n      var stringSize = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;\n      if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0) {\n        throw new BSONError(\"bad string length in bson\");\n      }\n      value = getValidatedString(buffer2, index, index + stringSize - 1, shouldValidateKey);\n      index = index + stringSize;\n    } else if (elementType === BSON_DATA_OID) {\n      var oid = buffer_1.alloc(12);\n      buffer2.copy(oid, 0, index, index + 12);\n      value = new ObjectId(oid);\n      index = index + 12;\n    } else if (elementType === BSON_DATA_INT && promoteValues === false) {\n      value = new Int32(buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24);\n    } else if (elementType === BSON_DATA_INT) {\n      value = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;\n    } else if (elementType === BSON_DATA_NUMBER && promoteValues === false) {\n      value = new Double(dataview.getFloat64(index, true));\n      index = index + 8;\n    } else if (elementType === BSON_DATA_NUMBER) {\n      value = dataview.getFloat64(index, true);\n      index = index + 8;\n    } else if (elementType === BSON_DATA_DATE) {\n      var lowBits = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;\n      var highBits = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;\n      value = new Date(new Long(lowBits, highBits).toNumber());\n    } else if (elementType === BSON_DATA_BOOLEAN) {\n      if (buffer2[index] !== 0 && buffer2[index] !== 1)\n        throw new BSONError(\"illegal boolean type value\");\n      value = buffer2[index++] === 1;\n    } else if (elementType === BSON_DATA_OBJECT) {\n      var _index = index;\n      var objectSize = buffer2[index] | buffer2[index + 1] << 8 | buffer2[index + 2] << 16 | buffer2[index + 3] << 24;\n      if (objectSize <= 0 || objectSize > buffer2.length - index)\n        throw new BSONError(\"bad embedded document length in bson\");\n      if (raw) {\n        value = buffer2.slice(index, index + objectSize);\n      } else {\n        var objectOptions = options;\n        if (!globalUTFValidation) {\n          objectOptions = _assign(_assign({}, options), { validation: { utf8: shouldValidateKey } });\n        }\n        value = deserializeObject(buffer2, _index, objectOptions, false);\n      }\n      index = index + objectSize;\n    } else if (elementType === BSON_DATA_ARRAY) {\n      var _index = index;\n      var objectSize = buffer2[index] | buffer2[index + 1] << 8 | buffer2[index + 2] << 16 | buffer2[index + 3] << 24;\n      var arrayOptions = options;\n      var stopIndex = index + objectSize;\n      if (fieldsAsRaw && fieldsAsRaw[name]) {\n        arrayOptions = {};\n        for (var n in options) {\n          arrayOptions[n] = options[n];\n        }\n        arrayOptions[\"raw\"] = true;\n      }\n      if (!globalUTFValidation) {\n        arrayOptions = _assign(_assign({}, arrayOptions), { validation: { utf8: shouldValidateKey } });\n      }\n      value = deserializeObject(buffer2, _index, arrayOptions, true);\n      index = index + objectSize;\n      if (buffer2[index - 1] !== 0)\n        throw new BSONError(\"invalid array terminator byte\");\n      if (index !== stopIndex)\n        throw new BSONError(\"corrupted array bson\");\n    } else if (elementType === BSON_DATA_UNDEFINED) {\n      value = void 0;\n    } else if (elementType === BSON_DATA_NULL) {\n      value = null;\n    } else if (elementType === BSON_DATA_LONG) {\n      var lowBits = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;\n      var highBits = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;\n      var long = new Long(lowBits, highBits);\n      if (promoteLongs && promoteValues === true) {\n        value = long.lessThanOrEqual(JS_INT_MAX_LONG) && long.greaterThanOrEqual(JS_INT_MIN_LONG) ? long.toNumber() : long;\n      } else {\n        value = long;\n      }\n    } else if (elementType === BSON_DATA_DECIMAL128) {\n      var bytes = buffer_1.alloc(16);\n      buffer2.copy(bytes, 0, index, index + 16);\n      index = index + 16;\n      var decimal128 = new Decimal128(bytes);\n      if (\"toObject\" in decimal128 && typeof decimal128.toObject === \"function\") {\n        value = decimal128.toObject();\n      } else {\n        value = decimal128;\n      }\n    } else if (elementType === BSON_DATA_BINARY) {\n      var binarySize = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;\n      var totalBinarySize = binarySize;\n      var subType = buffer2[index++];\n      if (binarySize < 0)\n        throw new BSONError(\"Negative binary type element size found\");\n      if (binarySize > buffer2.byteLength)\n        throw new BSONError(\"Binary type size larger than document size\");\n      if (buffer2[\"slice\"] != null) {\n        if (subType === Binary.SUBTYPE_BYTE_ARRAY) {\n          binarySize = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;\n          if (binarySize < 0)\n            throw new BSONError(\"Negative binary type element size found for subtype 0x02\");\n          if (binarySize > totalBinarySize - 4)\n            throw new BSONError(\"Binary type with subtype 0x02 contains too long binary size\");\n          if (binarySize < totalBinarySize - 4)\n            throw new BSONError(\"Binary type with subtype 0x02 contains too short binary size\");\n        }\n        if (promoteBuffers && promoteValues) {\n          value = buffer2.slice(index, index + binarySize);\n        } else {\n          value = new Binary(buffer2.slice(index, index + binarySize), subType);\n          if (subType === BSON_BINARY_SUBTYPE_UUID_NEW) {\n            value = value.toUUID();\n          }\n        }\n      } else {\n        var _buffer = buffer_1.alloc(binarySize);\n        if (subType === Binary.SUBTYPE_BYTE_ARRAY) {\n          binarySize = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;\n          if (binarySize < 0)\n            throw new BSONError(\"Negative binary type element size found for subtype 0x02\");\n          if (binarySize > totalBinarySize - 4)\n            throw new BSONError(\"Binary type with subtype 0x02 contains too long binary size\");\n          if (binarySize < totalBinarySize - 4)\n            throw new BSONError(\"Binary type with subtype 0x02 contains too short binary size\");\n        }\n        for (i = 0; i < binarySize; i++) {\n          _buffer[i] = buffer2[index + i];\n        }\n        if (promoteBuffers && promoteValues) {\n          value = _buffer;\n        } else if (subType === BSON_BINARY_SUBTYPE_UUID_NEW) {\n          value = new Binary(buffer2.slice(index, index + binarySize), subType).toUUID();\n        } else {\n          value = new Binary(buffer2.slice(index, index + binarySize), subType);\n        }\n      }\n      index = index + binarySize;\n    } else if (elementType === BSON_DATA_REGEXP && bsonRegExp === false) {\n      i = index;\n      while (buffer2[i] !== 0 && i < buffer2.length) {\n        i++;\n      }\n      if (i >= buffer2.length)\n        throw new BSONError(\"Bad BSON Document: illegal CString\");\n      var source = buffer2.toString(\"utf8\", index, i);\n      index = i + 1;\n      i = index;\n      while (buffer2[i] !== 0 && i < buffer2.length) {\n        i++;\n      }\n      if (i >= buffer2.length)\n        throw new BSONError(\"Bad BSON Document: illegal CString\");\n      var regExpOptions = buffer2.toString(\"utf8\", index, i);\n      index = i + 1;\n      var optionsArray = new Array(regExpOptions.length);\n      for (i = 0; i < regExpOptions.length; i++) {\n        switch (regExpOptions[i]) {\n          case \"m\":\n            optionsArray[i] = \"m\";\n            break;\n          case \"s\":\n            optionsArray[i] = \"g\";\n            break;\n          case \"i\":\n            optionsArray[i] = \"i\";\n            break;\n        }\n      }\n      value = new RegExp(source, optionsArray.join(\"\"));\n    } else if (elementType === BSON_DATA_REGEXP && bsonRegExp === true) {\n      i = index;\n      while (buffer2[i] !== 0 && i < buffer2.length) {\n        i++;\n      }\n      if (i >= buffer2.length)\n        throw new BSONError(\"Bad BSON Document: illegal CString\");\n      var source = buffer2.toString(\"utf8\", index, i);\n      index = i + 1;\n      i = index;\n      while (buffer2[i] !== 0 && i < buffer2.length) {\n        i++;\n      }\n      if (i >= buffer2.length)\n        throw new BSONError(\"Bad BSON Document: illegal CString\");\n      var regExpOptions = buffer2.toString(\"utf8\", index, i);\n      index = i + 1;\n      value = new BSONRegExp(source, regExpOptions);\n    } else if (elementType === BSON_DATA_SYMBOL) {\n      var stringSize = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;\n      if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0) {\n        throw new BSONError(\"bad string length in bson\");\n      }\n      var symbol = getValidatedString(buffer2, index, index + stringSize - 1, shouldValidateKey);\n      value = promoteValues ? symbol : new BSONSymbol(symbol);\n      index = index + stringSize;\n    } else if (elementType === BSON_DATA_TIMESTAMP) {\n      var lowBits = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;\n      var highBits = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;\n      value = new Timestamp(lowBits, highBits);\n    } else if (elementType === BSON_DATA_MIN_KEY) {\n      value = new MinKey();\n    } else if (elementType === BSON_DATA_MAX_KEY) {\n      value = new MaxKey();\n    } else if (elementType === BSON_DATA_CODE) {\n      var stringSize = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;\n      if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0) {\n        throw new BSONError(\"bad string length in bson\");\n      }\n      var functionString = getValidatedString(buffer2, index, index + stringSize - 1, shouldValidateKey);\n      if (evalFunctions) {\n        if (cacheFunctions) {\n          value = isolateEval(functionString, functionCache, object);\n        } else {\n          value = isolateEval(functionString);\n        }\n      } else {\n        value = new Code(functionString);\n      }\n      index = index + stringSize;\n    } else if (elementType === BSON_DATA_CODE_W_SCOPE) {\n      var totalSize = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;\n      if (totalSize < 4 + 4 + 4 + 1) {\n        throw new BSONError(\"code_w_scope total size shorter minimum expected length\");\n      }\n      var stringSize = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;\n      if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0) {\n        throw new BSONError(\"bad string length in bson\");\n      }\n      var functionString = getValidatedString(buffer2, index, index + stringSize - 1, shouldValidateKey);\n      index = index + stringSize;\n      var _index = index;\n      var objectSize = buffer2[index] | buffer2[index + 1] << 8 | buffer2[index + 2] << 16 | buffer2[index + 3] << 24;\n      var scopeObject = deserializeObject(buffer2, _index, options, false);\n      index = index + objectSize;\n      if (totalSize < 4 + 4 + objectSize + stringSize) {\n        throw new BSONError(\"code_w_scope total size is too short, truncating scope\");\n      }\n      if (totalSize > 4 + 4 + objectSize + stringSize) {\n        throw new BSONError(\"code_w_scope total size is too long, clips outer document\");\n      }\n      if (evalFunctions) {\n        if (cacheFunctions) {\n          value = isolateEval(functionString, functionCache, object);\n        } else {\n          value = isolateEval(functionString);\n        }\n        value.scope = scopeObject;\n      } else {\n        value = new Code(functionString, scopeObject);\n      }\n    } else if (elementType === BSON_DATA_DBPOINTER) {\n      var stringSize = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;\n      if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0)\n        throw new BSONError(\"bad string length in bson\");\n      if (validation != null && validation.utf8) {\n        if (!validateUtf8(buffer2, index, index + stringSize - 1)) {\n          throw new BSONError(\"Invalid UTF-8 string in BSON document\");\n        }\n      }\n      var namespace = buffer2.toString(\"utf8\", index, index + stringSize - 1);\n      index = index + stringSize;\n      var oidBuffer = buffer_1.alloc(12);\n      buffer2.copy(oidBuffer, 0, index, index + 12);\n      var oid = new ObjectId(oidBuffer);\n      index = index + 12;\n      value = new DBRef(namespace, oid);\n    } else {\n      throw new BSONError(\"Detected unknown BSON type \".concat(elementType.toString(16), ' for fieldname \"').concat(name, '\"'));\n    }\n    if (name === \"__proto__\") {\n      Object.defineProperty(object, name, {\n        value,\n        writable: true,\n        enumerable: true,\n        configurable: true\n      });\n    } else {\n      object[name] = value;\n    }\n  }\n  if (size !== index - startIndex) {\n    if (isArray)\n      throw new BSONError(\"corrupt array bson\");\n    throw new BSONError(\"corrupt object bson\");\n  }\n  if (!isPossibleDBRef)\n    return object;\n  if (isDBRefLike(object)) {\n    var copy = Object.assign({}, object);\n    delete copy.$ref;\n    delete copy.$id;\n    delete copy.$db;\n    return new DBRef(object.$ref, object.$id, object.$db, copy);\n  }\n  return object;\n}\nfunction isolateEval(functionString, functionCache2, object) {\n  if (!functionCache2)\n    return new Function(functionString);\n  if (functionCache2[functionString] == null) {\n    functionCache2[functionString] = new Function(functionString);\n  }\n  return functionCache2[functionString].bind(object);\n}\nfunction getValidatedString(buffer2, start, end, shouldValidateUtf8) {\n  var value = buffer2.toString(\"utf8\", start, end);\n  if (shouldValidateUtf8) {\n    for (var i = 0; i < value.length; i++) {\n      if (value.charCodeAt(i) === 65533) {\n        if (!validateUtf8(buffer2, start, end)) {\n          throw new BSONError(\"Invalid UTF-8 string in BSON document\");\n        }\n        break;\n      }\n    }\n  }\n  return value;\n}\nvar regexp = /\\x00/;\nvar ignoreKeys = /* @__PURE__ */ new Set([\"$db\", \"$ref\", \"$id\", \"$clusterTime\"]);\nfunction serializeString(buffer2, key, value, index, isArray) {\n  buffer2[index++] = BSON_DATA_STRING;\n  var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, \"utf8\") : buffer2.write(key, index, void 0, \"ascii\");\n  index = index + numberOfWrittenBytes + 1;\n  buffer2[index - 1] = 0;\n  var size = buffer2.write(value, index + 4, void 0, \"utf8\");\n  buffer2[index + 3] = size + 1 >> 24 & 255;\n  buffer2[index + 2] = size + 1 >> 16 & 255;\n  buffer2[index + 1] = size + 1 >> 8 & 255;\n  buffer2[index] = size + 1 & 255;\n  index = index + 4 + size;\n  buffer2[index++] = 0;\n  return index;\n}\nvar SPACE_FOR_FLOAT64 = new Uint8Array(8);\nvar DV_FOR_FLOAT64 = new DataView(SPACE_FOR_FLOAT64.buffer, SPACE_FOR_FLOAT64.byteOffset, SPACE_FOR_FLOAT64.byteLength);\nfunction serializeNumber(buffer2, key, value, index, isArray) {\n  if (Number.isInteger(value) && value >= BSON_INT32_MIN$1 && value <= BSON_INT32_MAX$1) {\n    buffer2[index++] = BSON_DATA_INT;\n    var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, \"utf8\") : buffer2.write(key, index, void 0, \"ascii\");\n    index = index + numberOfWrittenBytes;\n    buffer2[index++] = 0;\n    buffer2[index++] = value & 255;\n    buffer2[index++] = value >> 8 & 255;\n    buffer2[index++] = value >> 16 & 255;\n    buffer2[index++] = value >> 24 & 255;\n  } else {\n    buffer2[index++] = BSON_DATA_NUMBER;\n    var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, \"utf8\") : buffer2.write(key, index, void 0, \"ascii\");\n    index = index + numberOfWrittenBytes;\n    buffer2[index++] = 0;\n    DV_FOR_FLOAT64.setFloat64(0, value, true);\n    buffer2.set(SPACE_FOR_FLOAT64, index);\n    index = index + 8;\n  }\n  return index;\n}\nfunction serializeNull(buffer2, key, _, index, isArray) {\n  buffer2[index++] = BSON_DATA_NULL;\n  var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, \"utf8\") : buffer2.write(key, index, void 0, \"ascii\");\n  index = index + numberOfWrittenBytes;\n  buffer2[index++] = 0;\n  return index;\n}\nfunction serializeBoolean(buffer2, key, value, index, isArray) {\n  buffer2[index++] = BSON_DATA_BOOLEAN;\n  var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, \"utf8\") : buffer2.write(key, index, void 0, \"ascii\");\n  index = index + numberOfWrittenBytes;\n  buffer2[index++] = 0;\n  buffer2[index++] = value ? 1 : 0;\n  return index;\n}\nfunction serializeDate(buffer2, key, value, index, isArray) {\n  buffer2[index++] = BSON_DATA_DATE;\n  var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, \"utf8\") : buffer2.write(key, index, void 0, \"ascii\");\n  index = index + numberOfWrittenBytes;\n  buffer2[index++] = 0;\n  var dateInMilis = Long.fromNumber(value.getTime());\n  var lowBits = dateInMilis.getLowBits();\n  var highBits = dateInMilis.getHighBits();\n  buffer2[index++] = lowBits & 255;\n  buffer2[index++] = lowBits >> 8 & 255;\n  buffer2[index++] = lowBits >> 16 & 255;\n  buffer2[index++] = lowBits >> 24 & 255;\n  buffer2[index++] = highBits & 255;\n  buffer2[index++] = highBits >> 8 & 255;\n  buffer2[index++] = highBits >> 16 & 255;\n  buffer2[index++] = highBits >> 24 & 255;\n  return index;\n}\nfunction serializeRegExp(buffer2, key, value, index, isArray) {\n  buffer2[index++] = BSON_DATA_REGEXP;\n  var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, \"utf8\") : buffer2.write(key, index, void 0, \"ascii\");\n  index = index + numberOfWrittenBytes;\n  buffer2[index++] = 0;\n  if (value.source && value.source.match(regexp) != null) {\n    throw Error(\"value \" + value.source + \" must not contain null bytes\");\n  }\n  index = index + buffer2.write(value.source, index, void 0, \"utf8\");\n  buffer2[index++] = 0;\n  if (value.ignoreCase)\n    buffer2[index++] = 105;\n  if (value.global)\n    buffer2[index++] = 115;\n  if (value.multiline)\n    buffer2[index++] = 109;\n  buffer2[index++] = 0;\n  return index;\n}\nfunction serializeBSONRegExp(buffer2, key, value, index, isArray) {\n  buffer2[index++] = BSON_DATA_REGEXP;\n  var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, \"utf8\") : buffer2.write(key, index, void 0, \"ascii\");\n  index = index + numberOfWrittenBytes;\n  buffer2[index++] = 0;\n  if (value.pattern.match(regexp) != null) {\n    throw Error(\"pattern \" + value.pattern + \" must not contain null bytes\");\n  }\n  index = index + buffer2.write(value.pattern, index, void 0, \"utf8\");\n  buffer2[index++] = 0;\n  index = index + buffer2.write(value.options.split(\"\").sort().join(\"\"), index, void 0, \"utf8\");\n  buffer2[index++] = 0;\n  return index;\n}\nfunction serializeMinMax(buffer2, key, value, index, isArray) {\n  if (value === null) {\n    buffer2[index++] = BSON_DATA_NULL;\n  } else if (value._bsontype === \"MinKey\") {\n    buffer2[index++] = BSON_DATA_MIN_KEY;\n  } else {\n    buffer2[index++] = BSON_DATA_MAX_KEY;\n  }\n  var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, \"utf8\") : buffer2.write(key, index, void 0, \"ascii\");\n  index = index + numberOfWrittenBytes;\n  buffer2[index++] = 0;\n  return index;\n}\nfunction serializeObjectId(buffer2, key, value, index, isArray) {\n  buffer2[index++] = BSON_DATA_OID;\n  var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, \"utf8\") : buffer2.write(key, index, void 0, \"ascii\");\n  index = index + numberOfWrittenBytes;\n  buffer2[index++] = 0;\n  if (typeof value.id === \"string\") {\n    buffer2.write(value.id, index, void 0, \"binary\");\n  } else if (isUint8Array(value.id)) {\n    buffer2.set(value.id.subarray(0, 12), index);\n  } else {\n    throw new BSONTypeError(\"object [\" + JSON.stringify(value) + \"] is not a valid ObjectId\");\n  }\n  return index + 12;\n}\nfunction serializeBuffer(buffer2, key, value, index, isArray) {\n  buffer2[index++] = BSON_DATA_BINARY;\n  var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, \"utf8\") : buffer2.write(key, index, void 0, \"ascii\");\n  index = index + numberOfWrittenBytes;\n  buffer2[index++] = 0;\n  var size = value.length;\n  buffer2[index++] = size & 255;\n  buffer2[index++] = size >> 8 & 255;\n  buffer2[index++] = size >> 16 & 255;\n  buffer2[index++] = size >> 24 & 255;\n  buffer2[index++] = BSON_BINARY_SUBTYPE_DEFAULT;\n  buffer2.set(ensureBuffer(value), index);\n  index = index + size;\n  return index;\n}\nfunction serializeObject(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, isArray, path) {\n  if (checkKeys === void 0) {\n    checkKeys = false;\n  }\n  if (depth === void 0) {\n    depth = 0;\n  }\n  if (serializeFunctions === void 0) {\n    serializeFunctions = false;\n  }\n  if (ignoreUndefined === void 0) {\n    ignoreUndefined = true;\n  }\n  if (isArray === void 0) {\n    isArray = false;\n  }\n  if (path === void 0) {\n    path = [];\n  }\n  for (var i = 0; i < path.length; i++) {\n    if (path[i] === value)\n      throw new BSONError(\"cyclic dependency detected\");\n  }\n  path.push(value);\n  buffer2[index++] = Array.isArray(value) ? BSON_DATA_ARRAY : BSON_DATA_OBJECT;\n  var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, \"utf8\") : buffer2.write(key, index, void 0, \"ascii\");\n  index = index + numberOfWrittenBytes;\n  buffer2[index++] = 0;\n  var endIndex = serializeInto(buffer2, value, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path);\n  path.pop();\n  return endIndex;\n}\nfunction serializeDecimal128(buffer2, key, value, index, isArray) {\n  buffer2[index++] = BSON_DATA_DECIMAL128;\n  var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, \"utf8\") : buffer2.write(key, index, void 0, \"ascii\");\n  index = index + numberOfWrittenBytes;\n  buffer2[index++] = 0;\n  buffer2.set(value.bytes.subarray(0, 16), index);\n  return index + 16;\n}\nfunction serializeLong(buffer2, key, value, index, isArray) {\n  buffer2[index++] = value._bsontype === \"Long\" ? BSON_DATA_LONG : BSON_DATA_TIMESTAMP;\n  var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, \"utf8\") : buffer2.write(key, index, void 0, \"ascii\");\n  index = index + numberOfWrittenBytes;\n  buffer2[index++] = 0;\n  var lowBits = value.getLowBits();\n  var highBits = value.getHighBits();\n  buffer2[index++] = lowBits & 255;\n  buffer2[index++] = lowBits >> 8 & 255;\n  buffer2[index++] = lowBits >> 16 & 255;\n  buffer2[index++] = lowBits >> 24 & 255;\n  buffer2[index++] = highBits & 255;\n  buffer2[index++] = highBits >> 8 & 255;\n  buffer2[index++] = highBits >> 16 & 255;\n  buffer2[index++] = highBits >> 24 & 255;\n  return index;\n}\nfunction serializeInt32(buffer2, key, value, index, isArray) {\n  value = value.valueOf();\n  buffer2[index++] = BSON_DATA_INT;\n  var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, \"utf8\") : buffer2.write(key, index, void 0, \"ascii\");\n  index = index + numberOfWrittenBytes;\n  buffer2[index++] = 0;\n  buffer2[index++] = value & 255;\n  buffer2[index++] = value >> 8 & 255;\n  buffer2[index++] = value >> 16 & 255;\n  buffer2[index++] = value >> 24 & 255;\n  return index;\n}\nfunction serializeDouble(buffer2, key, value, index, isArray) {\n  buffer2[index++] = BSON_DATA_NUMBER;\n  var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, \"utf8\") : buffer2.write(key, index, void 0, \"ascii\");\n  index = index + numberOfWrittenBytes;\n  buffer2[index++] = 0;\n  DV_FOR_FLOAT64.setFloat64(0, value.value, true);\n  buffer2.set(SPACE_FOR_FLOAT64, index);\n  index = index + 8;\n  return index;\n}\nfunction serializeFunction(buffer2, key, value, index, _checkKeys, _depth, isArray) {\n  buffer2[index++] = BSON_DATA_CODE;\n  var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, \"utf8\") : buffer2.write(key, index, void 0, \"ascii\");\n  index = index + numberOfWrittenBytes;\n  buffer2[index++] = 0;\n  var functionString = normalizedFunctionString(value);\n  var size = buffer2.write(functionString, index + 4, void 0, \"utf8\") + 1;\n  buffer2[index] = size & 255;\n  buffer2[index + 1] = size >> 8 & 255;\n  buffer2[index + 2] = size >> 16 & 255;\n  buffer2[index + 3] = size >> 24 & 255;\n  index = index + 4 + size - 1;\n  buffer2[index++] = 0;\n  return index;\n}\nfunction serializeCode(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, isArray) {\n  if (checkKeys === void 0) {\n    checkKeys = false;\n  }\n  if (depth === void 0) {\n    depth = 0;\n  }\n  if (serializeFunctions === void 0) {\n    serializeFunctions = false;\n  }\n  if (ignoreUndefined === void 0) {\n    ignoreUndefined = true;\n  }\n  if (isArray === void 0) {\n    isArray = false;\n  }\n  if (value.scope && typeof value.scope === \"object\") {\n    buffer2[index++] = BSON_DATA_CODE_W_SCOPE;\n    var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, \"utf8\") : buffer2.write(key, index, void 0, \"ascii\");\n    index = index + numberOfWrittenBytes;\n    buffer2[index++] = 0;\n    var startIndex = index;\n    var functionString = typeof value.code === \"string\" ? value.code : value.code.toString();\n    index = index + 4;\n    var codeSize = buffer2.write(functionString, index + 4, void 0, \"utf8\") + 1;\n    buffer2[index] = codeSize & 255;\n    buffer2[index + 1] = codeSize >> 8 & 255;\n    buffer2[index + 2] = codeSize >> 16 & 255;\n    buffer2[index + 3] = codeSize >> 24 & 255;\n    buffer2[index + 4 + codeSize - 1] = 0;\n    index = index + codeSize + 4;\n    var endIndex = serializeInto(buffer2, value.scope, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined);\n    index = endIndex - 1;\n    var totalSize = endIndex - startIndex;\n    buffer2[startIndex++] = totalSize & 255;\n    buffer2[startIndex++] = totalSize >> 8 & 255;\n    buffer2[startIndex++] = totalSize >> 16 & 255;\n    buffer2[startIndex++] = totalSize >> 24 & 255;\n    buffer2[index++] = 0;\n  } else {\n    buffer2[index++] = BSON_DATA_CODE;\n    var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, \"utf8\") : buffer2.write(key, index, void 0, \"ascii\");\n    index = index + numberOfWrittenBytes;\n    buffer2[index++] = 0;\n    var functionString = value.code.toString();\n    var size = buffer2.write(functionString, index + 4, void 0, \"utf8\") + 1;\n    buffer2[index] = size & 255;\n    buffer2[index + 1] = size >> 8 & 255;\n    buffer2[index + 2] = size >> 16 & 255;\n    buffer2[index + 3] = size >> 24 & 255;\n    index = index + 4 + size - 1;\n    buffer2[index++] = 0;\n  }\n  return index;\n}\nfunction serializeBinary(buffer2, key, value, index, isArray) {\n  buffer2[index++] = BSON_DATA_BINARY;\n  var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, \"utf8\") : buffer2.write(key, index, void 0, \"ascii\");\n  index = index + numberOfWrittenBytes;\n  buffer2[index++] = 0;\n  var data = value.value(true);\n  var size = value.position;\n  if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY)\n    size = size + 4;\n  buffer2[index++] = size & 255;\n  buffer2[index++] = size >> 8 & 255;\n  buffer2[index++] = size >> 16 & 255;\n  buffer2[index++] = size >> 24 & 255;\n  buffer2[index++] = value.sub_type;\n  if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY) {\n    size = size - 4;\n    buffer2[index++] = size & 255;\n    buffer2[index++] = size >> 8 & 255;\n    buffer2[index++] = size >> 16 & 255;\n    buffer2[index++] = size >> 24 & 255;\n  }\n  buffer2.set(data, index);\n  index = index + value.position;\n  return index;\n}\nfunction serializeSymbol(buffer2, key, value, index, isArray) {\n  buffer2[index++] = BSON_DATA_SYMBOL;\n  var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, \"utf8\") : buffer2.write(key, index, void 0, \"ascii\");\n  index = index + numberOfWrittenBytes;\n  buffer2[index++] = 0;\n  var size = buffer2.write(value.value, index + 4, void 0, \"utf8\") + 1;\n  buffer2[index] = size & 255;\n  buffer2[index + 1] = size >> 8 & 255;\n  buffer2[index + 2] = size >> 16 & 255;\n  buffer2[index + 3] = size >> 24 & 255;\n  index = index + 4 + size - 1;\n  buffer2[index++] = 0;\n  return index;\n}\nfunction serializeDBRef(buffer2, key, value, index, depth, serializeFunctions, isArray) {\n  buffer2[index++] = BSON_DATA_OBJECT;\n  var numberOfWrittenBytes = !isArray ? buffer2.write(key, index, void 0, \"utf8\") : buffer2.write(key, index, void 0, \"ascii\");\n  index = index + numberOfWrittenBytes;\n  buffer2[index++] = 0;\n  var startIndex = index;\n  var output = {\n    $ref: value.collection || value.namespace,\n    $id: value.oid\n  };\n  if (value.db != null) {\n    output.$db = value.db;\n  }\n  output = Object.assign(output, value.fields);\n  var endIndex = serializeInto(buffer2, output, false, index, depth + 1, serializeFunctions);\n  var size = endIndex - startIndex;\n  buffer2[startIndex++] = size & 255;\n  buffer2[startIndex++] = size >> 8 & 255;\n  buffer2[startIndex++] = size >> 16 & 255;\n  buffer2[startIndex++] = size >> 24 & 255;\n  return endIndex;\n}\nfunction serializeInto(buffer2, object, checkKeys, startingIndex, depth, serializeFunctions, ignoreUndefined, path) {\n  if (checkKeys === void 0) {\n    checkKeys = false;\n  }\n  if (startingIndex === void 0) {\n    startingIndex = 0;\n  }\n  if (depth === void 0) {\n    depth = 0;\n  }\n  if (serializeFunctions === void 0) {\n    serializeFunctions = false;\n  }\n  if (ignoreUndefined === void 0) {\n    ignoreUndefined = true;\n  }\n  if (path === void 0) {\n    path = [];\n  }\n  startingIndex = startingIndex || 0;\n  path = path || [];\n  path.push(object);\n  var index = startingIndex + 4;\n  if (Array.isArray(object)) {\n    for (var i = 0; i < object.length; i++) {\n      var key = \"\".concat(i);\n      var value = object[i];\n      if (typeof (value === null || value === void 0 ? void 0 : value.toBSON) === \"function\") {\n        value = value.toBSON();\n      }\n      if (typeof value === \"string\") {\n        index = serializeString(buffer2, key, value, index, true);\n      } else if (typeof value === \"number\") {\n        index = serializeNumber(buffer2, key, value, index, true);\n      } else if (typeof value === \"bigint\") {\n        throw new BSONTypeError(\"Unsupported type BigInt, please use Decimal128\");\n      } else if (typeof value === \"boolean\") {\n        index = serializeBoolean(buffer2, key, value, index, true);\n      } else if (value instanceof Date || isDate(value)) {\n        index = serializeDate(buffer2, key, value, index, true);\n      } else if (value === void 0) {\n        index = serializeNull(buffer2, key, value, index, true);\n      } else if (value === null) {\n        index = serializeNull(buffer2, key, value, index, true);\n      } else if (value[\"_bsontype\"] === \"ObjectId\" || value[\"_bsontype\"] === \"ObjectID\") {\n        index = serializeObjectId(buffer2, key, value, index, true);\n      } else if (isUint8Array(value)) {\n        index = serializeBuffer(buffer2, key, value, index, true);\n      } else if (value instanceof RegExp || isRegExp(value)) {\n        index = serializeRegExp(buffer2, key, value, index, true);\n      } else if (typeof value === \"object\" && value[\"_bsontype\"] == null) {\n        index = serializeObject(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, true, path);\n      } else if (typeof value === \"object\" && isBSONType(value) && value._bsontype === \"Decimal128\") {\n        index = serializeDecimal128(buffer2, key, value, index, true);\n      } else if (value[\"_bsontype\"] === \"Long\" || value[\"_bsontype\"] === \"Timestamp\") {\n        index = serializeLong(buffer2, key, value, index, true);\n      } else if (value[\"_bsontype\"] === \"Double\") {\n        index = serializeDouble(buffer2, key, value, index, true);\n      } else if (typeof value === \"function\" && serializeFunctions) {\n        index = serializeFunction(buffer2, key, value, index, checkKeys, depth, true);\n      } else if (value[\"_bsontype\"] === \"Code\") {\n        index = serializeCode(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, true);\n      } else if (value[\"_bsontype\"] === \"Binary\") {\n        index = serializeBinary(buffer2, key, value, index, true);\n      } else if (value[\"_bsontype\"] === \"Symbol\") {\n        index = serializeSymbol(buffer2, key, value, index, true);\n      } else if (value[\"_bsontype\"] === \"DBRef\") {\n        index = serializeDBRef(buffer2, key, value, index, depth, serializeFunctions, true);\n      } else if (value[\"_bsontype\"] === \"BSONRegExp\") {\n        index = serializeBSONRegExp(buffer2, key, value, index, true);\n      } else if (value[\"_bsontype\"] === \"Int32\") {\n        index = serializeInt32(buffer2, key, value, index, true);\n      } else if (value[\"_bsontype\"] === \"MinKey\" || value[\"_bsontype\"] === \"MaxKey\") {\n        index = serializeMinMax(buffer2, key, value, index, true);\n      } else if (typeof value[\"_bsontype\"] !== \"undefined\") {\n        throw new BSONTypeError(\"Unrecognized or invalid _bsontype: \".concat(String(value[\"_bsontype\"])));\n      }\n    }\n  } else if (object instanceof bsonMap || isMap(object)) {\n    var iterator = object.entries();\n    var done = false;\n    while (!done) {\n      var entry = iterator.next();\n      done = !!entry.done;\n      if (done)\n        continue;\n      var key = entry.value[0];\n      var value = entry.value[1];\n      var type = typeof value;\n      if (typeof key === \"string\" && !ignoreKeys.has(key)) {\n        if (key.match(regexp) != null) {\n          throw Error(\"key \" + key + \" must not contain null bytes\");\n        }\n        if (checkKeys) {\n          if (\"$\" === key[0]) {\n            throw Error(\"key \" + key + \" must not start with '$'\");\n          } else if (~key.indexOf(\".\")) {\n            throw Error(\"key \" + key + \" must not contain '.'\");\n          }\n        }\n      }\n      if (type === \"string\") {\n        index = serializeString(buffer2, key, value, index);\n      } else if (type === \"number\") {\n        index = serializeNumber(buffer2, key, value, index);\n      } else if (type === \"bigint\" || isBigInt64Array(value) || isBigUInt64Array(value)) {\n        throw new BSONTypeError(\"Unsupported type BigInt, please use Decimal128\");\n      } else if (type === \"boolean\") {\n        index = serializeBoolean(buffer2, key, value, index);\n      } else if (value instanceof Date || isDate(value)) {\n        index = serializeDate(buffer2, key, value, index);\n      } else if (value === null || value === void 0 && ignoreUndefined === false) {\n        index = serializeNull(buffer2, key, value, index);\n      } else if (value[\"_bsontype\"] === \"ObjectId\" || value[\"_bsontype\"] === \"ObjectID\") {\n        index = serializeObjectId(buffer2, key, value, index);\n      } else if (isUint8Array(value)) {\n        index = serializeBuffer(buffer2, key, value, index);\n      } else if (value instanceof RegExp || isRegExp(value)) {\n        index = serializeRegExp(buffer2, key, value, index);\n      } else if (type === \"object\" && value[\"_bsontype\"] == null) {\n        index = serializeObject(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, false, path);\n      } else if (type === \"object\" && value[\"_bsontype\"] === \"Decimal128\") {\n        index = serializeDecimal128(buffer2, key, value, index);\n      } else if (value[\"_bsontype\"] === \"Long\" || value[\"_bsontype\"] === \"Timestamp\") {\n        index = serializeLong(buffer2, key, value, index);\n      } else if (value[\"_bsontype\"] === \"Double\") {\n        index = serializeDouble(buffer2, key, value, index);\n      } else if (value[\"_bsontype\"] === \"Code\") {\n        index = serializeCode(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined);\n      } else if (typeof value === \"function\" && serializeFunctions) {\n        index = serializeFunction(buffer2, key, value, index, checkKeys, depth, serializeFunctions);\n      } else if (value[\"_bsontype\"] === \"Binary\") {\n        index = serializeBinary(buffer2, key, value, index);\n      } else if (value[\"_bsontype\"] === \"Symbol\") {\n        index = serializeSymbol(buffer2, key, value, index);\n      } else if (value[\"_bsontype\"] === \"DBRef\") {\n        index = serializeDBRef(buffer2, key, value, index, depth, serializeFunctions);\n      } else if (value[\"_bsontype\"] === \"BSONRegExp\") {\n        index = serializeBSONRegExp(buffer2, key, value, index);\n      } else if (value[\"_bsontype\"] === \"Int32\") {\n        index = serializeInt32(buffer2, key, value, index);\n      } else if (value[\"_bsontype\"] === \"MinKey\" || value[\"_bsontype\"] === \"MaxKey\") {\n        index = serializeMinMax(buffer2, key, value, index);\n      } else if (typeof value[\"_bsontype\"] !== \"undefined\") {\n        throw new BSONTypeError(\"Unrecognized or invalid _bsontype: \".concat(String(value[\"_bsontype\"])));\n      }\n    }\n  } else {\n    if (typeof (object === null || object === void 0 ? void 0 : object.toBSON) === \"function\") {\n      object = object.toBSON();\n      if (object != null && typeof object !== \"object\") {\n        throw new BSONTypeError(\"toBSON function did not return an object\");\n      }\n    }\n    for (var key in object) {\n      var value = object[key];\n      if (typeof (value === null || value === void 0 ? void 0 : value.toBSON) === \"function\") {\n        value = value.toBSON();\n      }\n      var type = typeof value;\n      if (typeof key === \"string\" && !ignoreKeys.has(key)) {\n        if (key.match(regexp) != null) {\n          throw Error(\"key \" + key + \" must not contain null bytes\");\n        }\n        if (checkKeys) {\n          if (\"$\" === key[0]) {\n            throw Error(\"key \" + key + \" must not start with '$'\");\n          } else if (~key.indexOf(\".\")) {\n            throw Error(\"key \" + key + \" must not contain '.'\");\n          }\n        }\n      }\n      if (type === \"string\") {\n        index = serializeString(buffer2, key, value, index);\n      } else if (type === \"number\") {\n        index = serializeNumber(buffer2, key, value, index);\n      } else if (type === \"bigint\") {\n        throw new BSONTypeError(\"Unsupported type BigInt, please use Decimal128\");\n      } else if (type === \"boolean\") {\n        index = serializeBoolean(buffer2, key, value, index);\n      } else if (value instanceof Date || isDate(value)) {\n        index = serializeDate(buffer2, key, value, index);\n      } else if (value === void 0) {\n        if (ignoreUndefined === false)\n          index = serializeNull(buffer2, key, value, index);\n      } else if (value === null) {\n        index = serializeNull(buffer2, key, value, index);\n      } else if (value[\"_bsontype\"] === \"ObjectId\" || value[\"_bsontype\"] === \"ObjectID\") {\n        index = serializeObjectId(buffer2, key, value, index);\n      } else if (isUint8Array(value)) {\n        index = serializeBuffer(buffer2, key, value, index);\n      } else if (value instanceof RegExp || isRegExp(value)) {\n        index = serializeRegExp(buffer2, key, value, index);\n      } else if (type === \"object\" && value[\"_bsontype\"] == null) {\n        index = serializeObject(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, false, path);\n      } else if (type === \"object\" && value[\"_bsontype\"] === \"Decimal128\") {\n        index = serializeDecimal128(buffer2, key, value, index);\n      } else if (value[\"_bsontype\"] === \"Long\" || value[\"_bsontype\"] === \"Timestamp\") {\n        index = serializeLong(buffer2, key, value, index);\n      } else if (value[\"_bsontype\"] === \"Double\") {\n        index = serializeDouble(buffer2, key, value, index);\n      } else if (value[\"_bsontype\"] === \"Code\") {\n        index = serializeCode(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined);\n      } else if (typeof value === \"function\" && serializeFunctions) {\n        index = serializeFunction(buffer2, key, value, index, checkKeys, depth, serializeFunctions);\n      } else if (value[\"_bsontype\"] === \"Binary\") {\n        index = serializeBinary(buffer2, key, value, index);\n      } else if (value[\"_bsontype\"] === \"Symbol\") {\n        index = serializeSymbol(buffer2, key, value, index);\n      } else if (value[\"_bsontype\"] === \"DBRef\") {\n        index = serializeDBRef(buffer2, key, value, index, depth, serializeFunctions);\n      } else if (value[\"_bsontype\"] === \"BSONRegExp\") {\n        index = serializeBSONRegExp(buffer2, key, value, index);\n      } else if (value[\"_bsontype\"] === \"Int32\") {\n        index = serializeInt32(buffer2, key, value, index);\n      } else if (value[\"_bsontype\"] === \"MinKey\" || value[\"_bsontype\"] === \"MaxKey\") {\n        index = serializeMinMax(buffer2, key, value, index);\n      } else if (typeof value[\"_bsontype\"] !== \"undefined\") {\n        throw new BSONTypeError(\"Unrecognized or invalid _bsontype: \".concat(String(value[\"_bsontype\"])));\n      }\n    }\n  }\n  path.pop();\n  buffer2[index++] = 0;\n  var size = index - startingIndex;\n  buffer2[startingIndex++] = size & 255;\n  buffer2[startingIndex++] = size >> 8 & 255;\n  buffer2[startingIndex++] = size >> 16 & 255;\n  buffer2[startingIndex++] = size >> 24 & 255;\n  return index;\n}\nvar MAXSIZE = 1024 * 1024 * 17;\nvar buffer = buffer_1.alloc(MAXSIZE);\nfunction setInternalBufferSize(size) {\n  if (buffer.length < size) {\n    buffer = buffer_1.alloc(size);\n  }\n}\nfunction serialize(object, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var checkKeys = typeof options.checkKeys === \"boolean\" ? options.checkKeys : false;\n  var serializeFunctions = typeof options.serializeFunctions === \"boolean\" ? options.serializeFunctions : false;\n  var ignoreUndefined = typeof options.ignoreUndefined === \"boolean\" ? options.ignoreUndefined : true;\n  var minInternalBufferSize = typeof options.minInternalBufferSize === \"number\" ? options.minInternalBufferSize : MAXSIZE;\n  if (buffer.length < minInternalBufferSize) {\n    buffer = buffer_1.alloc(minInternalBufferSize);\n  }\n  var serializationIndex = serializeInto(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, []);\n  var finishedBuffer = buffer_1.alloc(serializationIndex);\n  buffer.copy(finishedBuffer, 0, 0, finishedBuffer.length);\n  return finishedBuffer;\n}\nfunction serializeWithBufferAndIndex(object, finalBuffer, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var checkKeys = typeof options.checkKeys === \"boolean\" ? options.checkKeys : false;\n  var serializeFunctions = typeof options.serializeFunctions === \"boolean\" ? options.serializeFunctions : false;\n  var ignoreUndefined = typeof options.ignoreUndefined === \"boolean\" ? options.ignoreUndefined : true;\n  var startIndex = typeof options.index === \"number\" ? options.index : 0;\n  var serializationIndex = serializeInto(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined);\n  buffer.copy(finalBuffer, startIndex, 0, serializationIndex);\n  return startIndex + serializationIndex - 1;\n}\nfunction deserialize(buffer2, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return deserialize$1(buffer2 instanceof buffer_1 ? buffer2 : ensureBuffer(buffer2), options);\n}\nfunction calculateObjectSize(object, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  options = options || {};\n  var serializeFunctions = typeof options.serializeFunctions === \"boolean\" ? options.serializeFunctions : false;\n  var ignoreUndefined = typeof options.ignoreUndefined === \"boolean\" ? options.ignoreUndefined : true;\n  return calculateObjectSize$1(object, serializeFunctions, ignoreUndefined);\n}\nfunction deserializeStream(data, startIndex, numberOfDocuments, documents, docStartIndex, options) {\n  var internalOptions = Object.assign({ allowObjectSmallerThanBufferSize: true, index: 0 }, options);\n  var bufferData = ensureBuffer(data);\n  var index = startIndex;\n  for (var i = 0; i < numberOfDocuments; i++) {\n    var size = bufferData[index] | bufferData[index + 1] << 8 | bufferData[index + 2] << 16 | bufferData[index + 3] << 24;\n    internalOptions.index = index;\n    documents[docStartIndex + i] = deserialize$1(bufferData, internalOptions);\n    index = index + size;\n  }\n  return index;\n}\nvar BSON = {\n  Binary,\n  Code,\n  DBRef,\n  Decimal128,\n  Double,\n  Int32,\n  Long,\n  UUID,\n  Map: bsonMap,\n  MaxKey,\n  MinKey,\n  ObjectId,\n  ObjectID: ObjectId,\n  BSONRegExp,\n  BSONSymbol,\n  Timestamp,\n  EJSON,\n  setInternalBufferSize,\n  serialize,\n  serializeWithBufferAndIndex,\n  deserialize,\n  calculateObjectSize,\n  deserializeStream,\n  BSONError,\n  BSONTypeError\n};\nvar bson_browser_esm_default = BSON;\n\n// node_modules/realm-web/dist/bundle.dom.es.js\nvar __spreadArray = function(to, from, pack) {\n  if (pack || arguments.length === 2)\n    for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n        if (!ar)\n          ar = Array.prototype.slice.call(from, 0, i);\n        ar[i] = from[i];\n      }\n    }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar BrowserInfo = (\n  /** @class */\n  /* @__PURE__ */ function() {\n    function BrowserInfo2(name, version2, os) {\n      this.name = name;\n      this.version = version2;\n      this.os = os;\n      this.type = \"browser\";\n    }\n    return BrowserInfo2;\n  }()\n);\nvar NodeInfo = (\n  /** @class */\n  /* @__PURE__ */ function() {\n    function NodeInfo2(version2) {\n      this.version = version2;\n      this.type = \"node\";\n      this.name = \"node\";\n      this.os = process.platform;\n    }\n    return NodeInfo2;\n  }()\n);\nvar SearchBotDeviceInfo = (\n  /** @class */\n  /* @__PURE__ */ function() {\n    function SearchBotDeviceInfo2(name, version2, os, bot) {\n      this.name = name;\n      this.version = version2;\n      this.os = os;\n      this.bot = bot;\n      this.type = \"bot-device\";\n    }\n    return SearchBotDeviceInfo2;\n  }()\n);\nvar BotInfo = (\n  /** @class */\n  /* @__PURE__ */ function() {\n    function BotInfo2() {\n      this.type = \"bot\";\n      this.bot = true;\n      this.name = \"bot\";\n      this.version = null;\n      this.os = null;\n    }\n    return BotInfo2;\n  }()\n);\nvar ReactNativeInfo = (\n  /** @class */\n  /* @__PURE__ */ function() {\n    function ReactNativeInfo2() {\n      this.type = \"react-native\";\n      this.name = \"react-native\";\n      this.version = null;\n      this.os = null;\n    }\n    return ReactNativeInfo2;\n  }()\n);\nvar SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;\nvar SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\\ Jeeves\\/Teoma|ia_archiver)/;\nvar REQUIRED_VERSION_PARTS = 3;\nvar userAgentRules = [\n  [\"aol\", /AOLShield\\/([0-9\\._]+)/],\n  [\"edge\", /Edge\\/([0-9\\._]+)/],\n  [\"edge-ios\", /EdgiOS\\/([0-9\\._]+)/],\n  [\"yandexbrowser\", /YaBrowser\\/([0-9\\._]+)/],\n  [\"kakaotalk\", /KAKAOTALK\\s([0-9\\.]+)/],\n  [\"samsung\", /SamsungBrowser\\/([0-9\\.]+)/],\n  [\"silk\", /\\bSilk\\/([0-9._-]+)\\b/],\n  [\"miui\", /MiuiBrowser\\/([0-9\\.]+)$/],\n  [\"beaker\", /BeakerBrowser\\/([0-9\\.]+)/],\n  [\"edge-chromium\", /EdgA?\\/([0-9\\.]+)/],\n  [\n    \"chromium-webview\",\n    /(?!Chrom.*OPR)wv\\).*Chrom(?:e|ium)\\/([0-9\\.]+)(:?\\s|$)/\n  ],\n  [\"chrome\", /(?!Chrom.*OPR)Chrom(?:e|ium)\\/([0-9\\.]+)(:?\\s|$)/],\n  [\"phantomjs\", /PhantomJS\\/([0-9\\.]+)(:?\\s|$)/],\n  [\"crios\", /CriOS\\/([0-9\\.]+)(:?\\s|$)/],\n  [\"firefox\", /Firefox\\/([0-9\\.]+)(?:\\s|$)/],\n  [\"fxios\", /FxiOS\\/([0-9\\.]+)/],\n  [\"opera-mini\", /Opera Mini.*Version\\/([0-9\\.]+)/],\n  [\"opera\", /Opera\\/([0-9\\.]+)(?:\\s|$)/],\n  [\"opera\", /OPR\\/([0-9\\.]+)(:?\\s|$)/],\n  [\"ie\", /Trident\\/7\\.0.*rv\\:([0-9\\.]+).*\\).*Gecko$/],\n  [\"ie\", /MSIE\\s([0-9\\.]+);.*Trident\\/[4-7].0/],\n  [\"ie\", /MSIE\\s(7\\.0)/],\n  [\"bb10\", /BB10;\\sTouch.*Version\\/([0-9\\.]+)/],\n  [\"android\", /Android\\s([0-9\\.]+)/],\n  [\"ios\", /Version\\/([0-9\\._]+).*Mobile.*Safari.*/],\n  [\"safari\", /Version\\/([0-9\\._]+).*Safari/],\n  [\"facebook\", /FB[AS]V\\/([0-9\\.]+)/],\n  [\"instagram\", /Instagram\\s([0-9\\.]+)/],\n  [\"ios-webview\", /AppleWebKit\\/([0-9\\.]+).*Mobile/],\n  [\"ios-webview\", /AppleWebKit\\/([0-9\\.]+).*Gecko\\)$/],\n  [\"curl\", /^curl\\/([0-9\\.]+)$/],\n  [\"searchbot\", SEARCHBOX_UA_REGEX]\n];\nvar operatingSystemRules = [\n  [\"iOS\", /iP(hone|od|ad)/],\n  [\"Android OS\", /Android/],\n  [\"BlackBerry OS\", /BlackBerry|BB10/],\n  [\"Windows Mobile\", /IEMobile/],\n  [\"Amazon OS\", /Kindle/],\n  [\"Windows 3.11\", /Win16/],\n  [\"Windows 95\", /(Windows 95)|(Win95)|(Windows_95)/],\n  [\"Windows 98\", /(Windows 98)|(Win98)/],\n  [\"Windows 2000\", /(Windows NT 5.0)|(Windows 2000)/],\n  [\"Windows XP\", /(Windows NT 5.1)|(Windows XP)/],\n  [\"Windows Server 2003\", /(Windows NT 5.2)/],\n  [\"Windows Vista\", /(Windows NT 6.0)/],\n  [\"Windows 7\", /(Windows NT 6.1)/],\n  [\"Windows 8\", /(Windows NT 6.2)/],\n  [\"Windows 8.1\", /(Windows NT 6.3)/],\n  [\"Windows 10\", /(Windows NT 10.0)/],\n  [\"Windows ME\", /Windows ME/],\n  [\"Open BSD\", /OpenBSD/],\n  [\"Sun OS\", /SunOS/],\n  [\"Chrome OS\", /CrOS/],\n  [\"Linux\", /(Linux)|(X11)/],\n  [\"Mac OS\", /(Mac_PowerPC)|(Macintosh)/],\n  [\"QNX\", /QNX/],\n  [\"BeOS\", /BeOS/],\n  [\"OS/2\", /OS\\/2/]\n];\nfunction detect(userAgent) {\n  if (!!userAgent) {\n    return parseUserAgent(userAgent);\n  }\n  if (typeof document === \"undefined\" && typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\") {\n    return new ReactNativeInfo();\n  }\n  if (typeof navigator !== \"undefined\") {\n    return parseUserAgent(navigator.userAgent);\n  }\n  return getNodeVersion();\n}\nfunction matchUserAgent(ua) {\n  return ua !== \"\" && userAgentRules.reduce(function(matched, _a) {\n    var browser2 = _a[0], regex = _a[1];\n    if (matched) {\n      return matched;\n    }\n    var uaMatch = regex.exec(ua);\n    return !!uaMatch && [browser2, uaMatch];\n  }, false);\n}\nfunction parseUserAgent(ua) {\n  var matchedRule = matchUserAgent(ua);\n  if (!matchedRule) {\n    return null;\n  }\n  var name = matchedRule[0], match = matchedRule[1];\n  if (name === \"searchbot\") {\n    return new BotInfo();\n  }\n  var versionParts = match[1] && match[1].split(\".\").join(\"_\").split(\"_\").slice(0, 3);\n  if (versionParts) {\n    if (versionParts.length < REQUIRED_VERSION_PARTS) {\n      versionParts = __spreadArray(__spreadArray([], versionParts, true), createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length), true);\n    }\n  } else {\n    versionParts = [];\n  }\n  var version2 = versionParts.join(\".\");\n  var os = detectOS(ua);\n  var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);\n  if (searchBotMatch && searchBotMatch[1]) {\n    return new SearchBotDeviceInfo(name, version2, os, searchBotMatch[1]);\n  }\n  return new BrowserInfo(name, version2, os);\n}\nfunction detectOS(ua) {\n  for (var ii = 0, count = operatingSystemRules.length; ii < count; ii++) {\n    var _a = operatingSystemRules[ii], os = _a[0], regex = _a[1];\n    var match = regex.exec(ua);\n    if (match) {\n      return os;\n    }\n  }\n  return null;\n}\nfunction getNodeVersion() {\n  var isNode = typeof process !== \"undefined\" && process.version;\n  return isNode ? new NodeInfo(process.version.slice(1)) : null;\n}\nfunction createVersionParts(count) {\n  var output = [];\n  for (var ii = 0; ii < count; ii++) {\n    output.push(\"0\");\n  }\n  return output;\n}\nvar DefaultNetworkTransport = class _DefaultNetworkTransport {\n  constructor() {\n    if (!_DefaultNetworkTransport.fetch) {\n      throw new Error(\"DefaultNetworkTransport.fetch must be set before it's used\");\n    }\n    if (!_DefaultNetworkTransport.AbortController) {\n      throw new Error(\"DefaultNetworkTransport.AbortController must be set before it's used\");\n    }\n  }\n  fetchWithCallbacks(request, handler) {\n    this.fetch(request).then(async (response) => {\n      const decodedBody = await response.text();\n      const responseHeaders = {};\n      response.headers.forEach((value, key) => {\n        responseHeaders[key] = value;\n      });\n      return {\n        statusCode: response.status,\n        headers: responseHeaders,\n        body: decodedBody\n      };\n    }).then((r) => handler.onSuccess(r)).catch((e) => handler.onError(e));\n  }\n  async fetch(request) {\n    const { timeoutMs, url, ...rest } = request;\n    const { signal, cancelTimeout } = this.createTimeoutSignal(timeoutMs);\n    try {\n      return await _DefaultNetworkTransport.fetch(url, {\n        ..._DefaultNetworkTransport.extraFetchOptions,\n        signal,\n        ...rest\n      });\n    } finally {\n      cancelTimeout();\n    }\n  }\n  createTimeoutSignal(timeoutMs) {\n    if (typeof timeoutMs === \"number\") {\n      const controller = new _DefaultNetworkTransport.AbortController();\n      const timeout = setTimeout(() => {\n        controller.abort();\n      }, timeoutMs);\n      return {\n        signal: controller.signal,\n        cancelTimeout: () => {\n          clearTimeout(timeout);\n        }\n      };\n    } else {\n      return {\n        signal: void 0,\n        cancelTimeout: () => {\n        }\n      };\n    }\n  }\n};\nDefaultNetworkTransport.DEFAULT_HEADERS = {\n  \"Content-Type\": \"application/json\"\n};\nvar setIsDevelopmentMode = (state) => {\n};\nvar check = function(it) {\n  return it && it.Math == Math && it;\n};\nvar safeGlobalThis = (\n  // eslint-disable-next-line no-restricted-globals\n  check(typeof globalThis == \"object\" && globalThis) || check(typeof window == \"object\" && window) || // eslint-disable-next-line no-restricted-globals -- safe\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore allow `self`\n  check(typeof self == \"object\" && self) || // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore allow `global`\n  check(typeof global == \"object\" && global) || // eslint-disable-next-line no-new-func -- fallback\n  /* @__PURE__ */ function() {\n    return this;\n  }() || Function(\"return this\")()\n);\nsetIsDevelopmentMode(typeof __DEV__ !== \"undefined\" && __DEV__);\nDefaultNetworkTransport.fetch = safeGlobalThis.fetch.bind(safeGlobalThis);\nDefaultNetworkTransport.AbortController = safeGlobalThis.AbortController.bind(safeGlobalThis);\nvar version = \"3.7.2\";\nvar VERSION = version;\nvar _hasatob = typeof atob === \"function\";\nvar _hasbtoa = typeof btoa === \"function\";\nvar _hasBuffer = typeof Buffer === \"function\";\nvar _TD = typeof TextDecoder === \"function\" ? new TextDecoder() : void 0;\nvar _TE = typeof TextEncoder === \"function\" ? new TextEncoder() : void 0;\nvar b64ch = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\nvar b64chs = Array.prototype.slice.call(b64ch);\nvar b64tab = ((a) => {\n  let tab = {};\n  a.forEach((c, i) => tab[c] = i);\n  return tab;\n})(b64chs);\nvar b64re = /^(?:[A-Za-z\\d+\\/]{4})*?(?:[A-Za-z\\d+\\/]{2}(?:==)?|[A-Za-z\\d+\\/]{3}=?)?$/;\nvar _fromCC = String.fromCharCode.bind(String);\nvar _U8Afrom = typeof Uint8Array.from === \"function\" ? Uint8Array.from.bind(Uint8Array) : (it, fn = (x) => x) => new Uint8Array(Array.prototype.slice.call(it, 0).map(fn));\nvar _mkUriSafe = (src) => src.replace(/=/g, \"\").replace(/[+\\/]/g, (m0) => m0 == \"+\" ? \"-\" : \"_\");\nvar _tidyB64 = (s) => s.replace(/[^A-Za-z0-9\\+\\/]/g, \"\");\nvar btoaPolyfill = (bin) => {\n  let u32, c0, c1, c2, asc = \"\";\n  const pad = bin.length % 3;\n  for (let i = 0; i < bin.length; ) {\n    if ((c0 = bin.charCodeAt(i++)) > 255 || (c1 = bin.charCodeAt(i++)) > 255 || (c2 = bin.charCodeAt(i++)) > 255)\n      throw new TypeError(\"invalid character found\");\n    u32 = c0 << 16 | c1 << 8 | c2;\n    asc += b64chs[u32 >> 18 & 63] + b64chs[u32 >> 12 & 63] + b64chs[u32 >> 6 & 63] + b64chs[u32 & 63];\n  }\n  return pad ? asc.slice(0, pad - 3) + \"===\".substring(pad) : asc;\n};\nvar _btoa = _hasbtoa ? (bin) => btoa(bin) : _hasBuffer ? (bin) => Buffer.from(bin, \"binary\").toString(\"base64\") : btoaPolyfill;\nvar _fromUint8Array = _hasBuffer ? (u8a) => Buffer.from(u8a).toString(\"base64\") : (u8a) => {\n  const maxargs = 4096;\n  let strs = [];\n  for (let i = 0, l = u8a.length; i < l; i += maxargs) {\n    strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));\n  }\n  return _btoa(strs.join(\"\"));\n};\nvar fromUint8Array = (u8a, urlsafe = false) => urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);\nvar cb_utob = (c) => {\n  if (c.length < 2) {\n    var cc = c.charCodeAt(0);\n    return cc < 128 ? c : cc < 2048 ? _fromCC(192 | cc >>> 6) + _fromCC(128 | cc & 63) : _fromCC(224 | cc >>> 12 & 15) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);\n  } else {\n    var cc = 65536 + (c.charCodeAt(0) - 55296) * 1024 + (c.charCodeAt(1) - 56320);\n    return _fromCC(240 | cc >>> 18 & 7) + _fromCC(128 | cc >>> 12 & 63) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);\n  }\n};\nvar re_utob = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFFF]|[^\\x00-\\x7F]/g;\nvar utob = (u) => u.replace(re_utob, cb_utob);\nvar _encode = _hasBuffer ? (s) => Buffer.from(s, \"utf8\").toString(\"base64\") : _TE ? (s) => _fromUint8Array(_TE.encode(s)) : (s) => _btoa(utob(s));\nvar encode = (src, urlsafe = false) => urlsafe ? _mkUriSafe(_encode(src)) : _encode(src);\nvar encodeURI = (src) => encode(src, true);\nvar re_btou = /[\\xC0-\\xDF][\\x80-\\xBF]|[\\xE0-\\xEF][\\x80-\\xBF]{2}|[\\xF0-\\xF7][\\x80-\\xBF]{3}/g;\nvar cb_btou = (cccc) => {\n  switch (cccc.length) {\n    case 4:\n      var cp = (7 & cccc.charCodeAt(0)) << 18 | (63 & cccc.charCodeAt(1)) << 12 | (63 & cccc.charCodeAt(2)) << 6 | 63 & cccc.charCodeAt(3), offset = cp - 65536;\n      return _fromCC((offset >>> 10) + 55296) + _fromCC((offset & 1023) + 56320);\n    case 3:\n      return _fromCC((15 & cccc.charCodeAt(0)) << 12 | (63 & cccc.charCodeAt(1)) << 6 | 63 & cccc.charCodeAt(2));\n    default:\n      return _fromCC((31 & cccc.charCodeAt(0)) << 6 | 63 & cccc.charCodeAt(1));\n  }\n};\nvar btou = (b) => b.replace(re_btou, cb_btou);\nvar atobPolyfill = (asc) => {\n  asc = asc.replace(/\\s+/g, \"\");\n  if (!b64re.test(asc))\n    throw new TypeError(\"malformed base64.\");\n  asc += \"==\".slice(2 - (asc.length & 3));\n  let u24, bin = \"\", r1, r2;\n  for (let i = 0; i < asc.length; ) {\n    u24 = b64tab[asc.charAt(i++)] << 18 | b64tab[asc.charAt(i++)] << 12 | (r1 = b64tab[asc.charAt(i++)]) << 6 | (r2 = b64tab[asc.charAt(i++)]);\n    bin += r1 === 64 ? _fromCC(u24 >> 16 & 255) : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255) : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);\n  }\n  return bin;\n};\nvar _atob = _hasatob ? (asc) => atob(_tidyB64(asc)) : _hasBuffer ? (asc) => Buffer.from(asc, \"base64\").toString(\"binary\") : atobPolyfill;\nvar _toUint8Array = _hasBuffer ? (a) => _U8Afrom(Buffer.from(a, \"base64\")) : (a) => _U8Afrom(_atob(a), (c) => c.charCodeAt(0));\nvar toUint8Array = (a) => _toUint8Array(_unURI(a));\nvar _decode = _hasBuffer ? (a) => Buffer.from(a, \"base64\").toString(\"utf8\") : _TD ? (a) => _TD.decode(_toUint8Array(a)) : (a) => btou(_atob(a));\nvar _unURI = (a) => _tidyB64(a.replace(/[-_]/g, (m0) => m0 == \"-\" ? \"+\" : \"/\"));\nvar decode = (src) => _decode(_unURI(src));\nvar isValid = (src) => {\n  if (typeof src !== \"string\")\n    return false;\n  const s = src.replace(/\\s+/g, \"\").replace(/={0,2}$/, \"\");\n  return !/[^\\s0-9a-zA-Z\\+/]/.test(s) || !/[^\\s0-9a-zA-Z\\-_]/.test(s);\n};\nvar _noEnum = (v) => {\n  return {\n    value: v,\n    enumerable: false,\n    writable: true,\n    configurable: true\n  };\n};\nvar extendString = function() {\n  const _add = (name, body) => Object.defineProperty(String.prototype, name, _noEnum(body));\n  _add(\"fromBase64\", function() {\n    return decode(this);\n  });\n  _add(\"toBase64\", function(urlsafe) {\n    return encode(this, urlsafe);\n  });\n  _add(\"toBase64URI\", function() {\n    return encode(this, true);\n  });\n  _add(\"toBase64URL\", function() {\n    return encode(this, true);\n  });\n  _add(\"toUint8Array\", function() {\n    return toUint8Array(this);\n  });\n};\nvar extendUint8Array = function() {\n  const _add = (name, body) => Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));\n  _add(\"toBase64\", function(urlsafe) {\n    return fromUint8Array(this, urlsafe);\n  });\n  _add(\"toBase64URI\", function() {\n    return fromUint8Array(this, true);\n  });\n  _add(\"toBase64URL\", function() {\n    return fromUint8Array(this, true);\n  });\n};\nvar extendBuiltins = () => {\n  extendString();\n  extendUint8Array();\n};\nvar gBase64 = {\n  version,\n  VERSION,\n  atob: _atob,\n  atobPolyfill,\n  btoa: _btoa,\n  btoaPolyfill,\n  fromBase64: decode,\n  toBase64: encode,\n  encode,\n  encodeURI,\n  encodeURL: encodeURI,\n  utob,\n  btou,\n  decode,\n  isValid,\n  fromUint8Array,\n  toUint8Array,\n  extendString,\n  extendUint8Array,\n  extendBuiltins\n};\nvar SERIALIZATION_OPTIONS = {\n  relaxed: false\n  // Ensure Canonical mode\n};\nfunction serialize2(obj) {\n  return EJSON.serialize(obj, SERIALIZATION_OPTIONS);\n}\nfunction deserialize2(obj) {\n  if (Array.isArray(obj)) {\n    return obj.map((doc) => EJSON.deserialize(doc));\n  } else {\n    return EJSON.deserialize(obj);\n  }\n}\nvar UserType;\n(function(UserType2) {\n  UserType2[\"Normal\"] = \"normal\";\n  UserType2[\"Server\"] = \"server\";\n})(UserType || (UserType = {}));\nvar DataKey;\n(function(DataKey2) {\n  DataKey2[\"NAME\"] = \"name\";\n  DataKey2[\"EMAIL\"] = \"email\";\n  DataKey2[\"PICTURE\"] = \"picture\";\n  DataKey2[\"FIRST_NAME\"] = \"first_name\";\n  DataKey2[\"LAST_NAME\"] = \"last_name\";\n  DataKey2[\"GENDER\"] = \"gender\";\n  DataKey2[\"BIRTHDAY\"] = \"birthday\";\n  DataKey2[\"MIN_AGE\"] = \"min_age\";\n  DataKey2[\"MAX_AGE\"] = \"max_age\";\n})(DataKey || (DataKey = {}));\nvar DATA_MAPPING = {\n  [DataKey.NAME]: \"name\",\n  [DataKey.EMAIL]: \"email\",\n  [DataKey.PICTURE]: \"pictureUrl\",\n  [DataKey.FIRST_NAME]: \"firstName\",\n  [DataKey.LAST_NAME]: \"lastName\",\n  [DataKey.GENDER]: \"gender\",\n  [DataKey.BIRTHDAY]: \"birthday\",\n  [DataKey.MIN_AGE]: \"minAge\",\n  [DataKey.MAX_AGE]: \"maxAge\"\n};\nvar UserProfile = class {\n  /**\n   * @param response The response of a call fetching the users profile.\n   */\n  constructor(response) {\n    this.type = UserType.Normal;\n    this.identities = [];\n    if (typeof response === \"object\" && response !== null) {\n      const { type, identities, data } = response;\n      if (typeof type === \"string\") {\n        this.type = type;\n      } else {\n        throw new Error(\"Expected 'type' in the response body\");\n      }\n      if (Array.isArray(identities)) {\n        this.identities = identities.map((identity) => {\n          const { id, provider_type: providerType } = identity;\n          return { id, providerType };\n        });\n      } else {\n        throw new Error(\"Expected 'identities' in the response body\");\n      }\n      if (typeof data === \"object\" && data !== null) {\n        const mappedData = Object.fromEntries(Object.entries(data).map(([key, value]) => {\n          if (key in DATA_MAPPING) {\n            return [DATA_MAPPING[key], value];\n          } else {\n            return [key, value];\n          }\n        }));\n        this.data = deserialize2(mappedData);\n      } else {\n        throw new Error(\"Expected 'data' in the response body\");\n      }\n    } else {\n      this.data = {};\n    }\n  }\n};\nvar PrefixedStorage = class _PrefixedStorage {\n  /**\n   * Construct a `Storage` which will prefix a key part to every operation.\n   *\n   * @param storage The underlying storage to use for operations.\n   * @param keyPart The part of the key to prefix when performing operations.\n   */\n  constructor(storage, keyPart) {\n    this.storage = storage;\n    this.keyPart = keyPart;\n  }\n  /** @inheritdoc */\n  get(key) {\n    return this.storage.get(this.keyPart + _PrefixedStorage.PART_SEPARATOR + key);\n  }\n  /** @inheritdoc */\n  set(key, value) {\n    return this.storage.set(this.keyPart + _PrefixedStorage.PART_SEPARATOR + key, value);\n  }\n  /** @inheritdoc */\n  remove(key) {\n    return this.storage.remove(this.keyPart + _PrefixedStorage.PART_SEPARATOR + key);\n  }\n  /** @inheritdoc */\n  prefix(keyPart) {\n    return new _PrefixedStorage(this, keyPart);\n  }\n  /** @inheritdoc */\n  clear(prefix = \"\") {\n    return this.storage.clear(this.keyPart + _PrefixedStorage.PART_SEPARATOR + prefix);\n  }\n  /** @inheritdoc */\n  addListener(listener) {\n    return this.storage.addListener(listener);\n  }\n  /** @inheritdoc */\n  removeListener(listener) {\n    return this.storage.addListener(listener);\n  }\n};\nPrefixedStorage.PART_SEPARATOR = \":\";\nvar MemoryStorage = class {\n  constructor() {\n    this.storage = {};\n    this.listeners = /* @__PURE__ */ new Set();\n  }\n  /** @inheritdoc */\n  get(key) {\n    if (key in this.storage) {\n      return this.storage[key];\n    } else {\n      return null;\n    }\n  }\n  /** @inheritdoc */\n  set(key, value) {\n    this.storage[key] = value;\n    this.fireListeners();\n  }\n  /** @inheritdoc */\n  remove(key) {\n    delete this.storage[key];\n    this.fireListeners();\n  }\n  /** @inheritdoc */\n  prefix(keyPart) {\n    return new PrefixedStorage(this, keyPart);\n  }\n  /** @inheritdoc */\n  clear(prefix) {\n    for (const key of Object.keys(this.storage)) {\n      if (!prefix || key.startsWith(prefix)) {\n        delete this.storage[key];\n      }\n    }\n    this.fireListeners();\n  }\n  /** @inheritdoc */\n  addListener(listener) {\n    this.listeners.add(listener);\n  }\n  /** @inheritdoc */\n  removeListener(listener) {\n    this.listeners.delete(listener);\n  }\n  /**\n   * Tell the listeners that a change occurred.\n   */\n  fireListeners() {\n    this.listeners.forEach((listener) => listener());\n  }\n};\nvar ACCESS_TOKEN_STORAGE_KEY = \"accessToken\";\nvar REFRESH_TOKEN_STORAGE_KEY = \"refreshToken\";\nvar PROFILE_STORAGE_KEY = \"profile\";\nvar PROVIDER_TYPE_STORAGE_KEY = \"providerType\";\nvar UserStorage = class extends PrefixedStorage {\n  /**\n   * Construct a storage for a `User`.\n   *\n   * @param storage The underlying storage to wrap.\n   * @param userId The id of the user.\n   */\n  constructor(storage, userId) {\n    super(storage, `user(${userId})`);\n  }\n  /**\n   * Get the access token from storage.\n   *\n   * @returns Access token (null if unknown).\n   */\n  get accessToken() {\n    return this.get(ACCESS_TOKEN_STORAGE_KEY);\n  }\n  /**\n   * Set the access token in storage.\n   *\n   * @param value Access token (null if unknown).\n   */\n  set accessToken(value) {\n    if (value === null) {\n      this.remove(ACCESS_TOKEN_STORAGE_KEY);\n    } else {\n      this.set(ACCESS_TOKEN_STORAGE_KEY, value);\n    }\n  }\n  /**\n   * Get the refresh token from storage.\n   *\n   * @returns Refresh token (null if unknown and user is logged out).\n   */\n  get refreshToken() {\n    return this.get(REFRESH_TOKEN_STORAGE_KEY);\n  }\n  /**\n   * Set the refresh token in storage.\n   *\n   * @param value Refresh token (null if unknown and user is logged out).\n   */\n  set refreshToken(value) {\n    if (value === null) {\n      this.remove(REFRESH_TOKEN_STORAGE_KEY);\n    } else {\n      this.set(REFRESH_TOKEN_STORAGE_KEY, value);\n    }\n  }\n  /**\n   * Get the user profile from storage.\n   *\n   * @returns User profile (undefined if its unknown).\n   */\n  get profile() {\n    const value = this.get(PROFILE_STORAGE_KEY);\n    if (value) {\n      const profile = new UserProfile();\n      Object.assign(profile, JSON.parse(value));\n      return profile;\n    }\n  }\n  /**\n   * Set the user profile in storage.\n   *\n   * @param value User profile (undefined if its unknown).\n   */\n  set profile(value) {\n    if (value) {\n      this.set(PROFILE_STORAGE_KEY, JSON.stringify(value));\n    } else {\n      this.remove(PROFILE_STORAGE_KEY);\n    }\n  }\n  /**\n   * Get the type of authentication provider used to authenticate\n   *\n   * @returns User profile (undefined if its unknown).\n   */\n  get providerType() {\n    const value = this.get(PROVIDER_TYPE_STORAGE_KEY);\n    if (value) {\n      return value;\n    }\n  }\n  /**\n   * Set the type of authentication provider used to authenticate\n   *\n   * @param value Type of authentication provider.\n   */\n  set providerType(value) {\n    if (value) {\n      this.set(PROVIDER_TYPE_STORAGE_KEY, value);\n    } else {\n      this.remove(PROVIDER_TYPE_STORAGE_KEY);\n    }\n  }\n};\nfunction removeKeysWithUndefinedValues(obj) {\n  return Object.fromEntries(Object.entries(obj).filter((entry) => typeof entry[1] !== \"undefined\"));\n}\nfunction generateRandomString(length, alphabet) {\n  let result = \"\";\n  for (let i = 0; i < length; i++) {\n    result += alphabet[Math.floor(Math.random() * alphabet.length)];\n  }\n  return result;\n}\nfunction encodeQueryString(params, prefixed = true) {\n  const cleanedParams = removeKeysWithUndefinedValues(params);\n  const prefix = prefixed && Object.keys(cleanedParams).length > 0 ? \"?\" : \"\";\n  return prefix + Object.entries(cleanedParams).map(([k, v]) => `${k}=${encodeURIComponent(v)}`).join(\"&\");\n}\nfunction decodeQueryString(str) {\n  const cleanStr = str[0] === \"?\" ? str.substr(1) : str;\n  return Object.fromEntries(cleanStr.split(\"&\").filter((s) => s.length > 0).map((kvp) => kvp.split(\"=\")).map(([k, v]) => [k, decodeURIComponent(v)]));\n}\nvar RESERVED_NAMES = [\n  \"inspect\",\n  \"callFunction\",\n  \"callFunctionStreaming\",\n  // Methods defined on the Object.prototype might be \"typeof probed\" and called by libraries and runtime environments.\n  ...Object.getOwnPropertyNames(Object.prototype)\n];\nfunction cleanArgs(args) {\n  for (const arg of args) {\n    if (typeof arg === \"object\" && arg) {\n      for (const [key, value] of Object.entries(arg)) {\n        if (value === void 0) {\n          delete arg[key];\n        }\n      }\n    }\n  }\n  return args;\n}\nfunction cleanArgsAndSerialize(args) {\n  const cleaned = cleanArgs(args);\n  return cleaned.map((arg) => typeof arg === \"object\" ? serialize2(arg) : arg);\n}\nvar FunctionsFactory = class _FunctionsFactory {\n  /**\n   * @param fetcher The underlying fetcher to use when sending requests.\n   * @param config Additional configuration parameters.\n   */\n  constructor(fetcher, config = {}) {\n    this.fetcher = fetcher;\n    this.serviceName = config.serviceName;\n    this.argsTransformation = config.argsTransformation || cleanArgsAndSerialize;\n  }\n  /**\n   * Create a factory of functions, wrapped in a Proxy that returns bound copies of `callFunction` on any property.\n   *\n   * @param fetcher The underlying fetcher to use when requesting.\n   * @param config Additional configuration parameters.\n   * @returns The newly created factory of functions.\n   */\n  static create(fetcher, config = {}) {\n    const factory = new _FunctionsFactory(fetcher, config);\n    return new Proxy(factory, {\n      get(target, p, receiver) {\n        if (typeof p === \"string\" && RESERVED_NAMES.indexOf(p) === -1) {\n          return target.callFunction.bind(target, p);\n        } else {\n          const prop = Reflect.get(target, p, receiver);\n          return typeof prop === \"function\" ? prop.bind(target) : prop;\n        }\n      }\n    });\n  }\n  /**\n   * Call a remote function by it's name.\n   *\n   * @param name Name of the remote function.\n   * @param args Arguments to pass to the remote function.\n   * @returns A promise of the value returned when executing the remote function.\n   */\n  async callFunction(name, ...args) {\n    const body = {\n      name,\n      arguments: this.argsTransformation ? this.argsTransformation(args) : args\n    };\n    if (this.serviceName) {\n      body.service = this.serviceName;\n    }\n    const appRoute = this.fetcher.appRoute;\n    return this.fetcher.fetchJSON({\n      method: \"POST\",\n      path: appRoute.functionsCall().path,\n      body\n    });\n  }\n  /**\n   * Call a remote function by it's name.\n   *\n   * @param name Name of the remote function.\n   * @param args Arguments to pass to the remote function.\n   * @returns A promise of the value returned when executing the remote function.\n   */\n  callFunctionStreaming(name, ...args) {\n    const body = {\n      name,\n      arguments: this.argsTransformation ? this.argsTransformation(args) : args\n    };\n    if (this.serviceName) {\n      body.service = this.serviceName;\n    }\n    const appRoute = this.fetcher.appRoute;\n    const qs = encodeQueryString({\n      [\"baas_request\"]: gBase64.encode(JSON.stringify(body))\n    });\n    return this.fetcher.fetchStream({\n      method: \"GET\",\n      path: appRoute.functionsCall().path + qs\n    });\n  }\n};\nvar EmailPasswordAuth = class {\n  /**\n   * Construct an interface to the email / password authentication provider.\n   *\n   * @param fetcher The underlying fetcher used to request the services.\n   * @param providerName Optional custom name of the authentication provider.\n   */\n  constructor(fetcher, providerName = \"local-userpass\") {\n    this.fetcher = fetcher;\n    this.providerName = providerName;\n  }\n  /** @inheritdoc */\n  async registerUser(details) {\n    const appRoute = this.fetcher.appRoute;\n    await this.fetcher.fetchJSON({\n      method: \"POST\",\n      path: appRoute.emailPasswordAuth(this.providerName).register().path,\n      body: details\n    });\n  }\n  /** @inheritdoc */\n  async confirmUser(details) {\n    const appRoute = this.fetcher.appRoute;\n    await this.fetcher.fetchJSON({\n      method: \"POST\",\n      path: appRoute.emailPasswordAuth(this.providerName).confirm().path,\n      body: details\n    });\n  }\n  /** @inheritdoc */\n  async resendConfirmationEmail(details) {\n    const appRoute = this.fetcher.appRoute;\n    await this.fetcher.fetchJSON({\n      method: \"POST\",\n      path: appRoute.emailPasswordAuth(this.providerName).confirmSend().path,\n      body: details\n    });\n  }\n  /** @inheritdoc */\n  async retryCustomConfirmation(details) {\n    const appRoute = this.fetcher.appRoute;\n    await this.fetcher.fetchJSON({\n      method: \"POST\",\n      path: appRoute.emailPasswordAuth(this.providerName).confirmCall().path,\n      body: details\n    });\n  }\n  /** @inheritdoc */\n  async resetPassword(details) {\n    const appRoute = this.fetcher.appRoute;\n    await this.fetcher.fetchJSON({\n      method: \"POST\",\n      path: appRoute.emailPasswordAuth(this.providerName).reset().path,\n      body: details\n    });\n  }\n  /** @inheritdoc */\n  async sendResetPasswordEmail(details) {\n    const appRoute = this.fetcher.appRoute;\n    await this.fetcher.fetchJSON({\n      method: \"POST\",\n      path: appRoute.emailPasswordAuth(this.providerName).resetSend().path,\n      body: details\n    });\n  }\n  /** @inheritdoc */\n  async callResetPasswordFunction(details, ...args) {\n    const appRoute = this.fetcher.appRoute;\n    await this.fetcher.fetchJSON({\n      method: \"POST\",\n      path: appRoute.emailPasswordAuth(this.providerName).resetCall().path,\n      body: { ...details, arguments: args }\n    });\n  }\n};\nfunction api() {\n  return {\n    path: \"/api/client/v2.0\",\n    /**\n     * @param appId The id of the app.\n     * @returns The URL of the app endpoint.\n     */\n    app(appId) {\n      return {\n        path: this.path + `/app/${appId}`,\n        /**\n         * @returns The URL of the app location endpoint.\n         */\n        location() {\n          return {\n            path: this.path + \"/location\"\n          };\n        },\n        /**\n         * @param providerName The name of the provider.\n         * @returns The app url concatinated with the /auth/providers/{providerName}\n         */\n        authProvider(providerName) {\n          return {\n            path: this.path + `/auth/providers/${providerName}`,\n            /**\n             * @returns Get the URL of an authentication provider.\n             */\n            login() {\n              return { path: this.path + \"/login\" };\n            }\n          };\n        },\n        /**\n         * @param providerName The name of the provider.\n         * @returns The app url concatinated with the /auth/providers/{providerName}\n         */\n        emailPasswordAuth(providerName) {\n          const authProviderRoutes = this.authProvider(providerName);\n          return {\n            ...authProviderRoutes,\n            register() {\n              return { path: this.path + \"/register\" };\n            },\n            confirm() {\n              return { path: this.path + \"/confirm\" };\n            },\n            confirmSend() {\n              return { path: this.path + \"/confirm/send\" };\n            },\n            confirmCall() {\n              return { path: this.path + \"/confirm/call\" };\n            },\n            reset() {\n              return { path: this.path + \"/reset\" };\n            },\n            resetSend() {\n              return { path: this.path + \"/reset/send\" };\n            },\n            resetCall() {\n              return { path: this.path + \"/reset/call\" };\n            }\n          };\n        },\n        functionsCall() {\n          return {\n            path: this.path + \"/functions/call\"\n          };\n        }\n      };\n    },\n    auth() {\n      return {\n        path: this.path + \"/auth\",\n        apiKeys() {\n          return {\n            path: this.path + \"/api_keys\",\n            key(id) {\n              return {\n                path: this.path + `/${id}`,\n                enable() {\n                  return { path: this.path + \"/enable\" };\n                },\n                disable() {\n                  return { path: this.path + \"/disable\" };\n                }\n              };\n            }\n          };\n        },\n        profile() {\n          return { path: this.path + \"/profile\" };\n        },\n        session() {\n          return { path: this.path + \"/session\" };\n        },\n        delete() {\n          return { path: this.path + \"/delete\" };\n        }\n      };\n    }\n  };\n}\nvar routes = { api };\nvar ApiKeyAuth = class {\n  /**\n   * Construct an interface to the API-key authentication provider.\n   *\n   * @param fetcher The fetcher used to send requests to services.\n   */\n  constructor(fetcher) {\n    this.fetcher = fetcher;\n  }\n  /** @inheritdoc */\n  create(name) {\n    return this.fetcher.fetchJSON({\n      method: \"POST\",\n      body: { name },\n      path: routes.api().auth().apiKeys().path,\n      tokenType: \"refresh\"\n    });\n  }\n  /** @inheritdoc */\n  fetch(keyId) {\n    return this.fetcher.fetchJSON({\n      method: \"GET\",\n      path: routes.api().auth().apiKeys().key(keyId).path,\n      tokenType: \"refresh\"\n    });\n  }\n  /** @inheritdoc */\n  fetchAll() {\n    return this.fetcher.fetchJSON({\n      method: \"GET\",\n      tokenType: \"refresh\",\n      path: routes.api().auth().apiKeys().path\n    });\n  }\n  /** @inheritdoc */\n  async delete(keyId) {\n    await this.fetcher.fetchJSON({\n      method: \"DELETE\",\n      path: routes.api().auth().apiKeys().key(keyId).path,\n      tokenType: \"refresh\"\n    });\n  }\n  /** @inheritdoc */\n  async enable(keyId) {\n    await this.fetcher.fetchJSON({\n      method: \"PUT\",\n      path: routes.api().auth().apiKeys().key(keyId).enable().path,\n      tokenType: \"refresh\"\n    });\n  }\n  /** @inheritdoc */\n  async disable(keyId) {\n    await this.fetcher.fetchJSON({\n      method: \"PUT\",\n      path: routes.api().auth().apiKeys().key(keyId).disable().path,\n      tokenType: \"refresh\"\n    });\n  }\n};\nvar environment = null;\nfunction setEnvironment(e) {\n  environment = e;\n}\nfunction getEnvironment() {\n  if (environment) {\n    return environment;\n  } else {\n    throw new Error(\"Cannot get environment before it's set\");\n  }\n}\nvar WatchError = class extends Error {\n  constructor({ message, code: code2 }) {\n    super(message);\n    this.name = \"WatchError\";\n    this.code = code2;\n  }\n};\nvar WatchStreamState;\n(function(WatchStreamState2) {\n  WatchStreamState2[\"NEED_DATA\"] = \"NEED_DATA\";\n  WatchStreamState2[\"HAVE_EVENT\"] = \"HAVE_EVENT\";\n  WatchStreamState2[\"HAVE_ERROR\"] = \"HAVE_ERROR\";\n})(WatchStreamState || (WatchStreamState = {}));\nvar WatchStream = class {\n  constructor() {\n    this._state = WatchStreamState.NEED_DATA;\n    this._error = null;\n    this._textDecoder = new (getEnvironment()).TextDecoder();\n    this._buffer = \"\";\n    this._bufferOffset = 0;\n    this._eventType = \"\";\n    this._dataBuffer = \"\";\n  }\n  // Call these when you have data, in whatever shape is easiest for your SDK to get.\n  // Pick one, mixing and matching on a single instance isn't supported.\n  // These can only be called in NEED_DATA state, which is the initial state.\n  feedBuffer(buffer2) {\n    this.assertState(WatchStreamState.NEED_DATA);\n    this._buffer += this._textDecoder.decode(buffer2, { stream: true });\n    this.advanceBufferState();\n  }\n  feedLine(line) {\n    this.assertState(WatchStreamState.NEED_DATA);\n    if (line.endsWith(\"\\n\"))\n      line = line.substr(0, line.length - 1);\n    if (line.endsWith(\"\\r\"))\n      line = line.substr(0, line.length - 1);\n    if (line.length === 0) {\n      if (this._dataBuffer.length === 0) {\n        this._eventType = \"\";\n        return;\n      }\n      if (this._dataBuffer.endsWith(\"\\n\"))\n        this._dataBuffer = this._dataBuffer.substr(0, this._dataBuffer.length - 1);\n      this.feedSse({\n        data: this._dataBuffer,\n        eventType: this._eventType\n      });\n      this._dataBuffer = \"\";\n      this._eventType = \"\";\n    }\n    if (line[0] === \":\")\n      return;\n    const colon = line.indexOf(\":\");\n    const field = line.substr(0, colon);\n    let value = colon === -1 ? \"\" : line.substr(colon + 1);\n    if (value.startsWith(\" \"))\n      value = value.substr(1);\n    if (field === \"event\") {\n      this._eventType = value;\n    } else if (field === \"data\") {\n      this._dataBuffer += value;\n      this._dataBuffer += \"\\n\";\n    } else\n      ;\n  }\n  feedSse(sse) {\n    this.assertState(WatchStreamState.NEED_DATA);\n    const firstPercentIndex = sse.data.indexOf(\"%\");\n    if (firstPercentIndex !== -1) {\n      let buffer2 = \"\";\n      let start = 0;\n      for (let percentIndex = firstPercentIndex; percentIndex !== -1; percentIndex = sse.data.indexOf(\"%\", start)) {\n        buffer2 += sse.data.substr(start, percentIndex - start);\n        const encoded = sse.data.substr(percentIndex, 3);\n        if (encoded === \"%25\") {\n          buffer2 += \"%\";\n        } else if (encoded === \"%0A\") {\n          buffer2 += \"\\n\";\n        } else if (encoded === \"%0D\") {\n          buffer2 += \"\\r\";\n        } else {\n          buffer2 += encoded;\n        }\n        start = percentIndex + encoded.length;\n      }\n      buffer2 += sse.data.substr(start);\n      sse.data = buffer2;\n    }\n    if (!sse.eventType || sse.eventType === \"message\") {\n      try {\n        const parsed = EJSON.parse(sse.data);\n        if (typeof parsed === \"object\") {\n          this._nextEvent = parsed;\n          this._state = WatchStreamState.HAVE_EVENT;\n          return;\n        }\n      } catch {\n      }\n      this._state = WatchStreamState.HAVE_ERROR;\n      this._error = new WatchError({\n        message: \"server returned malformed event: \" + sse.data,\n        code: \"bad bson parse\"\n      });\n    } else if (sse.eventType === \"error\") {\n      this._state = WatchStreamState.HAVE_ERROR;\n      this._error = new WatchError({\n        message: sse.data,\n        code: \"unknown\"\n      });\n      try {\n        const { error_code: errorCode, error } = EJSON.parse(sse.data);\n        if (typeof errorCode !== \"string\")\n          return;\n        if (typeof error !== \"string\")\n          return;\n        this._error = new WatchError({\n          message: error,\n          code: errorCode\n        });\n      } catch {\n        return;\n      }\n    } else\n      ;\n  }\n  get state() {\n    return this._state;\n  }\n  // Consumes the returned event. If you used feedBuffer(), there may be another event or error after this one,\n  // so you need to call state() again to see what to do next.\n  nextEvent() {\n    this.assertState(WatchStreamState.HAVE_EVENT);\n    const out = this._nextEvent;\n    this._state = WatchStreamState.NEED_DATA;\n    this.advanceBufferState();\n    return out;\n  }\n  // Once this enters the error state, it stays that way. You should not feed any more data.\n  get error() {\n    return this._error;\n  }\n  ////////////////////////////////////////////\n  advanceBufferState() {\n    this.assertState(WatchStreamState.NEED_DATA);\n    while (this.state === WatchStreamState.NEED_DATA) {\n      if (this._bufferOffset === this._buffer.length) {\n        this._buffer = \"\";\n        this._bufferOffset = 0;\n        return;\n      }\n      const nextNewlineIndex = this._buffer.indexOf(\"\\n\", this._bufferOffset);\n      if (nextNewlineIndex === -1) {\n        if (this._bufferOffset !== 0) {\n          this._buffer = this._buffer.substr(this._bufferOffset, this._buffer.length - this._bufferOffset);\n          this._bufferOffset = 0;\n        }\n        return;\n      }\n      this.feedLine(this._buffer.substr(this._bufferOffset, nextNewlineIndex - this._bufferOffset));\n      this._bufferOffset = nextNewlineIndex + 1;\n    }\n  }\n  assertState(state) {\n    if (this._state !== state) {\n      throw Error(`Expected WatchStream to be in state ${state}, but in state ${this._state}`);\n    }\n  }\n};\nvar MongoDBCollection = class {\n  /**\n   * Construct a remote collection of documents.\n   *\n   * @param fetcher The fetcher to use when requesting the service.\n   * @param serviceName The name of the remote service.\n   * @param databaseName The name of the database.\n   * @param collectionName The name of the remote collection.\n   */\n  constructor(fetcher, serviceName, databaseName, collectionName) {\n    this.functions = FunctionsFactory.create(fetcher, {\n      serviceName\n    });\n    this.databaseName = databaseName;\n    this.collectionName = collectionName;\n    this.serviceName = serviceName;\n    this.fetcher = fetcher;\n  }\n  /** @inheritdoc */\n  find(filter = {}, options = {}) {\n    return this.functions.find({\n      database: this.databaseName,\n      collection: this.collectionName,\n      query: filter,\n      project: options.projection,\n      sort: options.sort,\n      limit: options.limit\n    });\n  }\n  /** @inheritdoc */\n  findOne(filter = {}, options = {}) {\n    return this.functions.findOne({\n      database: this.databaseName,\n      collection: this.collectionName,\n      query: filter,\n      project: options.projection,\n      sort: options.sort\n    });\n  }\n  /** @inheritdoc */\n  findOneAndUpdate(filter = {}, update, options = {}) {\n    return this.functions.findOneAndUpdate({\n      database: this.databaseName,\n      collection: this.collectionName,\n      filter,\n      update,\n      sort: options.sort,\n      projection: options.projection,\n      upsert: options.upsert,\n      returnNewDocument: options.returnNewDocument\n    });\n  }\n  /** @inheritdoc */\n  findOneAndReplace(filter = {}, replacement, options = {}) {\n    return this.functions.findOneAndReplace({\n      database: this.databaseName,\n      collection: this.collectionName,\n      filter,\n      update: replacement,\n      sort: options.sort,\n      projection: options.projection,\n      upsert: options.upsert,\n      returnNewDocument: options.returnNewDocument\n    });\n  }\n  /** @inheritdoc */\n  findOneAndDelete(filter = {}, options = {}) {\n    return this.functions.findOneAndReplace({\n      database: this.databaseName,\n      collection: this.collectionName,\n      filter,\n      sort: options.sort,\n      projection: options.projection\n    });\n  }\n  /** @inheritdoc */\n  aggregate(pipeline) {\n    return this.functions.aggregate({\n      database: this.databaseName,\n      collection: this.collectionName,\n      pipeline\n    });\n  }\n  /** @inheritdoc */\n  count(filter = {}, options = {}) {\n    return this.functions.count({\n      database: this.databaseName,\n      collection: this.collectionName,\n      query: filter,\n      limit: options.limit\n    });\n  }\n  /** @inheritdoc */\n  insertOne(document2) {\n    return this.functions.insertOne({\n      database: this.databaseName,\n      collection: this.collectionName,\n      document: document2\n    });\n  }\n  /** @inheritdoc */\n  insertMany(documents) {\n    return this.functions.insertMany({\n      database: this.databaseName,\n      collection: this.collectionName,\n      documents\n    });\n  }\n  /** @inheritdoc */\n  deleteOne(filter = {}) {\n    return this.functions.deleteOne({\n      database: this.databaseName,\n      collection: this.collectionName,\n      query: filter\n    });\n  }\n  /** @inheritdoc */\n  deleteMany(filter = {}) {\n    return this.functions.deleteMany({\n      database: this.databaseName,\n      collection: this.collectionName,\n      query: filter\n    });\n  }\n  /** @inheritdoc */\n  updateOne(filter, update, options = {}) {\n    return this.functions.updateOne({\n      database: this.databaseName,\n      collection: this.collectionName,\n      query: filter,\n      update,\n      upsert: options.upsert,\n      arrayFilters: options.arrayFilters\n    });\n  }\n  /** @inheritdoc */\n  updateMany(filter, update, options = {}) {\n    return this.functions.updateMany({\n      database: this.databaseName,\n      collection: this.collectionName,\n      query: filter,\n      update,\n      upsert: options.upsert,\n      arrayFilters: options.arrayFilters\n    });\n  }\n  watch({ ids, filter } = {}) {\n    const iterable = this.functions.callFunctionStreaming(\"watch\", {\n      database: this.databaseName,\n      collection: this.collectionName,\n      ids,\n      filter\n    });\n    const iterator = iterable.then((i) => i[Symbol.asyncIterator]());\n    const stream = this.watchImpl(iterator);\n    const originalReturn = stream.return;\n    return Object.assign(stream, {\n      return(value) {\n        iterator.then((i) => i.return ? i.return(value) : void 0);\n        return originalReturn.call(stream, value);\n      }\n    });\n  }\n  /**\n   * @param iterator An async iterator of the response body of a watch request.\n   * @yields Change events.\n   * Note: We had to split this from the `watch` method above to enable manually calling `return` on the response body iterator.\n   */\n  async *watchImpl(iterator) {\n    const watchStream = new WatchStream();\n    const iterable = iterator.then((i) => ({ [Symbol.asyncIterator]: () => i }));\n    for await (const chunk of await iterable) {\n      if (!chunk)\n        continue;\n      watchStream.feedBuffer(chunk);\n      while (watchStream.state == WatchStreamState.HAVE_EVENT) {\n        yield watchStream.nextEvent();\n      }\n      if (watchStream.state == WatchStreamState.HAVE_ERROR)\n        throw watchStream.error;\n    }\n  }\n};\nfunction createCollection(fetcher, serviceName, databaseName, collectionName) {\n  return new MongoDBCollection(fetcher, serviceName, databaseName, collectionName);\n}\nfunction createDatabase(fetcher, serviceName, databaseName) {\n  return {\n    collection: createCollection.bind(null, fetcher, serviceName, databaseName)\n  };\n}\nfunction createService(fetcher, serviceName = \"mongo-db\") {\n  return { db: createDatabase.bind(null, fetcher, serviceName) };\n}\nvar DEFAULT_DEVICE_ID = \"000000000000000000000000\";\nvar UserState;\n(function(UserState2) {\n  UserState2[\"Active\"] = \"active\";\n  UserState2[\"LoggedOut\"] = \"logged-out\";\n  UserState2[\"Removed\"] = \"removed\";\n})(UserState || (UserState = {}));\nvar UserType$1;\n(function(UserType2) {\n  UserType2[\"Normal\"] = \"normal\";\n  UserType2[\"Server\"] = \"server\";\n})(UserType$1 || (UserType$1 = {}));\nvar User = class {\n  /**\n   * @param parameters Parameters of the user.\n   */\n  constructor(parameters) {\n    this.app = parameters.app;\n    this.id = parameters.id;\n    this.storage = new UserStorage(this.app.storage, this.id);\n    if (\"accessToken\" in parameters && \"refreshToken\" in parameters && \"providerType\" in parameters) {\n      this._accessToken = parameters.accessToken;\n      this._refreshToken = parameters.refreshToken;\n      this.providerType = parameters.providerType;\n      this.storage.accessToken = parameters.accessToken;\n      this.storage.refreshToken = parameters.refreshToken;\n      this.storage.providerType = parameters.providerType;\n    } else {\n      this._accessToken = this.storage.accessToken;\n      this._refreshToken = this.storage.refreshToken;\n      const providerType = this.storage.providerType;\n      this._profile = this.storage.profile;\n      if (providerType) {\n        this.providerType = providerType;\n      } else {\n        throw new Error(\"Storage is missing a provider type\");\n      }\n    }\n    this.fetcher = this.app.fetcher.clone({\n      userContext: { currentUser: this }\n    });\n    this.apiKeys = new ApiKeyAuth(this.fetcher);\n    this.functions = FunctionsFactory.create(this.fetcher);\n  }\n  /**\n   * @returns The access token used to authenticate the user towards Atlas App Services.\n   */\n  get accessToken() {\n    return this._accessToken;\n  }\n  /**\n   * @param token The new access token.\n   */\n  set accessToken(token) {\n    this._accessToken = token;\n    this.storage.accessToken = token;\n  }\n  /**\n   * @returns The refresh token used to issue new access tokens.\n   */\n  get refreshToken() {\n    return this._refreshToken;\n  }\n  /**\n   * @param token The new refresh token.\n   */\n  set refreshToken(token) {\n    this._refreshToken = token;\n    this.storage.refreshToken = token;\n  }\n  /**\n   * @returns The current state of the user.\n   */\n  get state() {\n    if (this.id in this.app.allUsers) {\n      return this.refreshToken === null ? UserState.LoggedOut : UserState.Active;\n    } else {\n      return UserState.Removed;\n    }\n  }\n  /**\n   * @returns The logged in state of the user.\n   */\n  get isLoggedIn() {\n    return this.state === UserState.Active;\n  }\n  get customData() {\n    if (this.accessToken) {\n      const decodedToken = this.decodeAccessToken();\n      return decodedToken.userData;\n    } else {\n      throw new Error(\"Cannot read custom data without an access token\");\n    }\n  }\n  /**\n   * @returns Profile containing detailed information about the user.\n   */\n  get profile() {\n    if (this._profile) {\n      return this._profile.data;\n    } else {\n      throw new Error(\"A profile was never fetched for this user\");\n    }\n  }\n  get identities() {\n    if (this._profile) {\n      return this._profile.identities;\n    } else {\n      throw new Error(\"A profile was never fetched for this user\");\n    }\n  }\n  get deviceId() {\n    if (this.accessToken) {\n      const payload = this.accessToken.split(\".\")[1];\n      if (payload) {\n        const parsedPayload = JSON.parse(gBase64.decode(payload));\n        const deviceId = parsedPayload[\"baas_device_id\"];\n        if (typeof deviceId === \"string\" && deviceId !== DEFAULT_DEVICE_ID) {\n          return deviceId;\n        }\n      }\n    }\n    return null;\n  }\n  /**\n   * Refresh the users profile data.\n   */\n  async refreshProfile() {\n    const response = await this.fetcher.fetchJSON({\n      method: \"GET\",\n      path: routes.api().auth().profile().path\n    });\n    this._profile = new UserProfile(response);\n    this.storage.profile = this._profile;\n  }\n  /**\n   * Log out the user, invalidating the session (and its refresh token).\n   */\n  async logOut() {\n    try {\n      if (this._refreshToken !== null) {\n        await this.fetcher.fetchJSON({\n          method: \"DELETE\",\n          path: routes.api().auth().session().path,\n          tokenType: \"refresh\"\n        });\n      }\n    } catch (err) {\n      if (!(err instanceof Error) || !err.message.includes(\"failed to find refresh token\")) {\n        throw err;\n      }\n    } finally {\n      this.accessToken = null;\n      this.refreshToken = null;\n    }\n  }\n  /** @inheritdoc */\n  async linkCredentials(credentials) {\n    const response = await this.app.authenticator.authenticate(credentials, this);\n    if (this.id !== response.userId) {\n      const details = `got user id ${response.userId} expected ${this.id}`;\n      throw new Error(`Link response ment for another user (${details})`);\n    }\n    this.accessToken = response.accessToken;\n    await this.refreshProfile();\n  }\n  /**\n   * Request a new access token, using the refresh token.\n   */\n  async refreshAccessToken() {\n    const response = await this.fetcher.fetchJSON({\n      method: \"POST\",\n      path: routes.api().auth().session().path,\n      tokenType: \"refresh\"\n    });\n    const { access_token: accessToken } = response;\n    if (typeof accessToken === \"string\") {\n      this.accessToken = accessToken;\n    } else {\n      throw new Error(\"Expected an 'access_token' in the response\");\n    }\n  }\n  /** @inheritdoc */\n  async refreshCustomData() {\n    await this.refreshAccessToken();\n    return this.customData;\n  }\n  /**\n   * @inheritdoc\n   */\n  addListener() {\n    throw new Error(\"Not yet implemented\");\n  }\n  /**\n   * @inheritdoc\n   */\n  removeListener() {\n    throw new Error(\"Not yet implemented\");\n  }\n  /**\n   * @inheritdoc\n   */\n  removeAllListeners() {\n    throw new Error(\"Not yet implemented\");\n  }\n  /** @inheritdoc */\n  callFunction(name, ...args) {\n    return this.functions.callFunction(name, ...args);\n  }\n  /**\n   * @returns A plain ol' JavaScript object representation of the user.\n   */\n  toJSON() {\n    return {\n      id: this.id,\n      accessToken: this.accessToken,\n      refreshToken: this.refreshToken,\n      profile: this._profile,\n      state: this.state,\n      customData: this.customData\n    };\n  }\n  /** @inheritdoc */\n  push() {\n    throw new Error(\"Not yet implemented\");\n  }\n  /** @inheritdoc */\n  mongoClient(serviceName) {\n    return createService(this.fetcher, serviceName);\n  }\n  decodeAccessToken() {\n    if (this.accessToken) {\n      const parts = this.accessToken.split(\".\");\n      if (parts.length !== 3) {\n        throw new Error(\"Expected an access token with three parts\");\n      }\n      const encodedPayload = parts[1];\n      const decodedPayload = gBase64.decode(encodedPayload);\n      const parsedPayload = JSON.parse(decodedPayload);\n      const { exp: expires, iat: issuedAt, sub: subject, user_data: userData = {} } = parsedPayload;\n      if (typeof expires !== \"number\") {\n        throw new Error(\"Failed to decode access token 'exp'\");\n      } else if (typeof issuedAt !== \"number\") {\n        throw new Error(\"Failed to decode access token 'iat'\");\n      }\n      return { expires, issuedAt, subject, userData };\n    } else {\n      throw new Error(\"Missing an access token\");\n    }\n  }\n};\nvar Credentials = class _Credentials {\n  /**\n   * Constructs an instance of credentials.\n   *\n   * @param providerName The name of the authentication provider used when authenticating.\n   * @param providerType The type of the authentication provider used when authenticating.\n   * @param payload The data being sent to the service when authenticating.\n   */\n  constructor(providerName, providerType, payload) {\n    this.providerName = providerName;\n    this.providerType = providerType;\n    this.payload = payload;\n  }\n  /**\n   * Creates credentials that logs in using the [Anonymous Provider](https://docs.mongodb.com/realm/authentication/anonymous/).\n   *\n   * @returns The credentials instance, which can be passed to `app.logIn`.\n   */\n  static anonymous() {\n    return new _Credentials(\"anon-user\", \"anon-user\", {});\n  }\n  /**\n   * Creates credentials that logs in using the [API Key Provider](https://docs.mongodb.com/realm/authentication/api-key/).\n   *\n   * @param key The secret content of the API key.\n   * @returns The credentials instance, which can be passed to `app.logIn`.\n   */\n  static apiKey(key) {\n    return new _Credentials(\"api-key\", \"api-key\", { key });\n  }\n  /**\n   * Creates credentials that logs in using the [Email/Password Provider](https://docs.mongodb.com/realm/authentication/email-password/).\n   * Note: This was formerly known as the \"Username/Password\" provider.\n   *\n   * @param email The end-users email address.\n   * @param password The end-users password.\n   * @returns The credentials instance, which can be passed to `app.logIn`.\n   */\n  static emailPassword(email, password) {\n    return new _Credentials(\"local-userpass\", \"local-userpass\", {\n      username: email,\n      password\n    });\n  }\n  /**\n   * Creates credentials that logs in using the [Custom Function Provider](https://docs.mongodb.com/realm/authentication/custom-function/).\n   *\n   * @param payload The custom payload as expected by the server.\n   * @returns The credentials instance, which can be passed to `app.logIn`.\n   */\n  static function(payload) {\n    return new _Credentials(\"custom-function\", \"custom-function\", payload);\n  }\n  /**\n   * Creates credentials that logs in using the [Custom JWT Provider](https://docs.mongodb.com/realm/authentication/custom-jwt/).\n   *\n   * @param token The JSON Web Token (JWT).\n   * @returns The credentials instance, which can be passed to `app.logIn`.\n   */\n  static jwt(token) {\n    return new _Credentials(\"custom-token\", \"custom-token\", {\n      token\n    });\n  }\n  /**\n   * Creates credentials that logs in using the [Google Provider](https://docs.mongodb.com/realm/authentication/google/).\n   *\n   * @param payload The URL that users should be redirected to, the auth code or id token from Google.\n   * @returns The credentials instance, which can be passed to `app.logIn`.\n   */\n  static google(payload) {\n    return new _Credentials(\"oauth2-google\", \"oauth2-google\", _Credentials.derivePayload(payload));\n  }\n  /**\n   * @param payload The payload string.\n   * @returns A payload object based on the string.\n   */\n  static derivePayload(payload) {\n    if (typeof payload === \"string\") {\n      throw new Error(\"`google(<tokenString>)` has been deprecated.  Please use `google(<authCodeObject>).\");\n    } else if (Object.keys(payload).length === 1) {\n      if (\"authCode\" in payload || \"redirectUrl\" in payload) {\n        return payload;\n      } else if (\"idToken\" in payload) {\n        return { id_token: payload.idToken };\n      } else {\n        throw new Error(\"Unexpected payload: \" + JSON.stringify(payload));\n      }\n    } else {\n      throw new Error(\"Expected only one property in payload, got \" + JSON.stringify(payload));\n    }\n  }\n  /**\n   * Creates credentials that logs in using the [Facebook Provider](https://docs.mongodb.com/realm/authentication/facebook/).\n   *\n   * @param redirectUrlOrAccessToken The URL that users should be redirected to or the auth code returned from Facebook.\n   * @returns The credentials instance, which can be passed to `app.logIn`.\n   */\n  static facebook(redirectUrlOrAccessToken) {\n    return new _Credentials(\"oauth2-facebook\", \"oauth2-facebook\", redirectUrlOrAccessToken.includes(\"://\") ? { redirectUrl: redirectUrlOrAccessToken } : { accessToken: redirectUrlOrAccessToken });\n  }\n  /**\n   * Creates credentials that logs in using the [Apple ID Provider](https://docs.mongodb.com/realm/authentication/apple/).\n   *\n   * @param redirectUrlOrIdToken The URL that users should be redirected to or the id_token returned from Apple.\n   * @returns The credentials instance, which can be passed to `app.logIn`.\n   */\n  static apple(redirectUrlOrIdToken) {\n    return new _Credentials(\"oauth2-apple\", \"oauth2-apple\", redirectUrlOrIdToken.includes(\"://\") ? { redirectUrl: redirectUrlOrIdToken } : { id_token: redirectUrlOrIdToken });\n  }\n};\nvar USER_IDS_STORAGE_KEY = \"userIds\";\nvar DEVICE_ID_STORAGE_KEY = \"deviceId\";\nvar AppStorage = class extends PrefixedStorage {\n  /**\n   * @param storage The underlying storage to wrap.\n   * @param appId The id of the app.\n   */\n  constructor(storage, appId) {\n    super(storage, `app(${appId})`);\n  }\n  /**\n   * Reads out the list of user ids from storage.\n   *\n   * @returns A list of user ids.\n   */\n  getUserIds() {\n    const userIdsString = this.get(USER_IDS_STORAGE_KEY);\n    const userIds = userIdsString ? JSON.parse(userIdsString) : [];\n    if (Array.isArray(userIds)) {\n      return [...new Set(userIds)];\n    } else {\n      throw new Error(\"Expected the user ids to be an array\");\n    }\n  }\n  /**\n   * Sets the list of ids in storage.\n   * Optionally merging with existing ids stored in the storage, by prepending these while voiding duplicates.\n   *\n   * @param userIds The list of ids to store.\n   * @param mergeWithExisting Prepend existing ids to avoid data-races with other apps using this storage.\n   */\n  setUserIds(userIds, mergeWithExisting) {\n    if (mergeWithExisting) {\n      const existingIds = this.getUserIds();\n      for (const id of existingIds) {\n        if (userIds.indexOf(id) === -1) {\n          userIds.push(id);\n        }\n      }\n    }\n    this.set(USER_IDS_STORAGE_KEY, JSON.stringify(userIds));\n  }\n  /**\n   * Remove an id from the list of ids.\n   *\n   * @param userId The id of a User to be removed.\n   */\n  removeUserId(userId) {\n    const existingIds = this.getUserIds();\n    const userIds = existingIds.filter((id) => id !== userId);\n    this.setUserIds(userIds, false);\n  }\n  /**\n   * @returns id of this device (if any exists)\n   */\n  getDeviceId() {\n    return this.get(DEVICE_ID_STORAGE_KEY);\n  }\n  /**\n   * @param deviceId The id of this device, to send on subsequent authentication requests.\n   */\n  setDeviceId(deviceId) {\n    this.set(DEVICE_ID_STORAGE_KEY, deviceId);\n  }\n};\nvar LOWERCASE_LETTERS = \"abcdefghijklmnopqrstuvwxyz\";\nvar CLOSE_CHECK_INTERVAL = 100;\nvar REDIRECT_HASH_TO_RESULT = {\n  _stitch_client_app_id: \"appId\",\n  _baas_client_app_id: \"appId\",\n  _stitch_ua: \"userAuth\",\n  _baas_ua: \"userAuth\",\n  _stitch_link: \"link\",\n  _baas_link: \"link\",\n  _stitch_error: \"error\",\n  _baas_error: \"error\",\n  _stitch_state: \"state\",\n  _baas_state: \"state\"\n};\nvar OAuth2Helper = class _OAuth2Helper {\n  /**\n   * @param storage The underlying storage to use when storing and retriving secrets.\n   * @param openWindow An optional function called when a browser window needs to open.\n   */\n  constructor(storage, openWindow2 = getEnvironment().openWindow) {\n    this.storage = storage.prefix(\"oauth2\");\n    this.openWindow = openWindow2;\n  }\n  /**\n   * Parses the query string from the final step of the OAuth flow.\n   *\n   * @param queryString The query string passed through in location.hash.\n   * @returns The result of the OAuth flow.\n   */\n  static parseRedirectLocation(queryString) {\n    const params = decodeQueryString(queryString);\n    const result = {};\n    for (const [p, r] of Object.entries(REDIRECT_HASH_TO_RESULT)) {\n      const value = params[p];\n      if (value) {\n        result[r] = value;\n      }\n    }\n    return result;\n  }\n  /**\n   * Handle the redirect querystring by parsing it and storing it for others to consume.\n   *\n   * @param queryString The query string containing the encoded result from the OAuth provider.\n   * @param storage The underlying storage used to persist the result.\n   */\n  static handleRedirect(queryString, storage = getEnvironment().defaultStorage) {\n    const result = _OAuth2Helper.parseRedirectLocation(queryString);\n    const { state, error } = result;\n    if (typeof state === \"string\") {\n      const oauth2Storage = storage.prefix(\"oauth2\");\n      const stateStorage = _OAuth2Helper.getStateStorage(oauth2Storage, state);\n      stateStorage.set(\"result\", JSON.stringify(result));\n    } else if (error) {\n      throw new Error(`Failed to handle OAuth 2.0 redirect: ${error}`);\n    } else {\n      throw new Error(\"Failed to handle OAuth 2.0 redirect.\");\n    }\n  }\n  /**\n   * Decodes the authInfo string into its seperate parts.\n   *\n   * @param authInfo An authInfo string returned from the server.\n   * @returns An object containing the separate parts of the authInfo string.\n   */\n  static decodeAuthInfo(authInfo) {\n    const parts = (authInfo || \"\").split(\"$\");\n    if (parts.length === 4) {\n      const [accessToken, refreshToken, userId, deviceId] = parts;\n      return { accessToken, refreshToken, userId, deviceId };\n    } else {\n      throw new Error(\"Failed to decode 'authInfo' into ids and tokens\");\n    }\n  }\n  /**\n   * Get the storage key associated of an secret associated with a state.\n   *\n   * @param storage The root storage used to derive a \"state namespaced\" storage.\n   * @param state The random state.\n   * @returns The storage associated with a particular state.\n   */\n  static getStateStorage(storage, state) {\n    return storage.prefix(`state(${state})`);\n  }\n  /**\n   * Open a window and wait for the redirect to be handled.\n   *\n   * @param url The URL to open.\n   * @param state The state which will be used to listen for storage updates.\n   * @returns The result passed through the redirect.\n   */\n  openWindowAndWaitForRedirect(url, state) {\n    const stateStorage = _OAuth2Helper.getStateStorage(this.storage, state);\n    return new Promise((resolve, reject) => {\n      let redirectWindow = null;\n      let windowClosedInterval;\n      const handleStorageUpdate = () => {\n        const result = stateStorage.get(\"result\");\n        if (result) {\n          const parsedResult = JSON.parse(result);\n          stateStorage.removeListener(handleStorageUpdate);\n          stateStorage.clear();\n          try {\n            if (redirectWindow) {\n              clearInterval(windowClosedInterval);\n              redirectWindow.close();\n            }\n          } catch (err) {\n            console.warn(`Failed closing redirect window: ${err}`);\n          } finally {\n            resolve(parsedResult);\n          }\n        }\n      };\n      stateStorage.addListener(handleStorageUpdate);\n      redirectWindow = this.openWindow(url);\n      windowClosedInterval = setInterval(() => {\n        if (!redirectWindow) {\n          clearInterval(windowClosedInterval);\n        } else if (redirectWindow.closed) {\n          clearInterval(windowClosedInterval);\n          stateStorage.removeListener(handleStorageUpdate);\n          const err = new Error(\"Window closed\");\n          reject(err);\n        }\n      }, CLOSE_CHECK_INTERVAL);\n    });\n  }\n  /**\n   * Generate a random state string.\n   *\n   * @returns The random state string.\n   */\n  generateState() {\n    return generateRandomString(12, LOWERCASE_LETTERS);\n  }\n};\nvar REDIRECT_LOCATION_HEADER = \"x-baas-location\";\nvar Authenticator = class {\n  /**\n   * @param fetcher The fetcher used to fetch responses from the server.\n   * @param storage The storage used when completing OAuth 2.0 flows (should not be scoped to a specific app).\n   * @param getDeviceInformation Called to get device information to be sent to the server.\n   */\n  constructor(fetcher, storage, getDeviceInformation) {\n    this.fetcher = fetcher;\n    this.oauth2 = new OAuth2Helper(storage);\n    this.getDeviceInformation = getDeviceInformation;\n  }\n  /**\n   * @param credentials Credentials to use when logging in.\n   * @param linkingUser A user requesting to link.\n   * @returns A promise resolving to the response from the server.\n   */\n  async authenticate(credentials, linkingUser) {\n    const deviceInformation = this.getDeviceInformation();\n    const isLinking = typeof linkingUser === \"object\";\n    if (credentials.providerType.startsWith(\"oauth2\") && typeof credentials.payload.redirectUrl === \"string\") {\n      const state = this.oauth2.generateState();\n      const url = await this.getLogInUrl(credentials, isLinking, {\n        state,\n        redirect: credentials.payload.redirectUrl,\n        // Ensure redirects are communicated in a header different from \"Location\" and status remains 200 OK\n        providerRedirectHeader: isLinking ? true : void 0,\n        // Add the device information, only if we're not linking - since that request won't have a body of its own.\n        device: !isLinking ? deviceInformation.encode() : void 0\n      });\n      if (isLinking) {\n        const response = await this.fetcher.fetch({\n          method: \"GET\",\n          url,\n          tokenType: isLinking ? \"access\" : \"none\",\n          user: linkingUser,\n          // The response will set a cookie that we need to tell the browser to store\n          mode: \"cors\",\n          credentials: \"include\"\n        });\n        const redirectUrl = response.headers.get(REDIRECT_LOCATION_HEADER);\n        if (redirectUrl) {\n          return this.openWindowAndWaitForAuthResponse(redirectUrl, state);\n        } else {\n          throw new Error(`Missing ${REDIRECT_LOCATION_HEADER} header`);\n        }\n      } else {\n        return this.openWindowAndWaitForAuthResponse(url, state);\n      }\n    } else {\n      const logInUrl = await this.getLogInUrl(credentials, isLinking);\n      const response = await this.fetcher.fetchJSON({\n        method: \"POST\",\n        url: logInUrl,\n        body: {\n          ...credentials.payload,\n          options: {\n            device: deviceInformation.toJSON()\n          }\n        },\n        tokenType: isLinking ? \"access\" : \"none\",\n        user: linkingUser\n      });\n      const { user_id: userId, access_token: accessToken, refresh_token: refreshToken = null, device_id: deviceId } = response;\n      if (typeof userId !== \"string\") {\n        throw new Error(\"Expected a user id in the response\");\n      }\n      if (typeof accessToken !== \"string\") {\n        throw new Error(\"Expected an access token in the response\");\n      }\n      if (typeof refreshToken !== \"string\" && refreshToken !== null) {\n        throw new Error(\"Expected refresh token to be a string or null\");\n      }\n      if (typeof deviceId !== \"string\") {\n        throw new Error(\"Expected device id to be a string\");\n      }\n      return { userId, accessToken, refreshToken, deviceId };\n    }\n  }\n  /**\n   * @param credentials Credentials to use when logging in.\n   * @param link Should the request link with the current user?\n   * @param extraQueryParams Any extra parameters to include in the query string\n   * @returns A promise resolving to the url to be used when logging in.\n   */\n  async getLogInUrl(credentials, link = false, extraQueryParams = {}) {\n    const appRoute = this.fetcher.appRoute;\n    const loginRoute = appRoute.authProvider(credentials.providerName).login();\n    const qs = encodeQueryString({\n      link: link ? \"true\" : void 0,\n      ...extraQueryParams\n    });\n    const locationUrl = await this.fetcher.locationUrl;\n    return locationUrl + loginRoute.path + qs;\n  }\n  async openWindowAndWaitForAuthResponse(redirectUrl, state) {\n    const redirectResult = await this.oauth2.openWindowAndWaitForRedirect(redirectUrl, state);\n    return OAuth2Helper.decodeAuthInfo(redirectResult.userAuth);\n  }\n};\nvar MongoDBRealmError = class _MongoDBRealmError extends Error {\n  constructor(method, url, statusCode, statusText, error, errorCode, link) {\n    const summary = statusText ? `status ${statusCode} ${statusText}` : `status ${statusCode}`;\n    if (typeof error === \"string\") {\n      super(`Request failed (${method} ${url}): ${error} (${summary})`);\n    } else {\n      super(`Request failed (${method} ${url}): (${summary})`);\n    }\n    this.method = method;\n    this.url = url;\n    this.statusText = statusText;\n    this.statusCode = statusCode;\n    this.error = error;\n    this.errorCode = errorCode;\n    this.link = link;\n  }\n  /**\n   * Constructs and returns an error from a request and a response.\n   * Note: The caller must throw this error themselves.\n   *\n   * @param request The request sent to the server.\n   * @param response A raw response, as returned from the server.\n   * @returns An error from a request and a response.\n   */\n  static async fromRequestAndResponse(request, response) {\n    var _a;\n    const { url, method } = request;\n    const { status, statusText } = response;\n    if ((_a = response.headers.get(\"content-type\")) === null || _a === void 0 ? void 0 : _a.startsWith(\"application/json\")) {\n      const body = await response.json();\n      if (typeof body === \"object\" && body) {\n        const { error, error_code: errorCode, link } = body;\n        return new _MongoDBRealmError(method, url, status, statusText, typeof error === \"string\" ? error : void 0, typeof errorCode === \"string\" ? errorCode : void 0, typeof link === \"string\" ? link : void 0);\n      }\n    }\n    return new _MongoDBRealmError(method, url, status, statusText);\n  }\n};\nfunction asyncIteratorFromResponseBody(body) {\n  if (typeof body !== \"object\" || body === null) {\n    throw new Error(\"Expected a non-null object\");\n  } else if (Symbol.asyncIterator in body) {\n    return body;\n  } else if (\"getReader\" in body) {\n    const stream = body;\n    return {\n      [Symbol.asyncIterator]() {\n        const reader = stream.getReader();\n        return {\n          next() {\n            return reader.read();\n          },\n          async return() {\n            await reader.cancel();\n            return { done: true, value: null };\n          }\n        };\n      }\n    };\n  } else {\n    throw new Error(\"Expected an AsyncIterable or a ReadableStream\");\n  }\n}\nvar Fetcher = class _Fetcher {\n  /**\n   * @param config A configuration of the fetcher.\n   * @param config.appId The application id.\n   * @param config.transport The transport used when fetching.\n   * @param config.userContext An object used to determine the requesting user.\n   * @param config.locationUrlContext An object used to determine the location / base URL.\n   */\n  constructor({ appId, transport, userContext, locationUrlContext }) {\n    this.appId = appId;\n    this.transport = transport;\n    this.userContext = userContext;\n    this.locationUrlContext = locationUrlContext;\n  }\n  /**\n   * @param user An optional user to generate the header for.\n   * @param tokenType The type of token (access or refresh).\n   * @returns An object containing the user's token as \"Authorization\" header or undefined if no user is given.\n   */\n  static buildAuthorizationHeader(user, tokenType) {\n    if (!user || tokenType === \"none\") {\n      return {};\n    } else if (tokenType === \"access\") {\n      return { Authorization: `Bearer ${user.accessToken}` };\n    } else if (tokenType === \"refresh\") {\n      return { Authorization: `Bearer ${user.refreshToken}` };\n    } else {\n      throw new Error(`Unexpected token type (${tokenType})`);\n    }\n  }\n  /**\n   * @param body The body string or object passed from a request.\n   * @returns An object optionally specifying the \"Content-Type\" header.\n   */\n  static buildBody(body) {\n    if (!body) {\n      return;\n    } else if (typeof body === \"object\" && body !== null) {\n      return JSON.stringify(serialize2(body));\n    } else if (typeof body === \"string\") {\n      return body;\n    } else {\n      console.log(\"body is\", body);\n      throw new Error(\"Unexpected type of body\");\n    }\n  }\n  /**\n   * @param body The body string or object passed from a request.\n   * @returns An object optionally specifying the \"Content-Type\" header.\n   */\n  static buildJsonHeader(body) {\n    if (body && body.length > 0) {\n      return { \"Content-Type\": \"application/json\" };\n    } else {\n      return {};\n    }\n  }\n  clone(config) {\n    return new _Fetcher({\n      appId: this.appId,\n      transport: this.transport,\n      userContext: this.userContext,\n      locationUrlContext: this.locationUrlContext,\n      ...config\n    });\n  }\n  /**\n   * Fetch a network resource as an authenticated user.\n   *\n   * @param request The request which should be sent to the server.\n   * @returns The response from the server.\n   */\n  async fetch(request) {\n    const { path, url, tokenType = \"access\", user = this.userContext.currentUser, ...restOfRequest } = request;\n    if (typeof path === \"string\" && typeof url === \"string\") {\n      throw new Error(\"Use of 'url' and 'path' mutually exclusive\");\n    } else if (typeof path === \"string\") {\n      const url2 = await this.locationUrlContext.locationUrl + path;\n      return this.fetch({ ...request, path: void 0, url: url2 });\n    } else if (typeof url === \"string\") {\n      const response = await this.transport.fetch({\n        ...restOfRequest,\n        url,\n        headers: {\n          ..._Fetcher.buildAuthorizationHeader(user, tokenType),\n          ...request.headers\n        }\n      });\n      if (response.ok) {\n        return response;\n      } else if (user && response.status === 401 && tokenType === \"access\") {\n        await user.refreshAccessToken();\n        return this.fetch({ ...request, user });\n      } else {\n        if (user && response.status === 401 && tokenType === \"refresh\") {\n          user.accessToken = null;\n          user.refreshToken = null;\n        }\n        throw await MongoDBRealmError.fromRequestAndResponse(request, response);\n      }\n    } else {\n      throw new Error(\"Expected either 'url' or 'path'\");\n    }\n  }\n  /**\n   * Fetch a network resource as an authenticated user and parse the result as extended JSON.\n   *\n   * @param request The request which should be sent to the server.\n   * @returns The response from the server, parsed as extended JSON.\n   */\n  async fetchJSON(request) {\n    const { body } = request;\n    const serializedBody = _Fetcher.buildBody(body);\n    const contentTypeHeaders = _Fetcher.buildJsonHeader(serializedBody);\n    const response = await this.fetch({\n      ...request,\n      body: serializedBody,\n      headers: {\n        Accept: \"application/json\",\n        ...contentTypeHeaders,\n        ...request.headers\n      }\n    });\n    const contentType = response.headers.get(\"content-type\");\n    if (contentType === null || contentType === void 0 ? void 0 : contentType.startsWith(\"application/json\")) {\n      const responseBody = await response.json();\n      return deserialize2(responseBody);\n    } else if (contentType === null) {\n      return null;\n    } else {\n      throw new Error(`Expected JSON response, got \"${contentType}\"`);\n    }\n  }\n  /**\n   * Fetch an \"event-stream\" resource as an authenticated user.\n   *\n   * @param request The request which should be sent to the server.\n   * @returns An async iterator over the response body.\n   */\n  async fetchStream(request) {\n    const { body } = await this.fetch({\n      ...request,\n      headers: {\n        Accept: \"text/event-stream\",\n        ...request.headers\n      }\n    });\n    return asyncIteratorFromResponseBody(body);\n  }\n  /**\n   * @returns The path of the app route.\n   */\n  get appRoute() {\n    return routes.api().app(this.appId);\n  }\n  /**\n   * @returns A promise of the location URL of the app.\n   */\n  get locationUrl() {\n    return this.locationUrlContext.locationUrl;\n  }\n};\nvar DEVICE_ID_STORAGE_KEY$1 = \"deviceId\";\nvar DeviceFields;\n(function(DeviceFields2) {\n  DeviceFields2[\"DEVICE_ID\"] = \"deviceId\";\n  DeviceFields2[\"APP_ID\"] = \"appId\";\n  DeviceFields2[\"APP_VERSION\"] = \"appVersion\";\n  DeviceFields2[\"PLATFORM\"] = \"platform\";\n  DeviceFields2[\"PLATFORM_VERSION\"] = \"platformVersion\";\n  DeviceFields2[\"SDK_VERSION\"] = \"sdkVersion\";\n})(DeviceFields || (DeviceFields = {}));\nvar DeviceInformation = class {\n  /**\n   * @param params Construct the device information from these parameters.\n   * @param params.appId A user-defined application id.\n   * @param params.appVersion A user-defined application version.\n   * @param params.deviceId An unique id for the end-users device.\n   */\n  constructor({ appId, appVersion, deviceId }) {\n    this.sdkVersion = \"2.0.0\";\n    const environment2 = getEnvironment();\n    this.platform = environment2.platform;\n    this.platformVersion = environment2.platformVersion;\n    this.appId = appId;\n    this.appVersion = appVersion;\n    this.deviceId = deviceId;\n  }\n  /**\n   * @returns An base64 URI encoded representation of the device information.\n   */\n  encode() {\n    const obj = removeKeysWithUndefinedValues(this);\n    return gBase64.encode(JSON.stringify(obj));\n  }\n  /**\n   * @returns The defaults\n   */\n  toJSON() {\n    return removeKeysWithUndefinedValues(this);\n  }\n};\nvar DEFAULT_BASE_URL = \"https://realm.mongodb.com\";\nvar App = class _App {\n  /**\n   * Construct a Realm App, either from the Realm App id visible from the Atlas App Services UI or a configuration.\n   *\n   * @param idOrConfiguration The Realm App id or a configuration to use for this app.\n   */\n  constructor(idOrConfiguration) {\n    this.users = [];\n    this._locationUrl = null;\n    const configuration = typeof idOrConfiguration === \"string\" ? { id: idOrConfiguration } : idOrConfiguration;\n    if (typeof configuration === \"object\" && typeof configuration.id === \"string\") {\n      this.id = configuration.id;\n    } else {\n      throw new Error(\"Missing an Atlas App Services app-id\");\n    }\n    this.baseUrl = configuration.baseUrl || DEFAULT_BASE_URL;\n    if (configuration.skipLocationRequest) {\n      this._locationUrl = Promise.resolve(this.baseUrl);\n    }\n    this.localApp = configuration.app;\n    const { storage, transport = new DefaultNetworkTransport() } = configuration;\n    this.fetcher = new Fetcher({\n      appId: this.id,\n      userContext: this,\n      locationUrlContext: this,\n      transport\n    });\n    this.emailPasswordAuth = new EmailPasswordAuth(this.fetcher);\n    const baseStorage = storage || getEnvironment().defaultStorage;\n    this.storage = new AppStorage(baseStorage, this.id);\n    this.authenticator = new Authenticator(this.fetcher, baseStorage, () => this.deviceInformation);\n    try {\n      this.hydrate();\n    } catch (err) {\n      this.storage.clear();\n      console.warn(\"Realm app hydration failed:\", err instanceof Error ? err.message : err);\n    }\n  }\n  /**\n   * Get or create a singleton Realm App from an id.\n   * Calling this function multiple times with the same id will return the same instance.\n   *\n   * @param id The Realm App id visible from the Atlas App Services UI or a configuration.\n   * @returns The Realm App instance.\n   */\n  static getApp(id) {\n    if (id in _App.appCache) {\n      return _App.appCache[id];\n    } else {\n      const instance = new _App(id);\n      _App.appCache[id] = instance;\n      return instance;\n    }\n  }\n  /**\n   * Switch user.\n   *\n   * @param nextUser The user or id of the user to switch to.\n   */\n  switchUser(nextUser) {\n    const index = this.users.findIndex((u) => u === nextUser);\n    if (index === -1) {\n      throw new Error(\"The user was never logged into this app\");\n    }\n    const [user] = this.users.splice(index, 1);\n    this.users.unshift(user);\n  }\n  /**\n   * Log in a user.\n   *\n   * @param credentials Credentials to use when logging in.\n   * @param fetchProfile Should the users profile be fetched? (default: true)\n   * @returns A promise resolving to the newly logged in user.\n   */\n  async logIn(credentials, fetchProfile = true) {\n    const response = await this.authenticator.authenticate(credentials);\n    const user = this.createOrUpdateUser(response, credentials.providerType);\n    this.switchUser(user);\n    if (fetchProfile) {\n      await user.refreshProfile();\n    }\n    this.storage.setUserIds(this.users.map((u) => u.id), true);\n    const deviceId = response.deviceId;\n    if (deviceId && deviceId !== \"000000000000000000000000\") {\n      this.storage.set(DEVICE_ID_STORAGE_KEY$1, deviceId);\n    }\n    return user;\n  }\n  /**\n   * @inheritdoc\n   */\n  async removeUser(user) {\n    const index = this.users.findIndex((u) => u === user);\n    if (index === -1) {\n      throw new Error(\"The user was never logged into this app\");\n    }\n    this.users.splice(index, 1);\n    await user.logOut();\n    this.storage.remove(`user(${user.id}):profile`);\n    this.storage.removeUserId(user.id);\n  }\n  /**\n   * @inheritdoc\n   */\n  async deleteUser(user) {\n    await this.fetcher.fetchJSON({\n      method: \"DELETE\",\n      path: routes.api().auth().delete().path\n    });\n    await this.removeUser(user);\n  }\n  /**\n   * @inheritdoc\n   */\n  addListener() {\n    throw new Error(\"Not yet implemented\");\n  }\n  /**\n   * @inheritdoc\n   */\n  removeListener() {\n    throw new Error(\"Not yet implemented\");\n  }\n  /**\n   * @inheritdoc\n   */\n  removeAllListeners() {\n    throw new Error(\"Not yet implemented\");\n  }\n  /**\n   * The currently active user (or null if no active users exists).\n   *\n   * @returns the currently active user or null.\n   */\n  get currentUser() {\n    const activeUsers = this.users.filter((user) => user.state === UserState.Active);\n    if (activeUsers.length === 0) {\n      return null;\n    } else {\n      return activeUsers[0];\n    }\n  }\n  /**\n   * All active and logged-out users:\n   *  - First in the list are active users (ordered by most recent call to switchUser or login)\n   *  - Followed by logged out users (also ordered by most recent call to switchUser or login).\n   *\n   * @returns An array of users active or logged out users (current user being the first).\n   */\n  get allUsers() {\n    return Object.fromEntries(this.users.map((user) => [user.id, user]));\n  }\n  /**\n   * @returns A promise of the app URL, with the app location resolved.\n   */\n  get locationUrl() {\n    if (!this._locationUrl) {\n      const path = routes.api().app(this.id).location().path;\n      this._locationUrl = this.fetcher.fetchJSON({\n        method: \"GET\",\n        url: this.baseUrl + path,\n        tokenType: \"none\"\n      }).then((body) => {\n        if (typeof body !== \"object\") {\n          throw new Error(\"Expected response body be an object\");\n        } else {\n          return body;\n        }\n      }).then(({ hostname }) => {\n        if (typeof hostname !== \"string\") {\n          throw new Error(\"Expected response to contain a 'hostname'\");\n        } else {\n          return hostname;\n        }\n      }).catch((err) => {\n        this._locationUrl = null;\n        throw err;\n      });\n    }\n    return this._locationUrl;\n  }\n  /**\n   * @returns Information about the current device, sent to the server when authenticating.\n   */\n  get deviceInformation() {\n    const deviceIdStr = this.storage.getDeviceId();\n    const deviceId = typeof deviceIdStr === \"string\" && deviceIdStr !== \"000000000000000000000000\" ? new ObjectId(deviceIdStr) : void 0;\n    return new DeviceInformation({\n      appId: this.localApp ? this.localApp.name : void 0,\n      appVersion: this.localApp ? this.localApp.version : void 0,\n      deviceId\n    });\n  }\n  /**\n   * Create (and store) a new user or update an existing user's access and refresh tokens.\n   * This helps de-duplicating users in the list of users known to the app.\n   *\n   * @param response A response from the Authenticator.\n   * @param providerType The type of the authentication provider used.\n   * @returns A new or an existing user.\n   */\n  createOrUpdateUser(response, providerType) {\n    const existingUser = this.users.find((u) => u.id === response.userId);\n    if (existingUser) {\n      existingUser.accessToken = response.accessToken;\n      existingUser.refreshToken = response.refreshToken;\n      return existingUser;\n    } else {\n      if (!response.refreshToken) {\n        throw new Error(\"No refresh token in response from server\");\n      }\n      const user = new User({\n        app: this,\n        id: response.userId,\n        accessToken: response.accessToken,\n        refreshToken: response.refreshToken,\n        providerType\n      });\n      this.users.unshift(user);\n      return user;\n    }\n  }\n  /**\n   * Restores the state of the app (active and logged-out users) from the storage\n   */\n  hydrate() {\n    const userIds = this.storage.getUserIds();\n    this.users = userIds.map((id) => new User({ app: this, id }));\n  }\n};\nApp.appCache = {};\nApp.Credentials = Credentials;\nfunction getApp(id) {\n  return App.getApp(id);\n}\nvar setIsDevelopmentMode$1 = (state) => {\n};\nvar check$1 = function(it) {\n  return it && it.Math == Math && it;\n};\nvar safeGlobalThis$1 = (\n  // eslint-disable-next-line no-restricted-globals\n  check$1(typeof globalThis == \"object\" && globalThis) || check$1(typeof window == \"object\" && window) || // eslint-disable-next-line no-restricted-globals -- safe\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore allow `self`\n  check$1(typeof self == \"object\" && self) || // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore allow `global`\n  check$1(typeof global == \"object\" && global) || // eslint-disable-next-line no-new-func -- fallback\n  /* @__PURE__ */ function() {\n    return this;\n  }() || Function(\"return this\")()\n);\nsetIsDevelopmentMode$1(typeof __DEV__ !== \"undefined\" && __DEV__);\nvar LocalStorage = class {\n  /**\n   * Constructs a LocalStorage using the global window.\n   */\n  constructor() {\n    if (typeof safeGlobalThis$1.localStorage === \"object\") {\n      this.global = safeGlobalThis$1;\n    } else {\n      throw new Error(\"Cannot use LocalStorage without a global localStorage object\");\n    }\n  }\n  /** @inheritdoc */\n  get(key) {\n    return this.global.localStorage.getItem(key);\n  }\n  /** @inheritdoc */\n  set(key, value) {\n    return this.global.localStorage.setItem(key, value);\n  }\n  /** @inheritdoc */\n  remove(key) {\n    return this.global.localStorage.removeItem(key);\n  }\n  /** @inheritdoc */\n  prefix(keyPart) {\n    return new PrefixedStorage(this, keyPart);\n  }\n  /** @inheritdoc */\n  clear(prefix) {\n    const keys = [];\n    for (let i = 0; i < this.global.localStorage.length; i++) {\n      const key = this.global.localStorage.key(i);\n      if (key && (!prefix || key.startsWith(prefix))) {\n        keys.push(key);\n      }\n    }\n    for (const key of keys) {\n      this.global.localStorage.removeItem(key);\n    }\n  }\n  /** @inheritdoc */\n  addListener(listener) {\n    return this.global.addEventListener(\"storage\", listener);\n  }\n  /** @inheritdoc */\n  removeListener(listener) {\n    return this.global.removeEventListener(\"storage\", listener);\n  }\n};\nvar browser = detect();\nvar DefaultStorage = \"localStorage\" in safeGlobalThis$1 ? LocalStorage : MemoryStorage;\nfunction openWindow(url) {\n  if (typeof safeGlobalThis$1.open === \"function\") {\n    return safeGlobalThis$1.open(url);\n  } else {\n    console.log(`Please open ${url}`);\n    return null;\n  }\n}\nvar environment$1 = {\n  defaultStorage: new DefaultStorage().prefix(\"realm-web\"),\n  openWindow,\n  platform: (browser === null || browser === void 0 ? void 0 : browser.name) || \"web\",\n  platformVersion: (browser === null || browser === void 0 ? void 0 : browser.version) || \"0.0.0\",\n  TextDecoder\n};\nsetEnvironment(environment$1);\nfunction handleAuthRedirect(location = safeGlobalThis$1.location, storage = environment$1.defaultStorage) {\n  try {\n    const queryString = location.hash.substr(1);\n    OAuth2Helper.handleRedirect(queryString, storage);\n  } catch (err) {\n    console.warn(err);\n  }\n}\nexport {\n  App,\n  bson_browser_esm_exports as BSON,\n  Credentials,\n  DEFAULT_BASE_URL,\n  LocalStorage,\n  MongoDBRealmError,\n  User,\n  UserState,\n  UserType$1 as UserType,\n  getApp,\n  getEnvironment,\n  handleAuthRedirect,\n  setEnvironment\n};\n/*! Bundled license information:\n\nbson/dist/bson.browser.esm.js:\n  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)\n  (*! *****************************************************************************\n  Copyright (c) Microsoft Corporation.\n  \n  Permission to use, copy, modify, and/or distribute this software for any\n  purpose with or without fee is hereby granted.\n  \n  THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n  PERFORMANCE OF THIS SOFTWARE.\n  ***************************************************************************** *)\n*/\n//# sourceMappingURL=realm-web.js.map\n",
      "start": 1703474742337,
      "end": 1703474742340,
      "order": "normal",
      "sourcemaps": null
    }
  ]
}
