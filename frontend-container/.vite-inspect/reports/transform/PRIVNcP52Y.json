{
  "resolvedId": "/home/zepor/ssweb/frontend-container/node_modules/.vite/deps/chunk-YNER2GXA.js?v=733ce8d4",
  "transforms": [
    {
      "name": "vite:optimized-deps",
      "result": "\"use strict\";\n(() => {\n  var __create = Object.create;\n  var __defProp = Object.defineProperty;\n  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n  var __getOwnPropNames = Object.getOwnPropertyNames;\n  var __getProtoOf = Object.getPrototypeOf;\n  var __hasOwnProp = Object.prototype.hasOwnProperty;\n  var __esm = (fn, res) => function __init() {\n    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;\n  };\n  var __commonJS = (cb, mod) => function __require() {\n    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n  };\n  var __copyProps = (to, from, except, desc) => {\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n      for (let key of __getOwnPropNames(from))\n        if (!__hasOwnProp.call(to, key) && key !== except)\n          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n    }\n    return to;\n  };\n  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n    // If the importer is in node compatibility mode or this is not an ESM\n    // file that has been converted to a CommonJS file using a Babel-\n    // compatible transform (i.e. \"__esModule\" has not been set), then set\n    // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n    isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n    mod\n  ));\n\n  // node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js\n  var require_base64_js = __commonJS({\n    \"node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js\"(exports) {\n      \"use strict\";\n      init_dist();\n      exports.byteLength = byteLength;\n      exports.toByteArray = toByteArray;\n      exports.fromByteArray = fromByteArray;\n      var lookup = [];\n      var revLookup = [];\n      var Arr = typeof Uint8Array !== \"undefined\" ? Uint8Array : Array;\n      var code = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n      for (i = 0, len = code.length; i < len; ++i) {\n        lookup[i] = code[i];\n        revLookup[code.charCodeAt(i)] = i;\n      }\n      var i;\n      var len;\n      revLookup[\"-\".charCodeAt(0)] = 62;\n      revLookup[\"_\".charCodeAt(0)] = 63;\n      function getLens(b64) {\n        var len2 = b64.length;\n        if (len2 % 4 > 0) {\n          throw new Error(\"Invalid string. Length must be a multiple of 4\");\n        }\n        var validLen = b64.indexOf(\"=\");\n        if (validLen === -1)\n          validLen = len2;\n        var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;\n        return [validLen, placeHoldersLen];\n      }\n      function byteLength(b64) {\n        var lens = getLens(b64);\n        var validLen = lens[0];\n        var placeHoldersLen = lens[1];\n        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n      }\n      function _byteLength(b64, validLen, placeHoldersLen) {\n        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n      }\n      function toByteArray(b64) {\n        var tmp;\n        var lens = getLens(b64);\n        var validLen = lens[0];\n        var placeHoldersLen = lens[1];\n        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n        var curByte = 0;\n        var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;\n        var i2;\n        for (i2 = 0; i2 < len2; i2 += 4) {\n          tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];\n          arr[curByte++] = tmp >> 16 & 255;\n          arr[curByte++] = tmp >> 8 & 255;\n          arr[curByte++] = tmp & 255;\n        }\n        if (placeHoldersLen === 2) {\n          tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;\n          arr[curByte++] = tmp & 255;\n        }\n        if (placeHoldersLen === 1) {\n          tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;\n          arr[curByte++] = tmp >> 8 & 255;\n          arr[curByte++] = tmp & 255;\n        }\n        return arr;\n      }\n      function tripletToBase64(num) {\n        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];\n      }\n      function encodeChunk(uint8, start, end) {\n        var tmp;\n        var output = [];\n        for (var i2 = start; i2 < end; i2 += 3) {\n          tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);\n          output.push(tripletToBase64(tmp));\n        }\n        return output.join(\"\");\n      }\n      function fromByteArray(uint8) {\n        var tmp;\n        var len2 = uint8.length;\n        var extraBytes = len2 % 3;\n        var parts = [];\n        var maxChunkLength = 16383;\n        for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {\n          parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));\n        }\n        if (extraBytes === 1) {\n          tmp = uint8[len2 - 1];\n          parts.push(\n            lookup[tmp >> 2] + lookup[tmp << 4 & 63] + \"==\"\n          );\n        } else if (extraBytes === 2) {\n          tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];\n          parts.push(\n            lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + \"=\"\n          );\n        }\n        return parts.join(\"\");\n      }\n    }\n  });\n\n  // node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js\n  var require_ieee754 = __commonJS({\n    \"node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js\"(exports) {\n      init_dist();\n      exports.read = function(buffer, offset, isLE, mLen, nBytes) {\n        var e, m;\n        var eLen = nBytes * 8 - mLen - 1;\n        var eMax = (1 << eLen) - 1;\n        var eBias = eMax >> 1;\n        var nBits = -7;\n        var i = isLE ? nBytes - 1 : 0;\n        var d = isLE ? -1 : 1;\n        var s2 = buffer[offset + i];\n        i += d;\n        e = s2 & (1 << -nBits) - 1;\n        s2 >>= -nBits;\n        nBits += eLen;\n        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {\n        }\n        m = e & (1 << -nBits) - 1;\n        e >>= -nBits;\n        nBits += mLen;\n        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {\n        }\n        if (e === 0) {\n          e = 1 - eBias;\n        } else if (e === eMax) {\n          return m ? NaN : (s2 ? -1 : 1) * Infinity;\n        } else {\n          m = m + Math.pow(2, mLen);\n          e = e - eBias;\n        }\n        return (s2 ? -1 : 1) * m * Math.pow(2, e - mLen);\n      };\n      exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {\n        var e, m, c;\n        var eLen = nBytes * 8 - mLen - 1;\n        var eMax = (1 << eLen) - 1;\n        var eBias = eMax >> 1;\n        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n        var i = isLE ? 0 : nBytes - 1;\n        var d = isLE ? 1 : -1;\n        var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n        value = Math.abs(value);\n        if (isNaN(value) || value === Infinity) {\n          m = isNaN(value) ? 1 : 0;\n          e = eMax;\n        } else {\n          e = Math.floor(Math.log(value) / Math.LN2);\n          if (value * (c = Math.pow(2, -e)) < 1) {\n            e--;\n            c *= 2;\n          }\n          if (e + eBias >= 1) {\n            value += rt / c;\n          } else {\n            value += rt * Math.pow(2, 1 - eBias);\n          }\n          if (value * c >= 2) {\n            e++;\n            c /= 2;\n          }\n          if (e + eBias >= eMax) {\n            m = 0;\n            e = eMax;\n          } else if (e + eBias >= 1) {\n            m = (value * c - 1) * Math.pow(2, mLen);\n            e = e + eBias;\n          } else {\n            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n            e = 0;\n          }\n        }\n        for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {\n        }\n        e = e << mLen | m;\n        eLen += mLen;\n        for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {\n        }\n        buffer[offset + i - d] |= s2 * 128;\n      };\n    }\n  });\n\n  // node_modules/.pnpm/buffer@6.0.3_patch_hash=zkkuxompt5d553skpnegwi5wuy/node_modules/buffer/index.js\n  var require_buffer = __commonJS({\n    \"node_modules/.pnpm/buffer@6.0.3_patch_hash=zkkuxompt5d553skpnegwi5wuy/node_modules/buffer/index.js\"(exports) {\n      \"use strict\";\n      init_dist();\n      var base64 = require_base64_js();\n      var ieee754 = require_ieee754();\n      var customInspectSymbol = typeof Symbol === \"function\" && typeof Symbol[\"for\"] === \"function\" ? Symbol[\"for\"](\"nodejs.util.inspect.custom\") : null;\n      exports.Buffer = Buffer2;\n      exports.SlowBuffer = SlowBuffer;\n      exports.INSPECT_MAX_BYTES = 50;\n      var K_MAX_LENGTH = 2147483647;\n      exports.kMaxLength = K_MAX_LENGTH;\n      var { Uint8Array: GlobalUint8Array, ArrayBuffer: GlobalArrayBuffer, SharedArrayBuffer: GlobalSharedArrayBuffer } = globalThis;\n      Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();\n      if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== \"undefined\" && typeof console.error === \"function\") {\n        console.error(\n          \"This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.\"\n        );\n      }\n      function typedArraySupport() {\n        try {\n          const arr = new GlobalUint8Array(1);\n          const proto = { foo: function() {\n            return 42;\n          } };\n          Object.setPrototypeOf(proto, GlobalUint8Array.prototype);\n          Object.setPrototypeOf(arr, proto);\n          return arr.foo() === 42;\n        } catch (e) {\n          return false;\n        }\n      }\n      Object.defineProperty(Buffer2.prototype, \"parent\", {\n        enumerable: true,\n        get: function() {\n          if (!Buffer2.isBuffer(this))\n            return void 0;\n          return this.buffer;\n        }\n      });\n      Object.defineProperty(Buffer2.prototype, \"offset\", {\n        enumerable: true,\n        get: function() {\n          if (!Buffer2.isBuffer(this))\n            return void 0;\n          return this.byteOffset;\n        }\n      });\n      function createBuffer(length) {\n        if (length > K_MAX_LENGTH) {\n          throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"');\n        }\n        const buf = new GlobalUint8Array(length);\n        Object.setPrototypeOf(buf, Buffer2.prototype);\n        return buf;\n      }\n      function Buffer2(arg, encodingOrOffset, length) {\n        if (typeof arg === \"number\") {\n          if (typeof encodingOrOffset === \"string\") {\n            throw new TypeError(\n              'The \"string\" argument must be of type string. Received type number'\n            );\n          }\n          return allocUnsafe(arg);\n        }\n        return from(arg, encodingOrOffset, length);\n      }\n      Buffer2.poolSize = 8192;\n      function from(value, encodingOrOffset, length) {\n        if (typeof value === \"string\") {\n          return fromString(value, encodingOrOffset);\n        }\n        if (GlobalArrayBuffer.isView(value)) {\n          return fromArrayView(value);\n        }\n        if (value == null) {\n          throw new TypeError(\n            \"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value\n          );\n        }\n        if (isInstance(value, GlobalArrayBuffer) || value && isInstance(value.buffer, GlobalArrayBuffer)) {\n          return fromArrayBuffer(value, encodingOrOffset, length);\n        }\n        if (typeof GlobalSharedArrayBuffer !== \"undefined\" && (isInstance(value, GlobalSharedArrayBuffer) || value && isInstance(value.buffer, GlobalSharedArrayBuffer))) {\n          return fromArrayBuffer(value, encodingOrOffset, length);\n        }\n        if (typeof value === \"number\") {\n          throw new TypeError(\n            'The \"value\" argument must not be of type number. Received type number'\n          );\n        }\n        const valueOf = value.valueOf && value.valueOf();\n        if (valueOf != null && valueOf !== value) {\n          return Buffer2.from(valueOf, encodingOrOffset, length);\n        }\n        const b = fromObject(value);\n        if (b)\n          return b;\n        if (typeof Symbol !== \"undefined\" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === \"function\") {\n          return Buffer2.from(value[Symbol.toPrimitive](\"string\"), encodingOrOffset, length);\n        }\n        throw new TypeError(\n          \"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value\n        );\n      }\n      Buffer2.from = function(value, encodingOrOffset, length) {\n        return from(value, encodingOrOffset, length);\n      };\n      Object.setPrototypeOf(Buffer2.prototype, GlobalUint8Array.prototype);\n      Object.setPrototypeOf(Buffer2, GlobalUint8Array);\n      function assertSize(size) {\n        if (typeof size !== \"number\") {\n          throw new TypeError('\"size\" argument must be of type number');\n        } else if (size < 0) {\n          throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"');\n        }\n      }\n      function alloc(size, fill, encoding) {\n        assertSize(size);\n        if (size <= 0) {\n          return createBuffer(size);\n        }\n        if (fill !== void 0) {\n          return typeof encoding === \"string\" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);\n        }\n        return createBuffer(size);\n      }\n      Buffer2.alloc = function(size, fill, encoding) {\n        return alloc(size, fill, encoding);\n      };\n      function allocUnsafe(size) {\n        assertSize(size);\n        return createBuffer(size < 0 ? 0 : checked(size) | 0);\n      }\n      Buffer2.allocUnsafe = function(size) {\n        return allocUnsafe(size);\n      };\n      Buffer2.allocUnsafeSlow = function(size) {\n        return allocUnsafe(size);\n      };\n      function fromString(string, encoding) {\n        if (typeof encoding !== \"string\" || encoding === \"\") {\n          encoding = \"utf8\";\n        }\n        if (!Buffer2.isEncoding(encoding)) {\n          throw new TypeError(\"Unknown encoding: \" + encoding);\n        }\n        const length = byteLength(string, encoding) | 0;\n        let buf = createBuffer(length);\n        const actual = buf.write(string, encoding);\n        if (actual !== length) {\n          buf = buf.slice(0, actual);\n        }\n        return buf;\n      }\n      function fromArrayLike(array) {\n        const length = array.length < 0 ? 0 : checked(array.length) | 0;\n        const buf = createBuffer(length);\n        for (let i = 0; i < length; i += 1) {\n          buf[i] = array[i] & 255;\n        }\n        return buf;\n      }\n      function fromArrayView(arrayView) {\n        if (isInstance(arrayView, GlobalUint8Array)) {\n          const copy = new GlobalUint8Array(arrayView);\n          return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);\n        }\n        return fromArrayLike(arrayView);\n      }\n      function fromArrayBuffer(array, byteOffset, length) {\n        if (byteOffset < 0 || array.byteLength < byteOffset) {\n          throw new RangeError('\"offset\" is outside of buffer bounds');\n        }\n        if (array.byteLength < byteOffset + (length || 0)) {\n          throw new RangeError('\"length\" is outside of buffer bounds');\n        }\n        let buf;\n        if (byteOffset === void 0 && length === void 0) {\n          buf = new GlobalUint8Array(array);\n        } else if (length === void 0) {\n          buf = new GlobalUint8Array(array, byteOffset);\n        } else {\n          buf = new GlobalUint8Array(array, byteOffset, length);\n        }\n        Object.setPrototypeOf(buf, Buffer2.prototype);\n        return buf;\n      }\n      function fromObject(obj) {\n        if (Buffer2.isBuffer(obj)) {\n          const len = checked(obj.length) | 0;\n          const buf = createBuffer(len);\n          if (buf.length === 0) {\n            return buf;\n          }\n          obj.copy(buf, 0, 0, len);\n          return buf;\n        }\n        if (obj.length !== void 0) {\n          if (typeof obj.length !== \"number\" || numberIsNaN(obj.length)) {\n            return createBuffer(0);\n          }\n          return fromArrayLike(obj);\n        }\n        if (obj.type === \"Buffer\" && Array.isArray(obj.data)) {\n          return fromArrayLike(obj.data);\n        }\n      }\n      function checked(length) {\n        if (length >= K_MAX_LENGTH) {\n          throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\" + K_MAX_LENGTH.toString(16) + \" bytes\");\n        }\n        return length | 0;\n      }\n      function SlowBuffer(length) {\n        if (+length != length) {\n          length = 0;\n        }\n        return Buffer2.alloc(+length);\n      }\n      Buffer2.isBuffer = function isBuffer(b) {\n        return b != null && b._isBuffer === true && b !== Buffer2.prototype;\n      };\n      Buffer2.compare = function compare(a, b) {\n        if (isInstance(a, GlobalUint8Array))\n          a = Buffer2.from(a, a.offset, a.byteLength);\n        if (isInstance(b, GlobalUint8Array))\n          b = Buffer2.from(b, b.offset, b.byteLength);\n        if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {\n          throw new TypeError(\n            'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n          );\n        }\n        if (a === b)\n          return 0;\n        let x = a.length;\n        let y = b.length;\n        for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n          if (a[i] !== b[i]) {\n            x = a[i];\n            y = b[i];\n            break;\n          }\n        }\n        if (x < y)\n          return -1;\n        if (y < x)\n          return 1;\n        return 0;\n      };\n      Buffer2.isEncoding = function isEncoding(encoding) {\n        switch (String(encoding).toLowerCase()) {\n          case \"hex\":\n          case \"utf8\":\n          case \"utf-8\":\n          case \"ascii\":\n          case \"latin1\":\n          case \"binary\":\n          case \"base64\":\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return true;\n          default:\n            return false;\n        }\n      };\n      Buffer2.concat = function concat(list, length) {\n        if (!Array.isArray(list)) {\n          throw new TypeError('\"list\" argument must be an Array of Buffers');\n        }\n        if (list.length === 0) {\n          return Buffer2.alloc(0);\n        }\n        let i;\n        if (length === void 0) {\n          length = 0;\n          for (i = 0; i < list.length; ++i) {\n            length += list[i].length;\n          }\n        }\n        const buffer = Buffer2.allocUnsafe(length);\n        let pos = 0;\n        for (i = 0; i < list.length; ++i) {\n          let buf = list[i];\n          if (isInstance(buf, GlobalUint8Array)) {\n            if (pos + buf.length > buffer.length) {\n              if (!Buffer2.isBuffer(buf))\n                buf = Buffer2.from(buf);\n              buf.copy(buffer, pos);\n            } else {\n              GlobalUint8Array.prototype.set.call(\n                buffer,\n                buf,\n                pos\n              );\n            }\n          } else if (!Buffer2.isBuffer(buf)) {\n            throw new TypeError('\"list\" argument must be an Array of Buffers');\n          } else {\n            buf.copy(buffer, pos);\n          }\n          pos += buf.length;\n        }\n        return buffer;\n      };\n      function byteLength(string, encoding) {\n        if (Buffer2.isBuffer(string)) {\n          return string.length;\n        }\n        if (GlobalArrayBuffer.isView(string) || isInstance(string, GlobalArrayBuffer)) {\n          return string.byteLength;\n        }\n        if (typeof string !== \"string\") {\n          throw new TypeError(\n            'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string\n          );\n        }\n        const len = string.length;\n        const mustMatch = arguments.length > 2 && arguments[2] === true;\n        if (!mustMatch && len === 0)\n          return 0;\n        let loweredCase = false;\n        for (; ; ) {\n          switch (encoding) {\n            case \"ascii\":\n            case \"latin1\":\n            case \"binary\":\n              return len;\n            case \"utf8\":\n            case \"utf-8\":\n              return utf8ToBytes(string).length;\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n              return len * 2;\n            case \"hex\":\n              return len >>> 1;\n            case \"base64\":\n              return base64ToBytes(string).length;\n            default:\n              if (loweredCase) {\n                return mustMatch ? -1 : utf8ToBytes(string).length;\n              }\n              encoding = (\"\" + encoding).toLowerCase();\n              loweredCase = true;\n          }\n        }\n      }\n      Buffer2.byteLength = byteLength;\n      function slowToString(encoding, start, end) {\n        let loweredCase = false;\n        if (start === void 0 || start < 0) {\n          start = 0;\n        }\n        if (start > this.length) {\n          return \"\";\n        }\n        if (end === void 0 || end > this.length) {\n          end = this.length;\n        }\n        if (end <= 0) {\n          return \"\";\n        }\n        end >>>= 0;\n        start >>>= 0;\n        if (end <= start) {\n          return \"\";\n        }\n        if (!encoding)\n          encoding = \"utf8\";\n        while (true) {\n          switch (encoding) {\n            case \"hex\":\n              return hexSlice(this, start, end);\n            case \"utf8\":\n            case \"utf-8\":\n              return utf8Slice(this, start, end);\n            case \"ascii\":\n              return asciiSlice(this, start, end);\n            case \"latin1\":\n            case \"binary\":\n              return latin1Slice(this, start, end);\n            case \"base64\":\n              return base64Slice(this, start, end);\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n              return utf16leSlice(this, start, end);\n            default:\n              if (loweredCase)\n                throw new TypeError(\"Unknown encoding: \" + encoding);\n              encoding = (encoding + \"\").toLowerCase();\n              loweredCase = true;\n          }\n        }\n      }\n      Buffer2.prototype._isBuffer = true;\n      function swap(b, n, m) {\n        const i = b[n];\n        b[n] = b[m];\n        b[m] = i;\n      }\n      Buffer2.prototype.swap16 = function swap16() {\n        const len = this.length;\n        if (len % 2 !== 0) {\n          throw new RangeError(\"Buffer size must be a multiple of 16-bits\");\n        }\n        for (let i = 0; i < len; i += 2) {\n          swap(this, i, i + 1);\n        }\n        return this;\n      };\n      Buffer2.prototype.swap32 = function swap32() {\n        const len = this.length;\n        if (len % 4 !== 0) {\n          throw new RangeError(\"Buffer size must be a multiple of 32-bits\");\n        }\n        for (let i = 0; i < len; i += 4) {\n          swap(this, i, i + 3);\n          swap(this, i + 1, i + 2);\n        }\n        return this;\n      };\n      Buffer2.prototype.swap64 = function swap64() {\n        const len = this.length;\n        if (len % 8 !== 0) {\n          throw new RangeError(\"Buffer size must be a multiple of 64-bits\");\n        }\n        for (let i = 0; i < len; i += 8) {\n          swap(this, i, i + 7);\n          swap(this, i + 1, i + 6);\n          swap(this, i + 2, i + 5);\n          swap(this, i + 3, i + 4);\n        }\n        return this;\n      };\n      Buffer2.prototype.toString = function toString() {\n        const length = this.length;\n        if (length === 0)\n          return \"\";\n        if (arguments.length === 0)\n          return utf8Slice(this, 0, length);\n        return slowToString.apply(this, arguments);\n      };\n      Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;\n      Buffer2.prototype.equals = function equals(b) {\n        if (!Buffer2.isBuffer(b))\n          throw new TypeError(\"Argument must be a Buffer\");\n        if (this === b)\n          return true;\n        return Buffer2.compare(this, b) === 0;\n      };\n      Buffer2.prototype.inspect = function inspect() {\n        let str = \"\";\n        const max = exports.INSPECT_MAX_BYTES;\n        str = this.toString(\"hex\", 0, max).replace(/(.{2})/g, \"$1 \").trim();\n        if (this.length > max)\n          str += \" ... \";\n        return \"<Buffer \" + str + \">\";\n      };\n      if (customInspectSymbol) {\n        Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;\n      }\n      Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n        if (isInstance(target, GlobalUint8Array)) {\n          target = Buffer2.from(target, target.offset, target.byteLength);\n        }\n        if (!Buffer2.isBuffer(target)) {\n          throw new TypeError(\n            'The \"target\" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target\n          );\n        }\n        if (start === void 0) {\n          start = 0;\n        }\n        if (end === void 0) {\n          end = target ? target.length : 0;\n        }\n        if (thisStart === void 0) {\n          thisStart = 0;\n        }\n        if (thisEnd === void 0) {\n          thisEnd = this.length;\n        }\n        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n          throw new RangeError(\"out of range index\");\n        }\n        if (thisStart >= thisEnd && start >= end) {\n          return 0;\n        }\n        if (thisStart >= thisEnd) {\n          return -1;\n        }\n        if (start >= end) {\n          return 1;\n        }\n        start >>>= 0;\n        end >>>= 0;\n        thisStart >>>= 0;\n        thisEnd >>>= 0;\n        if (this === target)\n          return 0;\n        let x = thisEnd - thisStart;\n        let y = end - start;\n        const len = Math.min(x, y);\n        const thisCopy = this.slice(thisStart, thisEnd);\n        const targetCopy = target.slice(start, end);\n        for (let i = 0; i < len; ++i) {\n          if (thisCopy[i] !== targetCopy[i]) {\n            x = thisCopy[i];\n            y = targetCopy[i];\n            break;\n          }\n        }\n        if (x < y)\n          return -1;\n        if (y < x)\n          return 1;\n        return 0;\n      };\n      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n        if (buffer.length === 0)\n          return -1;\n        if (typeof byteOffset === \"string\") {\n          encoding = byteOffset;\n          byteOffset = 0;\n        } else if (byteOffset > 2147483647) {\n          byteOffset = 2147483647;\n        } else if (byteOffset < -2147483648) {\n          byteOffset = -2147483648;\n        }\n        byteOffset = +byteOffset;\n        if (numberIsNaN(byteOffset)) {\n          byteOffset = dir ? 0 : buffer.length - 1;\n        }\n        if (byteOffset < 0)\n          byteOffset = buffer.length + byteOffset;\n        if (byteOffset >= buffer.length) {\n          if (dir)\n            return -1;\n          else\n            byteOffset = buffer.length - 1;\n        } else if (byteOffset < 0) {\n          if (dir)\n            byteOffset = 0;\n          else\n            return -1;\n        }\n        if (typeof val === \"string\") {\n          val = Buffer2.from(val, encoding);\n        }\n        if (Buffer2.isBuffer(val)) {\n          if (val.length === 0) {\n            return -1;\n          }\n          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n        } else if (typeof val === \"number\") {\n          val = val & 255;\n          if (typeof GlobalUint8Array.prototype.indexOf === \"function\") {\n            if (dir) {\n              return GlobalUint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n            } else {\n              return GlobalUint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n            }\n          }\n          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);\n        }\n        throw new TypeError(\"val must be string, number or Buffer\");\n      }\n      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n        let indexSize = 1;\n        let arrLength = arr.length;\n        let valLength = val.length;\n        if (encoding !== void 0) {\n          encoding = String(encoding).toLowerCase();\n          if (encoding === \"ucs2\" || encoding === \"ucs-2\" || encoding === \"utf16le\" || encoding === \"utf-16le\") {\n            if (arr.length < 2 || val.length < 2) {\n              return -1;\n            }\n            indexSize = 2;\n            arrLength /= 2;\n            valLength /= 2;\n            byteOffset /= 2;\n          }\n        }\n        function read(buf, i2) {\n          if (indexSize === 1) {\n            return buf[i2];\n          } else {\n            return buf.readUInt16BE(i2 * indexSize);\n          }\n        }\n        let i;\n        if (dir) {\n          let foundIndex = -1;\n          for (i = byteOffset; i < arrLength; i++) {\n            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n              if (foundIndex === -1)\n                foundIndex = i;\n              if (i - foundIndex + 1 === valLength)\n                return foundIndex * indexSize;\n            } else {\n              if (foundIndex !== -1)\n                i -= i - foundIndex;\n              foundIndex = -1;\n            }\n          }\n        } else {\n          if (byteOffset + valLength > arrLength)\n            byteOffset = arrLength - valLength;\n          for (i = byteOffset; i >= 0; i--) {\n            let found = true;\n            for (let j = 0; j < valLength; j++) {\n              if (read(arr, i + j) !== read(val, j)) {\n                found = false;\n                break;\n              }\n            }\n            if (found)\n              return i;\n          }\n        }\n        return -1;\n      }\n      Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {\n        return this.indexOf(val, byteOffset, encoding) !== -1;\n      };\n      Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n      };\n      Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n      };\n      function hexWrite(buf, string, offset, length) {\n        offset = Number(offset) || 0;\n        const remaining = buf.length - offset;\n        if (!length) {\n          length = remaining;\n        } else {\n          length = Number(length);\n          if (length > remaining) {\n            length = remaining;\n          }\n        }\n        const strLen = string.length;\n        if (length > strLen / 2) {\n          length = strLen / 2;\n        }\n        let i;\n        for (i = 0; i < length; ++i) {\n          const parsed = parseInt(string.substr(i * 2, 2), 16);\n          if (numberIsNaN(parsed))\n            return i;\n          buf[offset + i] = parsed;\n        }\n        return i;\n      }\n      function utf8Write(buf, string, offset, length) {\n        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n      }\n      function asciiWrite(buf, string, offset, length) {\n        return blitBuffer(asciiToBytes(string), buf, offset, length);\n      }\n      function base64Write(buf, string, offset, length) {\n        return blitBuffer(base64ToBytes(string), buf, offset, length);\n      }\n      function ucs2Write(buf, string, offset, length) {\n        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n      }\n      Buffer2.prototype.write = function write(string, offset, length, encoding) {\n        if (offset === void 0) {\n          encoding = \"utf8\";\n          length = this.length;\n          offset = 0;\n        } else if (length === void 0 && typeof offset === \"string\") {\n          encoding = offset;\n          length = this.length;\n          offset = 0;\n        } else if (isFinite(offset)) {\n          offset = offset >>> 0;\n          if (isFinite(length)) {\n            length = length >>> 0;\n            if (encoding === void 0)\n              encoding = \"utf8\";\n          } else {\n            encoding = length;\n            length = void 0;\n          }\n        } else {\n          throw new Error(\n            \"Buffer.write(string, encoding, offset[, length]) is no longer supported\"\n          );\n        }\n        const remaining = this.length - offset;\n        if (length === void 0 || length > remaining)\n          length = remaining;\n        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n          throw new RangeError(\"Attempt to write outside buffer bounds\");\n        }\n        if (!encoding)\n          encoding = \"utf8\";\n        let loweredCase = false;\n        for (; ; ) {\n          switch (encoding) {\n            case \"hex\":\n              return hexWrite(this, string, offset, length);\n            case \"utf8\":\n            case \"utf-8\":\n              return utf8Write(this, string, offset, length);\n            case \"ascii\":\n            case \"latin1\":\n            case \"binary\":\n              return asciiWrite(this, string, offset, length);\n            case \"base64\":\n              return base64Write(this, string, offset, length);\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n              return ucs2Write(this, string, offset, length);\n            default:\n              if (loweredCase)\n                throw new TypeError(\"Unknown encoding: \" + encoding);\n              encoding = (\"\" + encoding).toLowerCase();\n              loweredCase = true;\n          }\n        }\n      };\n      Buffer2.prototype.toJSON = function toJSON() {\n        return {\n          type: \"Buffer\",\n          data: Array.prototype.slice.call(this._arr || this, 0)\n        };\n      };\n      function base64Slice(buf, start, end) {\n        if (start === 0 && end === buf.length) {\n          return base64.fromByteArray(buf);\n        } else {\n          return base64.fromByteArray(buf.slice(start, end));\n        }\n      }\n      function utf8Slice(buf, start, end) {\n        end = Math.min(buf.length, end);\n        const res = [];\n        let i = start;\n        while (i < end) {\n          const firstByte = buf[i];\n          let codePoint = null;\n          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;\n          if (i + bytesPerSequence <= end) {\n            let secondByte, thirdByte, fourthByte, tempCodePoint;\n            switch (bytesPerSequence) {\n              case 1:\n                if (firstByte < 128) {\n                  codePoint = firstByte;\n                }\n                break;\n              case 2:\n                secondByte = buf[i + 1];\n                if ((secondByte & 192) === 128) {\n                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;\n                  if (tempCodePoint > 127) {\n                    codePoint = tempCodePoint;\n                  }\n                }\n                break;\n              case 3:\n                secondByte = buf[i + 1];\n                thirdByte = buf[i + 2];\n                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {\n                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;\n                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {\n                    codePoint = tempCodePoint;\n                  }\n                }\n                break;\n              case 4:\n                secondByte = buf[i + 1];\n                thirdByte = buf[i + 2];\n                fourthByte = buf[i + 3];\n                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {\n                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;\n                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {\n                    codePoint = tempCodePoint;\n                  }\n                }\n            }\n          }\n          if (codePoint === null) {\n            codePoint = 65533;\n            bytesPerSequence = 1;\n          } else if (codePoint > 65535) {\n            codePoint -= 65536;\n            res.push(codePoint >>> 10 & 1023 | 55296);\n            codePoint = 56320 | codePoint & 1023;\n          }\n          res.push(codePoint);\n          i += bytesPerSequence;\n        }\n        return decodeCodePointsArray(res);\n      }\n      var MAX_ARGUMENTS_LENGTH = 4096;\n      function decodeCodePointsArray(codePoints) {\n        const len = codePoints.length;\n        if (len <= MAX_ARGUMENTS_LENGTH) {\n          return String.fromCharCode.apply(String, codePoints);\n        }\n        let res = \"\";\n        let i = 0;\n        while (i < len) {\n          res += String.fromCharCode.apply(\n            String,\n            codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n          );\n        }\n        return res;\n      }\n      function asciiSlice(buf, start, end) {\n        let ret = \"\";\n        end = Math.min(buf.length, end);\n        for (let i = start; i < end; ++i) {\n          ret += String.fromCharCode(buf[i] & 127);\n        }\n        return ret;\n      }\n      function latin1Slice(buf, start, end) {\n        let ret = \"\";\n        end = Math.min(buf.length, end);\n        for (let i = start; i < end; ++i) {\n          ret += String.fromCharCode(buf[i]);\n        }\n        return ret;\n      }\n      function hexSlice(buf, start, end) {\n        const len = buf.length;\n        if (!start || start < 0)\n          start = 0;\n        if (!end || end < 0 || end > len)\n          end = len;\n        let out = \"\";\n        for (let i = start; i < end; ++i) {\n          out += hexSliceLookupTable[buf[i]];\n        }\n        return out;\n      }\n      function utf16leSlice(buf, start, end) {\n        const bytes = buf.slice(start, end);\n        let res = \"\";\n        for (let i = 0; i < bytes.length - 1; i += 2) {\n          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n        }\n        return res;\n      }\n      Buffer2.prototype.slice = function slice(start, end) {\n        const len = this.length;\n        start = ~~start;\n        end = end === void 0 ? len : ~~end;\n        if (start < 0) {\n          start += len;\n          if (start < 0)\n            start = 0;\n        } else if (start > len) {\n          start = len;\n        }\n        if (end < 0) {\n          end += len;\n          if (end < 0)\n            end = 0;\n        } else if (end > len) {\n          end = len;\n        }\n        if (end < start)\n          end = start;\n        const newBuf = this.subarray(start, end);\n        Object.setPrototypeOf(newBuf, Buffer2.prototype);\n        return newBuf;\n      };\n      function checkOffset(offset, ext, length) {\n        if (offset % 1 !== 0 || offset < 0)\n          throw new RangeError(\"offset is not uint\");\n        if (offset + ext > length)\n          throw new RangeError(\"Trying to access beyond buffer length\");\n      }\n      Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert)\n          checkOffset(offset, byteLength2, this.length);\n        let val = this[offset];\n        let mul = 1;\n        let i = 0;\n        while (++i < byteLength2 && (mul *= 256)) {\n          val += this[offset + i] * mul;\n        }\n        return val;\n      };\n      Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert) {\n          checkOffset(offset, byteLength2, this.length);\n        }\n        let val = this[offset + --byteLength2];\n        let mul = 1;\n        while (byteLength2 > 0 && (mul *= 256)) {\n          val += this[offset + --byteLength2] * mul;\n        }\n        return val;\n      };\n      Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 1, this.length);\n        return this[offset];\n      };\n      Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 2, this.length);\n        return this[offset] | this[offset + 1] << 8;\n      };\n      Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 2, this.length);\n        return this[offset] << 8 | this[offset + 1];\n      };\n      Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;\n      };\n      Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n      };\n      Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {\n        offset = offset >>> 0;\n        validateNumber(offset, \"offset\");\n        const first = this[offset];\n        const last = this[offset + 7];\n        if (first === void 0 || last === void 0) {\n          boundsError(offset, this.length - 8);\n        }\n        const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;\n        const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;\n        return BigInt(lo) + (BigInt(hi) << BigInt(32));\n      });\n      Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {\n        offset = offset >>> 0;\n        validateNumber(offset, \"offset\");\n        const first = this[offset];\n        const last = this[offset + 7];\n        if (first === void 0 || last === void 0) {\n          boundsError(offset, this.length - 8);\n        }\n        const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];\n        const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;\n        return (BigInt(hi) << BigInt(32)) + BigInt(lo);\n      });\n      Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert)\n          checkOffset(offset, byteLength2, this.length);\n        let val = this[offset];\n        let mul = 1;\n        let i = 0;\n        while (++i < byteLength2 && (mul *= 256)) {\n          val += this[offset + i] * mul;\n        }\n        mul *= 128;\n        if (val >= mul)\n          val -= Math.pow(2, 8 * byteLength2);\n        return val;\n      };\n      Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert)\n          checkOffset(offset, byteLength2, this.length);\n        let i = byteLength2;\n        let mul = 1;\n        let val = this[offset + --i];\n        while (i > 0 && (mul *= 256)) {\n          val += this[offset + --i] * mul;\n        }\n        mul *= 128;\n        if (val >= mul)\n          val -= Math.pow(2, 8 * byteLength2);\n        return val;\n      };\n      Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 1, this.length);\n        if (!(this[offset] & 128))\n          return this[offset];\n        return (255 - this[offset] + 1) * -1;\n      };\n      Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 2, this.length);\n        const val = this[offset] | this[offset + 1] << 8;\n        return val & 32768 ? val | 4294901760 : val;\n      };\n      Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 2, this.length);\n        const val = this[offset + 1] | this[offset] << 8;\n        return val & 32768 ? val | 4294901760 : val;\n      };\n      Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n      };\n      Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n      };\n      Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {\n        offset = offset >>> 0;\n        validateNumber(offset, \"offset\");\n        const first = this[offset];\n        const last = this[offset + 7];\n        if (first === void 0 || last === void 0) {\n          boundsError(offset, this.length - 8);\n        }\n        const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);\n        return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);\n      });\n      Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {\n        offset = offset >>> 0;\n        validateNumber(offset, \"offset\");\n        const first = this[offset];\n        const last = this[offset + 7];\n        if (first === void 0 || last === void 0) {\n          boundsError(offset, this.length - 8);\n        }\n        const val = (first << 24) + // Overflow\n        this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];\n        return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);\n      });\n      Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return ieee754.read(this, offset, true, 23, 4);\n      };\n      Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return ieee754.read(this, offset, false, 23, 4);\n      };\n      Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 8, this.length);\n        return ieee754.read(this, offset, true, 52, 8);\n      };\n      Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 8, this.length);\n        return ieee754.read(this, offset, false, 52, 8);\n      };\n      function checkInt(buf, value, offset, ext, max, min) {\n        if (!Buffer2.isBuffer(buf))\n          throw new TypeError('\"buffer\" argument must be a Buffer instance');\n        if (value > max || value < min)\n          throw new RangeError('\"value\" argument is out of bounds');\n        if (offset + ext > buf.length)\n          throw new RangeError(\"Index out of range\");\n      }\n      Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert) {\n          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;\n          checkInt(this, value, offset, byteLength2, maxBytes, 0);\n        }\n        let mul = 1;\n        let i = 0;\n        this[offset] = value & 255;\n        while (++i < byteLength2 && (mul *= 256)) {\n          this[offset + i] = value / mul & 255;\n        }\n        return offset + byteLength2;\n      };\n      Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert) {\n          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;\n          checkInt(this, value, offset, byteLength2, maxBytes, 0);\n        }\n        let i = byteLength2 - 1;\n        let mul = 1;\n        this[offset + i] = value & 255;\n        while (--i >= 0 && (mul *= 256)) {\n          this[offset + i] = value / mul & 255;\n        }\n        return offset + byteLength2;\n      };\n      Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 1, 255, 0);\n        this[offset] = value & 255;\n        return offset + 1;\n      };\n      Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 2, 65535, 0);\n        this[offset] = value & 255;\n        this[offset + 1] = value >>> 8;\n        return offset + 2;\n      };\n      Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 2, 65535, 0);\n        this[offset] = value >>> 8;\n        this[offset + 1] = value & 255;\n        return offset + 2;\n      };\n      Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 4, 4294967295, 0);\n        this[offset + 3] = value >>> 24;\n        this[offset + 2] = value >>> 16;\n        this[offset + 1] = value >>> 8;\n        this[offset] = value & 255;\n        return offset + 4;\n      };\n      Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 4, 4294967295, 0);\n        this[offset] = value >>> 24;\n        this[offset + 1] = value >>> 16;\n        this[offset + 2] = value >>> 8;\n        this[offset + 3] = value & 255;\n        return offset + 4;\n      };\n      function wrtBigUInt64LE(buf, value, offset, min, max) {\n        checkIntBI(value, min, max, buf, offset, 7);\n        let lo = Number(value & BigInt(4294967295));\n        buf[offset++] = lo;\n        lo = lo >> 8;\n        buf[offset++] = lo;\n        lo = lo >> 8;\n        buf[offset++] = lo;\n        lo = lo >> 8;\n        buf[offset++] = lo;\n        let hi = Number(value >> BigInt(32) & BigInt(4294967295));\n        buf[offset++] = hi;\n        hi = hi >> 8;\n        buf[offset++] = hi;\n        hi = hi >> 8;\n        buf[offset++] = hi;\n        hi = hi >> 8;\n        buf[offset++] = hi;\n        return offset;\n      }\n      function wrtBigUInt64BE(buf, value, offset, min, max) {\n        checkIntBI(value, min, max, buf, offset, 7);\n        let lo = Number(value & BigInt(4294967295));\n        buf[offset + 7] = lo;\n        lo = lo >> 8;\n        buf[offset + 6] = lo;\n        lo = lo >> 8;\n        buf[offset + 5] = lo;\n        lo = lo >> 8;\n        buf[offset + 4] = lo;\n        let hi = Number(value >> BigInt(32) & BigInt(4294967295));\n        buf[offset + 3] = hi;\n        hi = hi >> 8;\n        buf[offset + 2] = hi;\n        hi = hi >> 8;\n        buf[offset + 1] = hi;\n        hi = hi >> 8;\n        buf[offset] = hi;\n        return offset + 8;\n      }\n      Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {\n        return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n      });\n      Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {\n        return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n      });\n      Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          const limit = Math.pow(2, 8 * byteLength2 - 1);\n          checkInt(this, value, offset, byteLength2, limit - 1, -limit);\n        }\n        let i = 0;\n        let mul = 1;\n        let sub = 0;\n        this[offset] = value & 255;\n        while (++i < byteLength2 && (mul *= 256)) {\n          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n            sub = 1;\n          }\n          this[offset + i] = (value / mul >> 0) - sub & 255;\n        }\n        return offset + byteLength2;\n      };\n      Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          const limit = Math.pow(2, 8 * byteLength2 - 1);\n          checkInt(this, value, offset, byteLength2, limit - 1, -limit);\n        }\n        let i = byteLength2 - 1;\n        let mul = 1;\n        let sub = 0;\n        this[offset + i] = value & 255;\n        while (--i >= 0 && (mul *= 256)) {\n          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n            sub = 1;\n          }\n          this[offset + i] = (value / mul >> 0) - sub & 255;\n        }\n        return offset + byteLength2;\n      };\n      Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 1, 127, -128);\n        if (value < 0)\n          value = 255 + value + 1;\n        this[offset] = value & 255;\n        return offset + 1;\n      };\n      Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 2, 32767, -32768);\n        this[offset] = value & 255;\n        this[offset + 1] = value >>> 8;\n        return offset + 2;\n      };\n      Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 2, 32767, -32768);\n        this[offset] = value >>> 8;\n        this[offset + 1] = value & 255;\n        return offset + 2;\n      };\n      Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 4, 2147483647, -2147483648);\n        this[offset] = value & 255;\n        this[offset + 1] = value >>> 8;\n        this[offset + 2] = value >>> 16;\n        this[offset + 3] = value >>> 24;\n        return offset + 4;\n      };\n      Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 4, 2147483647, -2147483648);\n        if (value < 0)\n          value = 4294967295 + value + 1;\n        this[offset] = value >>> 24;\n        this[offset + 1] = value >>> 16;\n        this[offset + 2] = value >>> 8;\n        this[offset + 3] = value & 255;\n        return offset + 4;\n      };\n      Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {\n        return wrtBigUInt64LE(this, value, offset, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n      });\n      Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {\n        return wrtBigUInt64BE(this, value, offset, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n      });\n      function checkIEEE754(buf, value, offset, ext, max, min) {\n        if (offset + ext > buf.length)\n          throw new RangeError(\"Index out of range\");\n        if (offset < 0)\n          throw new RangeError(\"Index out of range\");\n      }\n      function writeFloat(buf, value, offset, littleEndian, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);\n        }\n        ieee754.write(buf, value, offset, littleEndian, 23, 4);\n        return offset + 4;\n      }\n      Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n        return writeFloat(this, value, offset, true, noAssert);\n      };\n      Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n        return writeFloat(this, value, offset, false, noAssert);\n      };\n      function writeDouble(buf, value, offset, littleEndian, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);\n        }\n        ieee754.write(buf, value, offset, littleEndian, 52, 8);\n        return offset + 8;\n      }\n      Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n        return writeDouble(this, value, offset, true, noAssert);\n      };\n      Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n        return writeDouble(this, value, offset, false, noAssert);\n      };\n      Buffer2.prototype.copy = function copy(target, targetStart, start, end) {\n        if (!Buffer2.isBuffer(target))\n          throw new TypeError(\"argument should be a Buffer\");\n        if (!start)\n          start = 0;\n        if (!end && end !== 0)\n          end = this.length;\n        if (targetStart >= target.length)\n          targetStart = target.length;\n        if (!targetStart)\n          targetStart = 0;\n        if (end > 0 && end < start)\n          end = start;\n        if (end === start)\n          return 0;\n        if (target.length === 0 || this.length === 0)\n          return 0;\n        if (targetStart < 0) {\n          throw new RangeError(\"targetStart out of bounds\");\n        }\n        if (start < 0 || start >= this.length)\n          throw new RangeError(\"Index out of range\");\n        if (end < 0)\n          throw new RangeError(\"sourceEnd out of bounds\");\n        if (end > this.length)\n          end = this.length;\n        if (target.length - targetStart < end - start) {\n          end = target.length - targetStart + start;\n        }\n        const len = end - start;\n        if (this === target && typeof GlobalUint8Array.prototype.copyWithin === \"function\") {\n          this.copyWithin(targetStart, start, end);\n        } else {\n          GlobalUint8Array.prototype.set.call(\n            target,\n            this.subarray(start, end),\n            targetStart\n          );\n        }\n        return len;\n      };\n      Buffer2.prototype.fill = function fill(val, start, end, encoding) {\n        if (typeof val === \"string\") {\n          if (typeof start === \"string\") {\n            encoding = start;\n            start = 0;\n            end = this.length;\n          } else if (typeof end === \"string\") {\n            encoding = end;\n            end = this.length;\n          }\n          if (encoding !== void 0 && typeof encoding !== \"string\") {\n            throw new TypeError(\"encoding must be a string\");\n          }\n          if (typeof encoding === \"string\" && !Buffer2.isEncoding(encoding)) {\n            throw new TypeError(\"Unknown encoding: \" + encoding);\n          }\n          if (val.length === 1) {\n            const code = val.charCodeAt(0);\n            if (encoding === \"utf8\" && code < 128 || encoding === \"latin1\") {\n              val = code;\n            }\n          }\n        } else if (typeof val === \"number\") {\n          val = val & 255;\n        } else if (typeof val === \"boolean\") {\n          val = Number(val);\n        }\n        if (start < 0 || this.length < start || this.length < end) {\n          throw new RangeError(\"Out of range index\");\n        }\n        if (end <= start) {\n          return this;\n        }\n        start = start >>> 0;\n        end = end === void 0 ? this.length : end >>> 0;\n        if (!val)\n          val = 0;\n        let i;\n        if (typeof val === \"number\") {\n          for (i = start; i < end; ++i) {\n            this[i] = val;\n          }\n        } else {\n          const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);\n          const len = bytes.length;\n          if (len === 0) {\n            throw new TypeError('The value \"' + val + '\" is invalid for argument \"value\"');\n          }\n          for (i = 0; i < end - start; ++i) {\n            this[i + start] = bytes[i % len];\n          }\n        }\n        return this;\n      };\n      var errors = {};\n      function E(sym, getMessage, Base) {\n        errors[sym] = class NodeError extends Base {\n          constructor() {\n            super();\n            Object.defineProperty(this, \"message\", {\n              value: getMessage.apply(this, arguments),\n              writable: true,\n              configurable: true\n            });\n            this.name = `${this.name} [${sym}]`;\n            this.stack;\n            delete this.name;\n          }\n          get code() {\n            return sym;\n          }\n          set code(value) {\n            Object.defineProperty(this, \"code\", {\n              configurable: true,\n              enumerable: true,\n              value,\n              writable: true\n            });\n          }\n          toString() {\n            return `${this.name} [${sym}]: ${this.message}`;\n          }\n        };\n      }\n      E(\n        \"ERR_BUFFER_OUT_OF_BOUNDS\",\n        function(name) {\n          if (name) {\n            return `${name} is outside of buffer bounds`;\n          }\n          return \"Attempt to access memory outside buffer bounds\";\n        },\n        RangeError\n      );\n      E(\n        \"ERR_INVALID_ARG_TYPE\",\n        function(name, actual) {\n          return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`;\n        },\n        TypeError\n      );\n      E(\n        \"ERR_OUT_OF_RANGE\",\n        function(str, range, input) {\n          let msg = `The value of \"${str}\" is out of range.`;\n          let received = input;\n          if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n            received = addNumericalSeparator(String(input));\n          } else if (typeof input === \"bigint\") {\n            received = String(input);\n            if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n              received = addNumericalSeparator(received);\n            }\n            received += \"n\";\n          }\n          msg += ` It must be ${range}. Received ${received}`;\n          return msg;\n        },\n        RangeError\n      );\n      function addNumericalSeparator(val) {\n        let res = \"\";\n        let i = val.length;\n        const start = val[0] === \"-\" ? 1 : 0;\n        for (; i >= start + 4; i -= 3) {\n          res = `_${val.slice(i - 3, i)}${res}`;\n        }\n        return `${val.slice(0, i)}${res}`;\n      }\n      function checkBounds(buf, offset, byteLength2) {\n        validateNumber(offset, \"offset\");\n        if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {\n          boundsError(offset, buf.length - (byteLength2 + 1));\n        }\n      }\n      function checkIntBI(value, min, max, buf, offset, byteLength2) {\n        if (value > max || value < min) {\n          const n = typeof min === \"bigint\" ? \"n\" : \"\";\n          let range;\n          if (byteLength2 > 3) {\n            if (min === 0 || min === BigInt(0)) {\n              range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;\n            } else {\n              range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;\n            }\n          } else {\n            range = `>= ${min}${n} and <= ${max}${n}`;\n          }\n          throw new errors.ERR_OUT_OF_RANGE(\"value\", range, value);\n        }\n        checkBounds(buf, offset, byteLength2);\n      }\n      function validateNumber(value, name) {\n        if (typeof value !== \"number\") {\n          throw new errors.ERR_INVALID_ARG_TYPE(name, \"number\", value);\n        }\n      }\n      function boundsError(value, length, type) {\n        if (Math.floor(value) !== value) {\n          validateNumber(value, type);\n          throw new errors.ERR_OUT_OF_RANGE(type || \"offset\", \"an integer\", value);\n        }\n        if (length < 0) {\n          throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();\n        }\n        throw new errors.ERR_OUT_OF_RANGE(\n          type || \"offset\",\n          `>= ${type ? 1 : 0} and <= ${length}`,\n          value\n        );\n      }\n      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;\n      function base64clean(str) {\n        str = str.split(\"=\")[0];\n        str = str.trim().replace(INVALID_BASE64_RE, \"\");\n        if (str.length < 2)\n          return \"\";\n        while (str.length % 4 !== 0) {\n          str = str + \"=\";\n        }\n        return str;\n      }\n      function utf8ToBytes(string, units) {\n        units = units || Infinity;\n        let codePoint;\n        const length = string.length;\n        let leadSurrogate = null;\n        const bytes = [];\n        for (let i = 0; i < length; ++i) {\n          codePoint = string.charCodeAt(i);\n          if (codePoint > 55295 && codePoint < 57344) {\n            if (!leadSurrogate) {\n              if (codePoint > 56319) {\n                if ((units -= 3) > -1)\n                  bytes.push(239, 191, 189);\n                continue;\n              } else if (i + 1 === length) {\n                if ((units -= 3) > -1)\n                  bytes.push(239, 191, 189);\n                continue;\n              }\n              leadSurrogate = codePoint;\n              continue;\n            }\n            if (codePoint < 56320) {\n              if ((units -= 3) > -1)\n                bytes.push(239, 191, 189);\n              leadSurrogate = codePoint;\n              continue;\n            }\n            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;\n          } else if (leadSurrogate) {\n            if ((units -= 3) > -1)\n              bytes.push(239, 191, 189);\n          }\n          leadSurrogate = null;\n          if (codePoint < 128) {\n            if ((units -= 1) < 0)\n              break;\n            bytes.push(codePoint);\n          } else if (codePoint < 2048) {\n            if ((units -= 2) < 0)\n              break;\n            bytes.push(\n              codePoint >> 6 | 192,\n              codePoint & 63 | 128\n            );\n          } else if (codePoint < 65536) {\n            if ((units -= 3) < 0)\n              break;\n            bytes.push(\n              codePoint >> 12 | 224,\n              codePoint >> 6 & 63 | 128,\n              codePoint & 63 | 128\n            );\n          } else if (codePoint < 1114112) {\n            if ((units -= 4) < 0)\n              break;\n            bytes.push(\n              codePoint >> 18 | 240,\n              codePoint >> 12 & 63 | 128,\n              codePoint >> 6 & 63 | 128,\n              codePoint & 63 | 128\n            );\n          } else {\n            throw new Error(\"Invalid code point\");\n          }\n        }\n        return bytes;\n      }\n      function asciiToBytes(str) {\n        const byteArray = [];\n        for (let i = 0; i < str.length; ++i) {\n          byteArray.push(str.charCodeAt(i) & 255);\n        }\n        return byteArray;\n      }\n      function utf16leToBytes(str, units) {\n        let c, hi, lo;\n        const byteArray = [];\n        for (let i = 0; i < str.length; ++i) {\n          if ((units -= 2) < 0)\n            break;\n          c = str.charCodeAt(i);\n          hi = c >> 8;\n          lo = c % 256;\n          byteArray.push(lo);\n          byteArray.push(hi);\n        }\n        return byteArray;\n      }\n      function base64ToBytes(str) {\n        return base64.toByteArray(base64clean(str));\n      }\n      function blitBuffer(src, dst, offset, length) {\n        let i;\n        for (i = 0; i < length; ++i) {\n          if (i + offset >= dst.length || i >= src.length)\n            break;\n          dst[i + offset] = src[i];\n        }\n        return i;\n      }\n      function isInstance(obj, type) {\n        return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;\n      }\n      function numberIsNaN(obj) {\n        return obj !== obj;\n      }\n      var hexSliceLookupTable = function() {\n        const alphabet = \"0123456789abcdef\";\n        const table = new Array(256);\n        for (let i = 0; i < 16; ++i) {\n          const i16 = i * 16;\n          for (let j = 0; j < 16; ++j) {\n            table[i16 + j] = alphabet[i] + alphabet[j];\n          }\n        }\n        return table;\n      }();\n      function defineBigIntMethod(fn) {\n        return typeof BigInt === \"undefined\" ? BufferBigIntNotDefined : fn;\n      }\n      function BufferBigIntNotDefined() {\n        throw new Error(\"BigInt not supported\");\n      }\n    }\n  });\n\n  // node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js\n  var require_browser = __commonJS({\n    \"node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js\"(exports, module) {\n      init_dist();\n      var process = module.exports = {};\n      var cachedSetTimeout;\n      var cachedClearTimeout;\n      function defaultSetTimout() {\n        throw new Error(\"setTimeout has not been defined\");\n      }\n      function defaultClearTimeout() {\n        throw new Error(\"clearTimeout has not been defined\");\n      }\n      (function() {\n        try {\n          if (typeof setTimeout === \"function\") {\n            cachedSetTimeout = setTimeout;\n          } else {\n            cachedSetTimeout = defaultSetTimout;\n          }\n        } catch (e) {\n          cachedSetTimeout = defaultSetTimout;\n        }\n        try {\n          if (typeof clearTimeout === \"function\") {\n            cachedClearTimeout = clearTimeout;\n          } else {\n            cachedClearTimeout = defaultClearTimeout;\n          }\n        } catch (e) {\n          cachedClearTimeout = defaultClearTimeout;\n        }\n      })();\n      function runTimeout(fun) {\n        if (cachedSetTimeout === setTimeout) {\n          return setTimeout(fun, 0);\n        }\n        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n          cachedSetTimeout = setTimeout;\n          return setTimeout(fun, 0);\n        }\n        try {\n          return cachedSetTimeout(fun, 0);\n        } catch (e) {\n          try {\n            return cachedSetTimeout.call(null, fun, 0);\n          } catch (e2) {\n            return cachedSetTimeout.call(this, fun, 0);\n          }\n        }\n      }\n      function runClearTimeout(marker) {\n        if (cachedClearTimeout === clearTimeout) {\n          return clearTimeout(marker);\n        }\n        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n          cachedClearTimeout = clearTimeout;\n          return clearTimeout(marker);\n        }\n        try {\n          return cachedClearTimeout(marker);\n        } catch (e) {\n          try {\n            return cachedClearTimeout.call(null, marker);\n          } catch (e2) {\n            return cachedClearTimeout.call(this, marker);\n          }\n        }\n      }\n      var queue = [];\n      var draining = false;\n      var currentQueue;\n      var queueIndex = -1;\n      function cleanUpNextTick() {\n        if (!draining || !currentQueue) {\n          return;\n        }\n        draining = false;\n        if (currentQueue.length) {\n          queue = currentQueue.concat(queue);\n        } else {\n          queueIndex = -1;\n        }\n        if (queue.length) {\n          drainQueue();\n        }\n      }\n      function drainQueue() {\n        if (draining) {\n          return;\n        }\n        var timeout = runTimeout(cleanUpNextTick);\n        draining = true;\n        var len = queue.length;\n        while (len) {\n          currentQueue = queue;\n          queue = [];\n          while (++queueIndex < len) {\n            if (currentQueue) {\n              currentQueue[queueIndex].run();\n            }\n          }\n          queueIndex = -1;\n          len = queue.length;\n        }\n        currentQueue = null;\n        draining = false;\n        runClearTimeout(timeout);\n      }\n      process.nextTick = function(fun) {\n        var args = new Array(arguments.length - 1);\n        if (arguments.length > 1) {\n          for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n          }\n        }\n        queue.push(new Item(fun, args));\n        if (queue.length === 1 && !draining) {\n          runTimeout(drainQueue);\n        }\n      };\n      function Item(fun, array) {\n        this.fun = fun;\n        this.array = array;\n      }\n      Item.prototype.run = function() {\n        this.fun.apply(null, this.array);\n      };\n      process.title = \"browser\";\n      process.browser = true;\n      process.env = {};\n      process.argv = [];\n      process.version = \"\";\n      process.versions = {};\n      function noop() {\n      }\n      process.on = noop;\n      process.addListener = noop;\n      process.once = noop;\n      process.off = noop;\n      process.removeListener = noop;\n      process.removeAllListeners = noop;\n      process.emit = noop;\n      process.prependListener = noop;\n      process.prependOnceListener = noop;\n      process.listeners = function(name) {\n        return [];\n      };\n      process.binding = function(name) {\n        throw new Error(\"process.binding is not supported\");\n      };\n      process.cwd = function() {\n        return \"/\";\n      };\n      process.chdir = function(dir) {\n        throw new Error(\"process.chdir is not supported\");\n      };\n      process.umask = function() {\n        return 0;\n      };\n    }\n  });\n\n  // shims/dist/index.js\n  var import_buffer_polyfill, import_process, o;\n  var init_dist = __esm({\n    \"shims/dist/index.js\"() {\n      \"use strict\";\n      import_buffer_polyfill = __toESM(require_buffer(), 1);\n      import_process = __toESM(require_browser(), 1);\n      o = globalThis || void 0 || self;\n    }\n  });\n\n  // shims/banner/index.cjs\n  var require_banner = __commonJS({\n    \"shims/banner/index.cjs\"() {\n      init_dist();\n      globalThis.Buffer = globalThis.Buffer || import_buffer_polyfill.Buffer;\n      globalThis.global = globalThis.global || o;\n      globalThis.process = globalThis.process || import_process.default;\n    }\n  });\n  require_banner();\n})();\n/*! Bundled license information:\n\nieee754/index.js:\n  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)\n\nbuffer/index.js:\n  (*!\n   * The buffer module from node.js, for the browser.\n   *\n   * @author   Feross Aboukhadijeh <https://feross.org>\n   * @license  MIT\n   *)\n*/\n\nimport {\n  __commonJS,\n  __toESM,\n  require_dist\n} from \"./chunk-VMXIV7NB.js\";\n\n// node_modules/highlight.js/lib/core.js\nvar require_core = __commonJS({\n  \"node_modules/highlight.js/lib/core.js\"(exports, module) {\n    var import_dist = __toESM(require_dist());\n    function deepFreeze(obj) {\n      if (obj instanceof Map) {\n        obj.clear = obj.delete = obj.set = function() {\n          throw new Error(\"map is read-only\");\n        };\n      } else if (obj instanceof Set) {\n        obj.add = obj.clear = obj.delete = function() {\n          throw new Error(\"set is read-only\");\n        };\n      }\n      Object.freeze(obj);\n      Object.getOwnPropertyNames(obj).forEach(function(name) {\n        var prop = obj[name];\n        if (typeof prop == \"object\" && !Object.isFrozen(prop)) {\n          deepFreeze(prop);\n        }\n      });\n      return obj;\n    }\n    var deepFreezeEs6 = deepFreeze;\n    var _default = deepFreeze;\n    deepFreezeEs6.default = _default;\n    var Response = class {\n      /**\n       * @param {CompiledMode} mode\n       */\n      constructor(mode) {\n        if (mode.data === void 0)\n          mode.data = {};\n        this.data = mode.data;\n        this.isMatchIgnored = false;\n      }\n      ignoreMatch() {\n        this.isMatchIgnored = true;\n      }\n    };\n    function escapeHTML(value) {\n      return value.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\").replace(/\"/g, \"&quot;\").replace(/'/g, \"&#x27;\");\n    }\n    function inherit(original, ...objects) {\n      const result = /* @__PURE__ */ Object.create(null);\n      for (const key in original) {\n        result[key] = original[key];\n      }\n      objects.forEach(function(obj) {\n        for (const key in obj) {\n          result[key] = obj[key];\n        }\n      });\n      return (\n        /** @type {T} */\n        result\n      );\n    }\n    var SPAN_CLOSE = \"</span>\";\n    var emitsWrappingTags = (node) => {\n      return !!node.kind;\n    };\n    var HTMLRenderer = class {\n      /**\n       * Creates a new HTMLRenderer\n       *\n       * @param {Tree} parseTree - the parse tree (must support `walk` API)\n       * @param {{classPrefix: string}} options\n       */\n      constructor(parseTree, options) {\n        this.buffer = \"\";\n        this.classPrefix = options.classPrefix;\n        parseTree.walk(this);\n      }\n      /**\n       * Adds texts to the output stream\n       *\n       * @param {string} text */\n      addText(text) {\n        this.buffer += escapeHTML(text);\n      }\n      /**\n       * Adds a node open to the output stream (if needed)\n       *\n       * @param {Node} node */\n      openNode(node) {\n        if (!emitsWrappingTags(node))\n          return;\n        let className = node.kind;\n        if (!node.sublanguage) {\n          className = `${this.classPrefix}${className}`;\n        }\n        this.span(className);\n      }\n      /**\n       * Adds a node close to the output stream (if needed)\n       *\n       * @param {Node} node */\n      closeNode(node) {\n        if (!emitsWrappingTags(node))\n          return;\n        this.buffer += SPAN_CLOSE;\n      }\n      /**\n       * returns the accumulated buffer\n      */\n      value() {\n        return this.buffer;\n      }\n      // helpers\n      /**\n       * Builds a span element\n       *\n       * @param {string} className */\n      span(className) {\n        this.buffer += `<span class=\"${className}\">`;\n      }\n    };\n    var TokenTree = class _TokenTree {\n      constructor() {\n        this.rootNode = { children: [] };\n        this.stack = [this.rootNode];\n      }\n      get top() {\n        return this.stack[this.stack.length - 1];\n      }\n      get root() {\n        return this.rootNode;\n      }\n      /** @param {Node} node */\n      add(node) {\n        this.top.children.push(node);\n      }\n      /** @param {string} kind */\n      openNode(kind) {\n        const node = { kind, children: [] };\n        this.add(node);\n        this.stack.push(node);\n      }\n      closeNode() {\n        if (this.stack.length > 1) {\n          return this.stack.pop();\n        }\n        return void 0;\n      }\n      closeAllNodes() {\n        while (this.closeNode())\n          ;\n      }\n      toJSON() {\n        return JSON.stringify(this.rootNode, null, 4);\n      }\n      /**\n       * @typedef { import(\"./html_renderer\").Renderer } Renderer\n       * @param {Renderer} builder\n       */\n      walk(builder) {\n        return this.constructor._walk(builder, this.rootNode);\n      }\n      /**\n       * @param {Renderer} builder\n       * @param {Node} node\n       */\n      static _walk(builder, node) {\n        if (typeof node === \"string\") {\n          builder.addText(node);\n        } else if (node.children) {\n          builder.openNode(node);\n          node.children.forEach((child) => this._walk(builder, child));\n          builder.closeNode(node);\n        }\n        return builder;\n      }\n      /**\n       * @param {Node} node\n       */\n      static _collapse(node) {\n        if (typeof node === \"string\")\n          return;\n        if (!node.children)\n          return;\n        if (node.children.every((el) => typeof el === \"string\")) {\n          node.children = [node.children.join(\"\")];\n        } else {\n          node.children.forEach((child) => {\n            _TokenTree._collapse(child);\n          });\n        }\n      }\n    };\n    var TokenTreeEmitter = class extends TokenTree {\n      /**\n       * @param {*} options\n       */\n      constructor(options) {\n        super();\n        this.options = options;\n      }\n      /**\n       * @param {string} text\n       * @param {string} kind\n       */\n      addKeyword(text, kind) {\n        if (text === \"\") {\n          return;\n        }\n        this.openNode(kind);\n        this.addText(text);\n        this.closeNode();\n      }\n      /**\n       * @param {string} text\n       */\n      addText(text) {\n        if (text === \"\") {\n          return;\n        }\n        this.add(text);\n      }\n      /**\n       * @param {Emitter & {root: DataNode}} emitter\n       * @param {string} name\n       */\n      addSublanguage(emitter, name) {\n        const node = emitter.root;\n        node.kind = name;\n        node.sublanguage = true;\n        this.add(node);\n      }\n      toHTML() {\n        const renderer = new HTMLRenderer(this, this.options);\n        return renderer.value();\n      }\n      finalize() {\n        return true;\n      }\n    };\n    function escape(value) {\n      return new RegExp(value.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\"), \"m\");\n    }\n    function source(re) {\n      if (!re)\n        return null;\n      if (typeof re === \"string\")\n        return re;\n      return re.source;\n    }\n    function concat(...args) {\n      const joined = args.map((x) => source(x)).join(\"\");\n      return joined;\n    }\n    function either(...args) {\n      const joined = \"(\" + args.map((x) => source(x)).join(\"|\") + \")\";\n      return joined;\n    }\n    function countMatchGroups(re) {\n      return new RegExp(re.toString() + \"|\").exec(\"\").length - 1;\n    }\n    function startsWith(re, lexeme) {\n      const match = re && re.exec(lexeme);\n      return match && match.index === 0;\n    }\n    var BACKREF_RE = /\\[(?:[^\\\\\\]]|\\\\.)*\\]|\\(\\??|\\\\([1-9][0-9]*)|\\\\./;\n    function join(regexps, separator = \"|\") {\n      let numCaptures = 0;\n      return regexps.map((regex) => {\n        numCaptures += 1;\n        const offset = numCaptures;\n        let re = source(regex);\n        let out = \"\";\n        while (re.length > 0) {\n          const match = BACKREF_RE.exec(re);\n          if (!match) {\n            out += re;\n            break;\n          }\n          out += re.substring(0, match.index);\n          re = re.substring(match.index + match[0].length);\n          if (match[0][0] === \"\\\\\" && match[1]) {\n            out += \"\\\\\" + String(Number(match[1]) + offset);\n          } else {\n            out += match[0];\n            if (match[0] === \"(\") {\n              numCaptures++;\n            }\n          }\n        }\n        return out;\n      }).map((re) => `(${re})`).join(separator);\n    }\n    var MATCH_NOTHING_RE = /\\b\\B/;\n    var IDENT_RE = \"[a-zA-Z]\\\\w*\";\n    var UNDERSCORE_IDENT_RE = \"[a-zA-Z_]\\\\w*\";\n    var NUMBER_RE = \"\\\\b\\\\d+(\\\\.\\\\d+)?\";\n    var C_NUMBER_RE = \"(-?)(\\\\b0[xX][a-fA-F0-9]+|(\\\\b\\\\d+(\\\\.\\\\d*)?|\\\\.\\\\d+)([eE][-+]?\\\\d+)?)\";\n    var BINARY_NUMBER_RE = \"\\\\b(0b[01]+)\";\n    var RE_STARTERS_RE = \"!|!=|!==|%|%=|&|&&|&=|\\\\*|\\\\*=|\\\\+|\\\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\\\?|\\\\[|\\\\{|\\\\(|\\\\^|\\\\^=|\\\\||\\\\|=|\\\\|\\\\||~\";\n    var SHEBANG = (opts = {}) => {\n      const beginShebang = /^#![ ]*\\//;\n      if (opts.binary) {\n        opts.begin = concat(\n          beginShebang,\n          /.*\\b/,\n          opts.binary,\n          /\\b.*/\n        );\n      }\n      return inherit({\n        className: \"meta\",\n        begin: beginShebang,\n        end: /$/,\n        relevance: 0,\n        /** @type {ModeCallback} */\n        \"on:begin\": (m, resp) => {\n          if (m.index !== 0)\n            resp.ignoreMatch();\n        }\n      }, opts);\n    };\n    var BACKSLASH_ESCAPE = {\n      begin: \"\\\\\\\\[\\\\s\\\\S]\",\n      relevance: 0\n    };\n    var APOS_STRING_MODE = {\n      className: \"string\",\n      begin: \"'\",\n      end: \"'\",\n      illegal: \"\\\\n\",\n      contains: [BACKSLASH_ESCAPE]\n    };\n    var QUOTE_STRING_MODE = {\n      className: \"string\",\n      begin: '\"',\n      end: '\"',\n      illegal: \"\\\\n\",\n      contains: [BACKSLASH_ESCAPE]\n    };\n    var PHRASAL_WORDS_MODE = {\n      begin: /\\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\\b/\n    };\n    var COMMENT = function(begin, end, modeOptions = {}) {\n      const mode = inherit(\n        {\n          className: \"comment\",\n          begin,\n          end,\n          contains: []\n        },\n        modeOptions\n      );\n      mode.contains.push(PHRASAL_WORDS_MODE);\n      mode.contains.push({\n        className: \"doctag\",\n        begin: \"(?:TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):\",\n        relevance: 0\n      });\n      return mode;\n    };\n    var C_LINE_COMMENT_MODE = COMMENT(\"//\", \"$\");\n    var C_BLOCK_COMMENT_MODE = COMMENT(\"/\\\\*\", \"\\\\*/\");\n    var HASH_COMMENT_MODE = COMMENT(\"#\", \"$\");\n    var NUMBER_MODE = {\n      className: \"number\",\n      begin: NUMBER_RE,\n      relevance: 0\n    };\n    var C_NUMBER_MODE = {\n      className: \"number\",\n      begin: C_NUMBER_RE,\n      relevance: 0\n    };\n    var BINARY_NUMBER_MODE = {\n      className: \"number\",\n      begin: BINARY_NUMBER_RE,\n      relevance: 0\n    };\n    var CSS_NUMBER_MODE = {\n      className: \"number\",\n      begin: NUMBER_RE + \"(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?\",\n      relevance: 0\n    };\n    var REGEXP_MODE = {\n      // this outer rule makes sure we actually have a WHOLE regex and not simply\n      // an expression such as:\n      //\n      //     3 / something\n      //\n      // (which will then blow up when regex's `illegal` sees the newline)\n      begin: /(?=\\/[^/\\n]*\\/)/,\n      contains: [{\n        className: \"regexp\",\n        begin: /\\//,\n        end: /\\/[gimuy]*/,\n        illegal: /\\n/,\n        contains: [\n          BACKSLASH_ESCAPE,\n          {\n            begin: /\\[/,\n            end: /\\]/,\n            relevance: 0,\n            contains: [BACKSLASH_ESCAPE]\n          }\n        ]\n      }]\n    };\n    var TITLE_MODE = {\n      className: \"title\",\n      begin: IDENT_RE,\n      relevance: 0\n    };\n    var UNDERSCORE_TITLE_MODE = {\n      className: \"title\",\n      begin: UNDERSCORE_IDENT_RE,\n      relevance: 0\n    };\n    var METHOD_GUARD = {\n      // excludes method names from keyword processing\n      begin: \"\\\\.\\\\s*\" + UNDERSCORE_IDENT_RE,\n      relevance: 0\n    };\n    var END_SAME_AS_BEGIN = function(mode) {\n      return Object.assign(\n        mode,\n        {\n          /** @type {ModeCallback} */\n          \"on:begin\": (m, resp) => {\n            resp.data._beginMatch = m[1];\n          },\n          /** @type {ModeCallback} */\n          \"on:end\": (m, resp) => {\n            if (resp.data._beginMatch !== m[1])\n              resp.ignoreMatch();\n          }\n        }\n      );\n    };\n    var MODES = Object.freeze({\n      __proto__: null,\n      MATCH_NOTHING_RE,\n      IDENT_RE,\n      UNDERSCORE_IDENT_RE,\n      NUMBER_RE,\n      C_NUMBER_RE,\n      BINARY_NUMBER_RE,\n      RE_STARTERS_RE,\n      SHEBANG,\n      BACKSLASH_ESCAPE,\n      APOS_STRING_MODE,\n      QUOTE_STRING_MODE,\n      PHRASAL_WORDS_MODE,\n      COMMENT,\n      C_LINE_COMMENT_MODE,\n      C_BLOCK_COMMENT_MODE,\n      HASH_COMMENT_MODE,\n      NUMBER_MODE,\n      C_NUMBER_MODE,\n      BINARY_NUMBER_MODE,\n      CSS_NUMBER_MODE,\n      REGEXP_MODE,\n      TITLE_MODE,\n      UNDERSCORE_TITLE_MODE,\n      METHOD_GUARD,\n      END_SAME_AS_BEGIN\n    });\n    function skipIfhasPrecedingDot(match, response) {\n      const before = match.input[match.index - 1];\n      if (before === \".\") {\n        response.ignoreMatch();\n      }\n    }\n    function beginKeywords(mode, parent) {\n      if (!parent)\n        return;\n      if (!mode.beginKeywords)\n        return;\n      mode.begin = \"\\\\b(\" + mode.beginKeywords.split(\" \").join(\"|\") + \")(?!\\\\.)(?=\\\\b|\\\\s)\";\n      mode.__beforeBegin = skipIfhasPrecedingDot;\n      mode.keywords = mode.keywords || mode.beginKeywords;\n      delete mode.beginKeywords;\n      if (mode.relevance === void 0)\n        mode.relevance = 0;\n    }\n    function compileIllegal(mode, _parent) {\n      if (!Array.isArray(mode.illegal))\n        return;\n      mode.illegal = either(...mode.illegal);\n    }\n    function compileMatch(mode, _parent) {\n      if (!mode.match)\n        return;\n      if (mode.begin || mode.end)\n        throw new Error(\"begin & end are not supported with match\");\n      mode.begin = mode.match;\n      delete mode.match;\n    }\n    function compileRelevance(mode, _parent) {\n      if (mode.relevance === void 0)\n        mode.relevance = 1;\n    }\n    var COMMON_KEYWORDS = [\n      \"of\",\n      \"and\",\n      \"for\",\n      \"in\",\n      \"not\",\n      \"or\",\n      \"if\",\n      \"then\",\n      \"parent\",\n      // common variable name\n      \"list\",\n      // common variable name\n      \"value\"\n      // common variable name\n    ];\n    var DEFAULT_KEYWORD_CLASSNAME = \"keyword\";\n    function compileKeywords(rawKeywords, caseInsensitive, className = DEFAULT_KEYWORD_CLASSNAME) {\n      const compiledKeywords = {};\n      if (typeof rawKeywords === \"string\") {\n        compileList(className, rawKeywords.split(\" \"));\n      } else if (Array.isArray(rawKeywords)) {\n        compileList(className, rawKeywords);\n      } else {\n        Object.keys(rawKeywords).forEach(function(className2) {\n          Object.assign(\n            compiledKeywords,\n            compileKeywords(rawKeywords[className2], caseInsensitive, className2)\n          );\n        });\n      }\n      return compiledKeywords;\n      function compileList(className2, keywordList) {\n        if (caseInsensitive) {\n          keywordList = keywordList.map((x) => x.toLowerCase());\n        }\n        keywordList.forEach(function(keyword) {\n          const pair = keyword.split(\"|\");\n          compiledKeywords[pair[0]] = [className2, scoreForKeyword(pair[0], pair[1])];\n        });\n      }\n    }\n    function scoreForKeyword(keyword, providedScore) {\n      if (providedScore) {\n        return Number(providedScore);\n      }\n      return commonKeyword(keyword) ? 0 : 1;\n    }\n    function commonKeyword(keyword) {\n      return COMMON_KEYWORDS.includes(keyword.toLowerCase());\n    }\n    function compileLanguage(language, { plugins }) {\n      function langRe(value, global) {\n        return new RegExp(\n          source(value),\n          \"m\" + (language.case_insensitive ? \"i\" : \"\") + (global ? \"g\" : \"\")\n        );\n      }\n      class MultiRegex {\n        constructor() {\n          this.matchIndexes = {};\n          this.regexes = [];\n          this.matchAt = 1;\n          this.position = 0;\n        }\n        // @ts-ignore\n        addRule(re, opts) {\n          opts.position = this.position++;\n          this.matchIndexes[this.matchAt] = opts;\n          this.regexes.push([opts, re]);\n          this.matchAt += countMatchGroups(re) + 1;\n        }\n        compile() {\n          if (this.regexes.length === 0) {\n            this.exec = () => null;\n          }\n          const terminators = this.regexes.map((el) => el[1]);\n          this.matcherRe = langRe(join(terminators), true);\n          this.lastIndex = 0;\n        }\n        /** @param {string} s */\n        exec(s) {\n          this.matcherRe.lastIndex = this.lastIndex;\n          const match = this.matcherRe.exec(s);\n          if (!match) {\n            return null;\n          }\n          const i = match.findIndex((el, i2) => i2 > 0 && el !== void 0);\n          const matchData = this.matchIndexes[i];\n          match.splice(0, i);\n          return Object.assign(match, matchData);\n        }\n      }\n      class ResumableMultiRegex {\n        constructor() {\n          this.rules = [];\n          this.multiRegexes = [];\n          this.count = 0;\n          this.lastIndex = 0;\n          this.regexIndex = 0;\n        }\n        // @ts-ignore\n        getMatcher(index) {\n          if (this.multiRegexes[index])\n            return this.multiRegexes[index];\n          const matcher = new MultiRegex();\n          this.rules.slice(index).forEach(([re, opts]) => matcher.addRule(re, opts));\n          matcher.compile();\n          this.multiRegexes[index] = matcher;\n          return matcher;\n        }\n        resumingScanAtSamePosition() {\n          return this.regexIndex !== 0;\n        }\n        considerAll() {\n          this.regexIndex = 0;\n        }\n        // @ts-ignore\n        addRule(re, opts) {\n          this.rules.push([re, opts]);\n          if (opts.type === \"begin\")\n            this.count++;\n        }\n        /** @param {string} s */\n        exec(s) {\n          const m = this.getMatcher(this.regexIndex);\n          m.lastIndex = this.lastIndex;\n          let result = m.exec(s);\n          if (this.resumingScanAtSamePosition()) {\n            if (result && result.index === this.lastIndex)\n              ;\n            else {\n              const m2 = this.getMatcher(0);\n              m2.lastIndex = this.lastIndex + 1;\n              result = m2.exec(s);\n            }\n          }\n          if (result) {\n            this.regexIndex += result.position + 1;\n            if (this.regexIndex === this.count) {\n              this.considerAll();\n            }\n          }\n          return result;\n        }\n      }\n      function buildModeRegex(mode) {\n        const mm = new ResumableMultiRegex();\n        mode.contains.forEach((term) => mm.addRule(term.begin, { rule: term, type: \"begin\" }));\n        if (mode.terminatorEnd) {\n          mm.addRule(mode.terminatorEnd, { type: \"end\" });\n        }\n        if (mode.illegal) {\n          mm.addRule(mode.illegal, { type: \"illegal\" });\n        }\n        return mm;\n      }\n      function compileMode(mode, parent) {\n        const cmode = (\n          /** @type CompiledMode */\n          mode\n        );\n        if (mode.isCompiled)\n          return cmode;\n        [\n          // do this early so compiler extensions generally don't have to worry about\n          // the distinction between match/begin\n          compileMatch\n        ].forEach((ext) => ext(mode, parent));\n        language.compilerExtensions.forEach((ext) => ext(mode, parent));\n        mode.__beforeBegin = null;\n        [\n          beginKeywords,\n          // do this later so compiler extensions that come earlier have access to the\n          // raw array if they wanted to perhaps manipulate it, etc.\n          compileIllegal,\n          // default to 1 relevance if not specified\n          compileRelevance\n        ].forEach((ext) => ext(mode, parent));\n        mode.isCompiled = true;\n        let keywordPattern = null;\n        if (typeof mode.keywords === \"object\") {\n          keywordPattern = mode.keywords.$pattern;\n          delete mode.keywords.$pattern;\n        }\n        if (mode.keywords) {\n          mode.keywords = compileKeywords(mode.keywords, language.case_insensitive);\n        }\n        if (mode.lexemes && keywordPattern) {\n          throw new Error(\"ERR: Prefer `keywords.$pattern` to `mode.lexemes`, BOTH are not allowed. (see mode reference) \");\n        }\n        keywordPattern = keywordPattern || mode.lexemes || /\\w+/;\n        cmode.keywordPatternRe = langRe(keywordPattern, true);\n        if (parent) {\n          if (!mode.begin)\n            mode.begin = /\\B|\\b/;\n          cmode.beginRe = langRe(mode.begin);\n          if (mode.endSameAsBegin)\n            mode.end = mode.begin;\n          if (!mode.end && !mode.endsWithParent)\n            mode.end = /\\B|\\b/;\n          if (mode.end)\n            cmode.endRe = langRe(mode.end);\n          cmode.terminatorEnd = source(mode.end) || \"\";\n          if (mode.endsWithParent && parent.terminatorEnd) {\n            cmode.terminatorEnd += (mode.end ? \"|\" : \"\") + parent.terminatorEnd;\n          }\n        }\n        if (mode.illegal)\n          cmode.illegalRe = langRe(\n            /** @type {RegExp | string} */\n            mode.illegal\n          );\n        if (!mode.contains)\n          mode.contains = [];\n        mode.contains = [].concat(...mode.contains.map(function(c) {\n          return expandOrCloneMode(c === \"self\" ? mode : c);\n        }));\n        mode.contains.forEach(function(c) {\n          compileMode(\n            /** @type Mode */\n            c,\n            cmode\n          );\n        });\n        if (mode.starts) {\n          compileMode(mode.starts, parent);\n        }\n        cmode.matcher = buildModeRegex(cmode);\n        return cmode;\n      }\n      if (!language.compilerExtensions)\n        language.compilerExtensions = [];\n      if (language.contains && language.contains.includes(\"self\")) {\n        throw new Error(\"ERR: contains `self` is not supported at the top-level of a language.  See documentation.\");\n      }\n      language.classNameAliases = inherit(language.classNameAliases || {});\n      return compileMode(\n        /** @type Mode */\n        language\n      );\n    }\n    function dependencyOnParent(mode) {\n      if (!mode)\n        return false;\n      return mode.endsWithParent || dependencyOnParent(mode.starts);\n    }\n    function expandOrCloneMode(mode) {\n      if (mode.variants && !mode.cachedVariants) {\n        mode.cachedVariants = mode.variants.map(function(variant) {\n          return inherit(mode, { variants: null }, variant);\n        });\n      }\n      if (mode.cachedVariants) {\n        return mode.cachedVariants;\n      }\n      if (dependencyOnParent(mode)) {\n        return inherit(mode, { starts: mode.starts ? inherit(mode.starts) : null });\n      }\n      if (Object.isFrozen(mode)) {\n        return inherit(mode);\n      }\n      return mode;\n    }\n    var version = \"10.7.3\";\n    function hasValueOrEmptyAttribute(value) {\n      return Boolean(value || value === \"\");\n    }\n    function BuildVuePlugin(hljs) {\n      const Component = {\n        props: [\"language\", \"code\", \"autodetect\"],\n        data: function() {\n          return {\n            detectedLanguage: \"\",\n            unknownLanguage: false\n          };\n        },\n        computed: {\n          className() {\n            if (this.unknownLanguage)\n              return \"\";\n            return \"hljs \" + this.detectedLanguage;\n          },\n          highlighted() {\n            if (!this.autoDetect && !hljs.getLanguage(this.language)) {\n              console.warn(`The language \"${this.language}\" you specified could not be found.`);\n              this.unknownLanguage = true;\n              return escapeHTML(this.code);\n            }\n            let result = {};\n            if (this.autoDetect) {\n              result = hljs.highlightAuto(this.code);\n              this.detectedLanguage = result.language;\n            } else {\n              result = hljs.highlight(this.language, this.code, this.ignoreIllegals);\n              this.detectedLanguage = this.language;\n            }\n            return result.value;\n          },\n          autoDetect() {\n            return !this.language || hasValueOrEmptyAttribute(this.autodetect);\n          },\n          ignoreIllegals() {\n            return true;\n          }\n        },\n        // this avoids needing to use a whole Vue compilation pipeline just\n        // to build Highlight.js\n        render(createElement) {\n          return createElement(\"pre\", {}, [\n            createElement(\"code\", {\n              class: this.className,\n              domProps: { innerHTML: this.highlighted }\n            })\n          ]);\n        }\n        // template: `<pre><code :class=\"className\" v-html=\"highlighted\"></code></pre>`\n      };\n      const VuePlugin = {\n        install(Vue) {\n          Vue.component(\"highlightjs\", Component);\n        }\n      };\n      return { Component, VuePlugin };\n    }\n    var mergeHTMLPlugin = {\n      \"after:highlightElement\": ({ el, result, text }) => {\n        const originalStream = nodeStream(el);\n        if (!originalStream.length)\n          return;\n        const resultNode = document.createElement(\"div\");\n        resultNode.innerHTML = result.value;\n        result.value = mergeStreams(originalStream, nodeStream(resultNode), text);\n      }\n    };\n    function tag(node) {\n      return node.nodeName.toLowerCase();\n    }\n    function nodeStream(node) {\n      const result = [];\n      (function _nodeStream(node2, offset) {\n        for (let child = node2.firstChild; child; child = child.nextSibling) {\n          if (child.nodeType === 3) {\n            offset += child.nodeValue.length;\n          } else if (child.nodeType === 1) {\n            result.push({\n              event: \"start\",\n              offset,\n              node: child\n            });\n            offset = _nodeStream(child, offset);\n            if (!tag(child).match(/br|hr|img|input/)) {\n              result.push({\n                event: \"stop\",\n                offset,\n                node: child\n              });\n            }\n          }\n        }\n        return offset;\n      })(node, 0);\n      return result;\n    }\n    function mergeStreams(original, highlighted, value) {\n      let processed = 0;\n      let result = \"\";\n      const nodeStack = [];\n      function selectStream() {\n        if (!original.length || !highlighted.length) {\n          return original.length ? original : highlighted;\n        }\n        if (original[0].offset !== highlighted[0].offset) {\n          return original[0].offset < highlighted[0].offset ? original : highlighted;\n        }\n        return highlighted[0].event === \"start\" ? original : highlighted;\n      }\n      function open(node) {\n        function attributeString(attr) {\n          return \" \" + attr.nodeName + '=\"' + escapeHTML(attr.value) + '\"';\n        }\n        result += \"<\" + tag(node) + [].map.call(node.attributes, attributeString).join(\"\") + \">\";\n      }\n      function close(node) {\n        result += \"</\" + tag(node) + \">\";\n      }\n      function render(event) {\n        (event.event === \"start\" ? open : close)(event.node);\n      }\n      while (original.length || highlighted.length) {\n        let stream = selectStream();\n        result += escapeHTML(value.substring(processed, stream[0].offset));\n        processed = stream[0].offset;\n        if (stream === original) {\n          nodeStack.reverse().forEach(close);\n          do {\n            render(stream.splice(0, 1)[0]);\n            stream = selectStream();\n          } while (stream === original && stream.length && stream[0].offset === processed);\n          nodeStack.reverse().forEach(open);\n        } else {\n          if (stream[0].event === \"start\") {\n            nodeStack.push(stream[0].node);\n          } else {\n            nodeStack.pop();\n          }\n          render(stream.splice(0, 1)[0]);\n        }\n      }\n      return result + escapeHTML(value.substr(processed));\n    }\n    var seenDeprecations = {};\n    var error = (message) => {\n      console.error(message);\n    };\n    var warn = (message, ...args) => {\n      console.log(`WARN: ${message}`, ...args);\n    };\n    var deprecated = (version2, message) => {\n      if (seenDeprecations[`${version2}/${message}`])\n        return;\n      console.log(`Deprecated as of ${version2}. ${message}`);\n      seenDeprecations[`${version2}/${message}`] = true;\n    };\n    var escape$1 = escapeHTML;\n    var inherit$1 = inherit;\n    var NO_MATCH = Symbol(\"nomatch\");\n    var HLJS = function(hljs) {\n      const languages = /* @__PURE__ */ Object.create(null);\n      const aliases = /* @__PURE__ */ Object.create(null);\n      const plugins = [];\n      let SAFE_MODE = true;\n      const fixMarkupRe = /(^(<[^>]+>|\\t|)+|\\n)/gm;\n      const LANGUAGE_NOT_FOUND = \"Could not find the language '{}', did you forget to load/include a language module?\";\n      const PLAINTEXT_LANGUAGE = { disableAutodetect: true, name: \"Plain text\", contains: [] };\n      let options = {\n        noHighlightRe: /^(no-?highlight)$/i,\n        languageDetectRe: /\\blang(?:uage)?-([\\w-]+)\\b/i,\n        classPrefix: \"hljs-\",\n        tabReplace: null,\n        useBR: false,\n        languages: null,\n        // beta configuration options, subject to change, welcome to discuss\n        // https://github.com/highlightjs/highlight.js/issues/1086\n        __emitter: TokenTreeEmitter\n      };\n      function shouldNotHighlight(languageName) {\n        return options.noHighlightRe.test(languageName);\n      }\n      function blockLanguage(block) {\n        let classes = block.className + \" \";\n        classes += block.parentNode ? block.parentNode.className : \"\";\n        const match = options.languageDetectRe.exec(classes);\n        if (match) {\n          const language = getLanguage(match[1]);\n          if (!language) {\n            warn(LANGUAGE_NOT_FOUND.replace(\"{}\", match[1]));\n            warn(\"Falling back to no-highlight mode for this block.\", block);\n          }\n          return language ? match[1] : \"no-highlight\";\n        }\n        return classes.split(/\\s+/).find((_class) => shouldNotHighlight(_class) || getLanguage(_class));\n      }\n      function highlight2(codeOrlanguageName, optionsOrCode, ignoreIllegals, continuation) {\n        let code = \"\";\n        let languageName = \"\";\n        if (typeof optionsOrCode === \"object\") {\n          code = codeOrlanguageName;\n          ignoreIllegals = optionsOrCode.ignoreIllegals;\n          languageName = optionsOrCode.language;\n          continuation = void 0;\n        } else {\n          deprecated(\"10.7.0\", \"highlight(lang, code, ...args) has been deprecated.\");\n          deprecated(\"10.7.0\", \"Please use highlight(code, options) instead.\\nhttps://github.com/highlightjs/highlight.js/issues/2277\");\n          languageName = codeOrlanguageName;\n          code = optionsOrCode;\n        }\n        const context = {\n          code,\n          language: languageName\n        };\n        fire(\"before:highlight\", context);\n        const result = context.result ? context.result : _highlight(context.language, context.code, ignoreIllegals, continuation);\n        result.code = context.code;\n        fire(\"after:highlight\", result);\n        return result;\n      }\n      function _highlight(languageName, codeToHighlight, ignoreIllegals, continuation) {\n        function keywordData(mode, match) {\n          const matchText = language.case_insensitive ? match[0].toLowerCase() : match[0];\n          return Object.prototype.hasOwnProperty.call(mode.keywords, matchText) && mode.keywords[matchText];\n        }\n        function processKeywords() {\n          if (!top.keywords) {\n            emitter.addText(modeBuffer);\n            return;\n          }\n          let lastIndex = 0;\n          top.keywordPatternRe.lastIndex = 0;\n          let match = top.keywordPatternRe.exec(modeBuffer);\n          let buf = \"\";\n          while (match) {\n            buf += modeBuffer.substring(lastIndex, match.index);\n            const data = keywordData(top, match);\n            if (data) {\n              const [kind, keywordRelevance] = data;\n              emitter.addText(buf);\n              buf = \"\";\n              relevance += keywordRelevance;\n              if (kind.startsWith(\"_\")) {\n                buf += match[0];\n              } else {\n                const cssClass = language.classNameAliases[kind] || kind;\n                emitter.addKeyword(match[0], cssClass);\n              }\n            } else {\n              buf += match[0];\n            }\n            lastIndex = top.keywordPatternRe.lastIndex;\n            match = top.keywordPatternRe.exec(modeBuffer);\n          }\n          buf += modeBuffer.substr(lastIndex);\n          emitter.addText(buf);\n        }\n        function processSubLanguage() {\n          if (modeBuffer === \"\")\n            return;\n          let result2 = null;\n          if (typeof top.subLanguage === \"string\") {\n            if (!languages[top.subLanguage]) {\n              emitter.addText(modeBuffer);\n              return;\n            }\n            result2 = _highlight(top.subLanguage, modeBuffer, true, continuations[top.subLanguage]);\n            continuations[top.subLanguage] = /** @type {CompiledMode} */\n            result2.top;\n          } else {\n            result2 = highlightAuto(modeBuffer, top.subLanguage.length ? top.subLanguage : null);\n          }\n          if (top.relevance > 0) {\n            relevance += result2.relevance;\n          }\n          emitter.addSublanguage(result2.emitter, result2.language);\n        }\n        function processBuffer() {\n          if (top.subLanguage != null) {\n            processSubLanguage();\n          } else {\n            processKeywords();\n          }\n          modeBuffer = \"\";\n        }\n        function startNewMode(mode) {\n          if (mode.className) {\n            emitter.openNode(language.classNameAliases[mode.className] || mode.className);\n          }\n          top = Object.create(mode, { parent: { value: top } });\n          return top;\n        }\n        function endOfMode(mode, match, matchPlusRemainder) {\n          let matched = startsWith(mode.endRe, matchPlusRemainder);\n          if (matched) {\n            if (mode[\"on:end\"]) {\n              const resp = new Response(mode);\n              mode[\"on:end\"](match, resp);\n              if (resp.isMatchIgnored)\n                matched = false;\n            }\n            if (matched) {\n              while (mode.endsParent && mode.parent) {\n                mode = mode.parent;\n              }\n              return mode;\n            }\n          }\n          if (mode.endsWithParent) {\n            return endOfMode(mode.parent, match, matchPlusRemainder);\n          }\n        }\n        function doIgnore(lexeme) {\n          if (top.matcher.regexIndex === 0) {\n            modeBuffer += lexeme[0];\n            return 1;\n          } else {\n            resumeScanAtSamePosition = true;\n            return 0;\n          }\n        }\n        function doBeginMatch(match) {\n          const lexeme = match[0];\n          const newMode = match.rule;\n          const resp = new Response(newMode);\n          const beforeCallbacks = [newMode.__beforeBegin, newMode[\"on:begin\"]];\n          for (const cb of beforeCallbacks) {\n            if (!cb)\n              continue;\n            cb(match, resp);\n            if (resp.isMatchIgnored)\n              return doIgnore(lexeme);\n          }\n          if (newMode && newMode.endSameAsBegin) {\n            newMode.endRe = escape(lexeme);\n          }\n          if (newMode.skip) {\n            modeBuffer += lexeme;\n          } else {\n            if (newMode.excludeBegin) {\n              modeBuffer += lexeme;\n            }\n            processBuffer();\n            if (!newMode.returnBegin && !newMode.excludeBegin) {\n              modeBuffer = lexeme;\n            }\n          }\n          startNewMode(newMode);\n          return newMode.returnBegin ? 0 : lexeme.length;\n        }\n        function doEndMatch(match) {\n          const lexeme = match[0];\n          const matchPlusRemainder = codeToHighlight.substr(match.index);\n          const endMode = endOfMode(top, match, matchPlusRemainder);\n          if (!endMode) {\n            return NO_MATCH;\n          }\n          const origin = top;\n          if (origin.skip) {\n            modeBuffer += lexeme;\n          } else {\n            if (!(origin.returnEnd || origin.excludeEnd)) {\n              modeBuffer += lexeme;\n            }\n            processBuffer();\n            if (origin.excludeEnd) {\n              modeBuffer = lexeme;\n            }\n          }\n          do {\n            if (top.className) {\n              emitter.closeNode();\n            }\n            if (!top.skip && !top.subLanguage) {\n              relevance += top.relevance;\n            }\n            top = top.parent;\n          } while (top !== endMode.parent);\n          if (endMode.starts) {\n            if (endMode.endSameAsBegin) {\n              endMode.starts.endRe = endMode.endRe;\n            }\n            startNewMode(endMode.starts);\n          }\n          return origin.returnEnd ? 0 : lexeme.length;\n        }\n        function processContinuations() {\n          const list = [];\n          for (let current = top; current !== language; current = current.parent) {\n            if (current.className) {\n              list.unshift(current.className);\n            }\n          }\n          list.forEach((item) => emitter.openNode(item));\n        }\n        let lastMatch = {};\n        function processLexeme(textBeforeMatch, match) {\n          const lexeme = match && match[0];\n          modeBuffer += textBeforeMatch;\n          if (lexeme == null) {\n            processBuffer();\n            return 0;\n          }\n          if (lastMatch.type === \"begin\" && match.type === \"end\" && lastMatch.index === match.index && lexeme === \"\") {\n            modeBuffer += codeToHighlight.slice(match.index, match.index + 1);\n            if (!SAFE_MODE) {\n              const err = new Error(\"0 width match regex\");\n              err.languageName = languageName;\n              err.badRule = lastMatch.rule;\n              throw err;\n            }\n            return 1;\n          }\n          lastMatch = match;\n          if (match.type === \"begin\") {\n            return doBeginMatch(match);\n          } else if (match.type === \"illegal\" && !ignoreIllegals) {\n            const err = new Error('Illegal lexeme \"' + lexeme + '\" for mode \"' + (top.className || \"<unnamed>\") + '\"');\n            err.mode = top;\n            throw err;\n          } else if (match.type === \"end\") {\n            const processed = doEndMatch(match);\n            if (processed !== NO_MATCH) {\n              return processed;\n            }\n          }\n          if (match.type === \"illegal\" && lexeme === \"\") {\n            return 1;\n          }\n          if (iterations > 1e5 && iterations > match.index * 3) {\n            const err = new Error(\"potential infinite loop, way more iterations than matches\");\n            throw err;\n          }\n          modeBuffer += lexeme;\n          return lexeme.length;\n        }\n        const language = getLanguage(languageName);\n        if (!language) {\n          error(LANGUAGE_NOT_FOUND.replace(\"{}\", languageName));\n          throw new Error('Unknown language: \"' + languageName + '\"');\n        }\n        const md = compileLanguage(language, { plugins });\n        let result = \"\";\n        let top = continuation || md;\n        const continuations = {};\n        const emitter = new options.__emitter(options);\n        processContinuations();\n        let modeBuffer = \"\";\n        let relevance = 0;\n        let index = 0;\n        let iterations = 0;\n        let resumeScanAtSamePosition = false;\n        try {\n          top.matcher.considerAll();\n          for (; ; ) {\n            iterations++;\n            if (resumeScanAtSamePosition) {\n              resumeScanAtSamePosition = false;\n            } else {\n              top.matcher.considerAll();\n            }\n            top.matcher.lastIndex = index;\n            const match = top.matcher.exec(codeToHighlight);\n            if (!match)\n              break;\n            const beforeMatch = codeToHighlight.substring(index, match.index);\n            const processedCount = processLexeme(beforeMatch, match);\n            index = match.index + processedCount;\n          }\n          processLexeme(codeToHighlight.substr(index));\n          emitter.closeAllNodes();\n          emitter.finalize();\n          result = emitter.toHTML();\n          return {\n            // avoid possible breakage with v10 clients expecting\n            // this to always be an integer\n            relevance: Math.floor(relevance),\n            value: result,\n            language: languageName,\n            illegal: false,\n            emitter,\n            top\n          };\n        } catch (err) {\n          if (err.message && err.message.includes(\"Illegal\")) {\n            return {\n              illegal: true,\n              illegalBy: {\n                msg: err.message,\n                context: codeToHighlight.slice(index - 100, index + 100),\n                mode: err.mode\n              },\n              sofar: result,\n              relevance: 0,\n              value: escape$1(codeToHighlight),\n              emitter\n            };\n          } else if (SAFE_MODE) {\n            return {\n              illegal: false,\n              relevance: 0,\n              value: escape$1(codeToHighlight),\n              emitter,\n              language: languageName,\n              top,\n              errorRaised: err\n            };\n          } else {\n            throw err;\n          }\n        }\n      }\n      function justTextHighlightResult(code) {\n        const result = {\n          relevance: 0,\n          emitter: new options.__emitter(options),\n          value: escape$1(code),\n          illegal: false,\n          top: PLAINTEXT_LANGUAGE\n        };\n        result.emitter.addText(code);\n        return result;\n      }\n      function highlightAuto(code, languageSubset) {\n        languageSubset = languageSubset || options.languages || Object.keys(languages);\n        const plaintext = justTextHighlightResult(code);\n        const results = languageSubset.filter(getLanguage).filter(autoDetection).map(\n          (name) => _highlight(name, code, false)\n        );\n        results.unshift(plaintext);\n        const sorted = results.sort((a, b) => {\n          if (a.relevance !== b.relevance)\n            return b.relevance - a.relevance;\n          if (a.language && b.language) {\n            if (getLanguage(a.language).supersetOf === b.language) {\n              return 1;\n            } else if (getLanguage(b.language).supersetOf === a.language) {\n              return -1;\n            }\n          }\n          return 0;\n        });\n        const [best, secondBest] = sorted;\n        const result = best;\n        result.second_best = secondBest;\n        return result;\n      }\n      function fixMarkup(html) {\n        if (!(options.tabReplace || options.useBR)) {\n          return html;\n        }\n        return html.replace(fixMarkupRe, (match) => {\n          if (match === \"\\n\") {\n            return options.useBR ? \"<br>\" : match;\n          } else if (options.tabReplace) {\n            return match.replace(/\\t/g, options.tabReplace);\n          }\n          return match;\n        });\n      }\n      function updateClassName(element, currentLang, resultLang) {\n        const language = currentLang ? aliases[currentLang] : resultLang;\n        element.classList.add(\"hljs\");\n        if (language)\n          element.classList.add(language);\n      }\n      const brPlugin = {\n        \"before:highlightElement\": ({ el }) => {\n          if (options.useBR) {\n            el.innerHTML = el.innerHTML.replace(/\\n/g, \"\").replace(/<br[ /]*>/g, \"\\n\");\n          }\n        },\n        \"after:highlightElement\": ({ result }) => {\n          if (options.useBR) {\n            result.value = result.value.replace(/\\n/g, \"<br>\");\n          }\n        }\n      };\n      const TAB_REPLACE_RE = /^(<[^>]+>|\\t)+/gm;\n      const tabReplacePlugin = {\n        \"after:highlightElement\": ({ result }) => {\n          if (options.tabReplace) {\n            result.value = result.value.replace(\n              TAB_REPLACE_RE,\n              (m) => m.replace(/\\t/g, options.tabReplace)\n            );\n          }\n        }\n      };\n      function highlightElement(element) {\n        let node = null;\n        const language = blockLanguage(element);\n        if (shouldNotHighlight(language))\n          return;\n        fire(\n          \"before:highlightElement\",\n          { el: element, language }\n        );\n        node = element;\n        const text = node.textContent;\n        const result = language ? highlight2(text, { language, ignoreIllegals: true }) : highlightAuto(text);\n        fire(\"after:highlightElement\", { el: element, result, text });\n        element.innerHTML = result.value;\n        updateClassName(element, language, result.language);\n        element.result = {\n          language: result.language,\n          // TODO: remove with version 11.0\n          re: result.relevance,\n          relavance: result.relevance\n        };\n        if (result.second_best) {\n          element.second_best = {\n            language: result.second_best.language,\n            // TODO: remove with version 11.0\n            re: result.second_best.relevance,\n            relavance: result.second_best.relevance\n          };\n        }\n      }\n      function configure(userOptions) {\n        if (userOptions.useBR) {\n          deprecated(\"10.3.0\", \"'useBR' will be removed entirely in v11.0\");\n          deprecated(\"10.3.0\", \"Please see https://github.com/highlightjs/highlight.js/issues/2559\");\n        }\n        options = inherit$1(options, userOptions);\n      }\n      const initHighlighting = () => {\n        if (initHighlighting.called)\n          return;\n        initHighlighting.called = true;\n        deprecated(\"10.6.0\", \"initHighlighting() is deprecated.  Use highlightAll() instead.\");\n        const blocks = document.querySelectorAll(\"pre code\");\n        blocks.forEach(highlightElement);\n      };\n      function initHighlightingOnLoad() {\n        deprecated(\"10.6.0\", \"initHighlightingOnLoad() is deprecated.  Use highlightAll() instead.\");\n        wantsHighlight = true;\n      }\n      let wantsHighlight = false;\n      function highlightAll() {\n        if (document.readyState === \"loading\") {\n          wantsHighlight = true;\n          return;\n        }\n        const blocks = document.querySelectorAll(\"pre code\");\n        blocks.forEach(highlightElement);\n      }\n      function boot() {\n        if (wantsHighlight)\n          highlightAll();\n      }\n      if (typeof window !== \"undefined\" && window.addEventListener) {\n        window.addEventListener(\"DOMContentLoaded\", boot, false);\n      }\n      function registerLanguage(languageName, languageDefinition) {\n        let lang = null;\n        try {\n          lang = languageDefinition(hljs);\n        } catch (error$1) {\n          error(\"Language definition for '{}' could not be registered.\".replace(\"{}\", languageName));\n          if (!SAFE_MODE) {\n            throw error$1;\n          } else {\n            error(error$1);\n          }\n          lang = PLAINTEXT_LANGUAGE;\n        }\n        if (!lang.name)\n          lang.name = languageName;\n        languages[languageName] = lang;\n        lang.rawDefinition = languageDefinition.bind(null, hljs);\n        if (lang.aliases) {\n          registerAliases(lang.aliases, { languageName });\n        }\n      }\n      function unregisterLanguage(languageName) {\n        delete languages[languageName];\n        for (const alias of Object.keys(aliases)) {\n          if (aliases[alias] === languageName) {\n            delete aliases[alias];\n          }\n        }\n      }\n      function listLanguages() {\n        return Object.keys(languages);\n      }\n      function requireLanguage(name) {\n        deprecated(\"10.4.0\", \"requireLanguage will be removed entirely in v11.\");\n        deprecated(\"10.4.0\", \"Please see https://github.com/highlightjs/highlight.js/pull/2844\");\n        const lang = getLanguage(name);\n        if (lang) {\n          return lang;\n        }\n        const err = new Error(\"The '{}' language is required, but not loaded.\".replace(\"{}\", name));\n        throw err;\n      }\n      function getLanguage(name) {\n        name = (name || \"\").toLowerCase();\n        return languages[name] || languages[aliases[name]];\n      }\n      function registerAliases(aliasList, { languageName }) {\n        if (typeof aliasList === \"string\") {\n          aliasList = [aliasList];\n        }\n        aliasList.forEach((alias) => {\n          aliases[alias.toLowerCase()] = languageName;\n        });\n      }\n      function autoDetection(name) {\n        const lang = getLanguage(name);\n        return lang && !lang.disableAutodetect;\n      }\n      function upgradePluginAPI(plugin) {\n        if (plugin[\"before:highlightBlock\"] && !plugin[\"before:highlightElement\"]) {\n          plugin[\"before:highlightElement\"] = (data) => {\n            plugin[\"before:highlightBlock\"](\n              Object.assign({ block: data.el }, data)\n            );\n          };\n        }\n        if (plugin[\"after:highlightBlock\"] && !plugin[\"after:highlightElement\"]) {\n          plugin[\"after:highlightElement\"] = (data) => {\n            plugin[\"after:highlightBlock\"](\n              Object.assign({ block: data.el }, data)\n            );\n          };\n        }\n      }\n      function addPlugin(plugin) {\n        upgradePluginAPI(plugin);\n        plugins.push(plugin);\n      }\n      function fire(event, args) {\n        const cb = event;\n        plugins.forEach(function(plugin) {\n          if (plugin[cb]) {\n            plugin[cb](args);\n          }\n        });\n      }\n      function deprecateFixMarkup(arg) {\n        deprecated(\"10.2.0\", \"fixMarkup will be removed entirely in v11.0\");\n        deprecated(\"10.2.0\", \"Please see https://github.com/highlightjs/highlight.js/issues/2534\");\n        return fixMarkup(arg);\n      }\n      function deprecateHighlightBlock(el) {\n        deprecated(\"10.7.0\", \"highlightBlock will be removed entirely in v12.0\");\n        deprecated(\"10.7.0\", \"Please use highlightElement now.\");\n        return highlightElement(el);\n      }\n      Object.assign(hljs, {\n        highlight: highlight2,\n        highlightAuto,\n        highlightAll,\n        fixMarkup: deprecateFixMarkup,\n        highlightElement,\n        // TODO: Remove with v12 API\n        highlightBlock: deprecateHighlightBlock,\n        configure,\n        initHighlighting,\n        initHighlightingOnLoad,\n        registerLanguage,\n        unregisterLanguage,\n        listLanguages,\n        getLanguage,\n        registerAliases,\n        requireLanguage,\n        autoDetection,\n        inherit: inherit$1,\n        addPlugin,\n        // plugins for frameworks\n        vuePlugin: BuildVuePlugin(hljs).VuePlugin\n      });\n      hljs.debugMode = function() {\n        SAFE_MODE = false;\n      };\n      hljs.safeMode = function() {\n        SAFE_MODE = true;\n      };\n      hljs.versionString = version;\n      for (const key in MODES) {\n        if (typeof MODES[key] === \"object\") {\n          deepFreezeEs6(MODES[key]);\n        }\n      }\n      Object.assign(hljs, MODES);\n      hljs.addPlugin(brPlugin);\n      hljs.addPlugin(mergeHTMLPlugin);\n      hljs.addPlugin(tabReplacePlugin);\n      return hljs;\n    };\n    var highlight = HLJS({});\n    module.exports = highlight;\n  }\n});\n\n// node_modules/format/format.js\nvar require_format = __commonJS({\n  \"node_modules/format/format.js\"(exports, module) {\n    var import_dist = __toESM(require_dist());\n    (function() {\n      var namespace;\n      if (typeof module !== \"undefined\") {\n        namespace = module.exports = format;\n      } else {\n        namespace = function() {\n          return this || (1, eval)(\"this\");\n        }();\n      }\n      namespace.format = format;\n      namespace.vsprintf = vsprintf;\n      if (typeof console !== \"undefined\" && typeof console.log === \"function\") {\n        namespace.printf = printf;\n      }\n      function printf() {\n        console.log(format.apply(null, arguments));\n      }\n      function vsprintf(fmt, replacements) {\n        return format.apply(null, [fmt].concat(replacements));\n      }\n      function format(fmt) {\n        var argIndex = 1, args = [].slice.call(arguments), i = 0, n = fmt.length, result = \"\", c, escaped = false, arg, tmp, leadingZero = false, precision, nextArg = function() {\n          return args[argIndex++];\n        }, slurpNumber = function() {\n          var digits = \"\";\n          while (/\\d/.test(fmt[i])) {\n            digits += fmt[i++];\n            c = fmt[i];\n          }\n          return digits.length > 0 ? parseInt(digits) : null;\n        };\n        for (; i < n; ++i) {\n          c = fmt[i];\n          if (escaped) {\n            escaped = false;\n            if (c == \".\") {\n              leadingZero = false;\n              c = fmt[++i];\n            } else if (c == \"0\" && fmt[i + 1] == \".\") {\n              leadingZero = true;\n              i += 2;\n              c = fmt[i];\n            } else {\n              leadingZero = true;\n            }\n            precision = slurpNumber();\n            switch (c) {\n              case \"b\":\n                result += parseInt(nextArg(), 10).toString(2);\n                break;\n              case \"c\":\n                arg = nextArg();\n                if (typeof arg === \"string\" || arg instanceof String)\n                  result += arg;\n                else\n                  result += String.fromCharCode(parseInt(arg, 10));\n                break;\n              case \"d\":\n                result += parseInt(nextArg(), 10);\n                break;\n              case \"f\":\n                tmp = String(parseFloat(nextArg()).toFixed(precision || 6));\n                result += leadingZero ? tmp : tmp.replace(/^0/, \"\");\n                break;\n              case \"j\":\n                result += JSON.stringify(nextArg());\n                break;\n              case \"o\":\n                result += \"0\" + parseInt(nextArg(), 10).toString(8);\n                break;\n              case \"s\":\n                result += nextArg();\n                break;\n              case \"x\":\n                result += \"0x\" + parseInt(nextArg(), 10).toString(16);\n                break;\n              case \"X\":\n                result += \"0x\" + parseInt(nextArg(), 10).toString(16).toUpperCase();\n                break;\n              default:\n                result += c;\n                break;\n            }\n          } else if (c === \"%\") {\n            escaped = true;\n          } else {\n            result += c;\n          }\n        }\n        return result;\n      }\n    })();\n  }\n});\n\n// node_modules/fault/index.js\nvar require_fault = __commonJS({\n  \"node_modules/fault/index.js\"(exports, module) {\n    \"use strict\";\n    var import_dist = __toESM(require_dist());\n    var formatter = require_format();\n    var fault = create(Error);\n    module.exports = fault;\n    fault.eval = create(EvalError);\n    fault.range = create(RangeError);\n    fault.reference = create(ReferenceError);\n    fault.syntax = create(SyntaxError);\n    fault.type = create(TypeError);\n    fault.uri = create(URIError);\n    fault.create = create;\n    function create(EConstructor) {\n      FormattedError.displayName = EConstructor.displayName || EConstructor.name;\n      return FormattedError;\n      function FormattedError(format) {\n        if (format) {\n          format = formatter.apply(null, arguments);\n        }\n        return new EConstructor(format);\n      }\n    }\n  }\n});\n\n// node_modules/lowlight/lib/core.js\nvar require_core2 = __commonJS({\n  \"node_modules/lowlight/lib/core.js\"(exports) {\n    var import_dist = __toESM(require_dist());\n    var high = require_core();\n    var fault = require_fault();\n    exports.highlight = highlight;\n    exports.highlightAuto = highlightAuto;\n    exports.registerLanguage = registerLanguage;\n    exports.listLanguages = listLanguages;\n    exports.registerAlias = registerAlias;\n    Emitter.prototype.addText = text;\n    Emitter.prototype.addKeyword = addKeyword;\n    Emitter.prototype.addSublanguage = addSublanguage;\n    Emitter.prototype.openNode = open;\n    Emitter.prototype.closeNode = close;\n    Emitter.prototype.closeAllNodes = noop;\n    Emitter.prototype.finalize = noop;\n    Emitter.prototype.toHTML = toHtmlNoop;\n    var defaultPrefix = \"hljs-\";\n    function highlight(name, value, options) {\n      var before = high.configure({});\n      var settings = options || {};\n      var prefix = settings.prefix;\n      var result;\n      if (typeof name !== \"string\") {\n        throw fault(\"Expected `string` for name, got `%s`\", name);\n      }\n      if (!high.getLanguage(name)) {\n        throw fault(\"Unknown language: `%s` is not registered\", name);\n      }\n      if (typeof value !== \"string\") {\n        throw fault(\"Expected `string` for value, got `%s`\", value);\n      }\n      if (prefix === null || prefix === void 0) {\n        prefix = defaultPrefix;\n      }\n      high.configure({ __emitter: Emitter, classPrefix: prefix });\n      result = high.highlight(value, { language: name, ignoreIllegals: true });\n      high.configure(before || {});\n      if (result.errorRaised) {\n        throw result.errorRaised;\n      }\n      return {\n        relevance: result.relevance,\n        language: result.language,\n        value: result.emitter.rootNode.children\n      };\n    }\n    function highlightAuto(value, options) {\n      var settings = options || {};\n      var subset = settings.subset || high.listLanguages();\n      var prefix = settings.prefix;\n      var length = subset.length;\n      var index = -1;\n      var result;\n      var secondBest;\n      var current;\n      var name;\n      if (prefix === null || prefix === void 0) {\n        prefix = defaultPrefix;\n      }\n      if (typeof value !== \"string\") {\n        throw fault(\"Expected `string` for value, got `%s`\", value);\n      }\n      secondBest = { relevance: 0, language: null, value: [] };\n      result = { relevance: 0, language: null, value: [] };\n      while (++index < length) {\n        name = subset[index];\n        if (!high.getLanguage(name)) {\n          continue;\n        }\n        current = highlight(name, value, options);\n        current.language = name;\n        if (current.relevance > secondBest.relevance) {\n          secondBest = current;\n        }\n        if (current.relevance > result.relevance) {\n          secondBest = result;\n          result = current;\n        }\n      }\n      if (secondBest.language) {\n        result.secondBest = secondBest;\n      }\n      return result;\n    }\n    function registerLanguage(name, syntax) {\n      high.registerLanguage(name, syntax);\n    }\n    function listLanguages() {\n      return high.listLanguages();\n    }\n    function registerAlias(name, alias) {\n      var map = name;\n      var key;\n      if (alias) {\n        map = {};\n        map[name] = alias;\n      }\n      for (key in map) {\n        high.registerAliases(map[key], { languageName: key });\n      }\n    }\n    function Emitter(options) {\n      this.options = options;\n      this.rootNode = { children: [] };\n      this.stack = [this.rootNode];\n    }\n    function addKeyword(value, name) {\n      this.openNode(name);\n      this.addText(value);\n      this.closeNode();\n    }\n    function addSublanguage(other, name) {\n      var stack = this.stack;\n      var current = stack[stack.length - 1];\n      var results = other.rootNode.children;\n      var node = name ? {\n        type: \"element\",\n        tagName: \"span\",\n        properties: { className: [name] },\n        children: results\n      } : results;\n      current.children = current.children.concat(node);\n    }\n    function text(value) {\n      var stack = this.stack;\n      var current;\n      var tail;\n      if (value === \"\")\n        return;\n      current = stack[stack.length - 1];\n      tail = current.children[current.children.length - 1];\n      if (tail && tail.type === \"text\") {\n        tail.value += value;\n      } else {\n        current.children.push({ type: \"text\", value });\n      }\n    }\n    function open(name) {\n      var stack = this.stack;\n      var className = this.options.classPrefix + name;\n      var current = stack[stack.length - 1];\n      var child = {\n        type: \"element\",\n        tagName: \"span\",\n        properties: { className: [className] },\n        children: []\n      };\n      current.children.push(child);\n      stack.push(child);\n    }\n    function close() {\n      this.stack.pop();\n    }\n    function toHtmlNoop() {\n      return \"\";\n    }\n    function noop() {\n    }\n  }\n});\n\nexport {\n  require_core2 as require_core\n};\n//# sourceMappingURL=chunk-YNER2GXA.js.map\n",
      "start": 1703289478635,
      "end": 1703289479088,
      "sourcemaps": null
    },
    {
      "name": "vite:react-babel",
      "start": 1703289479088,
      "end": 1703289479088,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1703289479088,
      "end": 1703289479088,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1703289479088,
      "end": 1703289479088,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1703289479088,
      "end": 1703289479088,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1703289479088,
      "end": 1703289479088,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1703289479088,
      "end": 1703289479088,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1703289479088,
      "end": 1703289479088,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1703289479088,
      "end": 1703289479088,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1703289479088,
      "end": 1703289479088,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1703289479088,
      "end": 1703289479088,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1703289479088,
      "end": 1703289479088,
      "order": "normal"
    },
    {
      "name": "vite:client-inject",
      "start": 1703289479088,
      "end": 1703289479088,
      "order": "normal"
    },
    {
      "name": "vite:import-analysis",
      "result": "\"use strict\";\n(() => {\n  var __create = Object.create;\n  var __defProp = Object.defineProperty;\n  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n  var __getOwnPropNames = Object.getOwnPropertyNames;\n  var __getProtoOf = Object.getPrototypeOf;\n  var __hasOwnProp = Object.prototype.hasOwnProperty;\n  var __esm = (fn, res) => function __init() {\n    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;\n  };\n  var __commonJS = (cb, mod) => function __require() {\n    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n  };\n  var __copyProps = (to, from, except, desc) => {\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n      for (let key of __getOwnPropNames(from))\n        if (!__hasOwnProp.call(to, key) && key !== except)\n          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n    }\n    return to;\n  };\n  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n    // If the importer is in node compatibility mode or this is not an ESM\n    // file that has been converted to a CommonJS file using a Babel-\n    // compatible transform (i.e. \"__esModule\" has not been set), then set\n    // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n    isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n    mod\n  ));\n\n  // node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js\n  var require_base64_js = __commonJS({\n    \"node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js\"(exports) {\n      \"use strict\";\n      init_dist();\n      exports.byteLength = byteLength;\n      exports.toByteArray = toByteArray;\n      exports.fromByteArray = fromByteArray;\n      var lookup = [];\n      var revLookup = [];\n      var Arr = typeof Uint8Array !== \"undefined\" ? Uint8Array : Array;\n      var code = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n      for (i = 0, len = code.length; i < len; ++i) {\n        lookup[i] = code[i];\n        revLookup[code.charCodeAt(i)] = i;\n      }\n      var i;\n      var len;\n      revLookup[\"-\".charCodeAt(0)] = 62;\n      revLookup[\"_\".charCodeAt(0)] = 63;\n      function getLens(b64) {\n        var len2 = b64.length;\n        if (len2 % 4 > 0) {\n          throw new Error(\"Invalid string. Length must be a multiple of 4\");\n        }\n        var validLen = b64.indexOf(\"=\");\n        if (validLen === -1)\n          validLen = len2;\n        var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;\n        return [validLen, placeHoldersLen];\n      }\n      function byteLength(b64) {\n        var lens = getLens(b64);\n        var validLen = lens[0];\n        var placeHoldersLen = lens[1];\n        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n      }\n      function _byteLength(b64, validLen, placeHoldersLen) {\n        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n      }\n      function toByteArray(b64) {\n        var tmp;\n        var lens = getLens(b64);\n        var validLen = lens[0];\n        var placeHoldersLen = lens[1];\n        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n        var curByte = 0;\n        var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;\n        var i2;\n        for (i2 = 0; i2 < len2; i2 += 4) {\n          tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];\n          arr[curByte++] = tmp >> 16 & 255;\n          arr[curByte++] = tmp >> 8 & 255;\n          arr[curByte++] = tmp & 255;\n        }\n        if (placeHoldersLen === 2) {\n          tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;\n          arr[curByte++] = tmp & 255;\n        }\n        if (placeHoldersLen === 1) {\n          tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;\n          arr[curByte++] = tmp >> 8 & 255;\n          arr[curByte++] = tmp & 255;\n        }\n        return arr;\n      }\n      function tripletToBase64(num) {\n        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];\n      }\n      function encodeChunk(uint8, start, end) {\n        var tmp;\n        var output = [];\n        for (var i2 = start; i2 < end; i2 += 3) {\n          tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);\n          output.push(tripletToBase64(tmp));\n        }\n        return output.join(\"\");\n      }\n      function fromByteArray(uint8) {\n        var tmp;\n        var len2 = uint8.length;\n        var extraBytes = len2 % 3;\n        var parts = [];\n        var maxChunkLength = 16383;\n        for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {\n          parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));\n        }\n        if (extraBytes === 1) {\n          tmp = uint8[len2 - 1];\n          parts.push(\n            lookup[tmp >> 2] + lookup[tmp << 4 & 63] + \"==\"\n          );\n        } else if (extraBytes === 2) {\n          tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];\n          parts.push(\n            lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + \"=\"\n          );\n        }\n        return parts.join(\"\");\n      }\n    }\n  });\n\n  // node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js\n  var require_ieee754 = __commonJS({\n    \"node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js\"(exports) {\n      init_dist();\n      exports.read = function(buffer, offset, isLE, mLen, nBytes) {\n        var e, m;\n        var eLen = nBytes * 8 - mLen - 1;\n        var eMax = (1 << eLen) - 1;\n        var eBias = eMax >> 1;\n        var nBits = -7;\n        var i = isLE ? nBytes - 1 : 0;\n        var d = isLE ? -1 : 1;\n        var s2 = buffer[offset + i];\n        i += d;\n        e = s2 & (1 << -nBits) - 1;\n        s2 >>= -nBits;\n        nBits += eLen;\n        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {\n        }\n        m = e & (1 << -nBits) - 1;\n        e >>= -nBits;\n        nBits += mLen;\n        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {\n        }\n        if (e === 0) {\n          e = 1 - eBias;\n        } else if (e === eMax) {\n          return m ? NaN : (s2 ? -1 : 1) * Infinity;\n        } else {\n          m = m + Math.pow(2, mLen);\n          e = e - eBias;\n        }\n        return (s2 ? -1 : 1) * m * Math.pow(2, e - mLen);\n      };\n      exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {\n        var e, m, c;\n        var eLen = nBytes * 8 - mLen - 1;\n        var eMax = (1 << eLen) - 1;\n        var eBias = eMax >> 1;\n        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n        var i = isLE ? 0 : nBytes - 1;\n        var d = isLE ? 1 : -1;\n        var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n        value = Math.abs(value);\n        if (isNaN(value) || value === Infinity) {\n          m = isNaN(value) ? 1 : 0;\n          e = eMax;\n        } else {\n          e = Math.floor(Math.log(value) / Math.LN2);\n          if (value * (c = Math.pow(2, -e)) < 1) {\n            e--;\n            c *= 2;\n          }\n          if (e + eBias >= 1) {\n            value += rt / c;\n          } else {\n            value += rt * Math.pow(2, 1 - eBias);\n          }\n          if (value * c >= 2) {\n            e++;\n            c /= 2;\n          }\n          if (e + eBias >= eMax) {\n            m = 0;\n            e = eMax;\n          } else if (e + eBias >= 1) {\n            m = (value * c - 1) * Math.pow(2, mLen);\n            e = e + eBias;\n          } else {\n            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n            e = 0;\n          }\n        }\n        for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {\n        }\n        e = e << mLen | m;\n        eLen += mLen;\n        for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {\n        }\n        buffer[offset + i - d] |= s2 * 128;\n      };\n    }\n  });\n\n  // node_modules/.pnpm/buffer@6.0.3_patch_hash=zkkuxompt5d553skpnegwi5wuy/node_modules/buffer/index.js\n  var require_buffer = __commonJS({\n    \"node_modules/.pnpm/buffer@6.0.3_patch_hash=zkkuxompt5d553skpnegwi5wuy/node_modules/buffer/index.js\"(exports) {\n      \"use strict\";\n      init_dist();\n      var base64 = require_base64_js();\n      var ieee754 = require_ieee754();\n      var customInspectSymbol = typeof Symbol === \"function\" && typeof Symbol[\"for\"] === \"function\" ? Symbol[\"for\"](\"nodejs.util.inspect.custom\") : null;\n      exports.Buffer = Buffer2;\n      exports.SlowBuffer = SlowBuffer;\n      exports.INSPECT_MAX_BYTES = 50;\n      var K_MAX_LENGTH = 2147483647;\n      exports.kMaxLength = K_MAX_LENGTH;\n      var { Uint8Array: GlobalUint8Array, ArrayBuffer: GlobalArrayBuffer, SharedArrayBuffer: GlobalSharedArrayBuffer } = globalThis;\n      Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();\n      if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== \"undefined\" && typeof console.error === \"function\") {\n        console.error(\n          \"This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.\"\n        );\n      }\n      function typedArraySupport() {\n        try {\n          const arr = new GlobalUint8Array(1);\n          const proto = { foo: function() {\n            return 42;\n          } };\n          Object.setPrototypeOf(proto, GlobalUint8Array.prototype);\n          Object.setPrototypeOf(arr, proto);\n          return arr.foo() === 42;\n        } catch (e) {\n          return false;\n        }\n      }\n      Object.defineProperty(Buffer2.prototype, \"parent\", {\n        enumerable: true,\n        get: function() {\n          if (!Buffer2.isBuffer(this))\n            return void 0;\n          return this.buffer;\n        }\n      });\n      Object.defineProperty(Buffer2.prototype, \"offset\", {\n        enumerable: true,\n        get: function() {\n          if (!Buffer2.isBuffer(this))\n            return void 0;\n          return this.byteOffset;\n        }\n      });\n      function createBuffer(length) {\n        if (length > K_MAX_LENGTH) {\n          throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"');\n        }\n        const buf = new GlobalUint8Array(length);\n        Object.setPrototypeOf(buf, Buffer2.prototype);\n        return buf;\n      }\n      function Buffer2(arg, encodingOrOffset, length) {\n        if (typeof arg === \"number\") {\n          if (typeof encodingOrOffset === \"string\") {\n            throw new TypeError(\n              'The \"string\" argument must be of type string. Received type number'\n            );\n          }\n          return allocUnsafe(arg);\n        }\n        return from(arg, encodingOrOffset, length);\n      }\n      Buffer2.poolSize = 8192;\n      function from(value, encodingOrOffset, length) {\n        if (typeof value === \"string\") {\n          return fromString(value, encodingOrOffset);\n        }\n        if (GlobalArrayBuffer.isView(value)) {\n          return fromArrayView(value);\n        }\n        if (value == null) {\n          throw new TypeError(\n            \"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value\n          );\n        }\n        if (isInstance(value, GlobalArrayBuffer) || value && isInstance(value.buffer, GlobalArrayBuffer)) {\n          return fromArrayBuffer(value, encodingOrOffset, length);\n        }\n        if (typeof GlobalSharedArrayBuffer !== \"undefined\" && (isInstance(value, GlobalSharedArrayBuffer) || value && isInstance(value.buffer, GlobalSharedArrayBuffer))) {\n          return fromArrayBuffer(value, encodingOrOffset, length);\n        }\n        if (typeof value === \"number\") {\n          throw new TypeError(\n            'The \"value\" argument must not be of type number. Received type number'\n          );\n        }\n        const valueOf = value.valueOf && value.valueOf();\n        if (valueOf != null && valueOf !== value) {\n          return Buffer2.from(valueOf, encodingOrOffset, length);\n        }\n        const b = fromObject(value);\n        if (b)\n          return b;\n        if (typeof Symbol !== \"undefined\" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === \"function\") {\n          return Buffer2.from(value[Symbol.toPrimitive](\"string\"), encodingOrOffset, length);\n        }\n        throw new TypeError(\n          \"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value\n        );\n      }\n      Buffer2.from = function(value, encodingOrOffset, length) {\n        return from(value, encodingOrOffset, length);\n      };\n      Object.setPrototypeOf(Buffer2.prototype, GlobalUint8Array.prototype);\n      Object.setPrototypeOf(Buffer2, GlobalUint8Array);\n      function assertSize(size) {\n        if (typeof size !== \"number\") {\n          throw new TypeError('\"size\" argument must be of type number');\n        } else if (size < 0) {\n          throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"');\n        }\n      }\n      function alloc(size, fill, encoding) {\n        assertSize(size);\n        if (size <= 0) {\n          return createBuffer(size);\n        }\n        if (fill !== void 0) {\n          return typeof encoding === \"string\" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);\n        }\n        return createBuffer(size);\n      }\n      Buffer2.alloc = function(size, fill, encoding) {\n        return alloc(size, fill, encoding);\n      };\n      function allocUnsafe(size) {\n        assertSize(size);\n        return createBuffer(size < 0 ? 0 : checked(size) | 0);\n      }\n      Buffer2.allocUnsafe = function(size) {\n        return allocUnsafe(size);\n      };\n      Buffer2.allocUnsafeSlow = function(size) {\n        return allocUnsafe(size);\n      };\n      function fromString(string, encoding) {\n        if (typeof encoding !== \"string\" || encoding === \"\") {\n          encoding = \"utf8\";\n        }\n        if (!Buffer2.isEncoding(encoding)) {\n          throw new TypeError(\"Unknown encoding: \" + encoding);\n        }\n        const length = byteLength(string, encoding) | 0;\n        let buf = createBuffer(length);\n        const actual = buf.write(string, encoding);\n        if (actual !== length) {\n          buf = buf.slice(0, actual);\n        }\n        return buf;\n      }\n      function fromArrayLike(array) {\n        const length = array.length < 0 ? 0 : checked(array.length) | 0;\n        const buf = createBuffer(length);\n        for (let i = 0; i < length; i += 1) {\n          buf[i] = array[i] & 255;\n        }\n        return buf;\n      }\n      function fromArrayView(arrayView) {\n        if (isInstance(arrayView, GlobalUint8Array)) {\n          const copy = new GlobalUint8Array(arrayView);\n          return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);\n        }\n        return fromArrayLike(arrayView);\n      }\n      function fromArrayBuffer(array, byteOffset, length) {\n        if (byteOffset < 0 || array.byteLength < byteOffset) {\n          throw new RangeError('\"offset\" is outside of buffer bounds');\n        }\n        if (array.byteLength < byteOffset + (length || 0)) {\n          throw new RangeError('\"length\" is outside of buffer bounds');\n        }\n        let buf;\n        if (byteOffset === void 0 && length === void 0) {\n          buf = new GlobalUint8Array(array);\n        } else if (length === void 0) {\n          buf = new GlobalUint8Array(array, byteOffset);\n        } else {\n          buf = new GlobalUint8Array(array, byteOffset, length);\n        }\n        Object.setPrototypeOf(buf, Buffer2.prototype);\n        return buf;\n      }\n      function fromObject(obj) {\n        if (Buffer2.isBuffer(obj)) {\n          const len = checked(obj.length) | 0;\n          const buf = createBuffer(len);\n          if (buf.length === 0) {\n            return buf;\n          }\n          obj.copy(buf, 0, 0, len);\n          return buf;\n        }\n        if (obj.length !== void 0) {\n          if (typeof obj.length !== \"number\" || numberIsNaN(obj.length)) {\n            return createBuffer(0);\n          }\n          return fromArrayLike(obj);\n        }\n        if (obj.type === \"Buffer\" && Array.isArray(obj.data)) {\n          return fromArrayLike(obj.data);\n        }\n      }\n      function checked(length) {\n        if (length >= K_MAX_LENGTH) {\n          throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\" + K_MAX_LENGTH.toString(16) + \" bytes\");\n        }\n        return length | 0;\n      }\n      function SlowBuffer(length) {\n        if (+length != length) {\n          length = 0;\n        }\n        return Buffer2.alloc(+length);\n      }\n      Buffer2.isBuffer = function isBuffer(b) {\n        return b != null && b._isBuffer === true && b !== Buffer2.prototype;\n      };\n      Buffer2.compare = function compare(a, b) {\n        if (isInstance(a, GlobalUint8Array))\n          a = Buffer2.from(a, a.offset, a.byteLength);\n        if (isInstance(b, GlobalUint8Array))\n          b = Buffer2.from(b, b.offset, b.byteLength);\n        if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {\n          throw new TypeError(\n            'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n          );\n        }\n        if (a === b)\n          return 0;\n        let x = a.length;\n        let y = b.length;\n        for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n          if (a[i] !== b[i]) {\n            x = a[i];\n            y = b[i];\n            break;\n          }\n        }\n        if (x < y)\n          return -1;\n        if (y < x)\n          return 1;\n        return 0;\n      };\n      Buffer2.isEncoding = function isEncoding(encoding) {\n        switch (String(encoding).toLowerCase()) {\n          case \"hex\":\n          case \"utf8\":\n          case \"utf-8\":\n          case \"ascii\":\n          case \"latin1\":\n          case \"binary\":\n          case \"base64\":\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return true;\n          default:\n            return false;\n        }\n      };\n      Buffer2.concat = function concat(list, length) {\n        if (!Array.isArray(list)) {\n          throw new TypeError('\"list\" argument must be an Array of Buffers');\n        }\n        if (list.length === 0) {\n          return Buffer2.alloc(0);\n        }\n        let i;\n        if (length === void 0) {\n          length = 0;\n          for (i = 0; i < list.length; ++i) {\n            length += list[i].length;\n          }\n        }\n        const buffer = Buffer2.allocUnsafe(length);\n        let pos = 0;\n        for (i = 0; i < list.length; ++i) {\n          let buf = list[i];\n          if (isInstance(buf, GlobalUint8Array)) {\n            if (pos + buf.length > buffer.length) {\n              if (!Buffer2.isBuffer(buf))\n                buf = Buffer2.from(buf);\n              buf.copy(buffer, pos);\n            } else {\n              GlobalUint8Array.prototype.set.call(\n                buffer,\n                buf,\n                pos\n              );\n            }\n          } else if (!Buffer2.isBuffer(buf)) {\n            throw new TypeError('\"list\" argument must be an Array of Buffers');\n          } else {\n            buf.copy(buffer, pos);\n          }\n          pos += buf.length;\n        }\n        return buffer;\n      };\n      function byteLength(string, encoding) {\n        if (Buffer2.isBuffer(string)) {\n          return string.length;\n        }\n        if (GlobalArrayBuffer.isView(string) || isInstance(string, GlobalArrayBuffer)) {\n          return string.byteLength;\n        }\n        if (typeof string !== \"string\") {\n          throw new TypeError(\n            'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string\n          );\n        }\n        const len = string.length;\n        const mustMatch = arguments.length > 2 && arguments[2] === true;\n        if (!mustMatch && len === 0)\n          return 0;\n        let loweredCase = false;\n        for (; ; ) {\n          switch (encoding) {\n            case \"ascii\":\n            case \"latin1\":\n            case \"binary\":\n              return len;\n            case \"utf8\":\n            case \"utf-8\":\n              return utf8ToBytes(string).length;\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n              return len * 2;\n            case \"hex\":\n              return len >>> 1;\n            case \"base64\":\n              return base64ToBytes(string).length;\n            default:\n              if (loweredCase) {\n                return mustMatch ? -1 : utf8ToBytes(string).length;\n              }\n              encoding = (\"\" + encoding).toLowerCase();\n              loweredCase = true;\n          }\n        }\n      }\n      Buffer2.byteLength = byteLength;\n      function slowToString(encoding, start, end) {\n        let loweredCase = false;\n        if (start === void 0 || start < 0) {\n          start = 0;\n        }\n        if (start > this.length) {\n          return \"\";\n        }\n        if (end === void 0 || end > this.length) {\n          end = this.length;\n        }\n        if (end <= 0) {\n          return \"\";\n        }\n        end >>>= 0;\n        start >>>= 0;\n        if (end <= start) {\n          return \"\";\n        }\n        if (!encoding)\n          encoding = \"utf8\";\n        while (true) {\n          switch (encoding) {\n            case \"hex\":\n              return hexSlice(this, start, end);\n            case \"utf8\":\n            case \"utf-8\":\n              return utf8Slice(this, start, end);\n            case \"ascii\":\n              return asciiSlice(this, start, end);\n            case \"latin1\":\n            case \"binary\":\n              return latin1Slice(this, start, end);\n            case \"base64\":\n              return base64Slice(this, start, end);\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n              return utf16leSlice(this, start, end);\n            default:\n              if (loweredCase)\n                throw new TypeError(\"Unknown encoding: \" + encoding);\n              encoding = (encoding + \"\").toLowerCase();\n              loweredCase = true;\n          }\n        }\n      }\n      Buffer2.prototype._isBuffer = true;\n      function swap(b, n, m) {\n        const i = b[n];\n        b[n] = b[m];\n        b[m] = i;\n      }\n      Buffer2.prototype.swap16 = function swap16() {\n        const len = this.length;\n        if (len % 2 !== 0) {\n          throw new RangeError(\"Buffer size must be a multiple of 16-bits\");\n        }\n        for (let i = 0; i < len; i += 2) {\n          swap(this, i, i + 1);\n        }\n        return this;\n      };\n      Buffer2.prototype.swap32 = function swap32() {\n        const len = this.length;\n        if (len % 4 !== 0) {\n          throw new RangeError(\"Buffer size must be a multiple of 32-bits\");\n        }\n        for (let i = 0; i < len; i += 4) {\n          swap(this, i, i + 3);\n          swap(this, i + 1, i + 2);\n        }\n        return this;\n      };\n      Buffer2.prototype.swap64 = function swap64() {\n        const len = this.length;\n        if (len % 8 !== 0) {\n          throw new RangeError(\"Buffer size must be a multiple of 64-bits\");\n        }\n        for (let i = 0; i < len; i += 8) {\n          swap(this, i, i + 7);\n          swap(this, i + 1, i + 6);\n          swap(this, i + 2, i + 5);\n          swap(this, i + 3, i + 4);\n        }\n        return this;\n      };\n      Buffer2.prototype.toString = function toString() {\n        const length = this.length;\n        if (length === 0)\n          return \"\";\n        if (arguments.length === 0)\n          return utf8Slice(this, 0, length);\n        return slowToString.apply(this, arguments);\n      };\n      Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;\n      Buffer2.prototype.equals = function equals(b) {\n        if (!Buffer2.isBuffer(b))\n          throw new TypeError(\"Argument must be a Buffer\");\n        if (this === b)\n          return true;\n        return Buffer2.compare(this, b) === 0;\n      };\n      Buffer2.prototype.inspect = function inspect() {\n        let str = \"\";\n        const max = exports.INSPECT_MAX_BYTES;\n        str = this.toString(\"hex\", 0, max).replace(/(.{2})/g, \"$1 \").trim();\n        if (this.length > max)\n          str += \" ... \";\n        return \"<Buffer \" + str + \">\";\n      };\n      if (customInspectSymbol) {\n        Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;\n      }\n      Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n        if (isInstance(target, GlobalUint8Array)) {\n          target = Buffer2.from(target, target.offset, target.byteLength);\n        }\n        if (!Buffer2.isBuffer(target)) {\n          throw new TypeError(\n            'The \"target\" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target\n          );\n        }\n        if (start === void 0) {\n          start = 0;\n        }\n        if (end === void 0) {\n          end = target ? target.length : 0;\n        }\n        if (thisStart === void 0) {\n          thisStart = 0;\n        }\n        if (thisEnd === void 0) {\n          thisEnd = this.length;\n        }\n        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n          throw new RangeError(\"out of range index\");\n        }\n        if (thisStart >= thisEnd && start >= end) {\n          return 0;\n        }\n        if (thisStart >= thisEnd) {\n          return -1;\n        }\n        if (start >= end) {\n          return 1;\n        }\n        start >>>= 0;\n        end >>>= 0;\n        thisStart >>>= 0;\n        thisEnd >>>= 0;\n        if (this === target)\n          return 0;\n        let x = thisEnd - thisStart;\n        let y = end - start;\n        const len = Math.min(x, y);\n        const thisCopy = this.slice(thisStart, thisEnd);\n        const targetCopy = target.slice(start, end);\n        for (let i = 0; i < len; ++i) {\n          if (thisCopy[i] !== targetCopy[i]) {\n            x = thisCopy[i];\n            y = targetCopy[i];\n            break;\n          }\n        }\n        if (x < y)\n          return -1;\n        if (y < x)\n          return 1;\n        return 0;\n      };\n      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n        if (buffer.length === 0)\n          return -1;\n        if (typeof byteOffset === \"string\") {\n          encoding = byteOffset;\n          byteOffset = 0;\n        } else if (byteOffset > 2147483647) {\n          byteOffset = 2147483647;\n        } else if (byteOffset < -2147483648) {\n          byteOffset = -2147483648;\n        }\n        byteOffset = +byteOffset;\n        if (numberIsNaN(byteOffset)) {\n          byteOffset = dir ? 0 : buffer.length - 1;\n        }\n        if (byteOffset < 0)\n          byteOffset = buffer.length + byteOffset;\n        if (byteOffset >= buffer.length) {\n          if (dir)\n            return -1;\n          else\n            byteOffset = buffer.length - 1;\n        } else if (byteOffset < 0) {\n          if (dir)\n            byteOffset = 0;\n          else\n            return -1;\n        }\n        if (typeof val === \"string\") {\n          val = Buffer2.from(val, encoding);\n        }\n        if (Buffer2.isBuffer(val)) {\n          if (val.length === 0) {\n            return -1;\n          }\n          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n        } else if (typeof val === \"number\") {\n          val = val & 255;\n          if (typeof GlobalUint8Array.prototype.indexOf === \"function\") {\n            if (dir) {\n              return GlobalUint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n            } else {\n              return GlobalUint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n            }\n          }\n          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);\n        }\n        throw new TypeError(\"val must be string, number or Buffer\");\n      }\n      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n        let indexSize = 1;\n        let arrLength = arr.length;\n        let valLength = val.length;\n        if (encoding !== void 0) {\n          encoding = String(encoding).toLowerCase();\n          if (encoding === \"ucs2\" || encoding === \"ucs-2\" || encoding === \"utf16le\" || encoding === \"utf-16le\") {\n            if (arr.length < 2 || val.length < 2) {\n              return -1;\n            }\n            indexSize = 2;\n            arrLength /= 2;\n            valLength /= 2;\n            byteOffset /= 2;\n          }\n        }\n        function read(buf, i2) {\n          if (indexSize === 1) {\n            return buf[i2];\n          } else {\n            return buf.readUInt16BE(i2 * indexSize);\n          }\n        }\n        let i;\n        if (dir) {\n          let foundIndex = -1;\n          for (i = byteOffset; i < arrLength; i++) {\n            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n              if (foundIndex === -1)\n                foundIndex = i;\n              if (i - foundIndex + 1 === valLength)\n                return foundIndex * indexSize;\n            } else {\n              if (foundIndex !== -1)\n                i -= i - foundIndex;\n              foundIndex = -1;\n            }\n          }\n        } else {\n          if (byteOffset + valLength > arrLength)\n            byteOffset = arrLength - valLength;\n          for (i = byteOffset; i >= 0; i--) {\n            let found = true;\n            for (let j = 0; j < valLength; j++) {\n              if (read(arr, i + j) !== read(val, j)) {\n                found = false;\n                break;\n              }\n            }\n            if (found)\n              return i;\n          }\n        }\n        return -1;\n      }\n      Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {\n        return this.indexOf(val, byteOffset, encoding) !== -1;\n      };\n      Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n      };\n      Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n      };\n      function hexWrite(buf, string, offset, length) {\n        offset = Number(offset) || 0;\n        const remaining = buf.length - offset;\n        if (!length) {\n          length = remaining;\n        } else {\n          length = Number(length);\n          if (length > remaining) {\n            length = remaining;\n          }\n        }\n        const strLen = string.length;\n        if (length > strLen / 2) {\n          length = strLen / 2;\n        }\n        let i;\n        for (i = 0; i < length; ++i) {\n          const parsed = parseInt(string.substr(i * 2, 2), 16);\n          if (numberIsNaN(parsed))\n            return i;\n          buf[offset + i] = parsed;\n        }\n        return i;\n      }\n      function utf8Write(buf, string, offset, length) {\n        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n      }\n      function asciiWrite(buf, string, offset, length) {\n        return blitBuffer(asciiToBytes(string), buf, offset, length);\n      }\n      function base64Write(buf, string, offset, length) {\n        return blitBuffer(base64ToBytes(string), buf, offset, length);\n      }\n      function ucs2Write(buf, string, offset, length) {\n        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n      }\n      Buffer2.prototype.write = function write(string, offset, length, encoding) {\n        if (offset === void 0) {\n          encoding = \"utf8\";\n          length = this.length;\n          offset = 0;\n        } else if (length === void 0 && typeof offset === \"string\") {\n          encoding = offset;\n          length = this.length;\n          offset = 0;\n        } else if (isFinite(offset)) {\n          offset = offset >>> 0;\n          if (isFinite(length)) {\n            length = length >>> 0;\n            if (encoding === void 0)\n              encoding = \"utf8\";\n          } else {\n            encoding = length;\n            length = void 0;\n          }\n        } else {\n          throw new Error(\n            \"Buffer.write(string, encoding, offset[, length]) is no longer supported\"\n          );\n        }\n        const remaining = this.length - offset;\n        if (length === void 0 || length > remaining)\n          length = remaining;\n        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n          throw new RangeError(\"Attempt to write outside buffer bounds\");\n        }\n        if (!encoding)\n          encoding = \"utf8\";\n        let loweredCase = false;\n        for (; ; ) {\n          switch (encoding) {\n            case \"hex\":\n              return hexWrite(this, string, offset, length);\n            case \"utf8\":\n            case \"utf-8\":\n              return utf8Write(this, string, offset, length);\n            case \"ascii\":\n            case \"latin1\":\n            case \"binary\":\n              return asciiWrite(this, string, offset, length);\n            case \"base64\":\n              return base64Write(this, string, offset, length);\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n              return ucs2Write(this, string, offset, length);\n            default:\n              if (loweredCase)\n                throw new TypeError(\"Unknown encoding: \" + encoding);\n              encoding = (\"\" + encoding).toLowerCase();\n              loweredCase = true;\n          }\n        }\n      };\n      Buffer2.prototype.toJSON = function toJSON() {\n        return {\n          type: \"Buffer\",\n          data: Array.prototype.slice.call(this._arr || this, 0)\n        };\n      };\n      function base64Slice(buf, start, end) {\n        if (start === 0 && end === buf.length) {\n          return base64.fromByteArray(buf);\n        } else {\n          return base64.fromByteArray(buf.slice(start, end));\n        }\n      }\n      function utf8Slice(buf, start, end) {\n        end = Math.min(buf.length, end);\n        const res = [];\n        let i = start;\n        while (i < end) {\n          const firstByte = buf[i];\n          let codePoint = null;\n          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;\n          if (i + bytesPerSequence <= end) {\n            let secondByte, thirdByte, fourthByte, tempCodePoint;\n            switch (bytesPerSequence) {\n              case 1:\n                if (firstByte < 128) {\n                  codePoint = firstByte;\n                }\n                break;\n              case 2:\n                secondByte = buf[i + 1];\n                if ((secondByte & 192) === 128) {\n                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;\n                  if (tempCodePoint > 127) {\n                    codePoint = tempCodePoint;\n                  }\n                }\n                break;\n              case 3:\n                secondByte = buf[i + 1];\n                thirdByte = buf[i + 2];\n                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {\n                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;\n                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {\n                    codePoint = tempCodePoint;\n                  }\n                }\n                break;\n              case 4:\n                secondByte = buf[i + 1];\n                thirdByte = buf[i + 2];\n                fourthByte = buf[i + 3];\n                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {\n                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;\n                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {\n                    codePoint = tempCodePoint;\n                  }\n                }\n            }\n          }\n          if (codePoint === null) {\n            codePoint = 65533;\n            bytesPerSequence = 1;\n          } else if (codePoint > 65535) {\n            codePoint -= 65536;\n            res.push(codePoint >>> 10 & 1023 | 55296);\n            codePoint = 56320 | codePoint & 1023;\n          }\n          res.push(codePoint);\n          i += bytesPerSequence;\n        }\n        return decodeCodePointsArray(res);\n      }\n      var MAX_ARGUMENTS_LENGTH = 4096;\n      function decodeCodePointsArray(codePoints) {\n        const len = codePoints.length;\n        if (len <= MAX_ARGUMENTS_LENGTH) {\n          return String.fromCharCode.apply(String, codePoints);\n        }\n        let res = \"\";\n        let i = 0;\n        while (i < len) {\n          res += String.fromCharCode.apply(\n            String,\n            codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n          );\n        }\n        return res;\n      }\n      function asciiSlice(buf, start, end) {\n        let ret = \"\";\n        end = Math.min(buf.length, end);\n        for (let i = start; i < end; ++i) {\n          ret += String.fromCharCode(buf[i] & 127);\n        }\n        return ret;\n      }\n      function latin1Slice(buf, start, end) {\n        let ret = \"\";\n        end = Math.min(buf.length, end);\n        for (let i = start; i < end; ++i) {\n          ret += String.fromCharCode(buf[i]);\n        }\n        return ret;\n      }\n      function hexSlice(buf, start, end) {\n        const len = buf.length;\n        if (!start || start < 0)\n          start = 0;\n        if (!end || end < 0 || end > len)\n          end = len;\n        let out = \"\";\n        for (let i = start; i < end; ++i) {\n          out += hexSliceLookupTable[buf[i]];\n        }\n        return out;\n      }\n      function utf16leSlice(buf, start, end) {\n        const bytes = buf.slice(start, end);\n        let res = \"\";\n        for (let i = 0; i < bytes.length - 1; i += 2) {\n          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n        }\n        return res;\n      }\n      Buffer2.prototype.slice = function slice(start, end) {\n        const len = this.length;\n        start = ~~start;\n        end = end === void 0 ? len : ~~end;\n        if (start < 0) {\n          start += len;\n          if (start < 0)\n            start = 0;\n        } else if (start > len) {\n          start = len;\n        }\n        if (end < 0) {\n          end += len;\n          if (end < 0)\n            end = 0;\n        } else if (end > len) {\n          end = len;\n        }\n        if (end < start)\n          end = start;\n        const newBuf = this.subarray(start, end);\n        Object.setPrototypeOf(newBuf, Buffer2.prototype);\n        return newBuf;\n      };\n      function checkOffset(offset, ext, length) {\n        if (offset % 1 !== 0 || offset < 0)\n          throw new RangeError(\"offset is not uint\");\n        if (offset + ext > length)\n          throw new RangeError(\"Trying to access beyond buffer length\");\n      }\n      Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert)\n          checkOffset(offset, byteLength2, this.length);\n        let val = this[offset];\n        let mul = 1;\n        let i = 0;\n        while (++i < byteLength2 && (mul *= 256)) {\n          val += this[offset + i] * mul;\n        }\n        return val;\n      };\n      Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert) {\n          checkOffset(offset, byteLength2, this.length);\n        }\n        let val = this[offset + --byteLength2];\n        let mul = 1;\n        while (byteLength2 > 0 && (mul *= 256)) {\n          val += this[offset + --byteLength2] * mul;\n        }\n        return val;\n      };\n      Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 1, this.length);\n        return this[offset];\n      };\n      Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 2, this.length);\n        return this[offset] | this[offset + 1] << 8;\n      };\n      Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 2, this.length);\n        return this[offset] << 8 | this[offset + 1];\n      };\n      Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;\n      };\n      Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n      };\n      Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {\n        offset = offset >>> 0;\n        validateNumber(offset, \"offset\");\n        const first = this[offset];\n        const last = this[offset + 7];\n        if (first === void 0 || last === void 0) {\n          boundsError(offset, this.length - 8);\n        }\n        const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;\n        const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;\n        return BigInt(lo) + (BigInt(hi) << BigInt(32));\n      });\n      Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {\n        offset = offset >>> 0;\n        validateNumber(offset, \"offset\");\n        const first = this[offset];\n        const last = this[offset + 7];\n        if (first === void 0 || last === void 0) {\n          boundsError(offset, this.length - 8);\n        }\n        const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];\n        const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;\n        return (BigInt(hi) << BigInt(32)) + BigInt(lo);\n      });\n      Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert)\n          checkOffset(offset, byteLength2, this.length);\n        let val = this[offset];\n        let mul = 1;\n        let i = 0;\n        while (++i < byteLength2 && (mul *= 256)) {\n          val += this[offset + i] * mul;\n        }\n        mul *= 128;\n        if (val >= mul)\n          val -= Math.pow(2, 8 * byteLength2);\n        return val;\n      };\n      Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert)\n          checkOffset(offset, byteLength2, this.length);\n        let i = byteLength2;\n        let mul = 1;\n        let val = this[offset + --i];\n        while (i > 0 && (mul *= 256)) {\n          val += this[offset + --i] * mul;\n        }\n        mul *= 128;\n        if (val >= mul)\n          val -= Math.pow(2, 8 * byteLength2);\n        return val;\n      };\n      Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 1, this.length);\n        if (!(this[offset] & 128))\n          return this[offset];\n        return (255 - this[offset] + 1) * -1;\n      };\n      Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 2, this.length);\n        const val = this[offset] | this[offset + 1] << 8;\n        return val & 32768 ? val | 4294901760 : val;\n      };\n      Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 2, this.length);\n        const val = this[offset + 1] | this[offset] << 8;\n        return val & 32768 ? val | 4294901760 : val;\n      };\n      Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n      };\n      Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n      };\n      Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {\n        offset = offset >>> 0;\n        validateNumber(offset, \"offset\");\n        const first = this[offset];\n        const last = this[offset + 7];\n        if (first === void 0 || last === void 0) {\n          boundsError(offset, this.length - 8);\n        }\n        const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);\n        return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);\n      });\n      Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {\n        offset = offset >>> 0;\n        validateNumber(offset, \"offset\");\n        const first = this[offset];\n        const last = this[offset + 7];\n        if (first === void 0 || last === void 0) {\n          boundsError(offset, this.length - 8);\n        }\n        const val = (first << 24) + // Overflow\n        this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];\n        return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);\n      });\n      Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return ieee754.read(this, offset, true, 23, 4);\n      };\n      Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return ieee754.read(this, offset, false, 23, 4);\n      };\n      Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 8, this.length);\n        return ieee754.read(this, offset, true, 52, 8);\n      };\n      Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 8, this.length);\n        return ieee754.read(this, offset, false, 52, 8);\n      };\n      function checkInt(buf, value, offset, ext, max, min) {\n        if (!Buffer2.isBuffer(buf))\n          throw new TypeError('\"buffer\" argument must be a Buffer instance');\n        if (value > max || value < min)\n          throw new RangeError('\"value\" argument is out of bounds');\n        if (offset + ext > buf.length)\n          throw new RangeError(\"Index out of range\");\n      }\n      Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert) {\n          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;\n          checkInt(this, value, offset, byteLength2, maxBytes, 0);\n        }\n        let mul = 1;\n        let i = 0;\n        this[offset] = value & 255;\n        while (++i < byteLength2 && (mul *= 256)) {\n          this[offset + i] = value / mul & 255;\n        }\n        return offset + byteLength2;\n      };\n      Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert) {\n          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;\n          checkInt(this, value, offset, byteLength2, maxBytes, 0);\n        }\n        let i = byteLength2 - 1;\n        let mul = 1;\n        this[offset + i] = value & 255;\n        while (--i >= 0 && (mul *= 256)) {\n          this[offset + i] = value / mul & 255;\n        }\n        return offset + byteLength2;\n      };\n      Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 1, 255, 0);\n        this[offset] = value & 255;\n        return offset + 1;\n      };\n      Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 2, 65535, 0);\n        this[offset] = value & 255;\n        this[offset + 1] = value >>> 8;\n        return offset + 2;\n      };\n      Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 2, 65535, 0);\n        this[offset] = value >>> 8;\n        this[offset + 1] = value & 255;\n        return offset + 2;\n      };\n      Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 4, 4294967295, 0);\n        this[offset + 3] = value >>> 24;\n        this[offset + 2] = value >>> 16;\n        this[offset + 1] = value >>> 8;\n        this[offset] = value & 255;\n        return offset + 4;\n      };\n      Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 4, 4294967295, 0);\n        this[offset] = value >>> 24;\n        this[offset + 1] = value >>> 16;\n        this[offset + 2] = value >>> 8;\n        this[offset + 3] = value & 255;\n        return offset + 4;\n      };\n      function wrtBigUInt64LE(buf, value, offset, min, max) {\n        checkIntBI(value, min, max, buf, offset, 7);\n        let lo = Number(value & BigInt(4294967295));\n        buf[offset++] = lo;\n        lo = lo >> 8;\n        buf[offset++] = lo;\n        lo = lo >> 8;\n        buf[offset++] = lo;\n        lo = lo >> 8;\n        buf[offset++] = lo;\n        let hi = Number(value >> BigInt(32) & BigInt(4294967295));\n        buf[offset++] = hi;\n        hi = hi >> 8;\n        buf[offset++] = hi;\n        hi = hi >> 8;\n        buf[offset++] = hi;\n        hi = hi >> 8;\n        buf[offset++] = hi;\n        return offset;\n      }\n      function wrtBigUInt64BE(buf, value, offset, min, max) {\n        checkIntBI(value, min, max, buf, offset, 7);\n        let lo = Number(value & BigInt(4294967295));\n        buf[offset + 7] = lo;\n        lo = lo >> 8;\n        buf[offset + 6] = lo;\n        lo = lo >> 8;\n        buf[offset + 5] = lo;\n        lo = lo >> 8;\n        buf[offset + 4] = lo;\n        let hi = Number(value >> BigInt(32) & BigInt(4294967295));\n        buf[offset + 3] = hi;\n        hi = hi >> 8;\n        buf[offset + 2] = hi;\n        hi = hi >> 8;\n        buf[offset + 1] = hi;\n        hi = hi >> 8;\n        buf[offset] = hi;\n        return offset + 8;\n      }\n      Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {\n        return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n      });\n      Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {\n        return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n      });\n      Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          const limit = Math.pow(2, 8 * byteLength2 - 1);\n          checkInt(this, value, offset, byteLength2, limit - 1, -limit);\n        }\n        let i = 0;\n        let mul = 1;\n        let sub = 0;\n        this[offset] = value & 255;\n        while (++i < byteLength2 && (mul *= 256)) {\n          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n            sub = 1;\n          }\n          this[offset + i] = (value / mul >> 0) - sub & 255;\n        }\n        return offset + byteLength2;\n      };\n      Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          const limit = Math.pow(2, 8 * byteLength2 - 1);\n          checkInt(this, value, offset, byteLength2, limit - 1, -limit);\n        }\n        let i = byteLength2 - 1;\n        let mul = 1;\n        let sub = 0;\n        this[offset + i] = value & 255;\n        while (--i >= 0 && (mul *= 256)) {\n          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n            sub = 1;\n          }\n          this[offset + i] = (value / mul >> 0) - sub & 255;\n        }\n        return offset + byteLength2;\n      };\n      Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 1, 127, -128);\n        if (value < 0)\n          value = 255 + value + 1;\n        this[offset] = value & 255;\n        return offset + 1;\n      };\n      Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 2, 32767, -32768);\n        this[offset] = value & 255;\n        this[offset + 1] = value >>> 8;\n        return offset + 2;\n      };\n      Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 2, 32767, -32768);\n        this[offset] = value >>> 8;\n        this[offset + 1] = value & 255;\n        return offset + 2;\n      };\n      Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 4, 2147483647, -2147483648);\n        this[offset] = value & 255;\n        this[offset + 1] = value >>> 8;\n        this[offset + 2] = value >>> 16;\n        this[offset + 3] = value >>> 24;\n        return offset + 4;\n      };\n      Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 4, 2147483647, -2147483648);\n        if (value < 0)\n          value = 4294967295 + value + 1;\n        this[offset] = value >>> 24;\n        this[offset + 1] = value >>> 16;\n        this[offset + 2] = value >>> 8;\n        this[offset + 3] = value & 255;\n        return offset + 4;\n      };\n      Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {\n        return wrtBigUInt64LE(this, value, offset, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n      });\n      Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {\n        return wrtBigUInt64BE(this, value, offset, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n      });\n      function checkIEEE754(buf, value, offset, ext, max, min) {\n        if (offset + ext > buf.length)\n          throw new RangeError(\"Index out of range\");\n        if (offset < 0)\n          throw new RangeError(\"Index out of range\");\n      }\n      function writeFloat(buf, value, offset, littleEndian, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);\n        }\n        ieee754.write(buf, value, offset, littleEndian, 23, 4);\n        return offset + 4;\n      }\n      Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n        return writeFloat(this, value, offset, true, noAssert);\n      };\n      Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n        return writeFloat(this, value, offset, false, noAssert);\n      };\n      function writeDouble(buf, value, offset, littleEndian, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);\n        }\n        ieee754.write(buf, value, offset, littleEndian, 52, 8);\n        return offset + 8;\n      }\n      Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n        return writeDouble(this, value, offset, true, noAssert);\n      };\n      Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n        return writeDouble(this, value, offset, false, noAssert);\n      };\n      Buffer2.prototype.copy = function copy(target, targetStart, start, end) {\n        if (!Buffer2.isBuffer(target))\n          throw new TypeError(\"argument should be a Buffer\");\n        if (!start)\n          start = 0;\n        if (!end && end !== 0)\n          end = this.length;\n        if (targetStart >= target.length)\n          targetStart = target.length;\n        if (!targetStart)\n          targetStart = 0;\n        if (end > 0 && end < start)\n          end = start;\n        if (end === start)\n          return 0;\n        if (target.length === 0 || this.length === 0)\n          return 0;\n        if (targetStart < 0) {\n          throw new RangeError(\"targetStart out of bounds\");\n        }\n        if (start < 0 || start >= this.length)\n          throw new RangeError(\"Index out of range\");\n        if (end < 0)\n          throw new RangeError(\"sourceEnd out of bounds\");\n        if (end > this.length)\n          end = this.length;\n        if (target.length - targetStart < end - start) {\n          end = target.length - targetStart + start;\n        }\n        const len = end - start;\n        if (this === target && typeof GlobalUint8Array.prototype.copyWithin === \"function\") {\n          this.copyWithin(targetStart, start, end);\n        } else {\n          GlobalUint8Array.prototype.set.call(\n            target,\n            this.subarray(start, end),\n            targetStart\n          );\n        }\n        return len;\n      };\n      Buffer2.prototype.fill = function fill(val, start, end, encoding) {\n        if (typeof val === \"string\") {\n          if (typeof start === \"string\") {\n            encoding = start;\n            start = 0;\n            end = this.length;\n          } else if (typeof end === \"string\") {\n            encoding = end;\n            end = this.length;\n          }\n          if (encoding !== void 0 && typeof encoding !== \"string\") {\n            throw new TypeError(\"encoding must be a string\");\n          }\n          if (typeof encoding === \"string\" && !Buffer2.isEncoding(encoding)) {\n            throw new TypeError(\"Unknown encoding: \" + encoding);\n          }\n          if (val.length === 1) {\n            const code = val.charCodeAt(0);\n            if (encoding === \"utf8\" && code < 128 || encoding === \"latin1\") {\n              val = code;\n            }\n          }\n        } else if (typeof val === \"number\") {\n          val = val & 255;\n        } else if (typeof val === \"boolean\") {\n          val = Number(val);\n        }\n        if (start < 0 || this.length < start || this.length < end) {\n          throw new RangeError(\"Out of range index\");\n        }\n        if (end <= start) {\n          return this;\n        }\n        start = start >>> 0;\n        end = end === void 0 ? this.length : end >>> 0;\n        if (!val)\n          val = 0;\n        let i;\n        if (typeof val === \"number\") {\n          for (i = start; i < end; ++i) {\n            this[i] = val;\n          }\n        } else {\n          const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);\n          const len = bytes.length;\n          if (len === 0) {\n            throw new TypeError('The value \"' + val + '\" is invalid for argument \"value\"');\n          }\n          for (i = 0; i < end - start; ++i) {\n            this[i + start] = bytes[i % len];\n          }\n        }\n        return this;\n      };\n      var errors = {};\n      function E(sym, getMessage, Base) {\n        errors[sym] = class NodeError extends Base {\n          constructor() {\n            super();\n            Object.defineProperty(this, \"message\", {\n              value: getMessage.apply(this, arguments),\n              writable: true,\n              configurable: true\n            });\n            this.name = `${this.name} [${sym}]`;\n            this.stack;\n            delete this.name;\n          }\n          get code() {\n            return sym;\n          }\n          set code(value) {\n            Object.defineProperty(this, \"code\", {\n              configurable: true,\n              enumerable: true,\n              value,\n              writable: true\n            });\n          }\n          toString() {\n            return `${this.name} [${sym}]: ${this.message}`;\n          }\n        };\n      }\n      E(\n        \"ERR_BUFFER_OUT_OF_BOUNDS\",\n        function(name) {\n          if (name) {\n            return `${name} is outside of buffer bounds`;\n          }\n          return \"Attempt to access memory outside buffer bounds\";\n        },\n        RangeError\n      );\n      E(\n        \"ERR_INVALID_ARG_TYPE\",\n        function(name, actual) {\n          return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`;\n        },\n        TypeError\n      );\n      E(\n        \"ERR_OUT_OF_RANGE\",\n        function(str, range, input) {\n          let msg = `The value of \"${str}\" is out of range.`;\n          let received = input;\n          if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n            received = addNumericalSeparator(String(input));\n          } else if (typeof input === \"bigint\") {\n            received = String(input);\n            if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n              received = addNumericalSeparator(received);\n            }\n            received += \"n\";\n          }\n          msg += ` It must be ${range}. Received ${received}`;\n          return msg;\n        },\n        RangeError\n      );\n      function addNumericalSeparator(val) {\n        let res = \"\";\n        let i = val.length;\n        const start = val[0] === \"-\" ? 1 : 0;\n        for (; i >= start + 4; i -= 3) {\n          res = `_${val.slice(i - 3, i)}${res}`;\n        }\n        return `${val.slice(0, i)}${res}`;\n      }\n      function checkBounds(buf, offset, byteLength2) {\n        validateNumber(offset, \"offset\");\n        if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {\n          boundsError(offset, buf.length - (byteLength2 + 1));\n        }\n      }\n      function checkIntBI(value, min, max, buf, offset, byteLength2) {\n        if (value > max || value < min) {\n          const n = typeof min === \"bigint\" ? \"n\" : \"\";\n          let range;\n          if (byteLength2 > 3) {\n            if (min === 0 || min === BigInt(0)) {\n              range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;\n            } else {\n              range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;\n            }\n          } else {\n            range = `>= ${min}${n} and <= ${max}${n}`;\n          }\n          throw new errors.ERR_OUT_OF_RANGE(\"value\", range, value);\n        }\n        checkBounds(buf, offset, byteLength2);\n      }\n      function validateNumber(value, name) {\n        if (typeof value !== \"number\") {\n          throw new errors.ERR_INVALID_ARG_TYPE(name, \"number\", value);\n        }\n      }\n      function boundsError(value, length, type) {\n        if (Math.floor(value) !== value) {\n          validateNumber(value, type);\n          throw new errors.ERR_OUT_OF_RANGE(type || \"offset\", \"an integer\", value);\n        }\n        if (length < 0) {\n          throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();\n        }\n        throw new errors.ERR_OUT_OF_RANGE(\n          type || \"offset\",\n          `>= ${type ? 1 : 0} and <= ${length}`,\n          value\n        );\n      }\n      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;\n      function base64clean(str) {\n        str = str.split(\"=\")[0];\n        str = str.trim().replace(INVALID_BASE64_RE, \"\");\n        if (str.length < 2)\n          return \"\";\n        while (str.length % 4 !== 0) {\n          str = str + \"=\";\n        }\n        return str;\n      }\n      function utf8ToBytes(string, units) {\n        units = units || Infinity;\n        let codePoint;\n        const length = string.length;\n        let leadSurrogate = null;\n        const bytes = [];\n        for (let i = 0; i < length; ++i) {\n          codePoint = string.charCodeAt(i);\n          if (codePoint > 55295 && codePoint < 57344) {\n            if (!leadSurrogate) {\n              if (codePoint > 56319) {\n                if ((units -= 3) > -1)\n                  bytes.push(239, 191, 189);\n                continue;\n              } else if (i + 1 === length) {\n                if ((units -= 3) > -1)\n                  bytes.push(239, 191, 189);\n                continue;\n              }\n              leadSurrogate = codePoint;\n              continue;\n            }\n            if (codePoint < 56320) {\n              if ((units -= 3) > -1)\n                bytes.push(239, 191, 189);\n              leadSurrogate = codePoint;\n              continue;\n            }\n            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;\n          } else if (leadSurrogate) {\n            if ((units -= 3) > -1)\n              bytes.push(239, 191, 189);\n          }\n          leadSurrogate = null;\n          if (codePoint < 128) {\n            if ((units -= 1) < 0)\n              break;\n            bytes.push(codePoint);\n          } else if (codePoint < 2048) {\n            if ((units -= 2) < 0)\n              break;\n            bytes.push(\n              codePoint >> 6 | 192,\n              codePoint & 63 | 128\n            );\n          } else if (codePoint < 65536) {\n            if ((units -= 3) < 0)\n              break;\n            bytes.push(\n              codePoint >> 12 | 224,\n              codePoint >> 6 & 63 | 128,\n              codePoint & 63 | 128\n            );\n          } else if (codePoint < 1114112) {\n            if ((units -= 4) < 0)\n              break;\n            bytes.push(\n              codePoint >> 18 | 240,\n              codePoint >> 12 & 63 | 128,\n              codePoint >> 6 & 63 | 128,\n              codePoint & 63 | 128\n            );\n          } else {\n            throw new Error(\"Invalid code point\");\n          }\n        }\n        return bytes;\n      }\n      function asciiToBytes(str) {\n        const byteArray = [];\n        for (let i = 0; i < str.length; ++i) {\n          byteArray.push(str.charCodeAt(i) & 255);\n        }\n        return byteArray;\n      }\n      function utf16leToBytes(str, units) {\n        let c, hi, lo;\n        const byteArray = [];\n        for (let i = 0; i < str.length; ++i) {\n          if ((units -= 2) < 0)\n            break;\n          c = str.charCodeAt(i);\n          hi = c >> 8;\n          lo = c % 256;\n          byteArray.push(lo);\n          byteArray.push(hi);\n        }\n        return byteArray;\n      }\n      function base64ToBytes(str) {\n        return base64.toByteArray(base64clean(str));\n      }\n      function blitBuffer(src, dst, offset, length) {\n        let i;\n        for (i = 0; i < length; ++i) {\n          if (i + offset >= dst.length || i >= src.length)\n            break;\n          dst[i + offset] = src[i];\n        }\n        return i;\n      }\n      function isInstance(obj, type) {\n        return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;\n      }\n      function numberIsNaN(obj) {\n        return obj !== obj;\n      }\n      var hexSliceLookupTable = function() {\n        const alphabet = \"0123456789abcdef\";\n        const table = new Array(256);\n        for (let i = 0; i < 16; ++i) {\n          const i16 = i * 16;\n          for (let j = 0; j < 16; ++j) {\n            table[i16 + j] = alphabet[i] + alphabet[j];\n          }\n        }\n        return table;\n      }();\n      function defineBigIntMethod(fn) {\n        return typeof BigInt === \"undefined\" ? BufferBigIntNotDefined : fn;\n      }\n      function BufferBigIntNotDefined() {\n        throw new Error(\"BigInt not supported\");\n      }\n    }\n  });\n\n  // node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js\n  var require_browser = __commonJS({\n    \"node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js\"(exports, module) {\n      init_dist();\n      var process = module.exports = {};\n      var cachedSetTimeout;\n      var cachedClearTimeout;\n      function defaultSetTimout() {\n        throw new Error(\"setTimeout has not been defined\");\n      }\n      function defaultClearTimeout() {\n        throw new Error(\"clearTimeout has not been defined\");\n      }\n      (function() {\n        try {\n          if (typeof setTimeout === \"function\") {\n            cachedSetTimeout = setTimeout;\n          } else {\n            cachedSetTimeout = defaultSetTimout;\n          }\n        } catch (e) {\n          cachedSetTimeout = defaultSetTimout;\n        }\n        try {\n          if (typeof clearTimeout === \"function\") {\n            cachedClearTimeout = clearTimeout;\n          } else {\n            cachedClearTimeout = defaultClearTimeout;\n          }\n        } catch (e) {\n          cachedClearTimeout = defaultClearTimeout;\n        }\n      })();\n      function runTimeout(fun) {\n        if (cachedSetTimeout === setTimeout) {\n          return setTimeout(fun, 0);\n        }\n        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n          cachedSetTimeout = setTimeout;\n          return setTimeout(fun, 0);\n        }\n        try {\n          return cachedSetTimeout(fun, 0);\n        } catch (e) {\n          try {\n            return cachedSetTimeout.call(null, fun, 0);\n          } catch (e2) {\n            return cachedSetTimeout.call(this, fun, 0);\n          }\n        }\n      }\n      function runClearTimeout(marker) {\n        if (cachedClearTimeout === clearTimeout) {\n          return clearTimeout(marker);\n        }\n        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n          cachedClearTimeout = clearTimeout;\n          return clearTimeout(marker);\n        }\n        try {\n          return cachedClearTimeout(marker);\n        } catch (e) {\n          try {\n            return cachedClearTimeout.call(null, marker);\n          } catch (e2) {\n            return cachedClearTimeout.call(this, marker);\n          }\n        }\n      }\n      var queue = [];\n      var draining = false;\n      var currentQueue;\n      var queueIndex = -1;\n      function cleanUpNextTick() {\n        if (!draining || !currentQueue) {\n          return;\n        }\n        draining = false;\n        if (currentQueue.length) {\n          queue = currentQueue.concat(queue);\n        } else {\n          queueIndex = -1;\n        }\n        if (queue.length) {\n          drainQueue();\n        }\n      }\n      function drainQueue() {\n        if (draining) {\n          return;\n        }\n        var timeout = runTimeout(cleanUpNextTick);\n        draining = true;\n        var len = queue.length;\n        while (len) {\n          currentQueue = queue;\n          queue = [];\n          while (++queueIndex < len) {\n            if (currentQueue) {\n              currentQueue[queueIndex].run();\n            }\n          }\n          queueIndex = -1;\n          len = queue.length;\n        }\n        currentQueue = null;\n        draining = false;\n        runClearTimeout(timeout);\n      }\n      process.nextTick = function(fun) {\n        var args = new Array(arguments.length - 1);\n        if (arguments.length > 1) {\n          for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n          }\n        }\n        queue.push(new Item(fun, args));\n        if (queue.length === 1 && !draining) {\n          runTimeout(drainQueue);\n        }\n      };\n      function Item(fun, array) {\n        this.fun = fun;\n        this.array = array;\n      }\n      Item.prototype.run = function() {\n        this.fun.apply(null, this.array);\n      };\n      process.title = \"browser\";\n      process.browser = true;\n      process.env = {};\n      process.argv = [];\n      process.version = \"\";\n      process.versions = {};\n      function noop() {\n      }\n      process.on = noop;\n      process.addListener = noop;\n      process.once = noop;\n      process.off = noop;\n      process.removeListener = noop;\n      process.removeAllListeners = noop;\n      process.emit = noop;\n      process.prependListener = noop;\n      process.prependOnceListener = noop;\n      process.listeners = function(name) {\n        return [];\n      };\n      process.binding = function(name) {\n        throw new Error(\"process.binding is not supported\");\n      };\n      process.cwd = function() {\n        return \"/\";\n      };\n      process.chdir = function(dir) {\n        throw new Error(\"process.chdir is not supported\");\n      };\n      process.umask = function() {\n        return 0;\n      };\n    }\n  });\n\n  // shims/dist/index.js\n  var import_buffer_polyfill, import_process, o;\n  var init_dist = __esm({\n    \"shims/dist/index.js\"() {\n      \"use strict\";\n      import_buffer_polyfill = __toESM(require_buffer(), 1);\n      import_process = __toESM(require_browser(), 1);\n      o = globalThis || void 0 || self;\n    }\n  });\n\n  // shims/banner/index.cjs\n  var require_banner = __commonJS({\n    \"shims/banner/index.cjs\"() {\n      init_dist();\n      globalThis.Buffer = globalThis.Buffer || import_buffer_polyfill.Buffer;\n      globalThis.global = globalThis.global || o;\n      globalThis.process = globalThis.process || import_process.default;\n    }\n  });\n  require_banner();\n})();\n/*! Bundled license information:\n\nieee754/index.js:\n  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)\n\nbuffer/index.js:\n  (*!\n   * The buffer module from node.js, for the browser.\n   *\n   * @author   Feross Aboukhadijeh <https://feross.org>\n   * @license  MIT\n   *)\n*/\n\nimport {\n  __commonJS,\n  __toESM,\n  require_dist\n} from \"/node_modules/.vite/deps/chunk-VMXIV7NB.js?v=733ce8d4\";\n\n// node_modules/highlight.js/lib/core.js\nvar require_core = __commonJS({\n  \"node_modules/highlight.js/lib/core.js\"(exports, module) {\n    var import_dist = __toESM(require_dist());\n    function deepFreeze(obj) {\n      if (obj instanceof Map) {\n        obj.clear = obj.delete = obj.set = function() {\n          throw new Error(\"map is read-only\");\n        };\n      } else if (obj instanceof Set) {\n        obj.add = obj.clear = obj.delete = function() {\n          throw new Error(\"set is read-only\");\n        };\n      }\n      Object.freeze(obj);\n      Object.getOwnPropertyNames(obj).forEach(function(name) {\n        var prop = obj[name];\n        if (typeof prop == \"object\" && !Object.isFrozen(prop)) {\n          deepFreeze(prop);\n        }\n      });\n      return obj;\n    }\n    var deepFreezeEs6 = deepFreeze;\n    var _default = deepFreeze;\n    deepFreezeEs6.default = _default;\n    var Response = class {\n      /**\n       * @param {CompiledMode} mode\n       */\n      constructor(mode) {\n        if (mode.data === void 0)\n          mode.data = {};\n        this.data = mode.data;\n        this.isMatchIgnored = false;\n      }\n      ignoreMatch() {\n        this.isMatchIgnored = true;\n      }\n    };\n    function escapeHTML(value) {\n      return value.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\").replace(/\"/g, \"&quot;\").replace(/'/g, \"&#x27;\");\n    }\n    function inherit(original, ...objects) {\n      const result = /* @__PURE__ */ Object.create(null);\n      for (const key in original) {\n        result[key] = original[key];\n      }\n      objects.forEach(function(obj) {\n        for (const key in obj) {\n          result[key] = obj[key];\n        }\n      });\n      return (\n        /** @type {T} */\n        result\n      );\n    }\n    var SPAN_CLOSE = \"</span>\";\n    var emitsWrappingTags = (node) => {\n      return !!node.kind;\n    };\n    var HTMLRenderer = class {\n      /**\n       * Creates a new HTMLRenderer\n       *\n       * @param {Tree} parseTree - the parse tree (must support `walk` API)\n       * @param {{classPrefix: string}} options\n       */\n      constructor(parseTree, options) {\n        this.buffer = \"\";\n        this.classPrefix = options.classPrefix;\n        parseTree.walk(this);\n      }\n      /**\n       * Adds texts to the output stream\n       *\n       * @param {string} text */\n      addText(text) {\n        this.buffer += escapeHTML(text);\n      }\n      /**\n       * Adds a node open to the output stream (if needed)\n       *\n       * @param {Node} node */\n      openNode(node) {\n        if (!emitsWrappingTags(node))\n          return;\n        let className = node.kind;\n        if (!node.sublanguage) {\n          className = `${this.classPrefix}${className}`;\n        }\n        this.span(className);\n      }\n      /**\n       * Adds a node close to the output stream (if needed)\n       *\n       * @param {Node} node */\n      closeNode(node) {\n        if (!emitsWrappingTags(node))\n          return;\n        this.buffer += SPAN_CLOSE;\n      }\n      /**\n       * returns the accumulated buffer\n      */\n      value() {\n        return this.buffer;\n      }\n      // helpers\n      /**\n       * Builds a span element\n       *\n       * @param {string} className */\n      span(className) {\n        this.buffer += `<span class=\"${className}\">`;\n      }\n    };\n    var TokenTree = class _TokenTree {\n      constructor() {\n        this.rootNode = { children: [] };\n        this.stack = [this.rootNode];\n      }\n      get top() {\n        return this.stack[this.stack.length - 1];\n      }\n      get root() {\n        return this.rootNode;\n      }\n      /** @param {Node} node */\n      add(node) {\n        this.top.children.push(node);\n      }\n      /** @param {string} kind */\n      openNode(kind) {\n        const node = { kind, children: [] };\n        this.add(node);\n        this.stack.push(node);\n      }\n      closeNode() {\n        if (this.stack.length > 1) {\n          return this.stack.pop();\n        }\n        return void 0;\n      }\n      closeAllNodes() {\n        while (this.closeNode())\n          ;\n      }\n      toJSON() {\n        return JSON.stringify(this.rootNode, null, 4);\n      }\n      /**\n       * @typedef { import(\"./html_renderer\").Renderer } Renderer\n       * @param {Renderer} builder\n       */\n      walk(builder) {\n        return this.constructor._walk(builder, this.rootNode);\n      }\n      /**\n       * @param {Renderer} builder\n       * @param {Node} node\n       */\n      static _walk(builder, node) {\n        if (typeof node === \"string\") {\n          builder.addText(node);\n        } else if (node.children) {\n          builder.openNode(node);\n          node.children.forEach((child) => this._walk(builder, child));\n          builder.closeNode(node);\n        }\n        return builder;\n      }\n      /**\n       * @param {Node} node\n       */\n      static _collapse(node) {\n        if (typeof node === \"string\")\n          return;\n        if (!node.children)\n          return;\n        if (node.children.every((el) => typeof el === \"string\")) {\n          node.children = [node.children.join(\"\")];\n        } else {\n          node.children.forEach((child) => {\n            _TokenTree._collapse(child);\n          });\n        }\n      }\n    };\n    var TokenTreeEmitter = class extends TokenTree {\n      /**\n       * @param {*} options\n       */\n      constructor(options) {\n        super();\n        this.options = options;\n      }\n      /**\n       * @param {string} text\n       * @param {string} kind\n       */\n      addKeyword(text, kind) {\n        if (text === \"\") {\n          return;\n        }\n        this.openNode(kind);\n        this.addText(text);\n        this.closeNode();\n      }\n      /**\n       * @param {string} text\n       */\n      addText(text) {\n        if (text === \"\") {\n          return;\n        }\n        this.add(text);\n      }\n      /**\n       * @param {Emitter & {root: DataNode}} emitter\n       * @param {string} name\n       */\n      addSublanguage(emitter, name) {\n        const node = emitter.root;\n        node.kind = name;\n        node.sublanguage = true;\n        this.add(node);\n      }\n      toHTML() {\n        const renderer = new HTMLRenderer(this, this.options);\n        return renderer.value();\n      }\n      finalize() {\n        return true;\n      }\n    };\n    function escape(value) {\n      return new RegExp(value.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\"), \"m\");\n    }\n    function source(re) {\n      if (!re)\n        return null;\n      if (typeof re === \"string\")\n        return re;\n      return re.source;\n    }\n    function concat(...args) {\n      const joined = args.map((x) => source(x)).join(\"\");\n      return joined;\n    }\n    function either(...args) {\n      const joined = \"(\" + args.map((x) => source(x)).join(\"|\") + \")\";\n      return joined;\n    }\n    function countMatchGroups(re) {\n      return new RegExp(re.toString() + \"|\").exec(\"\").length - 1;\n    }\n    function startsWith(re, lexeme) {\n      const match = re && re.exec(lexeme);\n      return match && match.index === 0;\n    }\n    var BACKREF_RE = /\\[(?:[^\\\\\\]]|\\\\.)*\\]|\\(\\??|\\\\([1-9][0-9]*)|\\\\./;\n    function join(regexps, separator = \"|\") {\n      let numCaptures = 0;\n      return regexps.map((regex) => {\n        numCaptures += 1;\n        const offset = numCaptures;\n        let re = source(regex);\n        let out = \"\";\n        while (re.length > 0) {\n          const match = BACKREF_RE.exec(re);\n          if (!match) {\n            out += re;\n            break;\n          }\n          out += re.substring(0, match.index);\n          re = re.substring(match.index + match[0].length);\n          if (match[0][0] === \"\\\\\" && match[1]) {\n            out += \"\\\\\" + String(Number(match[1]) + offset);\n          } else {\n            out += match[0];\n            if (match[0] === \"(\") {\n              numCaptures++;\n            }\n          }\n        }\n        return out;\n      }).map((re) => `(${re})`).join(separator);\n    }\n    var MATCH_NOTHING_RE = /\\b\\B/;\n    var IDENT_RE = \"[a-zA-Z]\\\\w*\";\n    var UNDERSCORE_IDENT_RE = \"[a-zA-Z_]\\\\w*\";\n    var NUMBER_RE = \"\\\\b\\\\d+(\\\\.\\\\d+)?\";\n    var C_NUMBER_RE = \"(-?)(\\\\b0[xX][a-fA-F0-9]+|(\\\\b\\\\d+(\\\\.\\\\d*)?|\\\\.\\\\d+)([eE][-+]?\\\\d+)?)\";\n    var BINARY_NUMBER_RE = \"\\\\b(0b[01]+)\";\n    var RE_STARTERS_RE = \"!|!=|!==|%|%=|&|&&|&=|\\\\*|\\\\*=|\\\\+|\\\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\\\?|\\\\[|\\\\{|\\\\(|\\\\^|\\\\^=|\\\\||\\\\|=|\\\\|\\\\||~\";\n    var SHEBANG = (opts = {}) => {\n      const beginShebang = /^#![ ]*\\//;\n      if (opts.binary) {\n        opts.begin = concat(\n          beginShebang,\n          /.*\\b/,\n          opts.binary,\n          /\\b.*/\n        );\n      }\n      return inherit({\n        className: \"meta\",\n        begin: beginShebang,\n        end: /$/,\n        relevance: 0,\n        /** @type {ModeCallback} */\n        \"on:begin\": (m, resp) => {\n          if (m.index !== 0)\n            resp.ignoreMatch();\n        }\n      }, opts);\n    };\n    var BACKSLASH_ESCAPE = {\n      begin: \"\\\\\\\\[\\\\s\\\\S]\",\n      relevance: 0\n    };\n    var APOS_STRING_MODE = {\n      className: \"string\",\n      begin: \"'\",\n      end: \"'\",\n      illegal: \"\\\\n\",\n      contains: [BACKSLASH_ESCAPE]\n    };\n    var QUOTE_STRING_MODE = {\n      className: \"string\",\n      begin: '\"',\n      end: '\"',\n      illegal: \"\\\\n\",\n      contains: [BACKSLASH_ESCAPE]\n    };\n    var PHRASAL_WORDS_MODE = {\n      begin: /\\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\\b/\n    };\n    var COMMENT = function(begin, end, modeOptions = {}) {\n      const mode = inherit(\n        {\n          className: \"comment\",\n          begin,\n          end,\n          contains: []\n        },\n        modeOptions\n      );\n      mode.contains.push(PHRASAL_WORDS_MODE);\n      mode.contains.push({\n        className: \"doctag\",\n        begin: \"(?:TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):\",\n        relevance: 0\n      });\n      return mode;\n    };\n    var C_LINE_COMMENT_MODE = COMMENT(\"//\", \"$\");\n    var C_BLOCK_COMMENT_MODE = COMMENT(\"/\\\\*\", \"\\\\*/\");\n    var HASH_COMMENT_MODE = COMMENT(\"#\", \"$\");\n    var NUMBER_MODE = {\n      className: \"number\",\n      begin: NUMBER_RE,\n      relevance: 0\n    };\n    var C_NUMBER_MODE = {\n      className: \"number\",\n      begin: C_NUMBER_RE,\n      relevance: 0\n    };\n    var BINARY_NUMBER_MODE = {\n      className: \"number\",\n      begin: BINARY_NUMBER_RE,\n      relevance: 0\n    };\n    var CSS_NUMBER_MODE = {\n      className: \"number\",\n      begin: NUMBER_RE + \"(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?\",\n      relevance: 0\n    };\n    var REGEXP_MODE = {\n      // this outer rule makes sure we actually have a WHOLE regex and not simply\n      // an expression such as:\n      //\n      //     3 / something\n      //\n      // (which will then blow up when regex's `illegal` sees the newline)\n      begin: /(?=\\/[^/\\n]*\\/)/,\n      contains: [{\n        className: \"regexp\",\n        begin: /\\//,\n        end: /\\/[gimuy]*/,\n        illegal: /\\n/,\n        contains: [\n          BACKSLASH_ESCAPE,\n          {\n            begin: /\\[/,\n            end: /\\]/,\n            relevance: 0,\n            contains: [BACKSLASH_ESCAPE]\n          }\n        ]\n      }]\n    };\n    var TITLE_MODE = {\n      className: \"title\",\n      begin: IDENT_RE,\n      relevance: 0\n    };\n    var UNDERSCORE_TITLE_MODE = {\n      className: \"title\",\n      begin: UNDERSCORE_IDENT_RE,\n      relevance: 0\n    };\n    var METHOD_GUARD = {\n      // excludes method names from keyword processing\n      begin: \"\\\\.\\\\s*\" + UNDERSCORE_IDENT_RE,\n      relevance: 0\n    };\n    var END_SAME_AS_BEGIN = function(mode) {\n      return Object.assign(\n        mode,\n        {\n          /** @type {ModeCallback} */\n          \"on:begin\": (m, resp) => {\n            resp.data._beginMatch = m[1];\n          },\n          /** @type {ModeCallback} */\n          \"on:end\": (m, resp) => {\n            if (resp.data._beginMatch !== m[1])\n              resp.ignoreMatch();\n          }\n        }\n      );\n    };\n    var MODES = Object.freeze({\n      __proto__: null,\n      MATCH_NOTHING_RE,\n      IDENT_RE,\n      UNDERSCORE_IDENT_RE,\n      NUMBER_RE,\n      C_NUMBER_RE,\n      BINARY_NUMBER_RE,\n      RE_STARTERS_RE,\n      SHEBANG,\n      BACKSLASH_ESCAPE,\n      APOS_STRING_MODE,\n      QUOTE_STRING_MODE,\n      PHRASAL_WORDS_MODE,\n      COMMENT,\n      C_LINE_COMMENT_MODE,\n      C_BLOCK_COMMENT_MODE,\n      HASH_COMMENT_MODE,\n      NUMBER_MODE,\n      C_NUMBER_MODE,\n      BINARY_NUMBER_MODE,\n      CSS_NUMBER_MODE,\n      REGEXP_MODE,\n      TITLE_MODE,\n      UNDERSCORE_TITLE_MODE,\n      METHOD_GUARD,\n      END_SAME_AS_BEGIN\n    });\n    function skipIfhasPrecedingDot(match, response) {\n      const before = match.input[match.index - 1];\n      if (before === \".\") {\n        response.ignoreMatch();\n      }\n    }\n    function beginKeywords(mode, parent) {\n      if (!parent)\n        return;\n      if (!mode.beginKeywords)\n        return;\n      mode.begin = \"\\\\b(\" + mode.beginKeywords.split(\" \").join(\"|\") + \")(?!\\\\.)(?=\\\\b|\\\\s)\";\n      mode.__beforeBegin = skipIfhasPrecedingDot;\n      mode.keywords = mode.keywords || mode.beginKeywords;\n      delete mode.beginKeywords;\n      if (mode.relevance === void 0)\n        mode.relevance = 0;\n    }\n    function compileIllegal(mode, _parent) {\n      if (!Array.isArray(mode.illegal))\n        return;\n      mode.illegal = either(...mode.illegal);\n    }\n    function compileMatch(mode, _parent) {\n      if (!mode.match)\n        return;\n      if (mode.begin || mode.end)\n        throw new Error(\"begin & end are not supported with match\");\n      mode.begin = mode.match;\n      delete mode.match;\n    }\n    function compileRelevance(mode, _parent) {\n      if (mode.relevance === void 0)\n        mode.relevance = 1;\n    }\n    var COMMON_KEYWORDS = [\n      \"of\",\n      \"and\",\n      \"for\",\n      \"in\",\n      \"not\",\n      \"or\",\n      \"if\",\n      \"then\",\n      \"parent\",\n      // common variable name\n      \"list\",\n      // common variable name\n      \"value\"\n      // common variable name\n    ];\n    var DEFAULT_KEYWORD_CLASSNAME = \"keyword\";\n    function compileKeywords(rawKeywords, caseInsensitive, className = DEFAULT_KEYWORD_CLASSNAME) {\n      const compiledKeywords = {};\n      if (typeof rawKeywords === \"string\") {\n        compileList(className, rawKeywords.split(\" \"));\n      } else if (Array.isArray(rawKeywords)) {\n        compileList(className, rawKeywords);\n      } else {\n        Object.keys(rawKeywords).forEach(function(className2) {\n          Object.assign(\n            compiledKeywords,\n            compileKeywords(rawKeywords[className2], caseInsensitive, className2)\n          );\n        });\n      }\n      return compiledKeywords;\n      function compileList(className2, keywordList) {\n        if (caseInsensitive) {\n          keywordList = keywordList.map((x) => x.toLowerCase());\n        }\n        keywordList.forEach(function(keyword) {\n          const pair = keyword.split(\"|\");\n          compiledKeywords[pair[0]] = [className2, scoreForKeyword(pair[0], pair[1])];\n        });\n      }\n    }\n    function scoreForKeyword(keyword, providedScore) {\n      if (providedScore) {\n        return Number(providedScore);\n      }\n      return commonKeyword(keyword) ? 0 : 1;\n    }\n    function commonKeyword(keyword) {\n      return COMMON_KEYWORDS.includes(keyword.toLowerCase());\n    }\n    function compileLanguage(language, { plugins }) {\n      function langRe(value, global) {\n        return new RegExp(\n          source(value),\n          \"m\" + (language.case_insensitive ? \"i\" : \"\") + (global ? \"g\" : \"\")\n        );\n      }\n      class MultiRegex {\n        constructor() {\n          this.matchIndexes = {};\n          this.regexes = [];\n          this.matchAt = 1;\n          this.position = 0;\n        }\n        // @ts-ignore\n        addRule(re, opts) {\n          opts.position = this.position++;\n          this.matchIndexes[this.matchAt] = opts;\n          this.regexes.push([opts, re]);\n          this.matchAt += countMatchGroups(re) + 1;\n        }\n        compile() {\n          if (this.regexes.length === 0) {\n            this.exec = () => null;\n          }\n          const terminators = this.regexes.map((el) => el[1]);\n          this.matcherRe = langRe(join(terminators), true);\n          this.lastIndex = 0;\n        }\n        /** @param {string} s */\n        exec(s) {\n          this.matcherRe.lastIndex = this.lastIndex;\n          const match = this.matcherRe.exec(s);\n          if (!match) {\n            return null;\n          }\n          const i = match.findIndex((el, i2) => i2 > 0 && el !== void 0);\n          const matchData = this.matchIndexes[i];\n          match.splice(0, i);\n          return Object.assign(match, matchData);\n        }\n      }\n      class ResumableMultiRegex {\n        constructor() {\n          this.rules = [];\n          this.multiRegexes = [];\n          this.count = 0;\n          this.lastIndex = 0;\n          this.regexIndex = 0;\n        }\n        // @ts-ignore\n        getMatcher(index) {\n          if (this.multiRegexes[index])\n            return this.multiRegexes[index];\n          const matcher = new MultiRegex();\n          this.rules.slice(index).forEach(([re, opts]) => matcher.addRule(re, opts));\n          matcher.compile();\n          this.multiRegexes[index] = matcher;\n          return matcher;\n        }\n        resumingScanAtSamePosition() {\n          return this.regexIndex !== 0;\n        }\n        considerAll() {\n          this.regexIndex = 0;\n        }\n        // @ts-ignore\n        addRule(re, opts) {\n          this.rules.push([re, opts]);\n          if (opts.type === \"begin\")\n            this.count++;\n        }\n        /** @param {string} s */\n        exec(s) {\n          const m = this.getMatcher(this.regexIndex);\n          m.lastIndex = this.lastIndex;\n          let result = m.exec(s);\n          if (this.resumingScanAtSamePosition()) {\n            if (result && result.index === this.lastIndex)\n              ;\n            else {\n              const m2 = this.getMatcher(0);\n              m2.lastIndex = this.lastIndex + 1;\n              result = m2.exec(s);\n            }\n          }\n          if (result) {\n            this.regexIndex += result.position + 1;\n            if (this.regexIndex === this.count) {\n              this.considerAll();\n            }\n          }\n          return result;\n        }\n      }\n      function buildModeRegex(mode) {\n        const mm = new ResumableMultiRegex();\n        mode.contains.forEach((term) => mm.addRule(term.begin, { rule: term, type: \"begin\" }));\n        if (mode.terminatorEnd) {\n          mm.addRule(mode.terminatorEnd, { type: \"end\" });\n        }\n        if (mode.illegal) {\n          mm.addRule(mode.illegal, { type: \"illegal\" });\n        }\n        return mm;\n      }\n      function compileMode(mode, parent) {\n        const cmode = (\n          /** @type CompiledMode */\n          mode\n        );\n        if (mode.isCompiled)\n          return cmode;\n        [\n          // do this early so compiler extensions generally don't have to worry about\n          // the distinction between match/begin\n          compileMatch\n        ].forEach((ext) => ext(mode, parent));\n        language.compilerExtensions.forEach((ext) => ext(mode, parent));\n        mode.__beforeBegin = null;\n        [\n          beginKeywords,\n          // do this later so compiler extensions that come earlier have access to the\n          // raw array if they wanted to perhaps manipulate it, etc.\n          compileIllegal,\n          // default to 1 relevance if not specified\n          compileRelevance\n        ].forEach((ext) => ext(mode, parent));\n        mode.isCompiled = true;\n        let keywordPattern = null;\n        if (typeof mode.keywords === \"object\") {\n          keywordPattern = mode.keywords.$pattern;\n          delete mode.keywords.$pattern;\n        }\n        if (mode.keywords) {\n          mode.keywords = compileKeywords(mode.keywords, language.case_insensitive);\n        }\n        if (mode.lexemes && keywordPattern) {\n          throw new Error(\"ERR: Prefer `keywords.$pattern` to `mode.lexemes`, BOTH are not allowed. (see mode reference) \");\n        }\n        keywordPattern = keywordPattern || mode.lexemes || /\\w+/;\n        cmode.keywordPatternRe = langRe(keywordPattern, true);\n        if (parent) {\n          if (!mode.begin)\n            mode.begin = /\\B|\\b/;\n          cmode.beginRe = langRe(mode.begin);\n          if (mode.endSameAsBegin)\n            mode.end = mode.begin;\n          if (!mode.end && !mode.endsWithParent)\n            mode.end = /\\B|\\b/;\n          if (mode.end)\n            cmode.endRe = langRe(mode.end);\n          cmode.terminatorEnd = source(mode.end) || \"\";\n          if (mode.endsWithParent && parent.terminatorEnd) {\n            cmode.terminatorEnd += (mode.end ? \"|\" : \"\") + parent.terminatorEnd;\n          }\n        }\n        if (mode.illegal)\n          cmode.illegalRe = langRe(\n            /** @type {RegExp | string} */\n            mode.illegal\n          );\n        if (!mode.contains)\n          mode.contains = [];\n        mode.contains = [].concat(...mode.contains.map(function(c) {\n          return expandOrCloneMode(c === \"self\" ? mode : c);\n        }));\n        mode.contains.forEach(function(c) {\n          compileMode(\n            /** @type Mode */\n            c,\n            cmode\n          );\n        });\n        if (mode.starts) {\n          compileMode(mode.starts, parent);\n        }\n        cmode.matcher = buildModeRegex(cmode);\n        return cmode;\n      }\n      if (!language.compilerExtensions)\n        language.compilerExtensions = [];\n      if (language.contains && language.contains.includes(\"self\")) {\n        throw new Error(\"ERR: contains `self` is not supported at the top-level of a language.  See documentation.\");\n      }\n      language.classNameAliases = inherit(language.classNameAliases || {});\n      return compileMode(\n        /** @type Mode */\n        language\n      );\n    }\n    function dependencyOnParent(mode) {\n      if (!mode)\n        return false;\n      return mode.endsWithParent || dependencyOnParent(mode.starts);\n    }\n    function expandOrCloneMode(mode) {\n      if (mode.variants && !mode.cachedVariants) {\n        mode.cachedVariants = mode.variants.map(function(variant) {\n          return inherit(mode, { variants: null }, variant);\n        });\n      }\n      if (mode.cachedVariants) {\n        return mode.cachedVariants;\n      }\n      if (dependencyOnParent(mode)) {\n        return inherit(mode, { starts: mode.starts ? inherit(mode.starts) : null });\n      }\n      if (Object.isFrozen(mode)) {\n        return inherit(mode);\n      }\n      return mode;\n    }\n    var version = \"10.7.3\";\n    function hasValueOrEmptyAttribute(value) {\n      return Boolean(value || value === \"\");\n    }\n    function BuildVuePlugin(hljs) {\n      const Component = {\n        props: [\"language\", \"code\", \"autodetect\"],\n        data: function() {\n          return {\n            detectedLanguage: \"\",\n            unknownLanguage: false\n          };\n        },\n        computed: {\n          className() {\n            if (this.unknownLanguage)\n              return \"\";\n            return \"hljs \" + this.detectedLanguage;\n          },\n          highlighted() {\n            if (!this.autoDetect && !hljs.getLanguage(this.language)) {\n              console.warn(`The language \"${this.language}\" you specified could not be found.`);\n              this.unknownLanguage = true;\n              return escapeHTML(this.code);\n            }\n            let result = {};\n            if (this.autoDetect) {\n              result = hljs.highlightAuto(this.code);\n              this.detectedLanguage = result.language;\n            } else {\n              result = hljs.highlight(this.language, this.code, this.ignoreIllegals);\n              this.detectedLanguage = this.language;\n            }\n            return result.value;\n          },\n          autoDetect() {\n            return !this.language || hasValueOrEmptyAttribute(this.autodetect);\n          },\n          ignoreIllegals() {\n            return true;\n          }\n        },\n        // this avoids needing to use a whole Vue compilation pipeline just\n        // to build Highlight.js\n        render(createElement) {\n          return createElement(\"pre\", {}, [\n            createElement(\"code\", {\n              class: this.className,\n              domProps: { innerHTML: this.highlighted }\n            })\n          ]);\n        }\n        // template: `<pre><code :class=\"className\" v-html=\"highlighted\"></code></pre>`\n      };\n      const VuePlugin = {\n        install(Vue) {\n          Vue.component(\"highlightjs\", Component);\n        }\n      };\n      return { Component, VuePlugin };\n    }\n    var mergeHTMLPlugin = {\n      \"after:highlightElement\": ({ el, result, text }) => {\n        const originalStream = nodeStream(el);\n        if (!originalStream.length)\n          return;\n        const resultNode = document.createElement(\"div\");\n        resultNode.innerHTML = result.value;\n        result.value = mergeStreams(originalStream, nodeStream(resultNode), text);\n      }\n    };\n    function tag(node) {\n      return node.nodeName.toLowerCase();\n    }\n    function nodeStream(node) {\n      const result = [];\n      (function _nodeStream(node2, offset) {\n        for (let child = node2.firstChild; child; child = child.nextSibling) {\n          if (child.nodeType === 3) {\n            offset += child.nodeValue.length;\n          } else if (child.nodeType === 1) {\n            result.push({\n              event: \"start\",\n              offset,\n              node: child\n            });\n            offset = _nodeStream(child, offset);\n            if (!tag(child).match(/br|hr|img|input/)) {\n              result.push({\n                event: \"stop\",\n                offset,\n                node: child\n              });\n            }\n          }\n        }\n        return offset;\n      })(node, 0);\n      return result;\n    }\n    function mergeStreams(original, highlighted, value) {\n      let processed = 0;\n      let result = \"\";\n      const nodeStack = [];\n      function selectStream() {\n        if (!original.length || !highlighted.length) {\n          return original.length ? original : highlighted;\n        }\n        if (original[0].offset !== highlighted[0].offset) {\n          return original[0].offset < highlighted[0].offset ? original : highlighted;\n        }\n        return highlighted[0].event === \"start\" ? original : highlighted;\n      }\n      function open(node) {\n        function attributeString(attr) {\n          return \" \" + attr.nodeName + '=\"' + escapeHTML(attr.value) + '\"';\n        }\n        result += \"<\" + tag(node) + [].map.call(node.attributes, attributeString).join(\"\") + \">\";\n      }\n      function close(node) {\n        result += \"</\" + tag(node) + \">\";\n      }\n      function render(event) {\n        (event.event === \"start\" ? open : close)(event.node);\n      }\n      while (original.length || highlighted.length) {\n        let stream = selectStream();\n        result += escapeHTML(value.substring(processed, stream[0].offset));\n        processed = stream[0].offset;\n        if (stream === original) {\n          nodeStack.reverse().forEach(close);\n          do {\n            render(stream.splice(0, 1)[0]);\n            stream = selectStream();\n          } while (stream === original && stream.length && stream[0].offset === processed);\n          nodeStack.reverse().forEach(open);\n        } else {\n          if (stream[0].event === \"start\") {\n            nodeStack.push(stream[0].node);\n          } else {\n            nodeStack.pop();\n          }\n          render(stream.splice(0, 1)[0]);\n        }\n      }\n      return result + escapeHTML(value.substr(processed));\n    }\n    var seenDeprecations = {};\n    var error = (message) => {\n      console.error(message);\n    };\n    var warn = (message, ...args) => {\n      console.log(`WARN: ${message}`, ...args);\n    };\n    var deprecated = (version2, message) => {\n      if (seenDeprecations[`${version2}/${message}`])\n        return;\n      console.log(`Deprecated as of ${version2}. ${message}`);\n      seenDeprecations[`${version2}/${message}`] = true;\n    };\n    var escape$1 = escapeHTML;\n    var inherit$1 = inherit;\n    var NO_MATCH = Symbol(\"nomatch\");\n    var HLJS = function(hljs) {\n      const languages = /* @__PURE__ */ Object.create(null);\n      const aliases = /* @__PURE__ */ Object.create(null);\n      const plugins = [];\n      let SAFE_MODE = true;\n      const fixMarkupRe = /(^(<[^>]+>|\\t|)+|\\n)/gm;\n      const LANGUAGE_NOT_FOUND = \"Could not find the language '{}', did you forget to load/include a language module?\";\n      const PLAINTEXT_LANGUAGE = { disableAutodetect: true, name: \"Plain text\", contains: [] };\n      let options = {\n        noHighlightRe: /^(no-?highlight)$/i,\n        languageDetectRe: /\\blang(?:uage)?-([\\w-]+)\\b/i,\n        classPrefix: \"hljs-\",\n        tabReplace: null,\n        useBR: false,\n        languages: null,\n        // beta configuration options, subject to change, welcome to discuss\n        // https://github.com/highlightjs/highlight.js/issues/1086\n        __emitter: TokenTreeEmitter\n      };\n      function shouldNotHighlight(languageName) {\n        return options.noHighlightRe.test(languageName);\n      }\n      function blockLanguage(block) {\n        let classes = block.className + \" \";\n        classes += block.parentNode ? block.parentNode.className : \"\";\n        const match = options.languageDetectRe.exec(classes);\n        if (match) {\n          const language = getLanguage(match[1]);\n          if (!language) {\n            warn(LANGUAGE_NOT_FOUND.replace(\"{}\", match[1]));\n            warn(\"Falling back to no-highlight mode for this block.\", block);\n          }\n          return language ? match[1] : \"no-highlight\";\n        }\n        return classes.split(/\\s+/).find((_class) => shouldNotHighlight(_class) || getLanguage(_class));\n      }\n      function highlight2(codeOrlanguageName, optionsOrCode, ignoreIllegals, continuation) {\n        let code = \"\";\n        let languageName = \"\";\n        if (typeof optionsOrCode === \"object\") {\n          code = codeOrlanguageName;\n          ignoreIllegals = optionsOrCode.ignoreIllegals;\n          languageName = optionsOrCode.language;\n          continuation = void 0;\n        } else {\n          deprecated(\"10.7.0\", \"highlight(lang, code, ...args) has been deprecated.\");\n          deprecated(\"10.7.0\", \"Please use highlight(code, options) instead.\\nhttps://github.com/highlightjs/highlight.js/issues/2277\");\n          languageName = codeOrlanguageName;\n          code = optionsOrCode;\n        }\n        const context = {\n          code,\n          language: languageName\n        };\n        fire(\"before:highlight\", context);\n        const result = context.result ? context.result : _highlight(context.language, context.code, ignoreIllegals, continuation);\n        result.code = context.code;\n        fire(\"after:highlight\", result);\n        return result;\n      }\n      function _highlight(languageName, codeToHighlight, ignoreIllegals, continuation) {\n        function keywordData(mode, match) {\n          const matchText = language.case_insensitive ? match[0].toLowerCase() : match[0];\n          return Object.prototype.hasOwnProperty.call(mode.keywords, matchText) && mode.keywords[matchText];\n        }\n        function processKeywords() {\n          if (!top.keywords) {\n            emitter.addText(modeBuffer);\n            return;\n          }\n          let lastIndex = 0;\n          top.keywordPatternRe.lastIndex = 0;\n          let match = top.keywordPatternRe.exec(modeBuffer);\n          let buf = \"\";\n          while (match) {\n            buf += modeBuffer.substring(lastIndex, match.index);\n            const data = keywordData(top, match);\n            if (data) {\n              const [kind, keywordRelevance] = data;\n              emitter.addText(buf);\n              buf = \"\";\n              relevance += keywordRelevance;\n              if (kind.startsWith(\"_\")) {\n                buf += match[0];\n              } else {\n                const cssClass = language.classNameAliases[kind] || kind;\n                emitter.addKeyword(match[0], cssClass);\n              }\n            } else {\n              buf += match[0];\n            }\n            lastIndex = top.keywordPatternRe.lastIndex;\n            match = top.keywordPatternRe.exec(modeBuffer);\n          }\n          buf += modeBuffer.substr(lastIndex);\n          emitter.addText(buf);\n        }\n        function processSubLanguage() {\n          if (modeBuffer === \"\")\n            return;\n          let result2 = null;\n          if (typeof top.subLanguage === \"string\") {\n            if (!languages[top.subLanguage]) {\n              emitter.addText(modeBuffer);\n              return;\n            }\n            result2 = _highlight(top.subLanguage, modeBuffer, true, continuations[top.subLanguage]);\n            continuations[top.subLanguage] = /** @type {CompiledMode} */\n            result2.top;\n          } else {\n            result2 = highlightAuto(modeBuffer, top.subLanguage.length ? top.subLanguage : null);\n          }\n          if (top.relevance > 0) {\n            relevance += result2.relevance;\n          }\n          emitter.addSublanguage(result2.emitter, result2.language);\n        }\n        function processBuffer() {\n          if (top.subLanguage != null) {\n            processSubLanguage();\n          } else {\n            processKeywords();\n          }\n          modeBuffer = \"\";\n        }\n        function startNewMode(mode) {\n          if (mode.className) {\n            emitter.openNode(language.classNameAliases[mode.className] || mode.className);\n          }\n          top = Object.create(mode, { parent: { value: top } });\n          return top;\n        }\n        function endOfMode(mode, match, matchPlusRemainder) {\n          let matched = startsWith(mode.endRe, matchPlusRemainder);\n          if (matched) {\n            if (mode[\"on:end\"]) {\n              const resp = new Response(mode);\n              mode[\"on:end\"](match, resp);\n              if (resp.isMatchIgnored)\n                matched = false;\n            }\n            if (matched) {\n              while (mode.endsParent && mode.parent) {\n                mode = mode.parent;\n              }\n              return mode;\n            }\n          }\n          if (mode.endsWithParent) {\n            return endOfMode(mode.parent, match, matchPlusRemainder);\n          }\n        }\n        function doIgnore(lexeme) {\n          if (top.matcher.regexIndex === 0) {\n            modeBuffer += lexeme[0];\n            return 1;\n          } else {\n            resumeScanAtSamePosition = true;\n            return 0;\n          }\n        }\n        function doBeginMatch(match) {\n          const lexeme = match[0];\n          const newMode = match.rule;\n          const resp = new Response(newMode);\n          const beforeCallbacks = [newMode.__beforeBegin, newMode[\"on:begin\"]];\n          for (const cb of beforeCallbacks) {\n            if (!cb)\n              continue;\n            cb(match, resp);\n            if (resp.isMatchIgnored)\n              return doIgnore(lexeme);\n          }\n          if (newMode && newMode.endSameAsBegin) {\n            newMode.endRe = escape(lexeme);\n          }\n          if (newMode.skip) {\n            modeBuffer += lexeme;\n          } else {\n            if (newMode.excludeBegin) {\n              modeBuffer += lexeme;\n            }\n            processBuffer();\n            if (!newMode.returnBegin && !newMode.excludeBegin) {\n              modeBuffer = lexeme;\n            }\n          }\n          startNewMode(newMode);\n          return newMode.returnBegin ? 0 : lexeme.length;\n        }\n        function doEndMatch(match) {\n          const lexeme = match[0];\n          const matchPlusRemainder = codeToHighlight.substr(match.index);\n          const endMode = endOfMode(top, match, matchPlusRemainder);\n          if (!endMode) {\n            return NO_MATCH;\n          }\n          const origin = top;\n          if (origin.skip) {\n            modeBuffer += lexeme;\n          } else {\n            if (!(origin.returnEnd || origin.excludeEnd)) {\n              modeBuffer += lexeme;\n            }\n            processBuffer();\n            if (origin.excludeEnd) {\n              modeBuffer = lexeme;\n            }\n          }\n          do {\n            if (top.className) {\n              emitter.closeNode();\n            }\n            if (!top.skip && !top.subLanguage) {\n              relevance += top.relevance;\n            }\n            top = top.parent;\n          } while (top !== endMode.parent);\n          if (endMode.starts) {\n            if (endMode.endSameAsBegin) {\n              endMode.starts.endRe = endMode.endRe;\n            }\n            startNewMode(endMode.starts);\n          }\n          return origin.returnEnd ? 0 : lexeme.length;\n        }\n        function processContinuations() {\n          const list = [];\n          for (let current = top; current !== language; current = current.parent) {\n            if (current.className) {\n              list.unshift(current.className);\n            }\n          }\n          list.forEach((item) => emitter.openNode(item));\n        }\n        let lastMatch = {};\n        function processLexeme(textBeforeMatch, match) {\n          const lexeme = match && match[0];\n          modeBuffer += textBeforeMatch;\n          if (lexeme == null) {\n            processBuffer();\n            return 0;\n          }\n          if (lastMatch.type === \"begin\" && match.type === \"end\" && lastMatch.index === match.index && lexeme === \"\") {\n            modeBuffer += codeToHighlight.slice(match.index, match.index + 1);\n            if (!SAFE_MODE) {\n              const err = new Error(\"0 width match regex\");\n              err.languageName = languageName;\n              err.badRule = lastMatch.rule;\n              throw err;\n            }\n            return 1;\n          }\n          lastMatch = match;\n          if (match.type === \"begin\") {\n            return doBeginMatch(match);\n          } else if (match.type === \"illegal\" && !ignoreIllegals) {\n            const err = new Error('Illegal lexeme \"' + lexeme + '\" for mode \"' + (top.className || \"<unnamed>\") + '\"');\n            err.mode = top;\n            throw err;\n          } else if (match.type === \"end\") {\n            const processed = doEndMatch(match);\n            if (processed !== NO_MATCH) {\n              return processed;\n            }\n          }\n          if (match.type === \"illegal\" && lexeme === \"\") {\n            return 1;\n          }\n          if (iterations > 1e5 && iterations > match.index * 3) {\n            const err = new Error(\"potential infinite loop, way more iterations than matches\");\n            throw err;\n          }\n          modeBuffer += lexeme;\n          return lexeme.length;\n        }\n        const language = getLanguage(languageName);\n        if (!language) {\n          error(LANGUAGE_NOT_FOUND.replace(\"{}\", languageName));\n          throw new Error('Unknown language: \"' + languageName + '\"');\n        }\n        const md = compileLanguage(language, { plugins });\n        let result = \"\";\n        let top = continuation || md;\n        const continuations = {};\n        const emitter = new options.__emitter(options);\n        processContinuations();\n        let modeBuffer = \"\";\n        let relevance = 0;\n        let index = 0;\n        let iterations = 0;\n        let resumeScanAtSamePosition = false;\n        try {\n          top.matcher.considerAll();\n          for (; ; ) {\n            iterations++;\n            if (resumeScanAtSamePosition) {\n              resumeScanAtSamePosition = false;\n            } else {\n              top.matcher.considerAll();\n            }\n            top.matcher.lastIndex = index;\n            const match = top.matcher.exec(codeToHighlight);\n            if (!match)\n              break;\n            const beforeMatch = codeToHighlight.substring(index, match.index);\n            const processedCount = processLexeme(beforeMatch, match);\n            index = match.index + processedCount;\n          }\n          processLexeme(codeToHighlight.substr(index));\n          emitter.closeAllNodes();\n          emitter.finalize();\n          result = emitter.toHTML();\n          return {\n            // avoid possible breakage with v10 clients expecting\n            // this to always be an integer\n            relevance: Math.floor(relevance),\n            value: result,\n            language: languageName,\n            illegal: false,\n            emitter,\n            top\n          };\n        } catch (err) {\n          if (err.message && err.message.includes(\"Illegal\")) {\n            return {\n              illegal: true,\n              illegalBy: {\n                msg: err.message,\n                context: codeToHighlight.slice(index - 100, index + 100),\n                mode: err.mode\n              },\n              sofar: result,\n              relevance: 0,\n              value: escape$1(codeToHighlight),\n              emitter\n            };\n          } else if (SAFE_MODE) {\n            return {\n              illegal: false,\n              relevance: 0,\n              value: escape$1(codeToHighlight),\n              emitter,\n              language: languageName,\n              top,\n              errorRaised: err\n            };\n          } else {\n            throw err;\n          }\n        }\n      }\n      function justTextHighlightResult(code) {\n        const result = {\n          relevance: 0,\n          emitter: new options.__emitter(options),\n          value: escape$1(code),\n          illegal: false,\n          top: PLAINTEXT_LANGUAGE\n        };\n        result.emitter.addText(code);\n        return result;\n      }\n      function highlightAuto(code, languageSubset) {\n        languageSubset = languageSubset || options.languages || Object.keys(languages);\n        const plaintext = justTextHighlightResult(code);\n        const results = languageSubset.filter(getLanguage).filter(autoDetection).map(\n          (name) => _highlight(name, code, false)\n        );\n        results.unshift(plaintext);\n        const sorted = results.sort((a, b) => {\n          if (a.relevance !== b.relevance)\n            return b.relevance - a.relevance;\n          if (a.language && b.language) {\n            if (getLanguage(a.language).supersetOf === b.language) {\n              return 1;\n            } else if (getLanguage(b.language).supersetOf === a.language) {\n              return -1;\n            }\n          }\n          return 0;\n        });\n        const [best, secondBest] = sorted;\n        const result = best;\n        result.second_best = secondBest;\n        return result;\n      }\n      function fixMarkup(html) {\n        if (!(options.tabReplace || options.useBR)) {\n          return html;\n        }\n        return html.replace(fixMarkupRe, (match) => {\n          if (match === \"\\n\") {\n            return options.useBR ? \"<br>\" : match;\n          } else if (options.tabReplace) {\n            return match.replace(/\\t/g, options.tabReplace);\n          }\n          return match;\n        });\n      }\n      function updateClassName(element, currentLang, resultLang) {\n        const language = currentLang ? aliases[currentLang] : resultLang;\n        element.classList.add(\"hljs\");\n        if (language)\n          element.classList.add(language);\n      }\n      const brPlugin = {\n        \"before:highlightElement\": ({ el }) => {\n          if (options.useBR) {\n            el.innerHTML = el.innerHTML.replace(/\\n/g, \"\").replace(/<br[ /]*>/g, \"\\n\");\n          }\n        },\n        \"after:highlightElement\": ({ result }) => {\n          if (options.useBR) {\n            result.value = result.value.replace(/\\n/g, \"<br>\");\n          }\n        }\n      };\n      const TAB_REPLACE_RE = /^(<[^>]+>|\\t)+/gm;\n      const tabReplacePlugin = {\n        \"after:highlightElement\": ({ result }) => {\n          if (options.tabReplace) {\n            result.value = result.value.replace(\n              TAB_REPLACE_RE,\n              (m) => m.replace(/\\t/g, options.tabReplace)\n            );\n          }\n        }\n      };\n      function highlightElement(element) {\n        let node = null;\n        const language = blockLanguage(element);\n        if (shouldNotHighlight(language))\n          return;\n        fire(\n          \"before:highlightElement\",\n          { el: element, language }\n        );\n        node = element;\n        const text = node.textContent;\n        const result = language ? highlight2(text, { language, ignoreIllegals: true }) : highlightAuto(text);\n        fire(\"after:highlightElement\", { el: element, result, text });\n        element.innerHTML = result.value;\n        updateClassName(element, language, result.language);\n        element.result = {\n          language: result.language,\n          // TODO: remove with version 11.0\n          re: result.relevance,\n          relavance: result.relevance\n        };\n        if (result.second_best) {\n          element.second_best = {\n            language: result.second_best.language,\n            // TODO: remove with version 11.0\n            re: result.second_best.relevance,\n            relavance: result.second_best.relevance\n          };\n        }\n      }\n      function configure(userOptions) {\n        if (userOptions.useBR) {\n          deprecated(\"10.3.0\", \"'useBR' will be removed entirely in v11.0\");\n          deprecated(\"10.3.0\", \"Please see https://github.com/highlightjs/highlight.js/issues/2559\");\n        }\n        options = inherit$1(options, userOptions);\n      }\n      const initHighlighting = () => {\n        if (initHighlighting.called)\n          return;\n        initHighlighting.called = true;\n        deprecated(\"10.6.0\", \"initHighlighting() is deprecated.  Use highlightAll() instead.\");\n        const blocks = document.querySelectorAll(\"pre code\");\n        blocks.forEach(highlightElement);\n      };\n      function initHighlightingOnLoad() {\n        deprecated(\"10.6.0\", \"initHighlightingOnLoad() is deprecated.  Use highlightAll() instead.\");\n        wantsHighlight = true;\n      }\n      let wantsHighlight = false;\n      function highlightAll() {\n        if (document.readyState === \"loading\") {\n          wantsHighlight = true;\n          return;\n        }\n        const blocks = document.querySelectorAll(\"pre code\");\n        blocks.forEach(highlightElement);\n      }\n      function boot() {\n        if (wantsHighlight)\n          highlightAll();\n      }\n      if (typeof window !== \"undefined\" && window.addEventListener) {\n        window.addEventListener(\"DOMContentLoaded\", boot, false);\n      }\n      function registerLanguage(languageName, languageDefinition) {\n        let lang = null;\n        try {\n          lang = languageDefinition(hljs);\n        } catch (error$1) {\n          error(\"Language definition for '{}' could not be registered.\".replace(\"{}\", languageName));\n          if (!SAFE_MODE) {\n            throw error$1;\n          } else {\n            error(error$1);\n          }\n          lang = PLAINTEXT_LANGUAGE;\n        }\n        if (!lang.name)\n          lang.name = languageName;\n        languages[languageName] = lang;\n        lang.rawDefinition = languageDefinition.bind(null, hljs);\n        if (lang.aliases) {\n          registerAliases(lang.aliases, { languageName });\n        }\n      }\n      function unregisterLanguage(languageName) {\n        delete languages[languageName];\n        for (const alias of Object.keys(aliases)) {\n          if (aliases[alias] === languageName) {\n            delete aliases[alias];\n          }\n        }\n      }\n      function listLanguages() {\n        return Object.keys(languages);\n      }\n      function requireLanguage(name) {\n        deprecated(\"10.4.0\", \"requireLanguage will be removed entirely in v11.\");\n        deprecated(\"10.4.0\", \"Please see https://github.com/highlightjs/highlight.js/pull/2844\");\n        const lang = getLanguage(name);\n        if (lang) {\n          return lang;\n        }\n        const err = new Error(\"The '{}' language is required, but not loaded.\".replace(\"{}\", name));\n        throw err;\n      }\n      function getLanguage(name) {\n        name = (name || \"\").toLowerCase();\n        return languages[name] || languages[aliases[name]];\n      }\n      function registerAliases(aliasList, { languageName }) {\n        if (typeof aliasList === \"string\") {\n          aliasList = [aliasList];\n        }\n        aliasList.forEach((alias) => {\n          aliases[alias.toLowerCase()] = languageName;\n        });\n      }\n      function autoDetection(name) {\n        const lang = getLanguage(name);\n        return lang && !lang.disableAutodetect;\n      }\n      function upgradePluginAPI(plugin) {\n        if (plugin[\"before:highlightBlock\"] && !plugin[\"before:highlightElement\"]) {\n          plugin[\"before:highlightElement\"] = (data) => {\n            plugin[\"before:highlightBlock\"](\n              Object.assign({ block: data.el }, data)\n            );\n          };\n        }\n        if (plugin[\"after:highlightBlock\"] && !plugin[\"after:highlightElement\"]) {\n          plugin[\"after:highlightElement\"] = (data) => {\n            plugin[\"after:highlightBlock\"](\n              Object.assign({ block: data.el }, data)\n            );\n          };\n        }\n      }\n      function addPlugin(plugin) {\n        upgradePluginAPI(plugin);\n        plugins.push(plugin);\n      }\n      function fire(event, args) {\n        const cb = event;\n        plugins.forEach(function(plugin) {\n          if (plugin[cb]) {\n            plugin[cb](args);\n          }\n        });\n      }\n      function deprecateFixMarkup(arg) {\n        deprecated(\"10.2.0\", \"fixMarkup will be removed entirely in v11.0\");\n        deprecated(\"10.2.0\", \"Please see https://github.com/highlightjs/highlight.js/issues/2534\");\n        return fixMarkup(arg);\n      }\n      function deprecateHighlightBlock(el) {\n        deprecated(\"10.7.0\", \"highlightBlock will be removed entirely in v12.0\");\n        deprecated(\"10.7.0\", \"Please use highlightElement now.\");\n        return highlightElement(el);\n      }\n      Object.assign(hljs, {\n        highlight: highlight2,\n        highlightAuto,\n        highlightAll,\n        fixMarkup: deprecateFixMarkup,\n        highlightElement,\n        // TODO: Remove with v12 API\n        highlightBlock: deprecateHighlightBlock,\n        configure,\n        initHighlighting,\n        initHighlightingOnLoad,\n        registerLanguage,\n        unregisterLanguage,\n        listLanguages,\n        getLanguage,\n        registerAliases,\n        requireLanguage,\n        autoDetection,\n        inherit: inherit$1,\n        addPlugin,\n        // plugins for frameworks\n        vuePlugin: BuildVuePlugin(hljs).VuePlugin\n      });\n      hljs.debugMode = function() {\n        SAFE_MODE = false;\n      };\n      hljs.safeMode = function() {\n        SAFE_MODE = true;\n      };\n      hljs.versionString = version;\n      for (const key in MODES) {\n        if (typeof MODES[key] === \"object\") {\n          deepFreezeEs6(MODES[key]);\n        }\n      }\n      Object.assign(hljs, MODES);\n      hljs.addPlugin(brPlugin);\n      hljs.addPlugin(mergeHTMLPlugin);\n      hljs.addPlugin(tabReplacePlugin);\n      return hljs;\n    };\n    var highlight = HLJS({});\n    module.exports = highlight;\n  }\n});\n\n// node_modules/format/format.js\nvar require_format = __commonJS({\n  \"node_modules/format/format.js\"(exports, module) {\n    var import_dist = __toESM(require_dist());\n    (function() {\n      var namespace;\n      if (typeof module !== \"undefined\") {\n        namespace = module.exports = format;\n      } else {\n        namespace = function() {\n          return this || (1, eval)(\"this\");\n        }();\n      }\n      namespace.format = format;\n      namespace.vsprintf = vsprintf;\n      if (typeof console !== \"undefined\" && typeof console.log === \"function\") {\n        namespace.printf = printf;\n      }\n      function printf() {\n        console.log(format.apply(null, arguments));\n      }\n      function vsprintf(fmt, replacements) {\n        return format.apply(null, [fmt].concat(replacements));\n      }\n      function format(fmt) {\n        var argIndex = 1, args = [].slice.call(arguments), i = 0, n = fmt.length, result = \"\", c, escaped = false, arg, tmp, leadingZero = false, precision, nextArg = function() {\n          return args[argIndex++];\n        }, slurpNumber = function() {\n          var digits = \"\";\n          while (/\\d/.test(fmt[i])) {\n            digits += fmt[i++];\n            c = fmt[i];\n          }\n          return digits.length > 0 ? parseInt(digits) : null;\n        };\n        for (; i < n; ++i) {\n          c = fmt[i];\n          if (escaped) {\n            escaped = false;\n            if (c == \".\") {\n              leadingZero = false;\n              c = fmt[++i];\n            } else if (c == \"0\" && fmt[i + 1] == \".\") {\n              leadingZero = true;\n              i += 2;\n              c = fmt[i];\n            } else {\n              leadingZero = true;\n            }\n            precision = slurpNumber();\n            switch (c) {\n              case \"b\":\n                result += parseInt(nextArg(), 10).toString(2);\n                break;\n              case \"c\":\n                arg = nextArg();\n                if (typeof arg === \"string\" || arg instanceof String)\n                  result += arg;\n                else\n                  result += String.fromCharCode(parseInt(arg, 10));\n                break;\n              case \"d\":\n                result += parseInt(nextArg(), 10);\n                break;\n              case \"f\":\n                tmp = String(parseFloat(nextArg()).toFixed(precision || 6));\n                result += leadingZero ? tmp : tmp.replace(/^0/, \"\");\n                break;\n              case \"j\":\n                result += JSON.stringify(nextArg());\n                break;\n              case \"o\":\n                result += \"0\" + parseInt(nextArg(), 10).toString(8);\n                break;\n              case \"s\":\n                result += nextArg();\n                break;\n              case \"x\":\n                result += \"0x\" + parseInt(nextArg(), 10).toString(16);\n                break;\n              case \"X\":\n                result += \"0x\" + parseInt(nextArg(), 10).toString(16).toUpperCase();\n                break;\n              default:\n                result += c;\n                break;\n            }\n          } else if (c === \"%\") {\n            escaped = true;\n          } else {\n            result += c;\n          }\n        }\n        return result;\n      }\n    })();\n  }\n});\n\n// node_modules/fault/index.js\nvar require_fault = __commonJS({\n  \"node_modules/fault/index.js\"(exports, module) {\n    \"use strict\";\n    var import_dist = __toESM(require_dist());\n    var formatter = require_format();\n    var fault = create(Error);\n    module.exports = fault;\n    fault.eval = create(EvalError);\n    fault.range = create(RangeError);\n    fault.reference = create(ReferenceError);\n    fault.syntax = create(SyntaxError);\n    fault.type = create(TypeError);\n    fault.uri = create(URIError);\n    fault.create = create;\n    function create(EConstructor) {\n      FormattedError.displayName = EConstructor.displayName || EConstructor.name;\n      return FormattedError;\n      function FormattedError(format) {\n        if (format) {\n          format = formatter.apply(null, arguments);\n        }\n        return new EConstructor(format);\n      }\n    }\n  }\n});\n\n// node_modules/lowlight/lib/core.js\nvar require_core2 = __commonJS({\n  \"node_modules/lowlight/lib/core.js\"(exports) {\n    var import_dist = __toESM(require_dist());\n    var high = require_core();\n    var fault = require_fault();\n    exports.highlight = highlight;\n    exports.highlightAuto = highlightAuto;\n    exports.registerLanguage = registerLanguage;\n    exports.listLanguages = listLanguages;\n    exports.registerAlias = registerAlias;\n    Emitter.prototype.addText = text;\n    Emitter.prototype.addKeyword = addKeyword;\n    Emitter.prototype.addSublanguage = addSublanguage;\n    Emitter.prototype.openNode = open;\n    Emitter.prototype.closeNode = close;\n    Emitter.prototype.closeAllNodes = noop;\n    Emitter.prototype.finalize = noop;\n    Emitter.prototype.toHTML = toHtmlNoop;\n    var defaultPrefix = \"hljs-\";\n    function highlight(name, value, options) {\n      var before = high.configure({});\n      var settings = options || {};\n      var prefix = settings.prefix;\n      var result;\n      if (typeof name !== \"string\") {\n        throw fault(\"Expected `string` for name, got `%s`\", name);\n      }\n      if (!high.getLanguage(name)) {\n        throw fault(\"Unknown language: `%s` is not registered\", name);\n      }\n      if (typeof value !== \"string\") {\n        throw fault(\"Expected `string` for value, got `%s`\", value);\n      }\n      if (prefix === null || prefix === void 0) {\n        prefix = defaultPrefix;\n      }\n      high.configure({ __emitter: Emitter, classPrefix: prefix });\n      result = high.highlight(value, { language: name, ignoreIllegals: true });\n      high.configure(before || {});\n      if (result.errorRaised) {\n        throw result.errorRaised;\n      }\n      return {\n        relevance: result.relevance,\n        language: result.language,\n        value: result.emitter.rootNode.children\n      };\n    }\n    function highlightAuto(value, options) {\n      var settings = options || {};\n      var subset = settings.subset || high.listLanguages();\n      var prefix = settings.prefix;\n      var length = subset.length;\n      var index = -1;\n      var result;\n      var secondBest;\n      var current;\n      var name;\n      if (prefix === null || prefix === void 0) {\n        prefix = defaultPrefix;\n      }\n      if (typeof value !== \"string\") {\n        throw fault(\"Expected `string` for value, got `%s`\", value);\n      }\n      secondBest = { relevance: 0, language: null, value: [] };\n      result = { relevance: 0, language: null, value: [] };\n      while (++index < length) {\n        name = subset[index];\n        if (!high.getLanguage(name)) {\n          continue;\n        }\n        current = highlight(name, value, options);\n        current.language = name;\n        if (current.relevance > secondBest.relevance) {\n          secondBest = current;\n        }\n        if (current.relevance > result.relevance) {\n          secondBest = result;\n          result = current;\n        }\n      }\n      if (secondBest.language) {\n        result.secondBest = secondBest;\n      }\n      return result;\n    }\n    function registerLanguage(name, syntax) {\n      high.registerLanguage(name, syntax);\n    }\n    function listLanguages() {\n      return high.listLanguages();\n    }\n    function registerAlias(name, alias) {\n      var map = name;\n      var key;\n      if (alias) {\n        map = {};\n        map[name] = alias;\n      }\n      for (key in map) {\n        high.registerAliases(map[key], { languageName: key });\n      }\n    }\n    function Emitter(options) {\n      this.options = options;\n      this.rootNode = { children: [] };\n      this.stack = [this.rootNode];\n    }\n    function addKeyword(value, name) {\n      this.openNode(name);\n      this.addText(value);\n      this.closeNode();\n    }\n    function addSublanguage(other, name) {\n      var stack = this.stack;\n      var current = stack[stack.length - 1];\n      var results = other.rootNode.children;\n      var node = name ? {\n        type: \"element\",\n        tagName: \"span\",\n        properties: { className: [name] },\n        children: results\n      } : results;\n      current.children = current.children.concat(node);\n    }\n    function text(value) {\n      var stack = this.stack;\n      var current;\n      var tail;\n      if (value === \"\")\n        return;\n      current = stack[stack.length - 1];\n      tail = current.children[current.children.length - 1];\n      if (tail && tail.type === \"text\") {\n        tail.value += value;\n      } else {\n        current.children.push({ type: \"text\", value });\n      }\n    }\n    function open(name) {\n      var stack = this.stack;\n      var className = this.options.classPrefix + name;\n      var current = stack[stack.length - 1];\n      var child = {\n        type: \"element\",\n        tagName: \"span\",\n        properties: { className: [className] },\n        children: []\n      };\n      current.children.push(child);\n      stack.push(child);\n    }\n    function close() {\n      this.stack.pop();\n    }\n    function toHtmlNoop() {\n      return \"\";\n    }\n    function noop() {\n    }\n  }\n});\n\nexport {\n  require_core2 as require_core\n};\n//# sourceMappingURL=chunk-YNER2GXA.js.map\n",
      "start": 1703289479088,
      "end": 1703289479089,
      "order": "normal",
      "sourcemaps": null
    }
  ]
}
